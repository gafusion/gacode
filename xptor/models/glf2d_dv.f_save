ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine glf2d_dv
c
      Implicit None
c
      include 'mpif.h'
      include '../inc/input.m'
      include '../inc/tport.m'
      include '../inc/model.m'
      include '../inc/data.m'
      include '../inc/share.m'
      include '../inc/sharegk.m'
      include '../inc/ptor.m'
      include '../inc/glf.m'
c
      call neoclassical
c
      if(imodel.eq.81)call glf23_dv
c
      if(imodel.eq.82)call tglf_dv
c
      if(imodel.eq.2) call ifsppl_dv
c
      if(imodel.eq.7) call mixshear_dv
c
      if(imodel.eq.99) call chi1_dv
c
      return
      END 
c
      SUBROUTINE chi1_dv
c
      implicit none
c
      include '../inc/input.m'
      include '../inc/tport.m'
      include '../inc/model.m'
      include '../inc/data.m'
      include '../inc/share.m'
      include '../inc/sharegk.m'
      include '../inc/ptor.m'
      include '../inc/glf.m'
c
      real*8 gfac, csdam
c
      cgyrobohm_m(jm)=1.D-4*
     >  9.79D5*DSQRT(tem*1.D3)/(arho_exp*100.D0)
     >  *(1.02D2*DSQRT(tem*1.D3)/bt_exp/1.D4)**2*DSQRT(amassgas_exp)
      rhosda_m(jm)=((1.02D2*DSQRT(tem*1.D3))/bt_exp/1.D4)
     >  *DSQRT(amassgas_exp)/(arho_exp*100.D0)
      zpmni = -arho_exp*gradnim/nim
      zpmte=-arho_exp*gradtem/tem
      zpmti=-arho_exp*gradtim/tim
      zpni_m(jm)=zpmni
      zpte_m(jm)=zpmte
      zpti_m(jm)=zpmti
      csdam=9.79D5*DSQRT(tem*1.D3)/
     &      (arho_exp*100.D0)/DSQRT(amassgas_exp)
      csda_m(jm)=csdam
      zpmni=zpmne
c
       if(igeo_m.ge.1) gfac=geofac(jm)
c
       chiineo_m=0.D0
       chieneo_m=0.D0
       chiineogb_m(jm)=0.D0
       chieneogb_m(jm)=0.D0
c
       diffnem=0.D0
       chietem=1.D0
       chiitim = 1.D0
       chie_m(jm)=chietem
       chii_m(jm)=chiitim
       chiegb_m(jm)=chietem/cgyrobohm_m(jm)
       chiigb_m(jm)=chiitim/cgyrobohm_m(jm)
       diffgb_m(jm)=diffnem/cgyrobohm_m(jm)
c
c... compute fluxes, power flows
c
      tefluxm = tem*nem*zpmte*chietem/arho_exp
      tifluxm = tim*nim*zpmti*chiitim/arho_exp
      powem = kevdsecpmw*tem*nem*1.D19/arho_exp*gradrhosq_exp(jm)*
     &        sfactor(jm)*(chietem*zpmte)
     &        +xconv*1.5D0*tem*flow_exp(jm)
      powim = kevdsecpmw*tim*nim*1.D19/arho_exp*gradrhosq_exp(jm)*
     &        sfactor(jm)*(chiitim*zpmti)
     &        +xconv*1.5D0*tim*flow_exp(jm)
      powem = 1.6022D-3*vprime(jm,2)*tefluxm + pow_ei_cor_m(jm)
      powim = 1.6022D-3*vprime(jm,2)*tifluxm - pow_ei_cor_m(jm)
c
      return
      END 
c
      SUBROUTINE mixshear_dv
c
      implicit none
c
      include '../inc/input.m'
      include '../inc/tport.m'
      include '../inc/model.m'
      include '../inc/data.m'
      include '../inc/share.m'
      include '../inc/sharegk.m'
      include '../inc/ptor.m'
      include '../inc/glf.m'
c
      real*8 ceqei_ms, chiemi_ms, facbr_ms, facgb_ms, fshea_ms,
     &       dbohm_ms, gyro_ms, rlte_ms, rlti_ms, gfac, csdam
c
       cgyrobohm_m(jm)=1.D-4*
     >  9.79D5*DSQRT(tem*1.D3)/(arho_exp*100.D0)
     >  *(1.02D2*DSQRT(tem*1.D3)/bt_exp/1.D4)**2*DSQRT(amassgas_exp)
       rhosda_m(jm)=((1.02D2*DSQRT(tem*1.D3))/bt_exp/1.D4)
     >  *DSQRT(amassgas_exp)/(arho_exp*100.D0)
       csdam=9.79D5*DSQRT(tem*1.D3)/
     &      (arho_exp*100.D0)/DSQRT(amassgas_exp)
       csda_m(jm)=csdam
c
       ceqei_ms  = 3.5D0
       chiemi_ms = 5.D-02
       facbr_ms  = 8.61D-03
       facgb_ms  = 5.07D-01
c
       if ( shat_exp(jm) .le. 0. ) then
         fshea_ms = 0.D0
       else
         fshea_ms = shat_exp(jm)**2.D0/(1.D0+shat_exp(jm)**3.D0)
       endif
c
       dbohm_ms = tem*1000.D0/(16.D0*bt_exp)
       gyro_ms  = 1.0D-4*dsqrt(tem*1000.D0)/bt_exp
       zpmni = -arho_exp*gradnim/nim
       zpmte=-arho_exp*gradtem/tem
       zpmti=-arho_exp*gradtim/tim
       rlte_ms  = - arho_exp*gradtem/tem
       rlti_ms  = - arho_exp*gradtim/tim
       gfac=1.D0
       if(igeo_m.ge.1) gfac=geofac(jm)

       chietem=cmodel_e*gfac
     &       *abs( facbr_ms*rlte_ms*dbohm_ms*q_exp(jm)**2.D0
     &       *fshea_ms + facgb_ms*rlte_ms*dbohm_ms*gyro_ms/arho_exp )
       chiitim=cmodel_i*gfac
     &       *abs( ceqei_ms*facbr_ms*rlti_ms*dbohm_ms*q_exp(jm)**2.D0
     &       *fshea_ms + facgb_ms*rlti_ms*dbohm_ms*gyro_ms/arho_exp )
       diffnem=0.D0
c
       chietem=dmax1(chietem,chiemi_ms)
c
       chie_m(jm)=chietem
       chii_m(jm)=chiitim
       chiegb_m(jm)=chietem/cgyrobohm_m(jm)
       chiigb_m(jm)=chiitim/cgyrobohm_m(jm)
       diffgb_m(jm)=diffnem/cgyrobohm_m(jm)
c
c... compute fluxes, power flows
c
      tefluxm = tem*nem*zpmte*chietem/arho_exp
      tifluxm = tim*nim*zpmti*chiitim/arho_exp
      powem = kevdsecpmw*tem*nem*1.D19/arho_exp*gradrhosq_exp(jm)*
     &        sfactor(jm)*(chietem*zpmte)
     &        +xconv*1.5D0*tem*flow_exp(jm)
      powim = kevdsecpmw*tim*nim*1.D19/arho_exp*gradrhosq_exp(jm)*
     &        sfactor(jm)*(chiitim*zpmti)
     &        +xconv*1.5D0*tim*flow_exp(jm)
      powem = 1.6022D-3*vprime(jm,2)*tefluxm + pow_ei_cor_m(jm)
      powim = 1.6022D-3*vprime(jm,2)*tifluxm - pow_ei_cor_m(jm)
c
      return
      END 
c
      SUBROUTINE glf23_dv
c
c... imodel=0 for GLF23 model
c      
c
      Implicit None
c
      include 'mpif.h'
      include '../inc/input.m'
      include '../inc/tport.m'
      include '../inc/model.m'
      include '../inc/data.m'
      include '../inc/share.m'
      include '../inc/sharegk.m'
      include '../inc/ptor.m'
      include '../inc/glf.m'
c
      integer i,j,k,ik
      real*8 exchgb_local,gfac,diffgb_local
      real*8 fc,vnewk3x,alpha_neo_hold,akappa1
      real*8 aiwt_jp1,xnimp_jp1,xnimp
      real*8 csdam,rmajm,rminm,rhom
      real*8 cv,fac_imp_flow
      real*8 art_diff
      real*8 zeffm,qm, mass_factor
      real*8 vneom(nspecies),vdiam(nspecies)
      real*8 gradvneom(nspecies),gradvdiam(nspecies)
      real*8 gradvphim
      real*8 cparm,cperm,ctorm,grad_c_par,grad_c_per,grad_c_tor
      real*8 apolm,atorm,grad_a_pol,grad_a_tor
c
      cv=1000.D0
      cxnu = 1.D0
      qm =(q_exp(jm+1)+q_exp(jm))/2.D0
      rmajm=(rmaj_exp(jm+1)+rmaj_exp(jm))/2.D0
      rhom=arho_exp*(rho(jm+1)+rho(jm))/2.D0
      rminm=(rmin_exp(jm+1)+rmin_exp(jm))/2.D0
      zeffm=(zeff_exp(jm+1)+zeff_exp(jm))/2.D0
      zpmne = -arho_exp*gradnem/nem
      if(zpmne.eq.0.D0)zpmne=1.0D-7
      zpne_m(jm)=zpmne
      zpmni = -arho_exp*gradnim/nim
      if(zpmni.eq.0.D0)zpmni=1.0D-7
      zpni_m(jm)=zpmni
      zpmte = -arho_exp*gradtem/tem
      if(zpmte.eq.0.D0)zpmte=1.0D-7
      zpte_m(jm)=zpmte
      zpmti = -arho_exp*gradtim/tim
      if(zpmti.eq.0.D0)zpmti=1.0D-7
      zpti_m(jm)=zpmti
      csdam=9.79D5*DSQRT(tem*1.D3)/
     > (arho_exp*100.D0)/DSQRT(amassgas_exp)
      csda_m(jm) = csdam
      vdiam(2) = (vdia_m(2,jm+1)+vdia_m(2,jm))/2.0
      vneom(2) = (vneo_m(2,jm+1)+vneo_m(2,jm))/2.0
      cparm = (c_par(jm+1)+c_par(jm))/2.0
      cperm = (c_per(jm+1)+c_per(jm))/2.0
      ctorm = (c_tor(jm+1)+c_tor(jm))/2.0
      apolm = (a_pol(jm+1)+a_pol(jm))/2.0
      atorm = (a_tor(jm+1)+a_tor(jm))/2.0
      gradvdiam(2) =(vdia_m(2,jm+1)-vdia_m(2,jm))/dr(jm,2)
      gradvneom(2) =(vneo_m(2,jm+1)-vneo_m(2,jm))/dr(jm,2)
      grad_c_par=(c_par(jm+1)-c_par(jm))/dr(jm,2)
      grad_c_per=(c_per(jm+1)-c_per(jm))/dr(jm,2)
      grad_c_tor=(c_tor(jm+1)-c_tor(jm))/dr(jm,2)
      grad_a_pol=(a_pol(jm+1)-a_pol(jm))/dr(jm,2)
      grad_a_tor=(a_tor(jm+1)-a_tor(jm))/dr(jm,2)
c
      gamma_p_m(jm) = -(cv/csdam)*drhodr(jm)*
     >  (apolm*(gradvpolm+gradvneom(2))+atorm*(gradvexbm+gradvdiam(2))
     >  +(vpolm+vneom(2))*grad_a_pol+(vexbm+vdiam(2))*grad_a_tor)
      egamma_m(jm) = -cv/csdam*(rminm/rhom)*drhodr(jm)
     >  *theta_exp(jm)*gradvexbm
      if(jm.eq.ngrid-1.and.itport_pt(5).eq.0)egamma_m(jm)=0.0
c       gradvphim = -gamma_p_m(jm)*csdam/cv
       gradvphim = cv*drhodr(jm)*gradvexbm
c      if(iexb.eq.2) then
c        egamma_m(jm)=egamma_exp(jm)
c      else
c        egamma_m(jm)=gamma_e_gf
c      endif
      gamma_e_gf = egamma_m(jm)
      gamma_p_gf = gamma_p_m(jm)
      exch_gf=0.D0
c   local rho_star
      if(bt_flag.gt.0)then
c    use effective B-field
       rhosda_m(jm)=((1.02D2*DSQRT(tem*1.D3))/bteff_exp(jm)
     > /1.D4)*DSQRT(amassgas_exp)/(arho_exp*100.D0)
      else
       rhosda_m(jm)=((1.02D2*DSQRT(tem*1.D3))/bt_exp/1.D4)
     >  *DSQRT(amassgas_exp)/(arho_exp*100.D0)
      endif
c   local gyrobohm unit of diffusion
      if(bt_flag.ge.2)then
c    use effective B-field
       cgyrobohm_m(jm)=1.D-4*
     >  9.79D5*DSQRT(tem*1.D3)/(arho_exp*100.D0)
     >  *(1.02D2*DSQRT(tem*1.D3)/bteff_exp(jm)/1.D4)**2
     >  *DSQRT(amassgas_exp)
      else
c   local gyrobohm unit of diffusion
       cgyrobohm_m(jm)=1.D-4*
     >  9.79D5*DSQRT(tem*1.D3)/(arho_exp*100.D0)
     >  *(1.02D2*DSQRT(tem*1.D3)/bt_exp/1.D4)**2*DSQRT(amassgas_exp)
      endif 
       betae_m(jm) = 400.D0*nem*tem/(1.D5*bt_exp**2)
       betai_m(jm) = 400.D0*nim*tim/(1.D5*bt_exp**2)

crew    gks collisionality (xnu/w_star_i)*(ky*rho_i)
       vnewk3x=
     >   0.117D0*nem/DSQRT(tem)**3/DSQRT(tim)*(arho_exp)*
     >   DSQRT(amassgas_exp/2.D0)
c
       xnu_m(jm) =vnewk3x*DSQRT(2.D0*tim/tem)
c
       if(ipert_gf.eq.0)alpha_m(jm)=drhodr(jm)*qm**2*rmajm
     >   *betae_m(jm)*((tim*nim/tem/nem)*
     >   (zpmni+zpmti)+zpmne+zpmte)/arho_exp
c bananna regime ie collisionless limit formulas
        alpha_neo_hold=alpha_neo
        fc=1-1.46D0*DSQRT(rminm/rmajm)+
     >      0.46D0*DSQRT(rminm/rmajm)**3
        akappa1=0.8839D0*fc/(0.3477D0+0.4058D0*fc)
        if(irot1.eq.1) alpha_neo=-akappa1+1.D0

       rmaj_gf=rmajm/arho_exp
       rmin_gf=rminm/arho_exp
       q_gf=qm
       betae_gf=cbetae*betae_m(jm)
       shat_gf=shat_exp(jm)
        if(igeo_m.ge.2) shat_gf=shat_exp(jm)*drhodrrrho(jm)
       alpha_gf=xalpha*alpha_exp(jm)
       if(ialphastab.gt.0) then
        alpha_gf=xalpha*alpha_m(jm)
       endif
       elong_gf=elong_exp(jm)
       if(igeo_m.eq.-1) elong_gf=elonga_exp
       xnu_gf=cxnu*xnu_m(jm)
c       write(*,*) jm, rho(jm), xnu_gf, 'xnu'
       taui_gf=tim/tem
       amassgas_gf=amassgas_exp
       rlte_gf=zpmte
       rlti_gf=zpmti
       rlne_gf=zpmne
       rlni_gf=rlne_gf
       if(i_dengrad.ge.1)then
         rlni_gf=zpmni
       endif
       dil_gf=0.D0
       apwt_gf=1.D0
       aiwt_gf=0.D0
       rlnimp_gf=1.D0
       zpmnimp=1.D0
       if(i_dengrad.eq.2) dil_gf=1.D0-nim/nem
       if(i_dengrad.eq.3) then
cgms not hooked up right
        apwt_gf=nim/nem
        aiwt_jp1=(zeffm*nem-ni_exp(jm+1)
     >    -nfst_exp(jm+1))/(zimp_gf**2*ne_exp(jm+1))
        xnimp_jp1=aiwt_jp1*ne_exp(jm+1)
        aiwt_gf=(zeffm*nem-nim
     >    -nfst_exp(jm))/(zimp_gf**2*ne_exp(jm))
        xnimp=aiwt_gf*ne_exp(jm)
        
        zpmnimp=-(xnimp_jp1-xnimp)/(rho(jm+1)-rho(jm))/
     >  ((xnimp_jp1+xnimp)/2.0D0)
        rlnimp_gf=zpmnimp
c zimp_gf and amassimp_gf are inputs
       endif
       if(igeo_m.ne.0)then
        rlte_gf=zpmte*DSQRT(elong_exp(jm))
        rlti_gf=zpmti*DSQRT(elong_exp(jm))
        rlne_gf=zpmne*DSQRT(elong_exp(jm))
        rlni_gf=rlne_gf
        if(i_dengrad.ge.1) then
         rlne_gf=zpmne*DSQRT(elong_exp(jm))
         rlni_gf=zpmni*DSQRT(elong_exp(jm)) 
        endif
        rlnimp_gf=zpmnimp*DSQRT(elong_exp(jm))
       endif
        if(igeo_m.ge.1) then
         rlte_gf=zpmte*drhodr(jm)
         rlti_gf=zpmti*drhodr(jm)
         rlne_gf=zpmne*drhodr(jm)
         rlni_gf=rlne_gf
         rlnimp_gf=zpmnimp*drhodr(jm)
c
         if(i_dengrad.ge.1) then
          rlne_gf=zpmne*drhodr(jm)
          rlni_gf=zpmni*drhodr(jm)
         endif
        endif
        if(igeo_m.eq.-1) then
         rlte_gf=zpmte*DSQRT(elonga_exp)
         rlti_gf=zpmti*DSQRT(elonga_exp)
         rlnimp_gf=zpmnimp*DSQRT(elonga_exp)
         rlne_gf=zpmne*DSQRT(elonga_exp)
         rlni_gf=rlne_gf
         if(i_dengrad.ge.1) then
          rlne_gf=zpmne*DSQRT(elonga_exp)
          rlni_gf=zpmni*DSQRT(elonga_exp)
          rlnimp_gf=zpmnimp*DSQRT(elonga_exp)
         endif
       endif
ctemp
c       rlni_gf=rlne_gf
ctemp
       gamma_star_gf=0.0D0
       gamma_mode_gf=0.0D0
c
 11       format(2x,1pe12.5)
c
c       write(*,*) 'q,shat = ',q_gf,shat_gf
c       write(*,*) 'a/Lt = ',rlti_gf,rlte_gf
c       write(*,*) 'a/Ln = ',rlni_gf,rlne_gf
c       write(*,*) 'R/a,r/a = ',rmaj_gf,rmin_gf
       call glf2d
c switch from ion particle diffusivity to electron particle diffusivity
       diff_gf = nim*rlni_gf*diff_gf/(nem*rlne_gf)
c
c       write(*,*) 'gamma_gf = ',jm,gamma_gf(1)
c
c 4/25/96 note: chie_gf and chii_gf from glf2d are energy diffusivies
c but here we can redefine them as heat diffusivites if we
c take the convection from experiment using xconv=1 or 5./3.
cgms disable xconv
c       chie_gf=chie_gf-xconv*1.5D0*rlni_gf/rlte_gf*diff_gf
c       chii_gf=chii_gf-xconv*1.5D0*rlni_gf/rlti_gf*diff_gf
       ky_j(jm)=xkyf_gf
       gamma_j(jm,1)=gamma_gf(1)
       gamma_j(jm,2)=gamma_gf(2)
       gamma_j(jm,3)=gamma_gf(3)
       gamma_j(jm,4)=gamma_gf(4)
c 
       freq_j(jm,1)=freq_gf(1)
       freq_j(jm,2)=freq_gf(2)
       freq_j(jm,3)=freq_gf(3)
       freq_j(jm,4)=freq_gf(4)
c
       phi_norm_j(jm,1)=phi_norm_gf(1)
       phi_norm_j(jm,2)=phi_norm_gf(2)
       phi_norm_j(jm,3)=phi_norm_gf(3)
       phi_norm_j(jm,4)=phi_norm_gf(4)
c 
       do ik=1,ikymax_gf
        gamma_k_j(ik,jm)=gamma_k_gf(1,ik)
        freq_k_j(ik,jm) =freq_k_gf(1,ik)
        chie_k_j(ik,jm) = chie_k_gf(ik)
        chii_k_j(ik,jm) = chii_k_gf(ik)
       enddo
c
       anrate_m(jm)=gamma_gf(1)
c        write(6,10)jm,anrate_m(jm)
 10      format(2x,i3,2x,1pe12.5)
       dnrate_m(jm)=0.D0
       dtnrate_m(jm)=0.D0
       anfreq_m(jm)=freq_gf(1)
       dnfreq_m(jm)=0.D0
        gfac=1.D0
        if(igeo_m.ge.1) gfac=geofac(jm)
        if(igeo_m.eq.-1) 
     >   gfac=(1.D0+elonga_exp**2)/(2.D0*elonga_exp)/gradrhosq_exp(jm)
cgms  rescale gfac to agree with shooting code
cgms       gfac=gfac*gradrhosq_exp(jm)*sfactor(jm)/vprime(jm,2)
       chiegb_m(jm)=chie_gf*cmodel
       chiigb_m(jm)=chii_gf*cmodel
       diffgb_m(jm)=diff_gf*cmodel
       diffgb_im_m(jm)=diff_im_gf*cmodel
c note diff_im_gf used only for diagnostics
c  to be compared with diff_gf or chii_gf
c
       exchgb_m(jm)=exch_gf*cmodel
       etagb_phi_m(jm)=eta_phi_gf*cmodel
       etagb_par_m(jm)=eta_par_gf*cmodel
       etagb_per_m(jm)=eta_per_gf*cmodel   
       chie_e_gb_m(jm)=chie_e_gf*cmodel
c  
c exch_m in MW/m**3  
c
cgms      exch_m(jm)=1.D19*
cgms     > kevdsecpmw*nem*tem*csda_m(jm)*rhosda_m(jm)**2*exch_gf*cmodel 
c
c exch_m is directly related to the flow
c for a single mode branch exch_gf=-(-freq_gf(1)/xkyf_gf)*diff_gf*rln_gf.
c we can  not expect to find exch_m without knowing flow_exp as input.
c and solving self consistant flow eq. flown=flow_exp for density
c density profile.
c
c however, knowing freq_gf(1) from the gf model we can compute exch_exp  
c from flow_exp using
c       flowm=kevdsecpmw*1.*nem*1.e19/arho_exp*gradrhosq_exp(jm)*
c     >       sfactor(jm)*(difftem*zpmte+difftim*zpmti+diffnem*zpmne)
c we have:

cgms       diffgb_local=flow_exp(jm)/
cgms     > (kevdsecpmw*1.*nem*1.e19/arho_exp*gradrhosq_exp(jm)*sfactor(jm)*
cgms     > zpmne_q)/cgyrobohm_m(jm)
c
cgms       exchgb_local=-(-freq_gf(1)/xkyf_gf)*diffgb_local*rlni_gf
c 
cgms       exch_exp(jm)=1.e19*
cgms     > kevdsecpmw*nem*tem*csda_m(jm)*rhosda_m(jm)**2*exchgb_local
c   
c       exch_exp(jm)=flow_exp(jm)*tem*(-1.)*(-freq_gf(1)/xkyf_gf)*
c     > DSQRT(elong_exp(jm))*arho_exp/gradrhosq_exp(jm)/sfactor(jm)
c     >/arho_exp(jm)**2 
c
c   note electron(ion) wave freq > 0(<0) cool(heat) electrons
c (-1) denotes electron to ion
c
c to emphasize, we can not know exch_exp better than we know flow_exp
c
c chietem, chiitim, diffen in m**2/sec
c
      chietem=cmodel*gfac*chie_gf*cgyrobohm_m(jm)
      chietem=chietem*cmodel_e
cgms      chietim=0.
cgms       chienem=0.
cgms       chiitem=0.
      chiitim=cmodel*gfac*chii_gf*cgyrobohm_m(jm)
      chiitim=cmodel_i*chiitim
cgms       chiinem=0. 
cgms       difftem=0.
cgms       difftim=0.
c
      diffnem=cmodel*gfac*diff_gf*cgyrobohm_m(jm)      
      etaparm=cmodel*gfac*eta_par_gf*cgyrobohm_m(jm)
      etaexbm=cmodel*gfac*eta_per_gf*cgyrobohm_m(jm)
      etaphim=cmodel*gfac*eta_phi_gf*cgyrobohm_m(jm)
      etaphim=DABS(etaphim)
      etaparm=DABS(etaparm)
c      etaexbm=etaparm
cgms temporary
c       etaexbm = DABS(chiitim)
c       etaparm = etaexbm
c save coeficients
      diff_m(jm)=diffnem
      chie_m(jm)=chietem
      chii_m(jm)=chiitim
      etapar_m(jm)=etaparm
      etaexb_m(jm)=etaexbm
      etaphi_m(jm)=etaphim
c
      chiegb_m(jm)=chietem/cgyrobohm_m(jm)
      chiigb_m(jm)=chiitim/cgyrobohm_m(jm)
      diffgb_m(jm)=diffnem/cgyrobohm_m(jm)
      etagb_phi_m(jm)=etaphim/cgyrobohm_m(jm)
      etagb_par_m(jm)=etaparm/cgyrobohm_m(jm)
      etagb_per_m(jm)=etaperm/cgyrobohm_m(jm)
      etagb_phi_m(jm)=etaphim/cgyrobohm_m(jm)
      chie_e_gb_m(jm)=chie_e_gf*cmodel*gfac
c
      if(use_xneo_m.eq.2) then
        diffnem = diffnem + xparam_pt(3)*deneo_m(jm)
        diffnem = diffnem + xparam_pt(8)*DABS(chietem)
      else
        diffnem = diffnem + xparam_pt(3)*chieneo_m(jm)
        diffnem = diffnem + xparam_pt(8)*DABS(chietem)
      endif
c      if(q_exp(jm).lt.1.) then
c        chietem = chietem + xparam_pt(4)*chiineo_m(jm)
c        diffnem = diffnem + xparam_pt(3)*chiineo_m(jm)
c      else
c        chietem = chietem + xparam_pt(4)*chieneo_m(jm)
c      endif
      chiitim = chiitim + xparam_pt(5)*chiineo_m(jm)
      fac_imp_flow=1.D0
      if(iexp_imp.eq.1) fac_imp_flow=1.D0+nz_exp(jm)/ni_exp(jm)
      chiitim = fac_imp_flow*chiitim
      etaparm = etaparm + xparam_pt(6)*chiineo_m(jm)
     >          *rmajor_exp**2/(f_exp(jm)*xr2_exp(jm))
c      etaphim = etaphim + xparam_pt(6)*chiineo_m(jm)
      vphifluxm = amassgas_exp*nim*xparam_pt(6)*chiineo_m(jm)
     >  *gamma_p_gf*(csdam/cv)
      etaexbm = etaexbm + xparam_pt(6)*chiineo_m(jm)
      etaparm = etaparm + xparam_pt(6)*chiineo_m(jm)
c
      if(xparam_pt(11).gt.0) then
        etaphim = etaphim + xparam_pt(11)*DABS(chietem) +
     >            xparam_pt(6)*chieneo_m(jm)
      endif
c
c add in artificial diffusion terms
c
       art_diff=adiff_dv*cgyrobohm_m(jm)*gfac
       diffnem = diffnem 
     > + art_diff*(dr(jm,2)*DABS(zpmne)/arho_exp)**2
       chietem = chietem
     > + art_diff*DABS(dr(jm,2)*zpmte/arho_exp)**2
       chiitim = chiitim
     > + art_diff*DABS(dr(jm,2)*zpmti/arho_exp)**2
       etaparm = etaparm  
     > + 1.D-2*art_diff*DABS(dr(jm,2)*gamma_p_gf/arho_exp)**2
       etaexbm = etaexbm
     > + 1.D-2*art_diff*DABS(dr(jm,2)*gamma_e_gf/arho_exp)**2
       etaphim = etaphim 
     > + 1.D-2*art_diff*DABS(gamma_p_gf/30.0)**2
c
c compute fluxes
c
c switch to electron particle flux
       nefluxm = nem*zpmne*diffnem/arho_exp
       tefluxm = tem*nem*zpmte*chietem/arho_exp
       tifluxm = tim*nim*zpmti*chiitim/arho_exp
c       vparfluxm = -nim*etaparm*gamma_p_gf*csdam/cv
c       vexbfluxm = -nim*etaexbm*gamma_e_gf*csdam/cv
c       vphifluxm = c_par(jm)*vparfluxm+c_per(jm)*vexbfluxm
c use diagonal form for agreement with previous versions
       vphifluxm = vphifluxm 
     >   +amassgas_exp*nim*etaphim*gamma_p_gf*csdam/cv
c       vphifluxm = nim*etaphim*gradvexbm*drhodr(jm)
       vparfluxm = vphifluxm*c_per(jm)/c_tor(jm)
c
       mass_factor = amassgas_exp+amassimp_exp*nzm/nim
       vphifluxm = vphifluxm*mass_factor
       vparfluxm = vparfluxm*mass_factor

c      
 50   format(2x,i2,2x,0p1f10.6,1p6e12.4)
c
      return
      END   !SUBROUTINE glf23_dv
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
      SUBROUTINE neoclassical
c
c... Calculate neoclassical chii from modelled profiles
c... Use adapted version KAPISN_ONE that calculats chii at one position
c... instead of the full profile
c... Note that arrays are name.nc while single parameters are name.nco
c
c
      use tglf_tg
      Implicit None
c
      include 'mpif.h'
      include '../inc/input.m'
      include '../inc/tport.m'
      include '../inc/model.m'
      include '../inc/data.m'
      include '../inc/share.m'
      include '../inc/sharegk.m'
      include '../inc/ptor.m'
      include '../inc/glf.m'
c
      real*8 ztau_nco, zrho_nco, csdam, rhosdam, rhom, rminm,
     >       rmajm,b_unit
      real*8 taui,rhoi,lnlamda
c
      a_unit_exp = rmin_exp(mxgrid)
      if(igeo_tg.eq.0)a_unit_exp=arho_exp
      rhom=arho_exp*(rho(jm+1)+rho(jm))/2.D0
      rminm=(rmin_exp(jm+1)+rmin_exp(jm))/2.D0
      rmajm=(rmaj_exp(jm+1)+rmaj_exp(jm))/2.0
      drhodr(jm) = arho_exp*(rho(jm+1)-rho(jm))/
     >             (rmin_exp(jm+1)-rmin_exp(jm))
      if(igeo_m.eq.0)then
        b_unit = bt_exp
c        if(bt_flag.gt.0)b_unit = bteff_exp(jm)
      else
        b_unit = bt_exp*(rhom/rminm)*drhodr(jm)
      endif
      csdam=9.79D5*DSQRT(tem*1.D3)/
     > (a_unit_exp*100.D0)/DSQRT(amassgas_exp)
      rhosdam=(1.02D2*DSQRT((tem*1.D3)*amassgas_exp)/
     >  (b_unit*1.D4))/(a_unit_exp*100.D0)
      cgyrobohm_m(jm)= csdam*(rhosdam*a_unit_exp)**2
c
      if (use_xneo_m.eq.0) then
        chieneo_m(jm)=0.D0 ! no electron chi from kapisn module
        chiineo_m(jm)=chiineo_exp(jm)
        chiineogb_m(jm)=chiineogb_exp(jm)
      elseif (use_xneo_m.eq.1) then
        ng_nc=1                     !number of hyd. species
        aplasm_nc(1)=amassgas_exp   !array of atomic masses of hyd. species
c        btf_nc=bt_exp               !tf (tesla) fld at cntr of outer flux
        btf_nc = b_unit
        drshaf_nc=0.0D0             !shaf shift of outer zone bdr. (cm)
cgms        numzones_nc=nj_d           !number of zones
cgms        rminor_nc=0.5D0*(rmin_exp(jm)+rmin_exp(jm+1))*1.D2  !on half grid
cgms        rmajor_nc=rmaj_exp(mxgrid)*1.D2
        rminor_nc = rminm*1.D2
        rmajor_nc = rmajm*1.D2
c
          rhoel_nco=dabs(nem*1.D13)             !electron density (cm**-3)
          rhob_nco(1)=dabs(nem*fi_m(jm)*1.D13)  !hyd. spec. den s (cm**-3)
          rhi_nco=dabs(nem*fz_m(jm)*1.D13)      !z.c. of av. impurity s density  
          rhoi_nco=rhi_nco+rhob_nco(1)   !z.c. of total ion density
          zeff_nco=(zeff_exp(jm+1)+zeff_exp(jm))/2.D0 !z.c. of plasma zeff
        if(nkimod_nc.eq.4)then  ! pure plasma CH model with b_unit 
          rhob_nco(1)=rhoel_nco
          rhi_nco = 0.0
          rhoi_nco = rhoel_nco
          zeff_nco = 1.0
          btf_nc = b_unit
          drshaf_nc = (rmaj_exp(jm+1)-rmaj_exp(jm))
     >              /(rmin_exp(jm+1)-rmin_exp(jm))
        endif
          te_nco=dabs(tem*1.D3)          !z.c.of Te (ev)
          ti_nco=dabs(tim*1.D3)          !z.c. of Ti (ev)
          q_nco=(q_exp(jm+1)+q_exp(jm))/2.D0          !z.c. of safety factor
          aimp_nco=pimpa
          xzimp_nco=pimpz
c
c       if(ipert_gf.eq.0.and.jm.eq.10)then
c        write(6,*)rmin_exp(mxgrid),rminavnpsi_d(nj_d)
c        write(6,*)"KAPISN input from glf2d_dv"
c        write(6,*)ng_nc,numzones_nc,btf_nc,drshaf_nc,rminor_nc,rmajor_nc
c        write(6,*)ng_nc,aplasm_nc(1),rhoel_nco,rhob_nco
c        write(6,*)rhoi_nco,te_nco,ti_nco,zeff_nco,q_nco
c        write(6,*)aimp_nco,xzimp_nco,rhi_nco
c       endif
c
c...    * means: default value given in input.mlt/mlt0in
c...    Note that the comments might be screwed up since some commentlines
c...    had to be deleted otherwise BASIS could not handle it (...) 
c...    See file neoclass.basf for the unscrewed comments
c
        call kapisn_one(
     >          nkimod_nc,         !*kapai model nr desired
     >          aimp_nco,          !*atomic mass of av. impurity
     >          xzimp_nco,         !*atomic number of av. impurity
     >          aplasm_nc,         !array of atomic masses of hyd. species
     >          ng_nc,             !number of hyd. species
     >          rhoel_nco,         !zone centered electron density (cm**-3)
     >          rhob_nco,          !z.c. array of hyd. spec. den s (cm**-3)
     >          rhi_nco,           !z.c. array of av. impurity s density  
     >          rhoi_nco,          !z.c. array of total ion density       
     >          te_nco,            !z.c. array of Te (ev)
     >          ti_nco,            !z.c. array of Ti (ev)
     >          zeff_nco,          !z.c. array of plasma zeff
     >          q_nco,             !z.c. array of safety factor
     >          btf_nc,            !tf (tesla) fld at cntr of outer flux 
     >          drshaf_nc,         !shaf shift of outer zone bdr. (cm)
     >          rminor_nc,         !plasma minor radius local on half grid (cm)
     >          rmajor_nc,         !major radius (cntr of outer flux) (cm)
     >          istringer_nc,      !Stringer correction
     >          xkapi_nco,         !o Neo-Class Ion thermal diff. (cm**2/sec)
     >          xnstari_nco,       !o nu-star-ions, 
     >          xnstare_nco,       !o nu-star-elecs, 
     >          ztau_nco,          !o ion collision time
     >          zrho_nco,          !o ion poloidal gyro-radius
     >          zfluxlim_nco)      !o flux lim flow max temp grad length
c
c      if(ipert_gf.eq.0.and.jm.eq.10)then
c       write(6,*)"xkapi_nco = ",xkapi_nco
c       write(6,*)istringer_nc,xnstari_nco,xnstare_nco
c       write(6,*)ztau_nco,zrho_nco,zfluxlim_nco
c      endif
c
c...   calculate neclassical conductivity (xkapi), diffusivity
c
       if(nkimod_nc.eq.4)then
         xkapi_nco=xkapi_nco*1.D-4*nim*1.D19  !1/(m*s)
         chiineo_m(jm)=xkapi_nco/(nim*1.D19)  !m**2/s
       else
c         xkapi_nco=xkapi_nco*1.D-4*nim*1.D19/elong_exp(jm)    !1/(m*s)
c         chiineo_m(jm)=xkapi_nco/nim/1.D19/gradrhosq_exp(jm)  !m**2/s
         xkapi_nco=xkapi_nco*1.D-4*nim*1.D19  !1/(m*s)
         chiineo_m(jm)=xkapi_nco/(nim*1.D19)  !m**2/s
       endif
       chieneo_m(jm)=chiineo_m(jm)/42.D0/DSQRT(amassgas_exp)
       deneo_m(jm)=chieneo_m(jm)
      elseif (use_xneo_m.eq.2) then
c       write(*,*) 'calling forcebal ...'
c       call forcebal
        deneo_m(jm)=deneo_exp(jm)
        dineo_m(jm)=dineo_exp(jm)
        chieneo_m(jm)=chieneo_exp(jm)
        chiineo_m(jm)=chiineo_exp(jm)
      else
        chiineo_m(jm)=0.D0
        chiineogb_m(jm)=0.D0
      endif
c compute toroidal momentum diffusivity
       lnlamda=15.94D0-0.5*LOG(nem)+LOG(tem)
c braginski ion collision time
       taui = 0.0661*(tim**1.5)/(nim*lnlamda)
       rhoi = rhosdam*a_unit_exp*SQRT(2.0*tim/tem)
       etaphineo_m(jm) = (3.0/5.0)*rhoi**2/taui
c
c ad-hoc model for transport in sawtooth region 
c
      if(ineo.eq.-1.or.ineo.eq.-2.and.q_exp(jm).lt.1.0)then
        chieneo_m(jm)=chiineo_m(jm)
        deneo_m(jm)=chiineo_m(jm)
        etaphineo_m(jm)=chiineo_m(jm)
      endif
c
      chiineogb_m(jm)=chiineo_m(jm)/cgyrobohm_m(jm)
c
      RETURN
      END !SUBROUTINE neoclassical
c
      SUBROUTINE  tglf_dv
c
      USE tglf_tg
      USE tglf_pkg
      IMPLICIT NONE
c
      include 'mpif.h'
      include '../inc/input.m'
      include '../inc/tport.m'
      include '../inc/model.m'
      include '../inc/data.m'
      include '../inc/share.m'
      include '../inc/sharegk.m'
      include '../inc/ptor.m'
      include '../inc/glf.m'
c
      integer i,j,k,ik
      integer nk_e,nx_e
      real*8 exchgb_local,gfac,diffgb_local,art_diff
      real*8 fc,vnewk3x,alpha_neo_hold,akappa1
      real*8 aiwt_jp1,xnimp_jp1,xnimp
      real*8 csdam,rhosdam,rmajm,rminm,rhom
      real*8 cv,fac_imp_flow
      real*8 zeffm,qm, gb_unit,b_unit
      REAL*8 dtest(5,5),vtest(5,5)
      REAl*8 debyelorhos
      real*8 dr_loc,xnuei,taue,lnlamda
      real*8 vneom(nspecies),vdiam(nspecies)
      real*8 gradvneom(nspecies),gradvdiam(nspecies)
      real*8 gradvphim
      real*8 cparm,cperm,ctorm,grad_c_par,grad_c_per,grad_c_tor
      real*8 apolm,atorm,grad_a_pol,grad_a_tor
      real*8 vphim,mass_factor,vpartotm
      real*8 chi_DR
c
c NOTE:
c The a_unit_exp convention is rmin at separatrix for TGLF for all geometries.
c This differes from GLF23 which uses a_unit_exp = arho_exp. This does not impact the 
c predicted plasma profiles since for both models the local flux does not depend
c on a_unit_exp so it is arbitrary
c
      a_unit_exp = rmin_exp(mxgrid)
      if(igeo_tg.eq.0)a_unit_exp=arho_exp
c
      cv=1000.D0
      cxnu = 1.0
      qm =(q_exp(jm+1)+q_exp(jm))/2.D0
      rmajm=(rmaj_exp(jm+1)+rmaj_exp(jm))/2.D0
      rhom=arho_exp*(rho(jm+1)+rho(jm))/2.D0
c recompute drhodr just to make sure
      drhodr(jm) = arho_exp*(rho(jm+1)-rho(jm))/
     >             (rmin_exp(jm+1)-rmin_exp(jm))
      rminm=(rmin_exp(jm+1)+rmin_exp(jm))/2.D0
      zeffm=(zeff_exp(jm+1)+zeff_exp(jm))/2.D0
c for TGLF derivatives are with respect to rmin for all geometries
      zpmne = -a_unit_exp*drhodr(jm)*gradnem/nem
      zpne_m(jm)=zpmne
      zpmni = -a_unit_exp*drhodr(jm)*gradnim/nim
      zpni_m(jm)=zpmni
      zpmnz = -a_unit_exp*drhodr(jm)*gradnzm/nzm
      zpnz_m(jm) = zpmnz
      zpmte = -a_unit_exp*drhodr(jm)*gradtem/tem
      zpte_m(jm)=zpmte
      zpmti = -a_unit_exp*drhodr(jm)*gradtim/tim
      zpti_m(jm)=zpmti
      csdam=9.79D5*DSQRT(tem*1.D3)/
     > (a_unit_exp*100.D0)/DSQRT(amassgas_exp)
      csda_m(jm) = csdam
      vdiam(1) = (vdia_m(1,jm+1)+vdia_m(1,jm))/2.0
      vdiam(2) = (vdia_m(2,jm+1)+vdia_m(2,jm))/2.0
      vdiam(3) = (vdia_m(3,jm+1)+vdia_m(3,jm))/2.0
      vneom(1) = (vneo_m(1,jm+1)+vneo_m(1,jm))/2.0
      vneom(2) = (vneo_m(2,jm+1)+vneo_m(2,jm))/2.0
      vneom(3) = (vneo_m(3,jm+1)+vneo_m(3,jm))/2.0
      gradvdiam(1) =(vdia_m(1,jm+1)-vdia_m(1,jm))/dr(jm,2)
      gradvdiam(2) =(vdia_m(2,jm+1)-vdia_m(2,jm))/dr(jm,2)
      gradvdiam(3) =(vdia_m(3,jm+1)-vdia_m(3,jm))/dr(jm,2)
      gradvneom(1) =(vneo_m(1,jm+1)-vneo_m(1,jm))/dr(jm,2)
      gradvneom(2) =(vneo_m(2,jm+1)-vneo_m(2,jm))/dr(jm,2)
      gradvneom(3) =(vneo_m(3,jm+1)-vneo_m(3,jm))/dr(jm,2)
      cparm = (c_par(jm+1)+c_par(jm))/2.0
      cperm = (c_per(jm+1)+c_per(jm))/2.0
      ctorm = (c_tor(jm+1)+c_tor(jm))/2.0
      apolm = (a_pol(jm+1)+a_pol(jm))/2.0
      atorm = (a_tor(jm+1)+a_tor(jm))/2.0
      grad_c_par=(c_par(jm+1)-c_par(jm))/dr(jm,2)
      grad_c_per=(c_per(jm+1)-c_per(jm))/dr(jm,2)
      grad_c_tor=(c_tor(jm+1)-c_tor(jm))/dr(jm,2)
      grad_a_pol=(a_pol(jm+1)-a_pol(jm))/dr(jm,2)
      grad_a_tor=(a_tor(jm+1)-a_tor(jm))/dr(jm,2)
      gamma_p_m(jm) = -(cv/(csdam))*drhodr(jm)*
     >  (apolm*(gradvpolm+gradvneom(2))+atorm*(gradvexbm+gradvdiam(2)) 
     >  +(vpolm+vneom(2))*grad_a_pol+(vexbm+vdiam(2))*grad_a_tor)
      egamma_m(jm) = -cv/csdam*(rminm/rhom)*drhodr(jm)
     >  *theta_exp(jm)*gradvexbm
c      egamma_m(jm) = -cv/csdam*(rminm/rhom)*drhodr(jm)
c     >  *theta_exp(jm)*(vexb_m(jm+1)-vexb_m(jm))/dr(jm,2)
      if(jm.eq.ngrid-1.and.itport_pt(5).eq.0)then
        egamma_m(jm)=0.0
      endif
c       gradvphim = -gamma_p_m(jm)*csdam/cv
       gradvphim = (cv/csdam)*drhodr(jm)*gradvexbm
c
c   local magnetic field unit 
      if(igeo_tg.eq.0)then
        b_unit = bt_exp
c        if(bt_flag.gt.0)b_unit = bteff_exp(jm)
      else
        b_unit = bt_exp*(rhom/rminm)*drhodr(jm)
      endif
c   local rho_star
      rhosdam=(1.02D2*DSQRT((tem*1.D3)*amassgas_exp)/
     >  (b_unit*1.D4))/(a_unit_exp*100.D0)
      rhosda_m(jm) = rhosdam
c   local gyrobohm unit of diffusion
      cgyrobohm_m(jm)= csdam*(rhosdam*a_unit_exp)**2
c   local beta
      betae_m(jm) = 4.03D-3*nem*tem/(b_unit**2)
      betai_m(jm) = 4.03D-3*nim*tim/(b_unit**2)
      if(iparam_pt(12).eq.1)then
        betae_m(jm) = 4.03D-3*ne_exp(jm)*te_exp(jm)/(b_unit**2)
      endif
c   debye length/rhos
      debyelorhos = 7.43D2*SQRT((tem*1.D3)/(nem*1.D13))/
     > (a_unit_exp*100.0*rhosdam)

c   gks collisionality nu_ei*a/vth_i  where vth_i = sqrt(2*ti/mi)
       vnewk3x= 0.5D0*(a_unit_exp)*DSQRT(amassgas_exp/2.D0)*
     >   0.117D0*nem/DSQRT(tim*tem**3)
c   switch to Cs/a units
       xnu_m(jm) =vnewk3x*DSQRT(2.D0*tim/tem)
c
c  new calculation of xnu_m with lnlamda 
c  xnuei = 3/4 sqt(Pi)/taue
c  lnlamda and taue from NRL formulary
c  note for Te=1Kev and ne=10**13 lnlamda = 15.94 and taue= 1.088D-3/lnlamda
       lnlamda=15.94D0-0.5*LOG(nem)+LOG(tem)
       taue = 1.088D-3*(tem**1.5)/(nem*lnlamda)
c  xnuei = 3/4 (Pi**0.5)/taue
       xnuei = 1.329/taue
c       if(jm.eq.35)write(*,*)"lnlamda=",lnlamda,
c     > "xnugks=",xnu_m(jm),"xnutglf=",xnuei/csdam
       xnu_m(jm) = xnuei/csdam
c
       if(ipert_gf.eq.0)alpha_m(jm)=drhodr(jm)*qm**2*rmajm
     >   *betae_m(jm)*((tim*nim/tem/nem)*
     >   (zpmni+zpmti)+zpmne+zpmte)/a_unit_exp
c bananna regime ie collisionless limit formulas
        alpha_neo_hold=alpha_neo
        fc=1-1.46D0*DSQRT(rminm/rmajm)+
     >      0.46D0*DSQRT(rminm/rmajm)**3
        akappa1=0.8839D0*fc/(0.3477D0+0.4058D0*fc)
        if(irot1.eq.1) alpha_neo=-akappa1+1.D0
c set TGLF gradients
      rlts_tg(1)=zpmte
      rlts_tg(2)=zpmti
      rlts_tg(3)=zpmti
      rlns_tg(1)=zpmne
      rlns_tg(2)=zpmni
      rlns_tg(3)=zpmnz
      if(iexb.eq.2) then
        vexb_shear_tg = egamma_exp(jm)
      else
        vexb_shear_tg = egamma_m(jm)
      endif
      vpar_shear_tg(1) = -sign_Bt_exp*(cv/(csdam))*drhodr(jm)*
     >  (apolm*(gradvpolm+gradvneom(1))+atorm*(gradvexbm+gradvdiam(1)) 
     >  +(vpolm+vneom(1))*grad_a_pol+(vexbm+vdiam(1))*grad_a_tor)
      vpar_shear_tg(2) = -sign_Bt_exp*(cv/(csdam))*drhodr(jm)*
     >  (apolm*(gradvpolm+gradvneom(2))+atorm*(gradvexbm+gradvdiam(2)) 
     >  +(vpolm+vneom(2))*grad_a_pol+(vexbm+vdiam(2))*grad_a_tor)
      vpar_shear_tg(3) = -sign_Bt_exp*(cv/(csdam))*drhodr(jm)*
     >  (apolm*(gradvpolm+gradvneom(3))+atorm*(gradvexbm+gradvdiam(3)) 
     >  +(vpolm+vneom(3))*grad_a_pol+(vexbm+vdiam(3))*grad_a_tor)
      if(alpha_p_tg.eq.0.0)then
        vpar_shear_tg(1)=0.0
        vpar_shear_tg(2)=0.0
        vpar_shear_tg(3)=0.0
      endif
c
c  model for neoclassical diffusivities
c
      diffnem = xparam_pt(3)*deneo_m(jm)
      chietem = xparam_pt(4)*chieneo_m(jm)
      chiitim = xparam_pt(5)*chiineo_m(jm)
      etaphim = xparam_pt(6)*etaphineo_m(jm)
c      etaexbm = xparam_pt(6)*chiineo_m(jm)
c      etaparm = xparam_pt(6)*chiineo_m(jm)
c
c add in artificial diffusion terms
c
       art_diff=adiff_dv*cgyrobohm_m(jm)
       diffnem = diffnem 
     > + art_diff*(dr(jm,2)*DABS(zpmne)/arho_exp)**2
       chietem = chietem
     > + art_diff*DABS(dr(jm,2)*zpmte/arho_exp)**2
       chiitim = chiitim
     > + art_diff*DABS(dr(jm,2)*zpmti/arho_exp)**2
       etaphim = etaphim 
     > + 1.D-2*art_diff*DABS(gamma_p_m(jm)/30.0)**2
c
c compute neoclassical fluxes
c
       nefluxm = nem*zpmne*diffnem/a_unit_exp
       tefluxm = tem*nem*zpmte*chietem/a_unit_exp
       tifluxm = tim*nim*zpmti*chiitim/a_unit_exp
c       vparfluxm = nim*etaparm*gamma_p_tg*csdam/cv
c       vexbfluxm = nim*etaexbm*gamma_e_tg*csdam/cv
c       vphifluxm = c_par(jm)*vparfluxm+c_per(jm)*vexbfluxm
c use diagonal form for agreement with previous versions
c       vphifluxm = nim*etaphim*gamma_p_tg*csdam/cv
      vphifluxm=amassgas_exp*nim*etaphim*gamma_p_m(jm)*csdam/cv
      vparfluxm = vphifluxm*c_per(jm)/c_tor(jm)
      nifluxm = nefluxm
      nzfluxm = 0.0
      tzfluxm = 0.0
      vparzfluxm = 0.0
      vphizfluxm = 0.0
c
      if(ineo.eq.-2.and.q_exp(jm).lt.1.0)go to 86 !skip TGLF fluxes
      if(ineo.eq.-3.and.interchange_DR_m(jm).lt.0.0)then
c use model for interchange mode fluxes
        chi_DR = xparam_pt(14)*cgyrobohm_m(jm)
        diffnem = chi_DR
        chietem = chi_DR
        chiitim = chi_DR
        etaphim = chi_DR
        nefluxm = nem*zpmne*diffnem/a_unit_exp
        tefluxm = tem*nem*zpmte*chietem/a_unit_exp
        tifluxm = tim*nim*zpmti*chiitim/a_unit_exp
        vphifluxm = amassgas_exp*nim*etaphim*gamma_p_m(jm)*(csdam/cv)
        vparfluxm = vphifluxm*c_per(jm)/c_tor(jm)
        nifluxm = nefluxm
        nzfluxm = 0.0
        tzfluxm = 0.0
        vparzfluxm = 0.0
        vphizfluxm = 0.0
        go to 86 !skip TGLF fluxes
      endif
c
c  do not call TGLF to compute variations if the first call has no flux
c       if(ipert_gf.eq.0)write(*,*)"glf2d_dv",jm
       if(ipert_gf.ne.0)then
        if(v2_bar.eq.0.0)go to 86  !skip TGLF fluxes
       endif

c  transfer inputs to TGLF
c
c
      CALL put_gaussian_width(width_max_tg,width_min_tg,nwidth_tg, 
     > find_width_tg)
c
      CALL put_switches(iflux_tg,use_bper_tg,use_bpar_tg,
     > use_mhd_rule_tg,use_bisection_tg, 
     > ibranch_tg,nmodes_tg,nb_max_tg,nb_min_tg,nx_tg,nky_tg)
c
      CALL put_gradients(rlns_tg,rlts_tg,vpar_shear_tg,vexb_shear_tg)
c
      taus_tg(1)=1.0
      taus_tg(2)=tim/tem
      taus_tg(3)=tim/tem
      as_tg(1)=1.0
      as_tg(2)= nim/nem
      as_tg(3)= nzm/nem
      betae_tg=cbetae*betae_m(jm)
      xnuei_tg =xnu_m(jm)
      zeff_tg=zeffm
      vpar_tg(1) = sign_Bt_exp*cv*(apolm*(vpolm+vneom(1))
     >     +atorm*(vexbm+vdiam(1)))/(a_unit_exp*csdam)
      vpar_tg(2) = sign_Bt_exp*cv*(apolm*(vpolm+vneom(2))
     >     +atorm*(vexbm+vdiam(2)))/(a_unit_exp*csdam)
      vpar_tg(3) = sign_Bt_exp*cv*(apolm*(vpolm+vneom(3))
     >     +atorm*(vexbm+vdiam(3)))/(a_unit_exp*csdam)
      if(alpha_p_tg.eq.0.0)then
        vpar_tg(1)=0.0
        vpar_tg(2)=0.0
        vpar_tg(3)=0.0
      endif
c      debye_tg = debyelorhos**2
       debye_tg = debyelorhos
c      if(ipert_gf.eq.0)write(*,*)"debye_tg=",debye_tg
c      write(*,*)"jm=",jm,"ipert_gf=",ipert_gf
c      write(*,*)"debug","gradtem=",gradtem,"tem=",tem
c      write(*,*)"debug","gradtim=",gradtim,"tim=",tim     
c
      CALL put_averages(taus_tg,as_tg,vpar_tg,betae_tg,xnuei_tg,
     > zeff_tg,debye_tg)
c
      if(ipert_gf.eq.0)then
       if(igeo_tg.eq.0)then
c s-alpha geometry
        rmin_tg = rminm/a_unit_exp
        rmaj_tg = rmajm/a_unit_exp
        q_tg = qm
        shat_tg = shat_exp(jm)
        alpha_tg=xalpha*alpha_exp(jm)
        if(ialphastab.gt.0) then
          alpha_tg=xalpha*alpha_m(jm)
        endif
        CALL put_s_alpha_geometry(rmin_tg,rmaj_tg,q_tg,shat_tg,alpha_tg, 
     >    xwell_tg,theta0_tg,b_model_tg,ft_model_tg)
c
       elseif(igeo_tg.eq.1)then  ! miller geometry
c
         dr_loc = (rmin_exp(jm+1)-rmin_exp(jm))/a_unit_exp
         rmin_tg = rminm/a_unit_exp
         rmaj_tg = rmajm/a_unit_exp
         zmaj_tg = 0.0
         q_tg = qm
         q_prime_tg = (q_tg/rmin_tg)*(q_exp(jm+1)-q_exp(jm))/dr_loc
         p_prime_tg = (q_tg/rmin_tg)*(1.6022D-4/b_unit**2)*
     >                (ptot_exp(jm+1)-ptot_exp(jm))/dr_loc
         if(ialphastab.eq.1)then
           p_prime_tg = (q_tg/rmin_tg)*(1.6022D-4/b_unit**2)*
     > (nem*gradtem+tem*gradnem+(nim+nzm)*gradtim+tim*(gradnim+gradnzm))
         endif
         drmindx_tg=1.0
         drmajdx_tg = (rmaj_exp(jm+1)-rmaj_exp(jm))/(dr_loc*a_unit_exp)
         dzmajdx_tg=0.0
         kappa_tg = 0.5*(elong_exp(jm+1)+elong_exp(jm))
         s_kappa_tg = (rmin_tg/kappa_tg)*
     >                (elong_exp(jm+1)-elong_exp(jm))/dr_loc
         s_kappa_tg = dmax1(s_kappa_tg,1.e-2)
c why prevent negative s_kappa? 
         delta_tg = 0.5*(delta_exp(jm+1)+delta_exp(jm))
         s_delta_tg = rmin_tg*(delta_exp(jm+1)-delta_exp(jm))/dr_loc
         zeta_tg=0.0
         s_zeta_tg=0.0
        CALL put_Miller_geometry(rmin_tg,rmaj_tg,zmaj_tg,drmindx_tg,
     >  drmajdx_tg,dzmajdx_tg,kappa_tg,s_kappa_tg,delta_tg,s_delta_tg,
     >  zeta_tg,s_zeta_tg,q_tg,q_prime_tg,p_prime_tg)
c
       else
        write(*,*)"igeo_tg invalid",igeo_tg
        stop
       endif
      endif
      if(ipert_gf.eq.0.and.jm.eq.-1)then
      write(*,*)"debug jm=",jm
      write(*,*)"nem=",nem
      write(*,*)"nzm=",nzm
      write(*,*)"nim=",nim
      write(*,*)"a_unit_exp=",a_unit_exp,"b_unit=",b_unit
      write(*,*)arho_exp,bt_exp
      write(*,*)"averages"
      write(*,*)as_tg(1),as_tg(2),as_tg(3)
      write(*,*)taus_tg(1),taus_tg(2),taus_tg(3)
      write(*,*)betae_tg,xnuei_tg
      write(*,*)zeff_tg,debye_tg
      write(*,*)"gradients"
      write(*,*)rlns_tg(1),rlns_tg(2),rlns_tg(3)
      write(*,*)rlts_tg(1),rlts_tg(2),rlts_tg(3)
c      write(*,*)gamma_e_tg,gamma_p_tg
      write(*,*)"igeo=",igeo_tg
c      write(*,*)"s-a geometry",rmin_tg,rmaj_tg,q_tg,shat_tg,alpha_tg
c      write(*,*)xwell_tg,theta0_tg,b_model_tg,ft_model_tg
      write(*,*)"miller geometry",rmin_tg,rmaj_tg,q_tg
      write(*,*)q_prime_tg,p_prime_tg,drmindx_tg,drmajdx_tg
      write(*,*)kappa_tg,s_kappa_tg,delta_tg,s_delta_tg
      write(*,*)"gaussian"
      write(*,*)width_max_tg,width_min_tg,nwidth_tg,find_width_tg
      write(*,*)"switches"
      write(*,*)iflux_tg,use_bper_tg,use_bpar_tg,use_bisection_tg
      write(*,*)ibranch_tg,nmodes_tg,nb_max_tg,nb_min_tg,nx_tg,nky_tg
      write(*,*)"parameters"
      write(*,*)adi_elec_tg,alpha_p_tg,alpha_e_tg,theta_trap_tg
      write(*,*)xnuei_fac_tg,debye_fac_tg
      write(*,*)"species",nspecies_tg
      do i=1,nspecies_tg
       write(*,*)zs_tg(i),mass_tg(i)
      enddo
c       
      endif
c
c
c      write(*,*)"glf2d_dv",jm,"ipert_gf=",ipert_gf
      if(ipert_gf.ne.0)new_eikonal_tg=.FALSE.
c use eikonal from last call to tglf_TM 
      CALL put_eikonal(new_eikonal_tg)
      CALL tglf_TM
      new_eikonal_tg=.TRUE.
c
c      write(*,'i3,0p6f11.6')jm,get_energy_flux(1,1),get_energy_flux(2,1)
      if(ipert_gf.eq.0)then
        v2_bar = get_v_bar_sum()
c        write(*,*)jm,"v2_bar=",v2_bar
        anrate_m(jm)= get_growthrate(1)
        anfreq_m(jm)= get_frequency(1)
c      write(*,*)"debug gamma",anrate_m(jm)
c      write(*,*)"debug freq",anfreq_m(jm)
c      write(*,*)"debug R_unit=",get_R_unit(),"q_unit=",get_q_unit()
      endif
c gb_unit = common gyrobohm factor for fluxes = cs*(rhos/a)**2
      gb_unit = cgyrobohm_m(jm)/a_unit_exp
cgms      if(igeo_tg.ne.0)gb_unit = gb_unit*drhodr(jm)
      nefluxm = nefluxm + nem*gb_unit*get_particle_flux(1,1)
      nifluxm = nifluxm + nem*gb_unit*get_particle_flux(2,1)
      tefluxm = tefluxm + nem*tem*gb_unit*get_energy_flux(1,1)
      tifluxm = tifluxm + nem*tem*gb_unit*get_energy_flux(2,1)
      vparfluxm = vparfluxm + 
     >   nem*gb_unit*csdam*a_unit_exp*get_stress_par(2,1)
     >   *amassgas_exp/(cv*ABS(bt_exp/B_unit))
      vphifluxm = vphifluxm + 
     >  nem*gb_unit*csdam*a_unit_exp*get_stress_tor(2,1)
     >  *amassgas_exp*a_unit_exp/(rmajor_exp*cv)
      if(nspecies_tg.eq.3)then
        nzfluxm = nzfluxm + nem*gb_unit*get_particle_flux(3,1)
        tzfluxm = tzfluxm + nem*tem*gb_unit*get_energy_flux(3,1)
        vphizfluxm = vphizfluxm + 
     >  nem*gb_unit*csdam*a_unit_exp*get_stress_tor(3,1)
     >  *amassgas_exp*a_unit_exp/(rmajor_exp*cv)
        vparzfluxm = vparzfluxm + 
     >   nem*gb_unit*csdam*a_unit_exp*get_stress_par(3,1)
     >   *amassgas_exp/(cv*ABS(bt_exp/B_unit))
      endif
c      if(use_bper_tg)then
c        nefluxm = nefluxm + nem*gb_unit*get_particle_flux(1,2)
c        tefluxm = tefluxm + nem*tem*gb_unit*get_energy_flux(1,2)
c        tifluxm = tifluxm + nem*tem*gb_unit*get_energy_flux(2,2)
c        if(nspecies_tg.eq.3)then
c          tifluxm = tifluxm + nem*tem*gb_unit*get_energy_flux(3,2)
c        endif
c      endif
c      if(use_bpar_tg)then
c        nefluxm = nefluxm + nem*gb_unit*get_particle_flux(1,3)
c        tefluxm = tefluxm + nem*tem*gb_unit*get_energy_flux(1,3)
c        tifluxm = tifluxm + nem*tem*gb_unit*get_energy_flux(2,3)
c        if(nspecies_tg.eq.3)then
c          tifluxm = tifluxm + nem*tem*gb_unit*get_energy_flux(3,3)
c        endif
c      endif
       tefluxm_etg = tefluxm -nem*tem*gb_unit*get_q_low(1)
       if(nspecies_tg.eq.3)then
c sum up the ions
         tifluxm = tifluxm + tzfluxm
         vphifluxm = vphifluxm + vphizfluxm
         vparfluxm = vparfluxm + vparzfluxm
       endif 
       if(nspecies_tg.eq.2)then
c model for impurity contributions to viscous stress
         mass_factor = 1.0 
     >   +amassimp_exp*fz_m(jm)/(amassgas_exp*fi_m(jm))
         vphifluxm = mass_factor*vphifluxm
         vparfluxm = mass_factor*vparfluxm
       endif
c
c      write(*,*)jm,"ipert = ",ipert_gf,"v2_bar =",v2_bar
c      write(*,*)"debug Qion",get_energy_flux(2)
c      write(*,*)"debug tefluxm=",tefluxm
c
 86   continue   !skip TGLF fluxes
c
c diffusivities in m**2/sec
      diff_m(jm)=nefluxm*zpmne*a_unit_exp/
     >             (nem*max(zpmne**2,1.d-12))
      chie_m(jm)=tefluxm*zpmte*a_unit_exp/
     >             (tem*nem*max(zpmte**2,1.d-12))
      chie_e_m(jm)=tefluxm_etg*zpmte*a_unit_exp/
     >             (tem*nem*max(zpmte**2,1.d-12))
      chii_m(jm)=tifluxm*zpmti*a_unit_exp/
     >             (tim*nim*max(zpmti**2,1.d-12))
      etaphi_m(jm) = cv*vphifluxm*gamma_p_m(jm)/
     >           (nim*csdam*max(gamma_p_m(jm)**2,1.d-12))
c diffusivities for comparison with GYRO in gyro-bohm units
c note that drhodr facotor is removed
      gb_unit = cgyrobohm_m(jm)
      diffgb_m(jm)=diff_m(jm)/gb_unit
      chiegb_m(jm)=chie_m(jm)/gb_unit
      chie_e_gb_m(jm)=chie_e_m(jm)/gb_unit
      chiigb_m(jm)=chii_m(jm)/gb_unit
      etagb_phi_m(jm)=etaphi_m(jm)/gb_unit
c
c multiply fluxes by drhdr factor from volume derivative dV/dr=dV/drho*drhodr
c to map from r-grid fluxes to rho-grid fluxes
c
      nefluxm = nefluxm*drhodr(jm)
      tefluxm = tefluxm*drhodr(jm)
      tifluxm = tifluxm*drhodr(jm)
      vphifluxm = vphifluxm*drhodr(jm)
      vparfluxm = vparfluxm*drhodr(jm)
c
      if(jm.eq.25)then
       open(unit=11,file="gyro_input",status="unknown")
       write(11,*)"gyro input for shot ",shot
       write(11,*)"RADIUS = ",rmin_tg
       write(11,*)"ASPECT_RATIO = ",rmaj_tg
       write(11,*)"KAPPA = ",kappa_tg
       write(11,*)"S_KAPPA = ",s_kappa_tg
       write(11,*)"DELTA0 = ",delta_tg
       write(11,*)"DELTA1 = ",0.0
       write(11,*)"S_DELTA0 = ",s_delta_tg*SQRT(1.0-delta_tg**2) 
       write(11,*)"S_DELTA1 = ",0.0
       write(11,*)"SHIFT = ",drmajdx_tg
       write(11,*)"SAFETY_FACTOR = ",q_tg
       write(11,*)"SHEAR = ",q_prime_tg*(rmin_tg/q_tg)**2
       write(11,*)"RHO_STAR = ",rhosda_m(jm)
       write(11,*)"Z_EFF = ",zeff_tg
       write(11,*)"MACH = ",0.0
       write(11,*)"PGAMMA = ",vpar_shear_tg(2)
       write(11,*)"GAMMA_E = ",vexb_shear_tg
       write(11,*)"LAMDA_DEBYE = ",debye_tg
       write(11,*)"NU_EI = ",xnuei_tg
       write(11,*)"NU_E_DRAG = ",0.0
       write(11,*)"NU_I_KROOK = ",0.0
       write(11,*)"# ION 1"
       write(11,*)"NI_OVER_NE = ",as_tg(2)/as_tg(1)
       write(11,*)"TI_OVER_TE = ",taus_tg(2)/taus_tg(1)
       write(11,*)"DLNNDR = ",rlns_tg(2)
       write(11,*)"DLNTDR = ",rlts_tg(2)
       write(11,*)"Z = ",zs_tg(2)
       write(11,*)"Electrons"
       write(11,*)"DLNNDR_ELECTRON = ",rlns_tg(1)
       write(11,*)"DLNTDR_ELECTRON = ",rlts_tg(1)
       write(11,*)"Z_ELECTRON = ",zs_tg(1)
       write(11,*)"BETAE_UNIT = ",betae_tg
       write(11,*)"MU_ELECTRON = ",SQRT(mass_tg(2)/mass_tg(1))
       write(11,*)"---- EFFECTIVE PHYSICAL UNITS ----"
       write(11,*)"b_unit_norm = ",b_unit
       write(11,*)"a_unit_norm = ",a_unit_exp
       write(11,*)"csda_norm = ",csdam
       write(11,*)"cs_norm = ",csdam*a_unit_exp
       write(11,*)"tem_norm = ",tem
       write(11,*)"den_norm = ",nem
       write(11,*)"chi_gb_norm = ",cgyrobohm_m(jm)
       write(11,*)"bt_exp = ",bt_exp
       write(11,*)"ion #1 mass/mp = ",amassgas_gf
       close(11)
      endif
c
c test for debug of d,v
      if(imodel.eq.-1)then
      do i=1,5
      do j=1,5
         dtest(i,j) = REAL(i+j)
         vtest(i,j) = 2.0*dtest(i,j)
      enddo
      enddo
      nefluxm=0.0
      tefluxm=0.0
      tifluxm=0.0
      vphifluxm=0.0
      vparfluxm=0.0
      i=0
      if(itport_pt(1).ne.0)then
        i=i+1
        j=0
        if(itport_pt(1).ne.0)then
          j=j+1
          nefluxm = nefluxm -dtest(i,j)*gradnem + vtest(i,j)*nem
        endif
        if(itport_pt(2).ne.0)then
          j=j+1
          nefluxm = nefluxm -dtest(i,j)*gradtem + vtest(i,j)*tem
        endif
        if(itport_pt(3).ne.0)then
          j=j+1
          nefluxm = nefluxm -dtest(i,j)*gradtim + vtest(i,j)*tim
        endif
        if(itport_pt(4).ne.0)then
          j=j+1
          nefluxm = nefluxm -dtest(i,j)*(nim*gradvexbm+gradnim*vexbm) 
     >     + vtest(i,j)*nim*vexbm
        endif
        if(itport_pt(5).ne.0)then
          j=j+1
          nefluxm = nefluxm -dtest(i,j)*(nim*gradvpolm+gradnim*vpolm)
     >     + vtest(i,j)*nim*vpolm
        endif
      endif     
      if(itport_pt(2).ne.0)then
        i=i+1
        j=0
        if(itport_pt(1).ne.0)then
          j=j+1
          tefluxm = tefluxm -dtest(i,j)*gradnem + vtest(i,j)*nem
        endif
        if(itport_pt(2).ne.0)then
          j=j+1
          tefluxm = tefluxm -dtest(i,j)*gradtem + vtest(i,j)*tem
        endif
        if(itport_pt(3).ne.0)then
          j=j+1
          tefluxm = tefluxm -dtest(i,j)*gradtim + vtest(i,j)*tim
        endif
        if(itport_pt(4).ne.0)then
          j=j+1
          tefluxm = tefluxm -dtest(i,j)*(nim*gradvexbm+gradnim*vexbm) 
     >    + vtest(i,j)*nim*vexbm
        endif
        if(itport_pt(5).ne.0)then
          j=j+1
          tefluxm = tefluxm -dtest(i,j)*(nim*gradvpolm+gradnim*vpolm)
     >    + vtest(i,j)*nim*vpolm
        endif
      endif     
      if(itport_pt(3).ne.0)then
        i=i+1
        j=0
        if(itport_pt(1).ne.0)then
          j=j+1
          tifluxm = tifluxm -dtest(i,j)*gradnem + vtest(i,j)*nem
        endif
        if(itport_pt(2).ne.0)then
          j=j+1
          tifluxm = tifluxm -dtest(i,j)*gradtem + vtest(i,j)*tem
        endif
        if(itport_pt(3).ne.0)then
          j=j+1
          tifluxm = tifluxm -dtest(i,j)*gradtim + vtest(i,j)*tim
        endif
        if(itport_pt(4).ne.0)then
          j=j+1
          tifluxm = tifluxm -dtest(i,j)*(nim*gradvexbm+gradnim*vexbm)
     >     + vtest(i,j)*nim*vexbm
        endif
        if(itport_pt(5).ne.0)then
          j=j+1
          tifluxm = tifluxm -dtest(i,j)*(nim*gradvpolm+gradnim*vpolm) 
     >     + vtest(i,j)*nim*vpolm
        endif
      endif     
      if(itport_pt(4).ne.0)then
        i=i+1
        j=0
        if(itport_pt(1).ne.0)then
          j=j+1
          vphifluxm = vphifluxm -dtest(i,j)*gradnem + vtest(i,j)*nem
        endif
        if(itport_pt(2).ne.0)then
          j=j+1
          vphifluxm = vphifluxm -dtest(i,j)*gradtem + vtest(i,j)*tem
        endif
        if(itport_pt(3).ne.0)then
          j=j+1
          vphifluxm = vphifluxm -dtest(i,j)*gradtim + vtest(i,j)*tim
        endif
        if(itport_pt(4).ne.0)then
          j=j+1
          vphifluxm = vphifluxm-dtest(i,j)*(nim*gradvexbm+gradnim*vexbm) 
     >    + vtest(i,j)*nim*vexbm
        endif
        if(itport_pt(5).ne.0)then
          j=j+1
          vphifluxm = vphifluxm-dtest(i,j)*(nim*gradvpolm+gradnim*vpolm)
     >    + vtest(i,j)*nim*vpolm
        endif
      endif 
      if(itport_pt(5).ne.0)then
        i=i+1
        j=0
        if(itport_pt(1).ne.0)then
          j=j+1
          vparfluxm = vparfluxm -dtest(i,j)*gradnem + vtest(i,j)*nem
        endif
        if(itport_pt(2).ne.0)then
          j=j+1
          vparfluxm = vparfluxm -dtest(i,j)*gradtem + vtest(i,j)*tem
        endif
        if(itport_pt(3).ne.0)then
          j=j+1
          vparfluxm = vparfluxm -dtest(i,j)*gradtim + vtest(i,j)*tim
        endif
        if(itport_pt(4).ne.0)then
          j=j+1
          vparfluxm = vparfluxm-dtest(i,j)*(nim*gradvexbm+gradnim*vexbm) 
     >    + vtest(i,j)*nim*vexbm
        endif
        if(itport_pt(5).ne.0)then
          j=j+1
          vparfluxm = vparfluxm-dtest(i,j)*(nim*gradvpolm+gradnim*vpolm)
     >    + vtest(i,j)*nim*vpolm
        endif
      endif 
      endif   
c
c
c      write(*,*)"debug tglf",jm
c
c      write(*,*) 'particle_flux(1) = ',get_particle_flux(1)
c      write(*,*) 'particle_flux(2) = ',get_particle_flux(2)
c      write(*,*) 'energy_flux(1) = ',get_energy_flux(1)
c      write(*,*) 'energy_flux(2) = ',get_energy_flux(2)
c      write(*,*) 'n_bar_sum(1) = ',get_n_bar_sum(1)
c      write(*,*) 'n_bar_sum(2) = ',get_n_bar_sum(2)
c      write(*,*) 't_bar_sum(1) = ',get_t_bar_sum(1)
c      write(*,*) 't_bar_sum(2) = ',get_t_bar_sum(2)
c      write(*,*) 'phi_bar_sum = ',get_phi_bar_sum()
c
c  
      END   !SUBROUTINE tglf_dv
c




      subroutine get_12_fiprof(time,pload_12)
c-----------------------------------------------------------------------
c  Interpolate all quantities generated by nubeam onto the current time
c  and store in Onetwo variable that corresponds to the nubeam value.
c  Note that this is for the old nubeam!!!!! 
c  nubeam_version > 0 doesnt use this
c-------------------------------------------------------------------------
      USE transp, only   : 
     .               nubeam_calls,qbeame_nub,qbeami_nub,
     .               qbeame_nubp,qbeami_nubp,nubeam_steps,
     .               qbth_nubp,qbth_nub,
     .               qbeame_intg_nubp,qbeame_intg_nub,
     .               qbeami_intg_nubp,qbeami_intg_nub,
     .               qbth_intg_nubp,qbth_intg_nub,
     .               curb_nub,curb_nubp,curb_intg_nub,
     .               curb_intg_nubp,storqueb_nub,
     .               storqueb_nubp,storqueb_intg_nub,
     .               storqueb_intg_nubp,sprbeame_nub,
     .               sprbeame_nubp,sprbeame_intg_nub,
     .               sprbeame_intg_nubp,sprbeami_nub,
     .               sprbeami_nubp,sprbeami_intg_nub,
     .               sprbeami_intg_nubp,beam_data,
     .               wbeam_nub,wbeam_nubp,wbeam_intg_nub,
     .               enbeam_intg_nubp,wbeam_intg_nubp,
     .               enbeam_nub,enbeam_nubp,enbeam_intg_nub,
     .               enbeam_intg_nubp,pwf_tot_intg_nub,
     .               pwf_tot_intg_nubp,
     .               beam_thermal_dtntot_nub,beam_thermal_dtntot_nubp,
     .               beam_thermal_ddntot_nub,beam_thermal_ddntot_nubp,
     .               beam_thermal_ddptot_nub,beam_thermal_ddptot_nubp,
     .               beam_thermal_tt2ntot_nub,beam_thermal_tt2ntot_nubp,
     .               beam_beam_dtntot_nub,beam_beam_dtntot_nubp,
     .               beam_beam_ddntot_nub,beam_beam_ddntot_nubp,
     .               beam_beam_ddptot_nub,beam_beam_ddptot_nubp,
     .               beam_beam_tt2ntot_nub,beam_beam_tt2ntot_nubp,
     .               beam_beamddp_nub,beam_beamddp_nubp,
     .               beam_beamtt2n_nub,beam_beamtt2n_nubp,
     .               beam_beamddn_nub,beam_beamddn_nubp,
     .               beam_beamdtn_nub,beam_beamdtn_nubp,
     .               beam_thermaltth_df_nub,beam_thermaltth_df_nubp,
     .               beam_thermalddp_nub,beam_thermalddp_nubp,
     .               beam_thermalddn_nub,beam_thermalddn_nubp,
     .               beam_thermaltt2n_nub,beam_thermaltt2n_nubp,
     .               beam_thermaldth_tf_nub,beam_thermaldth_tf_nubp,
     .               enbeam_species,enbeam_species_p,
     .               enbeam_species_c,mfi,
     .               sorbn0_nub,sorbn0_nubp,sorbh_nub,sorbh_nubp !jmp.den     

      USE sourc, only    :    qbeame,qbeami,qbeame_intg,qbeami_intg,
     .                        qbth_intg,qbth,curb_intg,curb,wbeam_intg,
     .                        enbeam_intg,sbeam !jmp.den

      USE fusion,only     :   beam_thermal_dtntot, beam_thermal_ddntot,
     .                        beam_thermal_ddptot, beam_thermal_tt2ntot,
     .                        beam_beam_dtntot, beam_beam_ddntot, 
     .                        beam_beam_tt2ntot,beam_beam_ddptot, 
     .                        beam_beamddn,beam_beamdtn,beam_beamddp,
     .                        beam_beamtt2n,beam_thermaltth_df,
     .                        beam_thermalddp, beam_thermalddn,
     .                        beam_thermaltt2n,beam_thermaldth_tf 
      USE nbi_restart, ONLY : set_fiprof
      USE nub,  ONLY: nbeams,sbcx,ibion !jmp.den
      USE nub2, ONLY: enbeam,wbeam


      USE numbrs, only     : nj,nion
      USE geom,   ONLY     : fcap,gcap,hcap
      USE solcon, only     : time_tol,dtmin
     
      USE tordlrot, only   :     storqueb,storqueb_intg,
     .                           sprbeame,sprbeami,sprbeame_intg,
     .                           sprbeami_intg,storque,angrot


       USE soln,        ONLY : te,ti,rbp,ene,en,curden,etor,curden
       USE sourc,       ONLY : curdri,curohm,currf,curboot
       USE restore_12
      IMPLICIT NONE
      REAL *8 time,timep,timef,dtime,deltat,slope,tolt
      INTEGER j,ksymp1,ksymp2,k,pload_12,ks


c     nbeams may be less than beam_data%nbeam
c     nevertheless use nbeam as index for arrays, chnaged 5/03/04 HSJ
c      IF(nbeams .ne. beam_data%nbeam)then
c           print *,'nbeams,beam_data%nbeam =',nbeams,beam_data%nbeam
c           Call STOP('get_12.fiprof nbeams .ne. beam_data%nbeam',1)
c      ENDIF

      ksymp1 = ((3*nbeams+1)*3*nbeams)/2+1      !for beam_beam
      ksymp2  = 3*nbeams+1                      !for beam_thermal

      timep = nubeam_calls(nubeam_steps-2)!penultimate nubeam results
                                            !were generated at timep
      timef = nubeam_calls(nubeam_steps-1)  !last nubeam results were
                                            !generated at timef

c      its possible that time > timef by some small fraction
c      of tol_time due to roundoff. Account for this here:
      tolt = time -timef !should be  .le. 0.0
      if ( tolt .gt. 0.0 .and. tolt .le. dtmin)timef = time
      tolt = time -timep !should be  .ge. 0.0
      if ( tolt .lt. 0.0 .and. tolt .le. dtmin)timep = time
c      tolt  = time -timep
c      if(tolt .lt. 0.0 .and.  ABS(tolt) .lt. 3*time_tol)then
c         nubeam_calls(nubeam_steps-2) = time
c         timep = nubeam_calls(nubeam_steps-2)
c      endif


      dtime = timef - timep
      tbracket: If(timep .le. time .and. time .le. timef)then
         deltat = time - timep
         tdelt: IF(deltat .gt. 3.*time_tol)then
            DO j=1,nj
               slope = (qbeame_nub(j) - qbeame_nubp(j)) /dtime
               qbeame(j) = qbeame_nubp(j) + slope * deltat

               slope = (qbeami_nub(j) - qbeami_nubp(j)) /dtime
               qbeami(j) = qbeami_nubp(j) + slope * deltat

               slope = (qbth_nub(j) - qbth_nubp(j)) /dtime
               qbth(j) = qbth_nubp(j) + slope * deltat

               slope = (curb_nub(j) - curb_nubp(j)) /dtime
               curb(j) = curb_nubp(j) + slope * deltat


               slope = (storqueb_nub(j) - storqueb_nubp(j)) /dtime
               storqueb(j) = storqueb_nubp(j) + slope * deltat

               slope = (sprbeame_nub(j) - sprbeame_nubp(j)) /dtime
               sprbeame(j) = sprbeame_nubp(j) + slope * deltat

               slope = (sprbeami_nub(j) - sprbeami_nubp(j)) /dtime
               sprbeami(j) = sprbeami_nubp(j) + slope * deltat


               slope = (wbeam_nub(j) - wbeam_nubp(j)) /dtime
               wbeam(j) = wbeam_nubp(j) + slope * deltat

               slope = (enbeam_nub(j) - enbeam_nubp(j)) /dtime
               enbeam(j) = enbeam_nubp(j) + slope * deltat

               DO  ks =1 , mfi
                  slope = (enbeam_species(j,ks) - 
     .                      enbeam_species_p(j,ks)) /dtime
                  enbeam_species_c(j,ks) = enbeam_species_p(j,ks) 
     .                            + slope * deltat
               ENDDO


               slope = (beam_beamdtn_nub(j) - beam_beamdtn_nubp(j)) 
     .                                                       /dtime
               beam_beamdtn(j,ksymp1) = beam_beamdtn_nubp(j) 
     .                                              + slope * deltat

               slope = (beam_beamddp_nub(j) - beam_beamddp_nubp(j)) 
     .                                                       /dtime
               beam_beamddp(j,ksymp1) = beam_beamddp_nubp(j) 
     .                                              + slope * deltat

               slope = (beam_beamddn_nub(j) - beam_beamddn_nubp(j)) 
     .                                                       /dtime
               beam_beamddn(j,ksymp1) = beam_beamddn_nubp(j) 
     .                                              + slope * deltat

               slope = (beam_beamtt2n_nub(j) - beam_beamtt2n_nubp(j)) 
     .                                                       /dtime
               beam_beamtt2n(j,ksymp1) = beam_beamtt2n_nubp(j) 
     .                                                + slope *deltat



               slope = (beam_thermaltth_df_nub(j) - 
     .                            beam_thermaltth_df_nubp(j))/dtime
               beam_thermaltth_df(j,ksymp2) = 
     .                     beam_thermaltth_df_nubp(j) + slope *deltat


               slope = (beam_thermalddp_nub(j) - 
     .                            beam_thermalddp_nubp(j))/dtime
               beam_thermalddp(j,ksymp2) = 
     .                     beam_thermalddp_nubp(j) + slope *deltat

               slope = (beam_thermalddn_nub(j) - 
     .                            beam_thermalddn_nubp(j))/dtime
               beam_thermalddn(j,ksymp2) = 
     .                     beam_thermalddn_nubp(j) + slope *deltat

               slope = (beam_thermaltt2n_nub(j) - 
     .                            beam_thermaltt2n_nubp(j))/dtime
               beam_thermaltt2n(j,ksymp2) = 
     .                     beam_thermaltt2n_nubp(j) + slope *deltat



               slope = (beam_thermaldth_tf_nub(j) - 
     .                            beam_thermaldth_tf_nubp(j))/dtime
               beam_thermaldth_tf(j,ksymp2) = 
     .                     beam_thermaldth_tf_nubp(j) + slope *deltat


               !jmp.den start
               slope = (sorbn0_nub(j) - sorbn0_nubp(j)) / dtime
               sbcx(j,1) = sorbn0_nubp(j) + slope * deltat
               slope = (sorbh_nub(j) - sorbh_nubp(j)) / dtime
               sbeam(j) = sorbh_nubp(j) + slope * deltat !hard-coded
               !jmp.den end

            IF(pload_12 ==1)THEN
               te(j) = te_nub(j)
               ti(j) = ti_nub(j)
               storque(j) = storque_nub(j)
               storqueb(j) = storqueb_nub(j)
               angrot(j) = angrot_nub(j)
               rbp(j) = rbp_nub(j)
               ene(j) = ene_nub(j)
               do k=1,nion
                  en(j,k) = en_nub(j,k)
               enddo
               curden(j) = curden_nub(j)
               etor(j) = etor_nub(j)
               curdri(j) = curdri_nub(j)
               curohm(j) = curohm_nub(j)
               !currf(j) = currf_nub(j)  ! currf is additive. to prevent double
                                         ! counting at startup we can not initialize  it to
                                         ! the value in the restart file. HSJ 06/15/06
               curboot(j) = curboot_nub(j)
               !for consistent current drive we set curb here
               !even though time interpoalted value is availble above
               curb(j) = curb_nub(j)
               hcap(j) = hcap_nub(j)
               gcap(j) = gcap_nub(j)
               fcap(j) = fcap_nub(j)
             ENDIF
               
            ENDDO

               slope = (qbeame_intg_nub - qbeame_intg_nubp)/dtime
               qbeame_intg = qbeame_intg_nubp + slope * deltat
               slope = (qbeami_intg_nub - qbeami_intg_nubp)/dtime
               qbeami_intg = qbeami_intg_nubp + slope * deltat
               slope = (qbth_intg_nub - qbth_intg_nubp)/dtime
               qbth_intg = qbth_intg_nubp + slope * deltat
               slope = (curb_intg_nub - curb_intg_nubp)/dtime
               curb_intg = curb_intg_nubp + slope * deltat
               slope = (storqueb_intg_nub - storqueb_intg_nubp)/dtime
               storqueb_intg = storqueb_intg_nubp + slope * deltat
               slope = (sprbeame_intg_nub - sprbeame_intg_nubp)/dtime
               sprbeame_intg = sprbeame_intg_nubp + slope * deltat
               slope = (sprbeami_intg_nub - sprbeami_intg_nubp)/dtime
               sprbeami_intg = sprbeami_intg_nubp + slope * deltat
               slope = (pwf_tot_intg_nub- pwf_tot_intg_nubp)/dtime
               beam_data%pwf_tot_intg = pwf_tot_intg_nubp + 
     .                                                  slope * deltat
               slope = (wbeam_intg_nub - wbeam_intg_nubp)/dtime
               wbeam_intg = wbeam_intg_nubp + slope * deltat
               slope = (enbeam_intg_nub - enbeam_intg_nubp)/dtime
               enbeam_intg = enbeam_intg_nubp + slope * deltat

               slope = (beam_thermal_dtntot_nub - 
     .                            beam_thermal_dtntot_nubp )/dtime
               beam_thermal_dtntot = beam_thermal_dtntot_nubp +
     .                                               slope * deltat
               slope = (beam_thermal_ddntot_nub - 
     .                            beam_thermal_ddntot_nubp )/dtime
               beam_thermal_ddntot = beam_thermal_ddntot_nubp +
     .                                               slope * deltat
               slope = (beam_thermal_ddptot_nub - 
     .                            beam_thermal_ddptot_nubp )/dtime
               beam_thermal_ddptot = beam_thermal_ddptot_nubp +
     .                                               slope * deltat
               slope = (beam_thermal_tt2ntot_nub - 
     .                            beam_thermal_tt2ntot_nubp )/dtime
               beam_thermal_tt2ntot = beam_thermal_tt2ntot_nubp +
     .                                               slope * deltat

               slope = (beam_beam_dtntot_nub - 
     .                            beam_beam_dtntot_nubp )/dtime
               beam_beam_dtntot = beam_beam_dtntot_nubp +
     .                                               slope * deltat
               slope = (beam_beam_ddntot_nub - 
     .                            beam_beam_ddntot_nubp )/dtime
               beam_beam_ddntot = beam_beam_ddntot_nubp +
     .                                               slope * deltat
               slope = (beam_beam_ddptot_nub - 
     .                            beam_beam_ddptot_nubp )/dtime
               beam_beam_ddptot = beam_beam_ddptot_nubp +
     .                                               slope * deltat
               slope = (beam_beam_tt2ntot_nub - 
     .                            beam_beam_tt2ntot_nubp )/dtime
               beam_beam_tt2ntot = beam_beam_tt2ntot_nubp +
     .                                               slope * deltat

         ELSE tdelt

            CALL  set_fiprof                ! nbi_restart.f90

         ENDIF tdelt
      else tbracket
         print *,'error in subroutine get_12_fiprof'
         print *,'timep,time,timef =',timep,time,timef
         print *,'nubeam_steps =',nubeam_steps
         print *,'nubeam_calls =',nubeam_calls
         CALL STOP('time sequence error',1)
      endif tbracket

      return
      end





      subroutine prep_mcgo (mcgo_beam, bpow, icbpow, enbeams)
c
      USE param
      USE neut
      USE io 
      USE ions
      USE nub
      USE nub2
      USE soln
      USE limiter
      USE numbrs
      USE mesh
      USE machin
      USE geom
      USE rhog
      USE mcgo
      USE neo2d
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c ----------------------------------------------------------------------
c     This subroutine prepares an input file for mcgo
c     Note that mcgo also uses file eqdskin
c     Also note that Mcgo expects mks input in some quantities
c --------------------------------------------------------HSJ-8/28/98---
c
      include 'storage.i'
      parameter (kmcgo = kprim+kimp+2)
      dimension enn_mcgo(kj),rgrid_mcgo(kj),rm2_mf(kj),eps_mf(kj),
     .          hcap_mf(kj),dumy_en(kj)
      dimension bpow(icbpow,*),enbeams(*)
      character*8   mcgo_name(kmcgo)
      equivalence(enn_mcgo(1),wdum(1))
      equivalence(rgrid_mcgo(1),wdum(kj+1))
      equivalence(rm2_mf(1),wdum(2*kj+1))
      equivalence(eps_mf(1),wdum(3*kj+1))
      equivalence(hcap_mf(1),wdum(4*kj+1))
      equivalence(dumy_en(1),wdum(5*kj+1))
      character apostrophe*1
      parameter (apostrophe = CHAR (39))
c
      if (kstore .lt. 5*kj)
     .  call STOP ('subroutine PREP_MCGO: kstore too small', 276)
c
c ----------------------------------------------------------------------
c
c     mcgo input file  to be created,fresh each time:
c
      call DESTROY (mcgo_input_file(mcgo_beam))
      call getioun(nmcgo1,nmcgo1)
      open  (unit = nmcgo1, file = mcgo_input_file(mcgo_beam), 
     .                                         status = 'NEW')
      write (nmcgo1, '(10x, "Input File For Mcgo Generated by Onetwo")')
      write (nmcgo1, '( 2x, "$input")')       ! start the namelist input
c
c ----------------------------------------------------------------------
c
c     Set the MCGO problem specifiers for a suitable onetwo coupled run:
c
      write (nmcgo1, '(2x, "iproblm = 3, inits = -1, irstrt = 0")')
      onetwo_beam = mcgo_beam
      write (nmcgo1,'(2x,''onetwo_beam = '',i3)')onetwo_beam
      write (nmcgo1,'(2x,"fionls = .false.")')
      write (nmcgo1,'(2x,"ibeam = 1")')
      write (nmcgo1,'(2x,"npart = ",i10)')npart_mcgo
      write (nmcgo1,'(2x,"ranseed = 0, rantest = .false.")')
c                         ranseed = 1 for non-random above
      njmcgo  = nj ! can't be greater than parameter kf in mcgo::param.i
      mf_mcgo = mf ! grid size used in MCGO
c                    (njmcgo is interpolated onto mf_mcgo)
      kf_mcgo = 51 ! should be set to kf in mcgo para.i
      mf_mcgo = MIN (mf_mcgo, kf_mcgo)
      timstp_mcgo = 3.0e-6
      write (nmcgo1, '(2x,"pin = 1.e10 ")') ! ion will not be followed..
c                             ..beyond this value of the totoridal angle
      write(nmcgo1,'(2x,"gfactr = 0.1, taufrac = 0.005 ")')
      write(nmcgo1,'(2x,"timeup = 100000., timmax = 100000.0,"
     .               " accurc=1.0e-04,"
     .                                                               )')
      write(nmcgo1,'(2x,"icoul =  1, icoul1 = 1, efrac =  1.5")')
      one = 1.0
      write(nmcgo1,'(2x,"bsgn = ",f5.0 ," csgn = 1.")')sign(one,btor)
      write(nmcgo1,'(2x,"bpscale = 1., btscale = 1.,vloop =0.
     .                                                   phinot =0.")')
c
      write(nmcgo1,'(2x,"qa=0.0, geometry = ""twodee"", irctr = 1 ")')
c                                              file intfl required above
      write(nmcgo1,'(2x,"rin = ",f10.5, " rout = ", f10.5," rmajor = "
     .                 f10.5 )')rin,rout,rmajor
      write(nmcgo1,'(2x,"rmin_onetwo = ",f10.5,2x,"rmax_onetwo = ",
     .      f10.5,2x,"zmin_onetwo  = ",f10.5,2x,
     .      "zmax_onetwo  = ",f10.5)')rmin,rmax,zmin,zmax
      write(nmcgo1,'(2x,"timstp = ",1Pe14.6," delta2  = 0", 1Pe14.6)')
     .                                                   timstp_mcgo
      write(nmcgo1,'(2x,"ibres = 0")')
c                  fast ion/neutral resonance charge exchg. is off above
      write(nmcgo1,'(2x,"gc_integ = ""rktwodee"", dti = 1.e-08 ")')
      write(nmcgo1,'(2x,"icxmode = ""disabled""")')
      write(nmcgo1,'(2x,"nradbin = 19")')
      write(nmcgo1,'(2x,"mf = ",i5," maxp_12 =",i5)') mf_mcgo,maxp
c                                                     in param.i above
      irctr = 0
c
c-----------------------------------------------------------------------------
c---the plasma properties MCGO sees . Note that we do not interpolate from the
c---r grid to a different grid for mcgo so njmcgo must equal nj here.
c---icenez =1 is passed to mcgo from onetwo. This means that the ion densities
c---in onetwo are passed to mcgo and then mcgo calculates zeff and the
c---electron densities. Doing it this way avoids some messy logic with
c---zfrac,etc.
      i=0
      do j=1,nprim
         i=i+1
         mcgo_name(i)=namep(j)
      end do
      do j=1,nimp
         i=i+1
         mcgo_name(i)=namei(j)
      end do
      do j=1,nneu
         i=i+1
         mcgo_name(i)=namen(j)
      end do
      do j=1,i
         if (mcgo_name(j) .eq. 'd' )  go to 95
         if (mcgo_name(j) .eq. 't' )  go to 95
         if (mcgo_name(j) .eq. 'he')  go to 95
         if (mcgo_name(j) .eq. 'c' )  go to 95
         if (mcgo_name(j) .eq. 'o' )  go to 95
         if (mcgo_name(j) .eq. 'si')  go to 95
         if (mcgo_name(j) .eq. 'fe')  go to 95
         if (mcgo_name(j) .eq. 'mo')  go to 95
         if (mcgo_name(j) .eq. 'w' )  go to 95
         call STOP ('subroutine PREP_MCGO: MCGO missing element', 277)
 95      continue
      end do
      icenez_mcgo=1
      iprmion_mcgo=1
      write(nmcgo1,'(2x,"nion =",i5,"  ibion =",i5)')nion,ibion
      write(nmcgo1,'(2x,"iprmion =",i5,"  icenez =",i5)')iprmion_mcgo,
     .                                                     icenez_mcgo
      write(nmcgo1,98)(apostrophe,
     .           TRIM(mcgo_name(j)),apostrophe,j=1,i)
 98   format (2x, "namei = ",(5(2x,3a,2x)))
c
c     if nion = 3 then mcgo assumes two primary ions and one impurity.
c     The second ion density is given by zfrac if icenez=0 in mcgo:
c
      write(nmcgo1,'(''    psi_beam_onetwo = '',5(2x,1pe16.8))')
     .                                             (psif(j),j=1,mf)
      call newgrid(psir,r,nj,psif,freyr,mf)
      write(nmcgo1,'(''    rho_beam_onetwo = '',5(2x,1pe16.8))')
     .                                             (freyr(j),j=1,mf)
c
c     rm2 =<1./R**2> cm-2:
c
      call newgrid(psir,r2cap,nj,psif,rm2_mf,mf)
      write(nmcgo1,'(''    rm2_onetwo = '',5(2x,1pe16.8))')
     .                                             (rm2_mf(j),j=1,mf)
c
c     eps:
c
      call newgrid(psir,eps,nj,psif,eps_mf,mf)
      write(nmcgo1,'(''    eps_onetwo = '',5(2x,1pe16.8))')
     .                                             (eps_mf(j),j=1,mf)
c
      call newgrid(r,hcap,nj,freyr,hcap_mf,mf)
      write(nmcgo1,'(''    hcap_onetwo = '',5(2x,1pe16.8))')
     .                                             (hcap_mf(j),j=1,mf)
      write(nmcgo1,'(''    psivol_onetwo = '',5(2x,1pe16.8))')
     .                                             (psivol(j),j=1,mfm1)
c
      do j=1,njmcgo
        rgrid_mcgo(j)=r(j)/r(njmcgo)
      end do
      call  copya(en(1,ibion),dumy_en,njmcgo)
      do ion_mcgo = 1, nion
c
c        add the beam density to the thermal ion density on option:
c
         if (mcgo_fast_ion_target .gt. 0 .and. ion_mcgo .eq. ibion) then
           do j=1,njmcgo
             en(j,ibion)=en(j,ibion)+enbeams(j)
           end do
         end if
c
         write(nmcgo1,100)ion_mcgo,(rgrid_mcgo(j),j=1,njmcgo)
         write (nmcgo1,101)ion_mcgo,(en(j,ion_mcgo),j=1,njmcgo)
  100    format(2x,'rni(1,',i1,') = ',5(2x,1pe14.8))
  101    format(2x,'eni(1,',i1,') = ',5(2x,1pe14.8))
c
c        MCGO requires separate specification of density in scrape off
c        region outside the plasma . This info is not currently
c        available here and we simply extend the edge density into
c        the scrapeoff layer HSJ:
c
         write(nmcgo1,'(''     enib1('',i1,'') = '',1pe14.8)')
     .                            ion_mcgo,en(njmcgo,ion_mcgo)
c
         write(nmcgo1,102)ion_mcgo,(rgrid_mcgo(j),j=1,njmcgo)
         write (nmcgo1,103)ion_mcgo,(zzi(j,ion_mcgo),j=1,njmcgo) !zzi is not of size njmcgo HSJ deliberate fail
  102    format(2x,'rzzi(1,',i1,') = ',5(2x,1pe14.8))
  103    format(2x,'zzi(1,',i1,') = ',5(2x,1pe14.8))
c
         write(nmcgo1,104)ion_mcgo,(rgrid_mcgo(j),j=1,njmcgo)
         write (nmcgo1,105)ion_mcgo,(zsq(j,ion_mcgo),j=1,njmcgo)
  104    format(2x,'rzsqi(1,',i1,') = ',5(2x,1pe14.8))
  105    format(2x,'zsqi(1,',i1,') = ',5(2x,1pe14.8))
c
c        MCGO requires separate specification of scrapeoff density!!!
c
         write(nmcgo1,'(''     enib1('',i1,'') = '',1pe14.8)')
     .     ion_mcgo,en(njmcgo,ion_mcgo) ! in scrapeoff layer
c
      end do
c
      call copya (dumy_en, en(1,ibion), njmcgo) !@restore en
c
      write(nmcgo1,110)(rgrid_mcgo(j),j=1,njmcgo)
      write (nmcgo1,111)(zeff(j),j=1,njmcgo)
  110 format(2x,'rzef = ',(5(2x,1pe14.8)))
  111 format(2x,'zef = ',(5(2x,1pe14.8)))
      zeffb1=1.0
      write(nmcgo1,'(''     zeffb1 = '',1pe14.8)')zeffb1 ! in SOL
c
      write(nmcgo1,115)(rgrid_mcgo(j),j=1,njmcgo)
      write (nmcgo1,116)(ene(j),j=1,njmcgo)
  115 format(2x,'rne = ',(5(2x,1pe14.8)))
  116 format(2x,'ene = ',(5(2x,1pe14.8)))
      write(nmcgo1,'(''     eneb1 = '',1pe14.8)')ene(njmcgo) ! in SOL
c
      write(nmcgo1,120)(rgrid_mcgo(j),j=1,njmcgo)
      write (nmcgo1,121)(te(j),j=1,njmcgo)
  120 format(2x,'rte = ',(5(2x,1pe14.8)))
  121 format(2x,'te = ',(5(2x,1pe14.8)))
      write(nmcgo1,'(''     teb1 = '',1pe14.8)')te(njmcgo) ! in SOL
c
      write(nmcgo1,130)(rgrid_mcgo(j),j=1,njmcgo)
      write (nmcgo1,131)(ti(j),j=1,njmcgo)
  130 format(2x,'rti = ',(5(2x,1pe14.8)))
  131 format(2x,'ti = ',(5(2x,1pe14.8)))
      write(nmcgo1,'(''     tib1 = '',1pe14.8)') ti(njmcgo) ! in SOL
c
c --- MCGO only takes a single neutral density
c --- so we sum the neutrals from onetwo:
c
      do j=1,nj
        enn_mcgo(j)=enn(j,1)+enn(j,2)
      end do
      write(nmcgo1,140)(rgrid_mcgo(j),j=1,njmcgo)
      write (nmcgo1,141)(enn_mcgo(j),j=1,njmcgo)
  140 format(2x,'rnn = ',(5(2x,1pe14.8)))
  141 format(2x,'enn(1) = ',(5(2x,1pe14.8)))
      write(nmcgo1,'(''     ennb1 = '',1pe14.8)') enn_mcgo(njmcgo)
c                                                 in scrapeoff layer
c --- beam stuff
c ----------------------------------------------------------------------
c
      mcgo_beams=1
      write(nmcgo1,'(4x,"mb = ",i5," ebkev = ",4(2x,1pe12.4))')
     .                             mcgo_beams,ebkev(onetwo_beam)
****  write(nmcgo1,'(4x,"mb = ",i5," ebkev = ",4(2x,1pe12.4))')
**** .                             nbeams,(ebkev(j),j=1,nbeams)
      write(nmcgo1,'(4x,''mcgo_input_file2 = '',3a)')apostrophe,
     . TRIM(mcgo_input_file2(onetwo_beam)),apostrophe
****  if (nbeams .gt. 1)
**** .  write(nmcgo1,'(4x,''mcgo_input_file2(2) = '',3a)')apostrophe,
**** .  mcgo_input_file2(2)(1:LENGTH(mcgo_input_file2)),apostrophe
c
          write(nmcgo1,145)npart_full(onetwo_beam),
     .    npart_half(onetwo_beam), npart_third(onetwo_beam)
  145     format(2x,'npart_full =',i6,'  npart_half =',i6,
     .    '  npart_third = ',i6)
c      if (nbeams .gt. 1)
c     .  write(nmcgo1,146)npart_full(2),npart_half(2),npart_third(2)
c  146 format(2x,'npart_full(2) =',i6,'  npart_half(2) =',i6,
c     .                               '  npart_third(2) = 'i6)
c
c     note bpow and pbeam are the same thing:
c
          do j=1,nbeams
             do i=1,3
               write(nmcgo1,150)i,j, bpow(i,j),i,j,fap(i,j)
               write(nmcgo1,151)i,j,fwall(i,j),i,j,bneut(i,j)
             end do
          end do
  150     format (2x,'bpow_onetwo(',i1,',',i1,') =' , 1pe12.6,
     .            2x,'fap_onetwo(',i1,',',i1,') ='  , 1pe12.6)
  151     format (2x,'fwall_onetwo(',i1,',',i1,') =' , 1pe12.6,
     .            2x,'bneut_onetwo(',i1,',',i1,') ='  , 1pe12.6)
c
c ----------------------------------------------------------------------
c --- MCGO needs the limiter points:
c
      write  (nmcgo1,'(2x,"nlimiter = ",i5)')nlimiter
      write  (nmcgo1,300)(xlimiter(j),j=1,nlimiter)
  300 format (2x,'xlimiter = ',(4(2x,1pe14.6)))
      write  (nmcgo1,301)(ylimiter(j),j=1,nlimiter)
  301 format (2x,'ylimiter = ',(4(2x,1pe14.6)))
      write  (nmcgo1,'(''   eqdskin = '',a)')eqdskin
      write  (nmcgo1,'(2x,"$end")')
      call giveupus(nmcgo1)
      close  (unit = nmcgo1)
      return
c
      end

      subroutine psumry (nunit)
c

c
c     PSUMRY writes out a 
c     summary page of transport analysis results
c
      USE param
      USE bd_condtn, only : use_pedestal,ped_nebar,ped_temp,
     .                      ped_Ngr,ped_grad,ped_mode,ped_nratio
      USE fusion
      USE aid_newton ,            ONLY : SSQR, gradmax,tot_iters
      USE ions
      USE nub
      USE solcon
      USE soln
      USE mhdpar
      USE rf
      USE extra
      USE yoka                    !  ptor,prf,pbe,pbi 
      USE numbrs
      USE mesh
      USE sourc                   ! totrf
      USE machin
      USE tfact
      USE geom
      USE flags
      USE tordlrot
      USE tcoef
      USE bd_condtn
      USE psig
      USE flxav
      USE cfactrs,               ONLY : H89pm,H_ITER98y2,H_Petty,
     .                                  confinement_factrs
      USE io,                    ONLY : versid
      USE rad_loss,              ONLY : brems_nions,
     .                                  brems_prim,brems_imp
      USE P_Nfreya_12_interface, ONLY : use_P_Nfreya

      USE transp,                ONLY : use_nubeam,nubeam_version


      implicit  integer (i-n), real*8 (a-h, o-z)

c
      character*8 np
c
c find "peakedness" of profiles:  central/volume-averaged values
c
      volrat = volfac / volume
      do j=1,nj
        fact(j) = volrat * hcap(j)
      end do
      call trapv (r,ene,fact,nj,enepk)
      enepk  = ene(1) / enepk
      call trapv (r,en,fact,nj,enpk)
      enpk   = en(1,1) / enpk
      call trapv (r,te,fact,nj,tepk)
      tepk   = te(1) / tepk
      call trapv (r,ti,fact,nj,tipk)
      tipk   = ti(1) / tipk
      call trapv (r,curden,fact,nj,curpk)
      curpk  = curden(1) / curpk
      call trapv (r,zeff,fact,nj,zefpk)
      zefpk  = zeff(1) / zefpk
      angpk  = 0.0
      if (iangrot .ne. 0) then
        call trapv (r, angrot, fact, nj, angpk)
        if (angpk .ne. 0)  angpk = angrot(1) / angpk
      end if
c
      tp = taupin
      np = namep(1)
      if (iten .eq. 1)  tp = taup
      if (iten .eq. 1)  np = 'e '
      alpnex = alpene(1)
      alpzx  = alpzef(1)
      if (inenez .eq. 0)  alpnex = 0.0
      if (inenez .eq. 0)  alpzx  = 0.0
      alptex = alpte(1)
      if (itran(nk-2-iangrot) .eq. 1)  alptex = 0.0
      t = n
      call header (nunit, time, t)
      write (nunit, 8000)
      write (nunit, 8010)  ishot, itime
      write (nunit, 8005)versid
      write (nunit, 8000)
c
c find q = 1 radius
c
      rq1 = 0.0
c
      do j=nj,1,-1
        if (q(j) .le. 1.0) then
          rq1 = r(j)
          if (  j  .eq. nj    )  go to 210
          if (q(j) .eq. q(j+1))  go to 210
          rq1 = r(j) + (r(j+1)-r(j))*(1.0-q(j)) / (q(j+1)-q(j))
          go to 210
        end if
      end do
c
 210  rq1 = rq1 / r(nj)
      cxamax = cxareanpsi(1)
      write (nunit, 8020) rminor,kappa,rmajor,rgeom,xmagn1,ymagn1,
     .          volume,circum,sfareanpsi(1),cxamax,btor,totcur(1),
     .          btgeom, rq1, enebar, np, tp
c
c calculate qstar
c
      bax   = rmajor * btor / xmagn1
      qcyl  = 5.0 * rminor**2*bax / (xmagn1*totcur(1))
      qstar = qcyl
     .      * 0.5 * (1.0 + kappa**2) * (1.0 + 1.5 * rminor**2
     .      / xmagn1**2) * SQRT (kappa)
c
      write (nunit, 8000)
      write (nunit, 8030) ene(1),ene(nj),enepk,te(1),te(nj),tepk,
     .                    ti(1),ti(nj),tipk,curden(1),curden(nj),curpk,
     .                    zeff(1),zeff(nj),zefpk,
     .                    q(1),q(nj),qstar,angrot(1),angrot(nj),angpk
c
      pohmx = 0.0D0
      if (voltin .gt. 0.0)  pohmx = totcur(1) * voltin
      if (voltav .gt. 0.0)  pohmx = totcur(1) * voltav
      pohmt = poh*1.0e6
      if ( ibeam .lt. 2)  pbx = 0.0
      if ( ibeam .ge. 2)  pbx = bptor(1)
      if ( ibeam .ge. 2 .and.
     .    nbeams .eq. 2)  pbx = bptor(1) + bptor(2)
      IF(use_P_Nfreya)ptor = SUM(bptor)

      ! power into torus is not output by nubeam
      ! approximate by assuming it is same as thermal power delivered to plasma
      ! note that this ignores slowing down times and  losses
      ! because beam power into torus is not output by nubeam:
         IF(use_nubeam)ptor = (pbe+pbi)*1.e6
c
      write (nunit, 8000)
      write (nunit, 8040) voltin, voltag, voltav, voltoh,
     .                    pohmx, pohmt, pbx, ptor, fusnin, ddntot
c
      pbel  =  pbe*1.0e6
      pbion =  pbi*1.0e6
      pbcx  = pfil*1.0e6
      prfx  =  prf*1.0e6
c
c find r* radius:  Te(r*) = (Te(0)+Te(a))/2
c
      rstar  = 0.0
      testar = 0.5 * (te(1)+te(nj))
      xkestr = 0.0
      xkistr = 0.0
      chistr = 0.0
      gtestr = 0.0
c
      do 230 j=nj,1,-1
         jp1=j+1
        if (te(j) .lt. testar )  go to 230
        frac   = 1.0
        rstar  = r(j)
        if (   j  .eq. nj     ) then
              jp1=nj
              go to 220
        end if
        if (te(j) .eq. te(jp1))  go to 220
        frac   = (testar-te(j))/(te(jp1)-te(j))
        rstar  = r(j) + frac*(r(jp1)-r(j))
  220   xkestr = xkeinv(j) + frac*(xkeinv(jp1)-xkeinv(j))
        enestr = ene(j) + frac*(ene(jp1)-ene(j))
        gtestr = (te(jp1)-te(j-1))/(r(jp1)-r(j-1))
        chistr = xkestr/enestr
        xkistr = xkiinv(j) + frac*(xkiinv(jp1)-xkiinv(j))
        go to 240
  230 continue
c
  240 rstar  = rstar/r(nj)
c
c find selected transport quantities at r = a/2
c
      nj2    = (nj+1)/2
      xkeao2 = xkeinv(nj2)
      xkiao2 = xkiinv(nj2)
      w3neo  = 0.0
      if (xkineo(nj2) .ne. 0.0)
     .  w3neo = wneo(3,3) * xkiinv(nj2) / xkineo(nj2)
      cheao2 = xkeao2/ene(nj2)
      enpao2 = 0.0
c
      do jprim=1,nprim
        enpao2 = enpao2 + en(nj2,jprim)
      end do
c
      chiao2 = xkiao2/enpao2
c
      write (nunit, 8000)
      write (nunit, 8050) pbel, xkeao2, pbion, xkiao2, pbcx, w3neo,
     .                    sthru, cheao2, prfx, chiao2, pradt, rstar,
     .                    brems_prim,brems_imp,
     .                    bpbar, betap, beamtorq, storquet, angmtot,
     .                    totinrta, avrotjou
c
      do model=1,krf
        if (irfmodel(model) .eq. 'fastwave') then
          write (nunit, 8110)  (totfwpe(j), j=1,nzrffw)
          write (nunit, 8111)  (totfwpi(j), j=1,nzrffw)
        end if
      end do
c
      eitot  =   etot -  eetot - eatot - ebtot
      deitot =  detot - deetot
      ethtot =  eetot + eitot
      taueth = (eetot + eitot) * taue / etot
c
c calculate H factor relative to iter89p scaling (assume ploss = pinput) HSJ
c
      havg = 0.0
      do j=1,nj
          hmass   = 0.0
          hden    = 0.0
          do i=1,nprim
            hmass = hmass + atw(i) * en(j,i)
            hden  = hden  +          en(j,i)
          end do
          havg = havg + hmass/hden
      end do
      hmass   = SQRT (havg/nj)
      hden    = (enebar    / 1.0e14)**0.1                  ! 10**20/m**3
      hkappa  =                kappa**0.5
      hcur    = (totcur(1) / 1.0e6 )**0.85                 ! in MA
      hrad    = (rminor    / 100.0 )**0.3                  ! in meters
      hrmaj   = (rmajor    / 100.0 )**1.2                  ! in meters
      hbtor   = ABS (btor  / 1.0e4 )**0.2                  ! in Tesla
      hpow    = 0.0
      call getpow (time, pwrtot)
      pwrinpt = qtot / 1.0e6                            ! in Mw
      if (pwrinpt .gt. 0.0)  hpow = pwrinpt**0.5
      htau89p = 0.0
      if (hpow .gt. 0.0)
     .htau89p = 0.048*hmass*hcur*hrmaj*hrad*hkappa*hden*hbtor/hpow
      h89p    = 0.0
      if (htau89p .gt. 0.0)
     .h89p    = taue / htau89p

      CALL confinement_factrs
c
      write (nunit, 8000)
      write (nunit, 8060) eetot,eitot,ethtot,etot,
     .                    deetot,deitot,detot,detot,qetot,qtot,qtot,
     .                    tauee,taueth,taue,h89p,H89pm,H_ITER98y2,
     .                    H_Petty,tauangt
      write (nunit, 8000)
      write (nunit, 8070) betae,betae0,betai,betai0,
     .                    betab,betab0,betaa,betaa0,beta,beta0
      write (nunit, 8091) betan
      write (nunit, 8090) pwrtot, time
      write (nunit, 8080) totcur(1), totohm, totboot, totbeam, totrf
      if(active_rf_models .gt.0)then
        write(nunit,FMT='(18x,"cd,amps",10x,"qe ,watts", 
     .                          10x,"qi, watts")')
        do i=1,krf
           if(irfmodel(i) .ne. no_rf)   ! model is/was on 
     .        write (nunit,FMT='(2x,a,t12,4x,1pe12.3,5x,1pe12.3,7x,
     .                           1pe12.3)')
     .        irfmodel(i)(1:LEN_TRIM(irfmodel(i))),
     .        rfmodel_cd(i),rfmodel_power_e(i),rfmodel_power_i(i) 
        enddo
      endif
c
c     some fusion stuff:
c
      if (ifus .ne. 0)THEN
       write (nunit, '(" QDD = ",f8.1," QDT = ",f8.1,
     .                  " QTT = ",f8.1," QHe3d = ",f8.1)') 
     .                  qdd, qdt, qtt,qhe3d
        write (nunit,'(" P DD  =",1pe8.2,"  P DT =",1pe8.2,
     .         "  P TT =",1pe8.2," W","  P He3d ",1pe8.2)')
     .         pfusdd,pfusdt,pfustt,pfushe3d
      ENDIF
c    neutron rates
      write (nunit,'(" D(D,n) = ",1pe10.2,"  D(T,n) = ", 1pe10.2,
     .               "  T(T,2n) = ",1pe10.2,"  He3(D,p)He4 = " ,
     .                1pe10.2, "   #/sec")')
     .                       ddntot,dtntot,ttntot,he3dptot
       paux = pbe + pbi + prf ! MW
       Pbrems      = pradt/1.e6  ! MW
       Palpha      = (3.5/17.6)*pfusdt/1.e6
       Ptransport  = Paux + Palpha - Pbrems 
       write(nunit,'(" paux (MW) = ",1pe8.2," palpha = ",1pe8.2, 
     .   " prad = ",1pe8.2 ," Ptransport =",1pe10.2)')
     .    paux,palpha,Pbrems,Ptransport
       IF(Ptransport .LT. 0.0)
     .     Write(nunit,'(" NEGATIVE Ptransport ==> H(89pm),",
     .                  " H_ITER98y2, H_Petty not defined")')


      IF(use_pedestal)THEN

         write(nunit,4343)

         if (ped_mode .eq. 0) then
            write(nunit, 2100)
         elseif (ped_mode .eq. 1) then 
            write(nunit, 2101)
         endif

           
           write(nunit,4344)ped_nebar,ped_nratio
           write(nunit,4345)ped_temp,ped_grad


 2100      format(/,' Plasma is in L mode')
 2101      format(/,' Plasma is in H mode')

 4343      format(//,2x,'----------PEDESTAL CODE RESULTS ------------')
 4344      Format(2x,'Pedestal density, 1/cm^3 :',1pe12.4,
     .            2x,'Greenwald fraction :',1pe12.4)
 4345      Format(2x,'Pedestal Temp, kev :',1pe12.4,
     .            2x,'Pressure gradient, kev/cm^4 :',1pe12.4,//)

      ENDIF

      if(diffeq_methd .eq. 2)then
            write(nunit,4321)SSQR,gradmax,tot_iters
 4321       format(2x,'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%',/,
     .       2x,'convergence results for Newton based  solver are :',/,
     .       2x,'for the scaled set of equations we have:',/,
     .       2x,'total sum of squares of residuals (all equations):',
     .           1pe12.2,/,
     .       2x,'maximum gradient of any equation:',1pe12.2,/,
     .       2x,'total number of iterations taken :',i5,/,
     .       2x,'%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
      endif
      do i=1,4
        write (nunit, 8000)
      end do 
c
      return
c 
 8000 format (' ')
 8005  format(25x,a)
 8010 format (10x,'Transport analysis summary:  Shot',i8,' at ',
     .             i5,' ms')
 8020 format ('  Minor radius a (cm):  ',f6.1,
     .            t40,'b/a:                  ',f7.2     /
     .        '  Nominal Rmajor (cm):',f8.1,
     .            t40,'R at geom. cent. (cm):',f6.1     /
     .        '  R at mag. axis (cm):',f8.1,
     .            t40,'Z at mag. axis (cm):',f8.1       /
     .        '  Volume (cm**3):        ',1pe10.2,
     .            t40,'Pol. circum. (cm):  ',0pf8.1     /
     .        '  surface area (cm**2):  ',1pe10.2,
     .            t40,'cross. sect area   :',1pe10.2    //
     .        '  Bt (G):                ',1pe10.2,
     .            t40,'Ip  (A):               ',1pe10.2 /
     .        '  Bt at Rgeom (G):       ',1pe10.2,
     .            t40,'r(q = 1)/a:             ',0pf7.2   /
     .        '  Line-avg den (1/cm**3):',1pe10.2,
     .            t40,'Tau-particle-',a2,' (s): ',0pf9.3)
 8030 format (6x, 'profiles',13x,'ucenter',5x,'uedge',5x,'ucen/uav' /
     .          '  elec. den. (1/cm**3):',1p2e12.2,t50,0pf6.2       /
     .          '  elec. temp. (keV):',5x,f6.2,6x,f6.2,t50,f6.2     /
     .          '  ion   temp. (keV):',5x,f6.2,6x,f6.2,t50,f6.2     /
     .          '  current  (A/cm**2):',4x,f6.2,6x,f6.2,t50,f6.2    /
     .          '  Zeff:             ',5x,f6.2,6x,f6.2,t50,f6.2     /
     .          '  q:                ',5x,f6.2,6x,f6.2              /
     .          '  q* at edge:       ',17x,f6.2                     /
     .          '  ang. speed (1/sec):', 1x,1pe12.2,1pe12.2,1pe12.2)
 8040 format (
     .   28x, 'exper.',10x,'code'                                   /
     .      '  Surface voltage  :',5x,f6.2,10x,f6.2,6x,'Volts'      /
     .      '  Average voltage  :',5x,f6.2,10x,f6.2,6x,'Volts'      /
     .      '  Ohmic power:      ',5x,1pe10.2,6x,1pe10.2,2x,'Watts' /
     .      '  Beam power-torus: ',5x,1pe10.2,6x,1pe10.2,2x,'Watts' /
     .      '  Neutron rate D(D,N): ',2x,1pe10.2,6x,1pe10.2,2x,'#/s')
 8050 format (6x, 'computed quantities'                    /
     .          '  Beam power elec. (W):  ',1pe10.2,
     .              t40,'ke at a/2 (1/cm-s):    ',1pe10.2  /
     .          '  Beam power ions  (W):  ',1pe10.2,
     .              t40,'ki at a/2 (1/cm-s):    ',1pe10.2  /
     .          '  Beam power cx loss (W):',1pe10.2,
     .             t40,'ki/kineo at a/2:     ',0pf8.2      /
     .          '  Shinethrough (%):    ',0pf8.2,
     .             t40,'chi electrons at a/2:  ',1pe10.2   /
     .          '  RF power absorbed:     ',1pe10.2,
     .             t40,'chi ions at a/2:       ',1pe10.2   /
     .          '  Radiated power   (W):  ',1pe10.2,
     .             t40,'r*/a: Te = (Te(0)+Te(a))/2',0pf5.2 /
     .          '  Brems prim ions  (W):  ',1pe10.2,
     .             t40 'Brems imp ions :       ',1pe10.2,   /
     .          '  Poloidal B field (G):  ',1pe10.2,
     .             t40,'Beta-poloidal:      ',0pf10.3      /
     .          '  beam torque (nt-m)',5x,1pe10.2,
     .       t40, 'total torque (nt-m):',3x,1pe10.2        /
     .          '  stored ang mtm (kg*m2/s):'1pe10.2,
     .       t40, 'momt inertia (kg*m**2):',1pe10.2        /
     .          '  kinetic energy of rotation (j) :', 1pe10.2)
 8060 format (27x, 'electrons',5x,'ions',7x,'thermal',6x,'total' /
     .           '  Stored Energy (J) ',5x,1pe11.3,1p3e12.3      /
     .           '  dE/dt (W):        ',5x,1pe11.3,1p3e12.3      /
     .           '  Input power (W):  ',5x,1pe11.3,12x,1p2e12.3  /
     .           '  Energy conf. time (s): ',0pf8.4,12x,2f12.4,  /
     .           '  H(89p) =  ', f6.2, 
     .           '  H(89pm) =',f6.2,' H_ITER98y2 =',f6.2,
     .              '  H_Petty =',f6.2,/
     .           '  angular momentum confinement time (sec)', t46,f12.4)
 8070 format (6x, 'Beta-toroidal',8x,'volume-avg',7x,'center'   /
     .          '  electrons:        ',5x,1pe11.3,5x,1pe11.3    /
     .          '  ions:             ',5x,1pe11.3,5x,1pe11.3    /
     .          '  beam:             ',5x,1pe11.3,5x,1pe11.3    /
     .          '  alphas:           ',5x,1pe11.3,5x,1pe11.3    /
     .          '  total:            ',5x,1pe11.3,5x,1pe11.3)
 8080 format ('  Itot =',1pe10.2,2x,'Iohm =',1pe10.2,
     .        '  Iboot =',1pe10.2,2x,'Ibeam = ',1pe10.2,
     .        '  Irf = ',1pe10.2)
 8090 format ('  total power input (W) =',1pe12.3, '  time =', 1pe12.4)
 8091 format ('  Normalized beta       ',1pe12.3)
 8110 format ('  totfwpe:', (4(2x,1pe12.4)))
 8111 format ('  totfwpi:', (4(2x,1pe12.4)))
c
      end

      subroutine ptherf (timet, t)
c
      USE param
      USE fusion
      USE io 
      USE nub
      USE extra
      USE numbrs
      USE mesh
      USE sourc
      USE machin
      USE geom
      USE constnts
      USE bd_condtn,only : bctime,ub,fluxb,
     .    ub_save,ub_rho_edge,bctime_zone
      USE flx
      USE pelcom
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c     this subroutine prints out details of thermal and beam fusion
c

      include 'storage.i'
c
      real*8       nete,net,neti,netea,neta,netia
      dimension    qlse(kj),nete(kj),qlsi(kj),net(kj),
     .             neti(kj),qtf(kj),qls(kj),snet(kj),
     .             dfluxe(kj),dfluxi(kj),eavg(kj),wasympt(kj),
     .             enasympt(kj),wprompt(kj)
      equivalence (udum(1),eavg(1))
      equivalence (tdum(1),wasympt(1))
      equivalence (sdum(1),enasympt(1))
      equivalence (vdum(1),wprompt(1))
c
c     calculate normalization factor for averages
c
      do 10 j=1,nj
   10 fact(j) = 4.0 * pisq*rmajor*hcap(j)
      cconst  = 1.0
      call trap1 (r,fact,cconst,nj,volume)
      i = nion + 2
      call divflx(flux,fluxb,hcap,r,ra,drr,i-1,nj,kk,dfluxe)
      call divflx(flux,fluxb,hcap,r,ra,drr,i,nj,kk,dfluxi)
c
      do j=1,nj
        fact(j) = fact(j)/volume
        qlse(j) = dfluxe(j)+qdelt(j)+qexch(j)+qione(j)+qrad(j)+qe2d(j)
        nete(j) = qtfuse(j)-qlse(j)
        qlsi(j) = dfluxi(j)-qdelt(j)-qexch(j)-qioni(j)-qi2d(j)
        neti(j) = qtfusi(j)-qlsi(j)
        qls (j) = qlse(j)+qlsi(j)
        qtf (j) = qtfuse(j)+qtfusi(j)
        net (j) = qtf(j)-qls(j)
      end do
c
      snet(1) = 0.0
      do 25 j=2,nj
   25 snet(j) = snet(j-1) + 0.5 * ( r(j-1)*fact(j-1)*net(j-1)
     .                    + r(j)*fact(j)*net(j))*(r(j)-r(j-1))
c
      call trapv (r,qlse,fact,nj,qlsea)
      call trapv (r,nete,fact,nj,netea)
      call trapv (r,qlsi,fact,nj,qlsia)
      call trapv (r,neti,fact,nj,netia)
      call trapv (r,qtf,fact,nj,qtfa)
      call trapv (r,qls,fact,nj,qlsa)
      neta = qtfa-qlsa
      call trapv (r,qtfuse,fact,nj,qtfe)
      call trapv (r,qbfuse,fact,nj,qbfe)
      call trapv (r,qtfusi,fact,nj,qtfi)
      call trapv (r,qbfusi,fact,nj,qbfi)
      qtft = (qtfe+qtfi)*volume*1.60217733e-16
      qbft = (qbfe+qbfi)*volume*1.60217733e-16
      qlosst = qlsa*volume*1.60217733e-16
c
      nunit = nout
      call header (nunit,timet,t)
      write (nunit, 1110)
      do 30 j=1,nj
        j1prt = ((j-1)/jprt)*jprt
        if (j1prt .ne. j-1 .and. j .ne. nj)  go to 30
        write (nunit, 1115) j,r(j),qtfuse(j),qlse(j),nete(j),qtfusi(j),
     .                      qlsi(j),neti(j)
   30 continue
      write  (nunit, 1130)  qtfe, qlsea, netea, qtfi, qlsia, netia
 1130 format (/ 7x, 'average', 1p9e13.3)
c
      call header (nunit, timet, t)
      write (nunit, 1120)
      do 40 j=1,nj
        j1prt = ((j-1)/jprt)*jprt
        if (j1prt .ne. j-1 .and. j .ne. nj)  go to 40
        write (nunit, 1115)  j,r(j),qtf(j),qls(j),net(j),snet(j)
 40   continue
      write  (nunit, 1130)  qtfa, qlsa, neta
      write  (nunit, 1140)  qbft, qtft, qlosst
 1140 format (/ 5x, 'totals in watts' /
     .          5x, 'qbft  = ' , 1pe11.3, 13x, 'qtft = ', 1pe11.3,
     .         13x, 'qlosst = ', 1pe11.3)
c
c     wasympt is the asymptotic (i.e., steady state) fast stored energy density.
c     it is defined as ndot*taus*e0*ge/2
c     define average fast alpha energy, eavg, as <nfast*e>/<nfastdot>
c
      if (iaslow .ne. 0) then
          do j=1,nj
              wasympt (j) = stfus(j)*3.5e3*tauea(j)    ! keV/cm**3
              wprompt (j) = stfus(j)*3.5e3             ! keV/(cm**3*sec)
              enasympt(j) = stfus(j)*taupa(j)          ! #/cm**3
              eavg(j) = 0.0
              if (fencap(j) .ne. 0.0)
     .          eavg(j) = 3.5e3*ffe(j)*0.5/fencap(j)   ! keV
          end do
          call trapv (r,stfus,fact,nj,stfustot)
          call trapv (r,wprompt,fact,nj,wprompttot)
          call trapv (r,wasympt,fact,nj,wasympttot)
          call trapv (r,enasympt,fact,nj,enasympttot)
          call trapv (r,walp,fact,nj,walptot)
          call trapv (r,enalp,fact,nj,enalptot)
          call header (nunit,timet,t)
          write (nunit, 1200)
c
          do j=1,nj
            j1prt = ((j-1) / jprt) * jprt
            if (.not. (j1prt .ne. j-1 .and. j .ne. nj)) then
              write (nunit, 1210) j, r(j), stfus(j), wprompt(j),
     .                            ecritalpha(j), eavg(j), wasympt(j),
     .                            enasympt(j), fencap(j), ffe(j),
     .                            walp(j), enalp(j)
            end if
          end do
c
          write (nunit, 1225)  stfustot, wprompttot, wasympttot,
     .                         enasympttot, walptot, enalptot
          stfustot    = stfustot    * volume
          wprompttot  = wprompttot  * volume
          wasympttot  = wasympttot  * volume
          enasympttot = enasympttot * volume
          walptot     = walptot     * volume
          enalptot    = enalptot    * volume
          write (nunit, 1220) stfustot, wprompttot, wasympttot,
     .                        enasympttot, walptot, enalptot
      end if
c
c     print out table of thermal and beam-thermal d-t reaction rate
c
      call header (nunit, timet, t)
      write (nunit, 1400)
      do j=1,nj
        j1prt = ((j-1) / jprt) * jprt
        if (.not. (j1prt .ne. j-1 .and. j .ne. nj)) then
          write (nunit, 1210)  j, r(j), stfus(j), sbfus(j), sfus(j)
        end if
      end do
      call trapv (r, stfus, fact, nj, stfustot)
      call trapv (r, sbfus, fact, nj, sbfustot)
      call trapv (r,  sfus, fact, nj,  sfustot)
      stfustot = stfustot * volume
      sbfustot = sbfustot * volume
       sfustot =  sfustot * volume
      write (nunit, 1420)  stfustot, sbfustot, sfustot
c
      call header (nunit, timet, t)
c
      call header (nunit, timet, t)
      write (nunit, 1405)
****  k=3*nbeams+1 ! points to total of various beam energies,beam lines
      kn=3*nbeams
      kkn=kn+1
      kn=(kn*(kn-1))/2 + kkn
c
      do j=1,nj
        sfstot=stfus(j)+beam_thermaltth_df(j,kkn)+
     .              beam_thermaldth_tf(j,kkn) +beam_beamdtn(j,kn)
        j1prt = ((j-1) / jprt) * jprt
        if (.not. (j1prt .ne. j-1 .and. j .ne. nj)) then
          write (nunit, 1210)  j, r(j), stfus(j),
     .                         beam_thermaltth_df(j,kkn),
     .                         beam_thermaldth_tf(j,kkn),
     .                         beam_beamdtn(j,kn),sfstot
     .
        end if
      end do
c
      sfstot=stfustot + beam_thermal_dtntot + beam_thermaldth_tftot +
     .       beam_beam_dtntot
      write (nunit,'("Integrated,#/sec :",1p10e11.3)')stfustot,
     .      beam_thermal_dtntot,beam_thermaldth_tftot,
     .      beam_beam_dtntot,sfstot
c
      pfusdd=(thermal_thermal_ddntot+ beam_thermal_ddntot
     .    +beam_beam_ddntot)*3270.0       ! 3.27 MeV for d(d,n)he3
     .    +(thermal_thermal_ddptot + beam_thermal_ddptot
     .    +beam_beam_ddptot)*4030.0       ! 4.03 MeV for d(d,p)t
      pfusdt=(thermal_thermal_dtntot+ beam_thermal_dtntot
     .    +beam_beam_dtntot)*17600.0      ! 17.6 MeV for d(t,n)he4
      pfustt=(thermal_thermal_tt2ntot+ beam_thermal_tt2ntot
     .    +beam_beam_tt2ntot)*11330.0     ! 11.33 MeV for t(t,2n)he4
      pfushe3d = thermal_thermal_he3dptot*18330.0  ! 18.33 Mev he3(dp)he4
                                                   !(p 14.7,he4 3.6)
      pfushe3d = pfushe3d*1.602e-16
      pfusdd   = pfusdd*1.602e-16 ! watts
      pfusdt   = pfusdt*1.602e-16
      pfustt   = pfustt*1.602e-16
c
      write (nunit, '(" thermal-thermal d(d,n)he3  rate per second",
     .                  1pe12.3 /
     .                " thermal-thermal d(t,n)he4  rate per second",
     .                  1pe12.3 /
     .                " thermal-thermal t(t,2n)he4 rate per second",
     .                  1pe12.3 /
     .                " thermal-thermal d(d,p)t    rate per second",
     .                  1pe12.3 /
     .                " thermal_thermal he3(d,p)he4 rate per second",
     .                  1pe12.3)')  thermal_thermal_ddntot,
     .                              thermal_thermal_dtntot,
     .                              thermal_thermal_tt2ntot,
     .                              thermal_thermal_ddptot,
     .                              thermal_thermal_he3dptot
c
      write (nunit,2020) beam_thermal_ddntot,beam_thermal_ddptot,
     .                   beam_thermal_dtntot,
     .                   beam_thermal_tt2ntot,beam_thermaldth_tftot,
     .                   beam_thermalhe3th_dftot
c
 2020 format (' beam-thermal    d(d,n)he3 rate per second: ', 1pe14.3 /
     .        ' beam-thermal    d(d,p)t   rate per second: ', 1pe14.3 /
     .        ' beam-thermal df(tth,n)he4 rate per second: ', 1pe14.3 /
     .        ' beam-thermal   t(t,2n)he4 rate per second: ', 1pe14.3 /
     .        ' beam-thermal tf(dth,n)he4 rate per second: ', 1pe14.3 /
     .        ' beam-thermal df(he3,p)he4 rate per second: ', 1pe14.3  )
c
      write (nunit, 2040) beam_beam_ddntot,beam_beam_ddptot,
     .                    beam_beam_dtntot,beam_beam_tt2ntot
 2040 format (// ' beam-beam  d(d,n)he3 rate per second: ', 1pe14.3 /
     .           ' beam-beam  d(d,p)t   rate per second: ', 1pe14.3 /
     .           ' beam-beam  d(t,n)he4 rate per second: ', 1pe14.3 /
     .           ' beam-beam t(t,2n)he4 rate per second: ', 1pe14.3)
c
      if (pfusdd .ne. 0.0)  write (nunit, 2060)  pfusdd, qdd
 2060 format (2x,'total prompt power,d(d,n)he3 and d(d,p)t =',
     .        1pe12.4,' watts',' Qdd = ',1pe12.4)
      if (pfusdt .ne. 0.0)  write (nunit, 2061)pfusdt, qdt
 2061 format (2x,'total prompt power,d(t,n)he4 =',
     .        1pe12.4,' watts',' Qdt = ',1pe12.4)
      if (pfustt .ne. 0.0)  write (nunit, 2062)  pfustt, qtt
 2062 format (2x,'total prompt power,t(t,2n)he4 =',
     .        1pe12.4,' watts',' Qtt = ',1pe12.4)
      IF(pfushe3d .ne. 0.0)WRITE(nunit,2063)pfushe3d,qhe3d
 2063 FORMAT(2x,'total prompt power He3(d,p)He4 ',
     .        1pe12.4,' watts',' QHe3d = ',1pe12.4)
      return
c
 1110 format (20x,'thermal fusion energy balance(keV/cm**3-s)' //
     .        29x,'electrons',26x,'ions'                        /
     .         4x,'j',7x,'r',7x,'qtfuse',8x,'qlse',8x,'nete',
     .         8x,'qtfusi',7x,'qlsi',8x,'neti'/10x,'(cm)')
 1115 format (1x,i4,f9.2,1p9e13.3)
 1120 format (20x,'thermal fusion energy balance(keV/cm**3-s)' //
     .       4x,'j',7x,'r',7x,'qtf',11x,'qls',7x,' net',
     .       10x,'snet'/10x,'(cm)')
 1200 format (5x,'alpha particle slowing down data, for thermal ',
     .      'fusion only (walp and enalp includes beam contribution)' /
     .       4x,'j',7x,'r',7x,'stfus',4x,'wprompt',5x,'ecrit',
     .       7x,'eavg',3x,'wasympt',4x,'nasympt',
     .       3x,'fencap',7x,'ge',7x,'walp',8x,'enalp'                 /
     .       9x,'cm',4x,'#/cm**3*-s',1x,'keV/cm**3-s',4x,
     .       'keV',7x,'keV',6x,'keV/cm**3', '  #/cm**3',
     .       25x,'keV/cm**3',5x,'#/cm**3')
 1210 format (1x,i4,f9.2,1p10e11.3)
 1220 format (1x,'vol intgrtd',3x,1pe10.3,2x,1pe10.3,22x,
     .       1pe10.3,2x,1pe10.3,23x,1pe10.3,2x,1pe10.3)
 1225 format (// ' vol avg',7x,1pe10.3,2x,1pe10.3,22x,
     .       1pe10.3,2x,1pe10.3,23x,1pe10.3,2x,1pe10.3)
 1400 format (5x,"THERMAL, BEAM-THERMAL AND TOTAL DT FUSION RATES" /
     .        4x,"j",7x,"r",7x,"stfus",4x,"sbfus",5x,"sfus"        /
     .        9x,"cm",4x,"#/cm**3*-s",2x,"#/cm**3-s",4x "#/cm**3-s")
 1405 format (5x,"THERMAL, BEAM-THERMAL AND BEAM-BEAM DT FUSION RATES"/
     .        4x,"j",7x,"r",3x,"DT-ther",4x,"Dbeam-T",5x,"Tbeam-D"
     .        5x,"DT_bb",7x,"DT-total" /
     .        9x,"cm",4x,"#/cm**3-s",3x,"#/cm**3-s",2x "#/cm**3-s",
     .        2x,"#/cm**3-s",3x,"#/cm**3-s")
 1420 format (/ ' vol intgrtd', 3x, 1pe10.3, 1x, 1pe10.3, 1x, 1pe10.3)
c
      end

      subroutine reset_fluxe (dnedt,sione,ssawe,r,ra,drr,hcap,nj,itimav)
c
      USE param
      USE flx
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c ----------------------------------------------------------------------
c     subroutine recalculates the electron particle flux due to a change
c     in the electron density
c ---------------------------------------------------------- HSJ 2/14/96
c
c      include 'param.i'
c      include 'flx.i'            ! load fluxe here
      include 'storage.i'
c
      integer      nj, j, itimav
      real*8       sione(*), dnedt(*), ssawe(*), r(*),
     .             ra(*), hcap(*), drr(*), dflux(kj)
      equivalence (udum(1), dflux(1))
c
      do j=1,nj
        dflux(j) = sione(j) - dnedt(j)
        if (itimav .eq. 1)  dflux(j) = dflux(j) + ssawe(j)
      end do
c
c --- get the electron flux on the half grid:
c
      call flxcal (dflux, drr, hcap, nj, r, ra, fluxe)
      return
c
      end


      subroutine source
c

c
c ----------------------------------------------------------------------
c this subroutine calculates the particle and energy sources and sinks.
c the net sources are stored in s(k,j).  the units are as follows:
c        particle sources: 1/cm**3-s
c        energy sources  : keV/cm**3-s
c        current sources : A/cm**2
c        toroidal angular momentum sources: g/(cm*sec**2)
c note:  1 W/cm**3 = 0.62415064e16 keV/cm**3-s
c ----------------------------------------------------------------------
c
      USE  nrtype,                            ONLY  : DP,I4B
      USE param
      USE ename ,only : eqdskfilename
      USE fusion
      USE aid_newton
      USE io 
      USE ions
      USE neut
      USE nub  
      USE nub2
      USE solcon
      USE solcon_gcnmp,         only : use_stab_flux
      USE soln
      USE mhdpar
      USE mhdgrid
      USE extra
      USE rf                   ! currf_save,relrf_pow
      USE numbrs
      USE xptor_sim
      USE mesh 
      USE verbose
      USE adaptive
      USE nbi_restart,   ONLY : set_fiprof
      USE transp,only : use_nubeam,sscxl,nubeam_evolve,
     .                  nubeam_on,qbeame_nub,qbeami_nub,
     .                  beam_data,nubeam_calls,nubeam_steps,
     .                  qbeame_intg_nub,qbeami_intg_nub,
     .                  qbeame_nubp,qbeami_nubp,
     .                  qbeame_intg_nubp,qbeami_intg_nubp,
     .                  qbth_nub,qbth_nubp,qbth_intg_nub,
     .                  qbth_intg_nubp,curb_nub,curb_nubp,
     .                  storqueb_nub,storqueb_nubp,
     .                  storqueb_intg_nub,storqueb_intg_nubp,
     .                  sprbeame_nub,sprbeame_nubp,sprbeami_nub,
     .                  sprbeami_nubp,wbeam_nub,wbeam_nubp,
     .                  enbeam_nub,enbeam_nubp,
     .                  sprbeami_intg_nub,sprbeami_intg_nubp,
     .                  sprbeame_intg_nub,sprbeame_intg_nubp,
     .                  wbeam_intg_nub,wbeam_intg_nubp,
     .                  pwf_tot_intg_nub,pwf_tot_intg_nubp,
     .                  enbeam_intg_nub,enbeam_intg_nubp,
     .               beam_thermal_dtntot_nub,beam_thermal_dtntot_nubp,
     .               beam_thermal_ddntot_nub,beam_thermal_ddntot_nubp,
     .               beam_thermal_ddptot_nub,beam_thermal_ddptot_nubp,
     .               beam_thermal_tt2ntot_nub,beam_thermal_tt2ntot_nubp,
     .               beam_beam_dtntot_nub,beam_beam_dtntot_nubp,
     .               beam_beam_ddntot_nub,beam_beam_ddntot_nubp,
     .               beam_beam_ddptot_nub,beam_beam_ddptot_nubp,
     .               beam_beam_tt2ntot_nub,beam_beam_tt2ntot_nubp,
     .               beam_thermaltth_df_nub,beam_thermaltth_df_nubp,
     .               beam_thermalddp_nub,beam_thermalddp_nubp,
     .               beam_thermalddn_nub,beam_thermalddn_nubp,
     .               beam_thermaltt2n_nub,beam_thermaltt2n_nubp,
     .               beam_thermaldth_tf_nub,beam_thermaldth_tf_nubp,
     .               beam_beamddn_nub,beam_beamddn_nubp,
     .               beam_beamdtn_nub,beam_beamdtn_nubp,
     .               beam_beamddp_nub,beam_beamddp_nubp,
     .               beam_beamtt2n_nub,beam_beamtt2n_nubp,
     .               nubeam_restart,nubeam_init,nubeam_version
                    
      USE Plasma_properties,        ONLY : neut_beam
      USE sourc
      USE machin
      USE nub4
      USE tfact
      USE geom
      USE flags
      USE tordlrot
      USE constnts
      USE nub3
      USE soln2d
      USE tcoef
      USE bd_condtn
      USE mixcom
      USE rhog
      USE mcgo
      USE flx
      USE bicube
      USE flxav
      USE neo2d
      USE tmpcom
      USE rad_loss,                 ONLY : brems_imp,brems_prim,
     .                                     brems_nions



      USE gpsi
      USE pelcom
      USE events,                   ONLY : check_prtlst,isave_event
      USE echdat_module,            ONLY : get_ech_params, model_globl
      USE P_Nfreya_12_interface,    ONLY : use_P_Nfreya,P_Nfreya_read, 
     .                                     process_beamlets
      USE P_Nfreya_rpc_interface,   ONLY : setup_run_P_Nfreya,
     .                                     P_Nfreya_call_no,
     .                                     P_Nfreya_call_time

      USE Nfreya_namelist,          ONLY : P_Nfreya_dt
 
      USE thermalization,           ONLY : fast_ion_parms,
     .                                     fast_ion_thermalization,
     .                                     fi_thermal_source
      USE neutral_beams,            ONLY : beam_sim_time_start,
     .                                     beam_sim_time_end

      USE replace_imsl,             ONLY : my_ibcccu

      USE statistics,               ONLY : collect_stats,start_timer,
     .                                     stop_timer,descrip_mon,
     .                                     p_nf_mon_set,p_nf_index,
     .                                     nubeam_mon_set,ech_mon_set,
     .                                     last_mon_index,
     .                                     nubeam_index,ech_index,
     .                                     elapsed_time,o12_index


      implicit  integer (i-n), real*8 (a-h, o-z)
      INTEGER pload_12
      LOGICAL recall_P_Nfreya,recall_nfreya
      include 'imsl.i'

c      include 'pelcom.i'

      include 'storage.i'

      include 'sauter.i' ! get the sl** arrays up here for viewing
c
      dimension    prad(kj), dendr(kj), dflux(kj), enx(kj)
      dimension    xnue(kj), enbeams(kj)    ! sscxl(kj),
      dimension    xnue_frozen(kj)
      dimension    dum(kjp), palpha0(kj), vzalpha(kj),work(kj)
      dimension    enntot(kj)
      logical      opened, exists
      character (len = 256) :: command
      real*8       fluxb2(2) !jmp.den start
      real*8       ebkev_m,pn_dt,pow_save
      integer      icalled,ech_run,run_P_Nfreya
      integer      beamlet_ct,beamlet_nosw
      save         icalled
      data         icalled /0/ !jmp.dens end

c --- note that vdum and wdum from INCLUDE file storage.i are used in
c --- spreadqtfus.  palpha0 is a placeholder for directed alpha particle
c --- momentum (due to drag by beam ?).
c --- for now, we neglect this effect ------------------------------ HSJ
c
c
c ----------------------------------------------------------------------
c     xmasse  / 9.1093897e-28 /   electron mass (g)
c     xmassp  / 1.6726231e-24 /   proton mass (g)
c     charge  / 4.8032067e-10 /   electron charge (esu)
c     charg4  / 5.3226161e-38 /   charge**4 (esu**4)
c     cee     / 2.99792458e10 /   speed of light (cm/s)
c     kevperg / 6.24150640e+8 /   keV per erg
c ----------------------------------------------------------------------
c
      data xmrat   / 1836.152701   /
      data initbm  / 0 /   !added  7/18/00 HSJ
c
      brem(t, zdumm) = 5.34e-31 * SQRT(t) * zdumm**2
c
c ----------------------------------------------------------------------
c the following two statement functions calculate derivative of u(r):
c   derv2 gives du/dr at r2
c   dernj gives du/dr at r3
c   der1                 r1
c ----------------------------------------------------------------------
c
      derv2(r1,r2,r3,u1,u2,u3) = (-u1*(r3-r2)**2 +
     .                         u2*((r3-r2)**2-(r2-r1)**2)+u3*(r2-r1)**2)
     .                         / ((r3-r2)*(r2-r1)*(r3-r1))
c
      dernj(r1,r2,r3,u1,u2,u3) = (u1*(r3-r2)**2-u2*(r3-r1)**2 +
     .              u3*(r2-r1)*(2.0*r3-r2-r1))/((r3-r2)*(r2-r1)*(r3-r1))
c
      der1(r1,r2,r3,u1,u2,u3) = (r3-r1)*(u2-u1)/((r3-r2)*(r2-r1))
     .                        - ((r2-r1)/(r3-r2))*(u3-u1)/(r3-r1)
      data five_halfs_te, five_halfs_ti /2.5,2.5/
c
c ----------------------------------------------------------------------
c initialize various sources and sinks
c ----------------------------------------------------------------------
c     



      if(.not. allocated(sscxl))then
         allocate(sscxl(nj))
      endif 
      if(no_te_convection .eq. -1)five_halfs_te =1.5
      if(no_ti_convection .eq. -1)five_halfs_ti =1.5
      if(no_ti_convection .eq. 1)five_halfs_ti = 0.0
      if(no_te_convection .eq. 1)five_halfs_te = 0.0
      zero   = 0.0
c      initbm = 0 !put in data statment above, so that initbm can get to be
c                 !greater than 1 below when it is incremented HSJ 7/18/00
c
      neut_beam%pwf_tot_source_intg = 0.0_DP

 1000   CONTINUE   ! come back to here if step=init and beam is on

        do j=1,njs         
        sbeam(j)  = 0.0
        sbion(j)  = 0.0
        enbeam(j) = 0.0
        wbeam(j)  = 0.0
        sione(j)  = 0.0
        sfus(j)   = 0.0
        stfus(j)  = 0.0
        sbfus(j)  = 0.0
        qdimpl(j) = 0.0
        qrad(j)   = 0.0
        prad(j)   = 0.0
        qohm(j)   = 0.0
        qione(j)  = 0.0
        qioni(j)  = 0.0
        qcx(j)    = 0.0
        qbeame(j) = 0.0
        qbeami(j) = 0.0
        qbeami_rot(j) = 0.0
        qbeame_rot(j) = 0.0
        qfus(j)   = 0.0
        qtfus(j)  = 0.0
        qbfus(j)  = 0.0
        qtfuse(j) = 0.0
        qtfusi(j) = 0.0
        qbfuse(j) = 0.0
        qbfusi(j) = 0.0
        qrfe(j)   = 0.0
        qrfi(j)   = 0.0
        currf(j)  = 0.0
        curdri(j) = 0.0
        sion(j,1) = 0.0
        sion(j,2) = 0.0
        siadd(j,1) =  0.0
        siadd(j,2) =  0.0
        scx(j,1)  = 0.0
        scx(j,2)  = 0.0
        sbcx(j,1) = 0.0
        sbcx(j,2) = 0.0
        sscxl(j)  = 0.0
        srecom(j,1) = 0.0
        srecom(j,2) = 0.0
        volsn(j,1) =  0.0
        volsn(j,2) =  0.0
        curbe(j)  = 0.0
        curbi(j)  = 0.0
        curboot(j) =  0.0
        curbet(j) = 0.0
c
c       arrays related to angular momentum sources:
c       delayed source of toroidal angular momentum to electrons sprbeame
c                                                      ions      sprbeami
c       electron impact of thermal neutrals spreimpt
c       recombination and charge exchange of thermal ions (sink) sprcxre
c       charge exchg thermal neutrals with thermal ions sprcx
c       secondary charge exchange (fast ion and thermal neutral) ssprcxl
c       sources for ion energy equation are:
c            sprcxe  due to thermal charge exchange
c            sprcxree  due to recombination and cx with fast ions
c            spreimpe  due to electron impact ionization (ion impact neglected)
c       smagtorque(j) magnetic breaking due to error fields
c       sntvtorque(j) toroidal rotation torque due to NTV


        sprbeame(j) = 0.0
        sprbeami(j) = 0.0
        ssprcxl(j)  = 0.0
        sprcxre(j)  = 0.0
        spreimpt(j) = 0.0
        sprcx(j)    = 0.0
        sprcxe(j)   = 0.0
        sprcxree(j) = 0.0
        spreimpe(j) = 0.0
        smagtorque(j) = 0.0 
        sntvtorque(j)=0.0
      end do
c
      do i=1,2
        flxadd(i) = 0.0
        sngas(i)  = 0.0
      end do


c
c  calculate safety factor
c
      btr = btor/rmajor
      do 2005 j=2,nj
        bpr = rbp(j)/(fcap(j)*gcap(j)*hcap(j)*r(j)**2)
 2005   q(j) = btr/bpr
      q(1) = q(2) + (r(1)-r(2))*(q(3)-q(2))/(r(3)-r(2))
c
c     keep ABS (q(2)) < 1.0e3
c
      do j=1,nj
        absq = ABS (q(j))
        if (absq .ge. 1.0e3)  q(j) = 1.0e3*q(j) / absq
      end do


c----------------------------magnetic drag------------------------------------
      if(nt_mgbr .gt. 0)then
         !find rho corresponding to qn_mgbr
         !q may be multiple valued, use first value found searching from
         !edge in toweard axis
         do j= nj,2,-1
            if(ABS(q(j-1)) .le. qn_mgbr .and. 
     .                          qn_mgbr .le. ABS(q(j)))then
               jk = j
               go to 20
            endif
         enddo
         !get to here if qn_mgbr is out of range
         go to 30
         !do linear (inverse) interpolation on r:
 20      slope = (r(jk)-r(jk-1))/(ABS(q(jk))-ABS(q(jk-1)))
         bincpt =r(jk)-slope*ABS(q(jk))
         r_mgbr = slope*ABS(qn_mgbr)+bincpt
         !do linear interpolation on toroidal rotation frequency:
         slope = (angrot(jk)-angrot(jk-1))/(r(jk)-r(jk-1))
         bincpt =angrot(jk)-slope*r(jk)
         w_mgbr = slope*r_mgbr+bincpt
         do j=1,nj
            arg = ((r(j)-r_mgbr)/lqn_mgbr)**2
            if(arg .lt. 50.)then
               smagtorque(j) = - cb_mgbr*berrqn_val**2
     .                              *exp(-arg)/w_mgbr
            else
               smagtorque(j) = 0.0
            endif
         enddo
      endif !nt_mgbr .gt. 0


 30   continue
 
c
c----------------------------NTV Torque---------------C.K.Pan--03/01/2010------
      if(include_ntv .eq.1)then

         do j = 1, nj
            angrot_ntv(j) = angrot(j)
            
c ------ A single mp_polnum,mp_tornum perturbation    
c ------ delta_b : Tesla
            bmn_theta_a_sqr = delta_b_sqr*real(mp_polnum)/2.0 
            delta_b_o_b_sqr = 2.0*bmn_theta_a_sqr/(DABS(btor)*1.0e-4)**2
     .                    *(r(j)/r(nj))**(2.0*real(mp_polnum)-2.0)
           
c ------ Effective inverse aspect ratio
            delta_ntv(j)    = r(j) / (DSQRT (kappa) * rmajor)
        
            tierg(j) = 1.6e-9*ti(j)       ! erg
         
            xlam   = 24.0 - LOG (DSQRT (ene(j))/(1.0e3*te(j)))  
            !ene(j):1/cm**3,te(j):KeV 
         
            vth2 =  2.0 * tierg(j)/xmassp     ! cm/sec
         
            xnu_ntv(j) = 1.33333*rootpi*en(j,1)*( 1.0+DSQRT(2.0_DP)*
     .                   (ene(j)/en(j,1)*zeff(j)-1.0) )*charg4*xlam 
     .                   / DSQRT (xmassp*tierg(j)**3)             ! 1/sec 

            if(j .ne. 1 )then
C       For unit : mks  
               drdpsi = fcap(j)*gcap(j)*hcap(j)*r(j)/rmajor/rbp(j) 
               drdpsi = drdpsi*1.0e6  ! 1/(Tesla*m) 
                
               ddeltadpsi = (delta_ntv(j)-delta_ntv(j-1))
     .                      /((r(j)-r(j-1))*1.0e-2)*drdpsi
        
               dtidpsi = (ti(j)*joupkev-ti(j-1)*joupkev)
     .                   /((r(j)-r(j-1))*1.0e-2)*drdpsi

               dpidpsi = (en(j,1)*1.0e6*ti(j)*joupkev
     .                   -en(j-1,1)*1.0e6*ti(j-1)*joupkev)
     .                   /((r(j)-r(j-1))*1.0e-2)*drdpsi
               dnedpsi = (ene(j)-ene(j-1))/((r(j)-r(j-1))*1.0e-2)*drdpsi
           
            else 
               ddeltadpsi = 0.0
               dtidpsi = 0.0
               dpidpsi = 0.0
               dnedpsi = 0.0

            endif
                  
            omega_gb = 1.0*(ti(j)*joupkev/(charge/esupc))*ddeltadpsi

            
c       For unit : mks         
            omegazero(j) = c_p*dtidpsi/(charge/esupc)-ti(j)*joupkev
     .           *dpidpsi/(charge/esupc*(en(j,1)*(1.0e6)*ti(j)*joupkev))
       
            omegas(j) = 1.0*(c_p+0.91)*dtidpsi/(charge/esupc)
            mu_ntv_p(j) = 0.21*DSQRT( real(mp_tornum)*xnu_ntv(j) )
     .               *vth2/r2capi(j)/
     .               ( (DABS(angrot_ntv(j)-omegazero(j)))**(3.0/2.0)
     .        +0.3*DSQRT( xnu_ntv(j)/(real(mp_tornum)*delta_ntv(j)) )
     .             *DABS(omega_gb)   
     .     +0.04*(xnu_ntv(j)/(real(mp_tornum)*delta_ntv(j)))**(3.0/2.0))
c                           mp_tornum: perturbed nonaxisymmetric
c                                  magnetic field toroidal number

            sntvtorque(j) = -xmassp*en(j,1)*mu_ntv_p(j)*delta_b_o_b_sqr
     .                      *r2capi(j)*(angrot_ntv(j)-omegas(j))
            
c        NTV torque source term: g/(cm*sec**2.0)
            if(angrot_ntv(j) .lt. 0.0)then
               sntvtorque(j) = -sntvtorque(j)
            end if

         enddo
                 
       
         sntvtorque(1)=sntvtorque(2)
      
c     Total NTV torque by integrating over whole plasma     
         do j=1,nj
            sntvtorque_int(j)= r(j)*(1.0e-2)*sntvtorque(j)*1.0e-1
            sntvtorque_int(j)= sntvtorque_int(j)*hcap(j)
            rntv(j)=r(j)*(1.0e-2)         
         enddo
      
      !call trapv(r*1.0e-2,sntvtorque*1.0e-1,hcap,nj,ntvtorquet)
         call integ(rntv,sntvtorque_int,nj,ntvtorquet)
     
         ntvtorquet = 4.0*pisq*(rmajor*1.0e-2)*ntvtorquet    !unit : Nm 
            
         ntvtorquet = ntvtorquet*1.0e+7       !unit : g*cm**2.0/sec**2.0
c             
      end if
c
c ----------------------------------------------------------------------
c  calculate the energy exchange term qdimpl.
c  this is related to the source term qdelt as follows:
c               qdelt = qdimpl * [ 0.5 * (te - ti) + 0.5 * (tesave - tisave)
c  qdimpl is used to enable the code to handle this source term
c  implicitly in the difference equations.  therefore, qdelt will not
c  appear explicitly in 'source', but rather appears through the matrix
c  'eqdimp' in 'abcg'.
c ----------------------------------------------------------------------
c
 
      do j=1,nj
        xlame   = 24.0 - LOG (SQRT (ene(j))/(1.0e3*te(j)))
        teerg   = te(j)*1.6e-9
        xnue(j) = 1.33333 * rot2pi * ene(j) * zeff(j) * charg4 * xlame
     .                    / SQRT (xmasse*teerg**3)
        taue    = 1.0/xnue(j)
        if(freeze_xnue .eq. 1)then
           ftaue = 1.0/xnue_frozen(j)
        else
           ftaue = taue
           xnue_frozen(j) = xnue(j)
        endif
        fdelt   = 3.0*wdelt / (xmrat*zeff(j)*ftaue)
        do k=1,nion                                    ! nion=nprim+nimp
          qdimpl(j) = qdimpl(j)+zsq(j,k)*en(j,k)/atw(k)
        end do
        qdimpl(j) = fdelt*qdimpl(j)
      end do
   

c
c ----------------------------------------------------------------------
c     anomalous energy exchange term qexch computed in diffus
c     (old neoclassical qgam has been removed) by Waltz/Dominguez ??
c     added back in by HSJ 11/15/01 

      do j =2,nj-1
        qgam(j) =0.0
        tiaa = 0.5*(ti(j+1)+ti(j))
        tibb = 0.5*(ti(j)+ti(j-1))
        dTidr =(tiaa-tibb)/(ra(j)-ra(j-1))
        do i =1,nion
            ena  = 0.5*(en(j+1,i)+en(j,i))
            enbb  = 0.5*(en(j,1)+en(j-1,i))
            dntdr = (ena*tiaa -enbb*tibb)/(ra(j)-ra(j-1))
            qgam(j) = qgam(j) +  (flux(i,j)/en(j,i))*dntdr  
        enddo
        qgam(j) = (qgam(j) + qieneo(j)*dTidr/ti(j))*wgam
      enddo
      qgam(1) =0.0
      qgam(nj) = qgam(nj-1)

c ----------------------------------------------------------------------
c
c          RADIATION
c
c ----------------------------------------------------------------------
c  use specified radiation profile if inrad .ne. 0
c ----------------------------------------------------------------------
c

      if (inrad .eq. 0)  go to 2065  ! inrad = 0 implies nqrad =0 ==> do calcs
      if (nqrad .eq. 0)  go to 2120  ! nqrad =0 implies inrad =0 ==>
      call getrad                    ! interpolates qradin
c
      do j=1,nj
        qrad(j) = qrad(j) * (1.0 + ddebug(30)) * (2.0*(te(j)/0.02) /
     .   (1.0 + (te(j)/0.02)**2))**ddebug(31)
      end do
c
      ! set calcualted brems values to zero:
        brems_nions(:,:) = 0.0_DP
      go to 2120
c
c ----------------------------------------------------------------------
c  calculate the radiative energy loss due to bremsstrahlung from
c     primary ions
c ----------------------------------------------------------------------
c
 2065 do j=1,nj
        do k=1,nprim
          if (namep(k) .eq. 'he') then
            brems_nions(j,k) = radhe(te(j))*en(j,k)  ! added 10/20/06 HSJ
            qrad(j) = qrad(j) + radhe(te(j))*en(j,k)

          else
            brems_nions(j,k) =   brem(te(j),z(j,k))*en(j,k)
            qrad(j) = qrad(j) + brems_nions(j,k) 
          end if
        end do
      end do

 
c
c ----------------------------------------------------------------------
c  calculate the radiative energy loss due to bremsstrahlung,
c  radiative recombination, and line radiation from impurities
c ----------------------------------------------------------------------
c
      if (nimp .eq. 0)  go to 2090
      call radfit (prad, en(1,nprim+1), te, namei, nimp, nj, kj,
     .             ncrt, nout)
c
c ----------------------------------------------------------------------
c  add radiative energy loss terms and convert units from
c  W/electron  to  keV/cm**3-s
c ----------------------------------------------------------------------
c
 2090 do 2100 j=1,nj
         DO i=1,nion
            brems_nions(j,i) = brems_nions(j,i)*0.62415064e16 * ene(j)
         ENDDO
 2100 qrad(j) = 0.62415064e16 * ene(j) * (qrad(j)+prad(j))
c
c ----------------------------------------------------------------------
c  add radiative energy loss due to cyclotron (synchrotron) radiation.
c  a realistic treatment of this term would require knowledge of the
c  emission and absoption characteristics of the plasma.  the present
c  calcultion is a simplified model which will probably only give
c  good global results. calculation is in CGS (Gaussian)
c  then converted to keV/cm**3-s.
c  ref: trubnikov: jetp letters 16, 25 (1972)
c ----------------------------------------------------------------------
c

      if (refrad .eq. 1.0)  go to 2120
      wbx     = charge * ABS (btor) / (xmasse * cee)
      do j=1,nj
        teerg   = te(j)*1.6e-9
        wpsq    = 4.0 * pi*ene(j)*charge**2/xmasse
        chi     = r(nj)/rmajor * SQRT (xmasse*cee**2 /teerg)
        phi     = 60.0*(teerg/(xmasse*cee**2))**1.5
     .             * SQRT (cee*wbx/(r(nj)*wpsq)*(1.0-refrad)*(1.0+chi))
        vdotsq  = wbx**2*2.0*teerg/xmasse
        cyclo   = ene(j)*1.5*charge**2/cee**3*vdotsq*phi/1.6e-9
        qrad(j) = qrad(j) + cyclo
      end do



 2120      continue

c ---------------------------------------------------------------------------
c          NEUTRAL BEAM INJECTION
c ---------------------------------------------------------------------------

c     make sure inside radial edge of rectangular grid is consistent
c     with eqdsk value:
      rin = MAX(rin,reqdsk_box_edge)


      beamif: if(time_dep_beam .eq. 1 .and.  .not. use_nubeam  
     .           .AND. .NOT. use_P_Nfreya )then
c         the new time dependent beams calcs




c         here we deal with arbitrary beam pulses,bstime(from pulse_start_time)
c         is the earliest pulse start time we have to consider:
          if(time .lt. bstime)go to 2280
c         As usual Freya is not called during corrector steps
c         But the time dependent aspects of the beam related
c         quantities are determined starting at label 2240??
          if (istep .eq. 'corr')  go to 2436
c
c         If this is the 'init' step, and beams are already on,
c         we first want to compute a reasonable neutral profile.
c         initbm is used to control this process for the init step.
c         after the init step initbm is never changed
c         from its value of zero, defined at the start of source:
c
               if (istep .ne. 'init')  go to 2435
               if ( nneu .eq.  0    )  go to 2435
               initbm = initbm + 1
               if (initbm .eq. 1)  go to 2280    ! skip ahead only the first time


c
c     use timbplt, array of times to PLOT beam data, to also
c     control times of beam CALCULATION:
c
 2435          do ibt = 1,ntimbplt
                  timbm = timbplt(ibt)
                  if( ABS(timbm-time) .lt. dtt*0.5 .and.
     .                 istep .eq. 'pred' )go to 2420
               enddo
c          check the beam pulse times if this is a predictor step
           ibeamon = 0
           ibeamoff = 0
           if(istep .eq. 'pred')then               
               do ibt = 1,n_pulse
                  do ib = 1,n21s
                     do jb =1,kb
                        if(abs(pbeamOn(ibt,ib,jb) - time) .lt.
     .                    5.0e-9)ibeamon=1 ! checkdt,beam_time_dependance
                                           !have to have consistent tolerance
                         if(abs(pbeamOff(ibt,ib,jb) - time) .lt.
     .                           5.0e-9)ibeamoff=1
                     enddo
                  enddo
               enddo
           endif

c     Decide if beam routine should be called: compute maximum
c     relative change in density and electron temperature since
c     beam routine was last called, delnub.  If delnub>relnub,
c     we call the beam routine.  For nneu = 2, we check average
c     of the two ion densities.
c     may have to check angular momentum here as well. Not done for now.
c
          if (ibion .gt. 0) then
             call copya (en(1,ibion), enx, nj) ! load enx w/thermal species
             if (nneu .ne. 2)  go to 2450      ! corresponding to beam
             iother = 3-ibion
             do  j=1,nj
                enx(j) = 0.5 * (enx(j)+en(j,iother))
             enddo
          else ! beam is dt mixture (single fluid), with separate thermal
c
c            D and T fluids
c
             do j=1,nj
                enx(j) = 0.5 * (en(j,id)+en(j,it))
             end do
          end if
c
 2450       if (icallnub .eq.  1    )  go to 2420
            if (   istep .eq. 'init')  go to 2420
            if (  ifreya .eq.  0    )  go to 2420
            if (  ibeamon .eq.  1    ) then
                if(freyavb .gt. 0)write(ncrt,'(" call FREYA:"
     .             " BEAM pulse starts now")')
                go to 2420  !pulse just on   time
            endif
c            if (  ibeamoff .eq.  1    )  go to 2420  !pulse just off time
            call maxrc(enx,ennub,nj,delnub) ! ennub is previous enx,see below
            call maxrc(te,tenub,nj,delte)
            delnub = MAX (delnub,delte)
            if ( delnub .le. relnub) go to 2432 !dont update beam_intensity
            if (freyavb .gt. 0     ) then
               if (ABS (delnub-delte) .lt. 1.0e-7) then
             write (ncrt,'(" call FREYA: te changed more than allowed" /
     .         " delte =",1pe12.4," relnub = ",1pe12.4)')delte,relnub
            else
            write (ncrt,'(" call FREYA: thermal density of beam species"
     .                      " changed more than allowed" /
     .         " delnub =",1pe12.4," relnub = ",1pe12.4)')delnub,relnub
            end if
      end if

c
c ----------------------------------------------------------------------
c          Call the neutral beam routine
c PRENUB  translates information from transport grid to psi zone grid.
c POSTNUB smoothes out data from FREYA to prevent numerical problems.
c ----------------------------------------------------------------------
c
 2420       call copya (enx, ennub, nj) ! save enx in ennub for next time
            call copya (te , tenub, nj)
            inub   =  inub + 1
            imslmd = 'prenub'

            call prenub_pre (enbeams)
c
c     set up array pitchloss for orbit loss calcs
c
            losseval = -1                 ! prevents evaluation in GET_ORBLOSS
            if (iborb .eq. 2)
     .              call get_orbloss (losseval,0,0,0,0,0,0,0,0,0) ! zero args not used
c
c           if iborb =3 freya will only be used to generate an
c           initial fast ion birth deposition distribution that mcgo will sample.
            call freya (nbeams,atw, codeid, kappa,nw,nh,nion,p,rmhdgrid,
     .       rin,rmax,zmhdgrid,zax,zmin,zmax,pbeam,ebeam,iexcit,enbeams,
     .       time,time0)
           imslmd = 'postnub'
           call postnub
           ifreya = ifreya + 1
c
           do  i=1,npts
                 rpts(i) = SQRT (xpts(i)**2+ypts(i)**2)
           enddo
c
c
           do     jb=1,nbeams
             do   ic=1,3  !WARNING neg ion source
               write(*,'("npulse,jb,ic =",3(2x,i5))')npulse(jb),jb,ic
                do  j=1,nj
                    sbsav(j,ic,jb) =   sb(j,ic,jb) !come out of postnub
                    qbsav(j,ic,jb) =   qb(j,ic,jb)
                    spbsav(j,ic,jb) =  spb(j,ic,jb)
                    spbrsav(j,ic,jb) = spbr(j,ic,jb)
                    if(npulse(jb) .ne. 0)then
                         beam_intensity(npulse(jb),j,n21s,ic,jb) 
     .                                               = sb(j,ic,jb)
                         beam_intensity(npulse(jb),j,n21s,ic,jb)
     .                       =1.0d13 !   WARNING
                    else
                         beam_intensity(jb,j,1,ic,jb) = 0.0d0
                    endif
                end do
             end do
           end do
c
c ----------------------------------------------------------------------
c evaluate the slowed down sources
c ----------------------------------------------------------------------
c
 2432      ifirst = 1


c
c     Get the target ion speed in the axial direction in cylindrical
c     coordinate system by using conservation of angular momentum:
c                 <vphi*rmajor> = w*<rmajor**2>
c     which we assume can be approximated as
c          vionz = <vphi>=w*<rmajor**2>/<rmajor>
c
      do j=1,nj
        vionz(j) = angrot(j)*r2capi(j)/rcap(j)
      end do
c
 
      do   jb=1,nbeams
        do ic=1,3
           if (ibion .gt. 0) then
             zsqf = zsq(1,ibion)
           else
             zsqf = 1.0
           end if
c
                call slow1 (atw,atw_beam,ene,en,enn,ebkev(jb)/ic,ibcur,
     .                ibcx,ifirst,kj,nj,nion,pb0(1,ic,jb),te,vionz,zsq,
     .                zsqf,bke(1,ic,jb),bki(1,ic,jb),ecrit,
     .                emzrat,bencap(1,ic,jb),fbe(1,ic,jb),fbi(1,ic,jb),
     .                fbth(1,ic,jb),taus,fionx,rtstcx)
c     Redefine some quantities calculated in slow1 if mcgo was run.
c     Due to the MC nature of these numbers we could get zeros
c     in crucial places. We fall back on the analytinc rsults when that
c     happens (this should only be a problem if not enough
c     ions are followed in Mcgo).
           if (mcgo_info_available .eq. 1) then
              do j=1,nj !incomplete at this time HSJ
                 if (fbth_12_mcgo(j,ic,jb) .gt. 0.0)
     .                         fbth(j,ic,jb) = fbth_12_mcgo(j,ic,jb)
                 if (fbe_12_mcgo(j,ic,jb) .gt. 0.0)
     .                         fbe(j,ic,jb)  = fbe_12_mcgo(j,ic,jb)
                 if (fbi_12_mcgo(j,ic,jb) .gt. 0.0)
     .                         fbi(j,ic,jb)  = fbi_12_mcgo(j,ic,jb)
c
c                define bencap so that it gives the mcgo fast ion
c                density in steady state:
c
                 denom = taus(j)*sbsav(j,ic,jb)
                 if (denom .ne. 0.0 .and. density_12_mcgo(j,ic,jb).ne.0)
     .                  bencap(j,ic,jb) = density_12_mcgo(j,ic,jb)/denom
c
c                need bke here also . This requires some calcs not
c                currently verified in Mco. For now we assume bke
c                is the Callen value. given bke we can define
c                spb and spbsav here. This should be moved to
c                POSTNUB when the MCGO calls are sorted out:  HSJ
c
                 if (use_Callen .eq. 0) then
                    denom = taus(j) * ABS (bke(j,ic,jb))
                    if (denom .ne. 0.0) then
                      spb(j,ic,jb)= curdens_12_mcgo(j,ic,jb)*
     .                  2.99792458e9*atw_beam*xmassp/charge/denom
                      spbsav(j,ic,jb)=spb(j,ic,jb)
                    else
                      spb(j,ic,jb)=0.0
                      spbsav(j,ic,jb)=0.0
                    end if
                 end if
              end do
            end if  !(mcgo_info_available .eq. 1)
          ifirst = 0
        end do  !(ic,energy component)
      end do    !(jb,beam number)
c
c ----------------------------------------------------------------------
c account for beam slowing down. sum sources over components of beam
c ----------------------------------------------------------------------
c
c  compute deposition of slowed-down ions, parallel momentum, and
c     energy; convert the power density from W/cm3 to keV/cm3-s




c          ibslow => neglect slowing down of fast ions
           do j = 1,nj
              enntot(j) = 0.0d0
              do i = 1,nneu
                enntot(j) =enn(j,i)+enntot(j)
              enddo
              z1     = 0.0
              z2     = 0.0
              do i=1,nion
                 z12 = en(j,i)*zsq(j,i)
                 z1  = z1+z12/atw(i)
                 z2  = z2+z12
              end do
              z1 = z1*atw_beam/ene(j)
              z1 =1.0                  !WARNING
              z2 = z2/(z1*ene(j))    ! effective charge of bg ions
              vthelec = 1.3256e9 * SQRT (2.0*te(j))            ! cm/sec
              do l=1,kb !here we assume z1 (ie atw_beam) is same for all beams
                mass_beami(l) = xmassp*atw_beam
                vcrit(j,l)   = 0.09*((z1/atw(ibion))**0.33)*vthelec
                vthi(j) = 4.0026e-5 * SQRT (2.0*ti(j)/mass_beami(l)) ! cm/sec
              enddo
              Pf0 = 0.0    !  WARNING must fix this
           enddo

           if(no_fast_losses)then
                  enbeam_tot_prev_nl = enbeam_tot_nl   !array assignments
           else
                  enbeam_tot_prev = enbeam_tot         !array assignments
           endif
           enbeam_tot    = 0.0d0    !arrray
           enbeam_tot_nl = 0.0d0    !arrray
           wenbeam_tot   = 0.0d0    !arrray
           Qfi_tot       = 0.0D0    !arrray
           Rfi_tot       = 0.0d0    !arrray
           Rfe_tot       = 0.0d0    !arrray
c           do j=1,kj
c                   enbeam_tot(j)    = 0.0d0
cc                   enbeam_tot_nl(j) = 0.0d0
c                   Qfi_tot(j)       = 0.0D0
c                   Rfi_tot(j)       = 0.0d0
c                   Rfe_tot(j)       = 0.0d0
c           enddo

           dtslow =0.0d0 ! no time advance in beam_time_dependance
                         !during beam iterations or startup calcs.

           if(beam_time_init .eq. 0)  !intialize beam_time_dependance
     .     call beam_time_dependance(taus,dtslow,vcrit,ebeam,vbeam,vthi,
     .                      time0,time,timmax,pbeamOn,pbeamOff,
     .                      enbeam_part,enbeam_tot,enbeam_part_nl,
     .                      enbeam_tot_nl,wenbeam_part,wenbeam_tot,
     .                      Qfi_part,Qfi_tot,Rfi_part,Rfe_part,
     .                      Rfi_tot,Rfe_tot,
     .                      kj,kbs,ke,kb,beam_time_init,
     .                      kt,beam_thermal_cutoff,
     .                      tau0_vlj,tau0_vljoff,nbeams,n21s,
     .                      neg_ion_source,beam_thermal_speed,
     .                      beam_intensity,nj,pssv,
     .                      pssvoff,method,therm_frac,
     .                      no_fast_losses,enntot,mass_beami,emzrat,Pf0,
     .                      nf_tot_source,pwf_tot_source) 
           
           if(istep .eq. 'pred')then
               dtslow = dt ! advance full time step during predictor step only
           call beam_time_dependance(taus,dtslow,vcrit,ebeam,vbeam,vthi,
     .                      time0,time,timmax,pbeamOn,pbeamOff,
     .                      enbeam_part,enbeam_tot,enbeam_part_nl,
     .                      enbeam_tot_nl,wenbeam_part,wenbeam_tot,
     .                      Qfi_part,Qfi_tot,Rfi_part,Rfe_part,
     .                      Rfi_tot,Rfe_tot,
     .                      kj,kbs,ke,kb,beam_time_init,
     .                      kt,beam_thermal_cutoff,
     .                      tau0_vlj,tau0_vljoff,nbeams,n21s,
     .                      neg_ion_source,beam_thermal_speed,
     .                      beam_intensity,nj,pssv,
     .                      pssvoff,method,therm_frac,
     .                      no_fast_losses,enntot,mass_beami,emzrat,Pf0,
     .                      nf_tot_source,pwf_tot_source)

                if(no_fast_losses)then
                     nf_tot_loss  = 0.0d0
                     d_nf_tot_dt  = (enbeam_tot_nl - 
     .                   enbeam_tot_prev_nl)/dt  !arrays
                else
                     nf_tot_loss  = enbeam_tot_nl - enbeam_tot         !arrays

                     d_nf_tot_dt  = (enbeam_tot - enbeam_tot_prev)/dt  !arrays
                endif
                nf_tot_therm = nf_tot_source  -nf_tot_loss 
     .                                        - d_nf_tot_dt     !arrays
c               nf_conf_time = enbeam_tot/(nf_tot_source - d_nf_tot_dt)
           endif
       testime= time+dtslow
      write(*,'("time+ dt,enbeam_tot_nl(1),source =",3(1pe16.8,2x))')
     .  testime,enbeam_tot_nl(1),beam_intensity(1,1,1,1,1)
      write(*,'("dtslow,beam_intensity = ",2(1pe14.8,2x))')
     .                  dtslow,beam_intensity(1,1,1,1,1)
      write(*,'("dtslow,beam_intensity2 = ",2(1pe14.8,2x))')
     .                  dtslow,beam_intensity(2,1,1,1,1)
      write(*,'("nf__s(1),nf_(1),nf__l,d_nf(1),prev,cur,time+dt= ",
     .          7(1pe16.8,2x))')nf_tot_source(1),nf_tot_therm(1),
     .           nf_tot_loss(1),d_nf_tot_dt(1),enbeam_tot_prev_nl(1),
     .           enbeam_tot_nl(1),time+dt

      do ie =1,3
      write(*,'("time++ dt,enbeam_part_nl(1,1,ie,1),ie ",
     .   2(1pe14.8,2x),i5)')testime,enbeam_part_nl(1,1,ie,1),ie
      enddo
c------------------------------------------------------------------------------
c        Quantities and                       UNITS returned by beam_time_dependance
c                  note that these are values at time time+dtslow
c                 NOT at time time
c     Qfi_part(j,n21s,ie,l)                   kev/(cm**3 sec) ion heating
c     enbeam_part_nl(j,n21s,ie,l)             #/cm**3         fast density without cx loss
c     wenbeam_part(j,n21s,ie,l)               kev/cm**3       fast energy density
c     enbeam_part(j,n21s,ie,l)                #/cm**3         fast density with cx loss
c                                                             (if cx loss calcs are enabled)
c     Rfi_part(j,n21s,ie,l)
c     Rfe_part(j,n21s,ie,l)
c        Totals of the above summed over sources,energies and beams:
c     enbeam_tot                              #/cm**3
c     wbeam                                   kev/cm**3
c     enbeam_tot_nl                           #/cm**3
c     Qfi_tot                                 kev/(cm**3 sec)
c     Rfi_tot
c     Rfe_tot
c--------------------------------------------------------------------------------

c          convert units and load standard arrays(the units are
c          manipulated further below)
           w_to_kev_sec = 1.60217733d-16
 2436      do ic =1,ke
              do jb=1 ,kb
                 do j=1,nj
                    qbbi(j,ic,jb) = w_to_kev_sec *Qfi_part(j,n21s,ic,jb)  ! qbbi in w/cm**3
                    if( no_fast_losses)then
                      enb(j,ic,jb) = enbeam_part_nl(j,n21s,ic,jb)
                    else
                      enb(j,ic,jb) = enbeam_part(j,n21s,ic,jb)
                    endif
                    enb(j,ic,jb) = MAX(enb(j,ic,jb),enbmin) !zero doesnt work
                                                            !in curray
                    wb(j,ic,jb) = wenbeam_part(j,n21s,ic,jb)
     .                                                  /0.62415064e16 !wb in joules/cm**3
                    qbbe(j,ic,jb) = (w_to_kev_sec * 2./taus(j))*
     .                     wenbeam_part(j,n21s,ic,jb) ! qbbe in w/cm**3
                    if(npulse(jb) .gt. 0)then
                       fbi(j,ic,jb) = 0.625e16*qbbi(j,ic,jb)/
     .                          (ebeam(ic,jb)*
     .                        beam_intensity(npulse(jb),j,n21s,ic,jb))
                       fbe(j,ic,jb) = 0.625e16*qbbe(j,ic,jb)/
     .                                (ebeam(ic,jb)*
     .                        beam_intensity(npulse(jb),j,n21s,ic,jb))
                       else
                          fbi(j,ic,jb)= 0.0d0
                          fbe(j,ic,jb)= 0.0d0
                    endif
c                    enbeam_part(j,n21s,ic,jb)
c                    Rfi_part(j,n21s,ic,jb)
c                    Rfe_part(j,n21s,ic,jb)
c                   pb0(j,ic,jb),fbth(),bke,bki,spbr,enb,wb,ppb, define
c                    enbeam(j) = enbeam_tot(j)
c                    enbeam_tot_nl
c                    Qfi_tot
c                    Rfi_tot
c                    Rfe_tot
c                    wenbeam_tot(j)  kev/cm**3

c66666666666666666666666666666666666666666666666666666666

      erot      = 0.5 * atw_beam*xmassp*vionz(j)**2
      trot      = atw_beam*xmassp*vionz(j)*r2capi(j)/rcap(j)
      prat      = 1.0
      if (pb0(j,ic,jb) .ne. 0.0)
     .  prat    = 1.0 - atw_beam * xmassp * vionz(j) / pb0(j,ic,jb)
c
c --- fraction that doesn't thermalize is assumed lost due to
c ---  charge exchange . fbth is calculated in slow1 (as gth(j))
c --- and is taken as (1.0-(taus/taucx)*N ) where N is evaluated in
c --- function encapf and has the form
c ---     N = (taucx/taus)*(1-EXP (-tauf/taucx))
c --- which results when taucx is assumed independent of fast ion speed.
c --- Hence fscxl is simply
c        (taus/taucx) * N = 1.0 - EXP (-tauf/taucx)             (HSJ)
c
        fscxl   = 1.0  - fbth(j,ic,jb)
      fprscxl   = prat - bke (j,ic,jb) - bki(j,ic,jb)
c
c --- fraction (of fast ions) that do thermalize are a thermal ion source (HSJ):
c
      sbeam(j)  = sbeam(j) + (1.0 - fscxl) * sb(j,ic,jb)
c

c --- fast ion charge exchange rate(note that sscxl is not included
c --- as a particle source term. only the associated energy is
c --- accounted for (HSJ)
c
      sscxl(j)      = sscxl(j) + fscxl*sb(j,ic,jb)
      if (mcgo_info_available .eq. 0) then !combine with above
            qbbe(j,ic,jb) = fbe(j,ic,jb)*qb(j,ic,jb)
     .        + bke(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07 ! w/cm3
            qbbi(j,ic,jb) = fbi(j,ic,jb)*qb(j,ic,jb)
     .        + bki(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07
     .        + fbth(j,ic,jb)*sb(j,ic,jb)*erot*1.0e-07
      else
            qbbe(j,ic,jb) = enere_12_mcgo(j,ic,jb) ! W/cm3
            qbbi(j,ic,jb) = eneri_12_mcgo(j,ic,jb)
      end if
      qbeame_rot(j) = qbeame_rot(j)
     .              + (bke(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07)
     .              * 0.62415064e16
      qbeami_rot(j) = qbeami_rot(j)
     .              + ( bki(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07
     .              + fbth(j,ic,jb)*sb(j,ic,jb)*erot*1.0e-07)
     .              * 0.62415064e16

         if(test_xptor .eq. 1 .and. 
     .      allocated(qbeame_fixed) )then
             call copya(qbeame_fixed,qbeame,nj)  !check units???
             call copya(qbeami_fixed,qbeami,nj)

         else
             qbeame(j)     = qbeame(j) +
     .                  qbbe(j,ic,jb)*0.62415064e16 ! keV/(cm3 sec)
             qbeami(j)     = qbeami(j) + qbbi(j,ic,jb)*0.62415064e16
         endif
      sprbeame(j)   = sprbeame(j) + bke(j,ic,jb)*spbr(j,ic,jb)
      sprbeami(j)   = sprbeami(j) + bki(j,ic,jb)*spbr(j,ic,jb)
     .                            + fbth(j,ic,jb)*sb(j,ic,jb)*trot
      ssprcxl(j)    = ssprcxl(j)  + fprscxl*spbr(j,ic,jb)
     .                            + fscxl*sb(j,ic,jb)*trot
      if (ibslow .ne. 0) then
      enbeam(j) = enbeam(j) + enb(j,ic,jb)
      wbeam (j)  = wbeam(j) + 0.62415064e16*wb(j,ic,jb)  !kev/cm3
      enbeams(j)= enbeam(j)
c
c     BEAM-DRIVEN CURRENT CALCULATIONS, ONETWO AND MCGO:
c
c ----------------------------------------------------------------------
c
         if(external_beam_cur .eq. 0)then
             curbi(j)  = curbi(j) + charge*ppb(j,ic,jb)
     .                       /(2.99792458e9*atw_beam*xmassp)
          else
             curbi(j) =0.0  
         endif
c
c             Compute beam-driven electron current per rational fit to
c             numerical results of D.F.H. Start and J.G. Cordey,
c             Phys. Fluids, 23, 1477 (1980).
c             The Mcgo value is determined by (in program Mcgo):
c
****          drvncur(j)=curdens(j,4)*
**** .             (1.0-(1.0/zef(j))*(1.0-((1.55+0.85/zef(j))
**** .             * SQRT (aspinv(j))-(0.20+1.55/zef(j))*aspinv(j))))
c
             curbe(j) = -curbi(j)/zeff(j)
             if (codeid .eq. 'onedee') then
                 delta = r(j)/(SQRT (kappa)*rmajor)
             else
c
c                eps is advanced in time in rhomesh. HSJ
c
****             delta = eps0(j)
****             if (itre .ne. 1)
**** .           delta = eps0(j) + (time-eqtim0)*(eps(j)-eps0(j))/dteq
                 delta = eps(j)
             end if
c
             If(external_beam_cur .eq. 0)then
               curbet(j) = -curbe(j)*((1.55+0.85/zeff(j)) * SQRT (delta)
     .                      -(0.20+1.55/zeff(j)) *       delta)
             else
                curbet(j) = 0.0 ! not available in this case
             endif           
                   endif   !ibslow .ne. 0
                 enddo !j
               enddo   !ic
            enddo      !jb


c     smooth wbeam (required for pprime in mhd calcs near axis)
c     just set gradient in wbeam at mag axis equal to zero HSJ
c
      wbeam(1)=(wbeam(2)*(dr(1)+dr(2))*(dr(1)+dr(2))
     .                 -dr(1)*dr(1)*wbeam(3))/(dr(2)*(2*dr(1)+dr(2)))

c     separate fast beam ion sources due to ionization and charge exchange
c
      call bproc (hicm, kb, ke, kj, nbeams, nj, sbsav, sbcx, sbion)
c
c     Compute particle and energy sources due to fast ion birth.
c     Compute energy source due to secondary charge exchange
c     loss of fast beam ion (ignore particle source).
c     sbcx is source of thermal neutrals and also the source
c     of fast ions due to beam neutral, thermal ion charge exchange. HSJ
c
      do i=1,2
        do j=1,nj
          volsn(j,i) = sbcx(j,i)            ! thermal neutral and fast..
c                                           ..ion particle source,sink
c                                           ..for thermal ions
          qcx(j)     = qcx(j) + cximult* 1.5*ti(j)*sbcx(j,i)    ! loss from ion..
c                ..distribution due to charge exchange with beam neutral
          sbcx(j,i)  = -sbcx(j,i)
          if (ineut(i) .ne. 0) then
            fenn     = 1.0
            if (ineut(3-i) .ne. 0 .and. enn(j,1)+enn(j,2) .ne. 0.0)
     .        fenn   = enn(j,i) / (enn(j,1) + enn(j,2))
            qcx(j)   = qcx(j) - cximult* 1.5*tn(j,i)*fenn*sscxl(j)*ibcx
c
c           above is GAIN for ion distribution due to fast ion thermal
c           neutral charge exchange. sscxl is rate at which fast ions
c           charge exchange with thermal neutrals to form thermal ion
c           and fast neutral
c
          end if
        end do
      end do
c
      do j=1,nj
        sione(j) = sbion(j)
      end do
c
c --- thermalized fast ions are added to siadd:
c
      if (ibion .gt. 0) then
        if (ineut(ibion) .ne. 0)  call copya (sbeam,siadd(1,ibion),nj)
      else
        if (ineut(id)    .ne. 0)
     .      call addac (sbeam, siadd(1,id), nj,     fdbeam)
        if (ineut(it)    .ne. 0)
     .      call addac (sbeam, siadd(1,it), nj, 1.0-fdbeam)
      end if






      elseif(time_dep_beam .eq. 1  .AND. use_P_Nfreya )then beamif 

         !----------------------------------------------------------
         ! check the beam on times to see if any beamlets are on
         ! We have to know the number of beamlets used.
         ! But the initial write to netcdf  statefile 
         ! (done in CALL setup_run_P_Nfreya) requires that 
         ! neut_beam%nbeams = 0
         ! Hence we use  beam_data%nbeam here.
         ! NOTES:
         ! (A) Any beamlets which were turned off before time0 (but might
         !     still have fast ions in the system due to thermalization lag
         !     are ignored 
         !----------------------------------------------------------
 
         if(initbm == 0 )THEN 
            P_Nfreya_call_time = time
            beam_data%beamlet_cp(:) = 0
            IF(.NOT. ASSOCIATED(neut_beam%prompt_sb))
     .      ALLOCATE(neut_beam%prompt_sb(nj,ke,beam_data%nbeam))
         ENDIF
         run_P_Nfreya = -1
         recall_P_Nfreya = .FALSE.
         CALL process_beamlets(beamlet_ct,beamlet_nosw,time,
     .    run_P_Nfreya,recall_P_Nfreya)                          !  P_Nfreya_12_interface.f90
      !   print *,'recall_P_nfreya,run_P_Nfreya,initbm  =',recall_P_Nfreya,
   !  .    run_P_Nfreya,initbm
 
        rp_NF :  IF(run_P_Nfreya == 1)THEN  ! at least one beamlet is active
                initbm = initbm + 1 ! neutral density must be known


                if (initbm .eq. 1)  go to 2280 ! skip ahead only the first time

                ! start collecting time info here
                  IF(.NOT. p_nf_mon_set)THEN  
                     p_nf_index = last_mon_index+1
                     last_mon_index = p_nf_index
                     p_nf_mon_set = .TRUE.
                     descrip_mon(p_nf_index) = "P_Nfreya elapsed time"

                  ENDIF
                  start_timer(p_nf_index) =.TRUE.
                  stop_timer(p_nf_index)  =.FALSE.
                  CALL collect_stats(p_nf_index)
                  start_timer(p_nf_index) =.FALSE.
                ! use enx (andd ennub)  for density change monitor due to beam fuelling and
                ! inital digout of thermal density profile:
                CALL load_enx (ibion,nj,iother,nneu,id,it,enx)

                IF(initbm == 2)THEN
                  ! initialize ennub,tenub . On first call these will be
                  ! equal to enx and te respectively.
                  ! on subsequent calls, initbm >2,ennub,tenub will be one
                  ! cycle in back of enx and te so that we can determine how
                  ! much these quantites havechanged since the last
                  ! call to P_Nfreya
                  P_Nfreya_call_time = time
                  CALL copya (enx, ennub, nj)
                  CALL copya (te , tenub, nj)
                ENDIF
                pn_dt = P_Nfreya_dt

                delnub = 0.0 ; delte =0.0 ! 88888999
                IF(initbm .GT. 2 .AND. .NOT. recall_P_Nfreya)THEN
                     CALL check_profiles(recall_P_Nfreya,
     .                                    enx,ennub,te,tenub,nj,
     .                                    delnub,relnub,delte,
     .                                              freyavb,ncrt) 
                     IF(recall_P_Nfreya)
     .                         pn_dt = time - P_Nfreya_call_time

                ENDIF  

 
                IF(time -  P_Nfreya_call_time > P_Nfreya_dt)THEN
                      recall_P_Nfreya = .TRUE. 
                      pn_dt = P_Nfreya_dt
c                 write(977,14)time,P_Nfreya_call_time,P_Nfreya_dt ! 8888899999
c 14              Format('time - call_time > P_Nf_dt,time =',
c     .                   3(1pe12.6,x))
                ENDIF
                IF(beam_iteration)THEN 
                   pn_dt = P_Nfreya_dt
                   recall_P_Nfreya = .TRUE.

                ENDIF
c                IF(pn_dt .LE. 0.0_DP .AND. recall_P_Nfreya)THEN
c                    write(977,16)pn_dt ! 8888899999
c 16                 Format('pn_dt turns off beam call ,pn_dt=',
c     .             1pe12.6) ! 88888899999
c                ENDIF
                IF(pn_dt .LE. 0.0_DP) recall_P_Nfreya = .FALSE.


         run_pnf: IF((initbm == 2 .OR. 
     .               (initbm > 2 .AND. recall_P_Nfreya))
     .               .AND. beamlet_ct .GT. 0 )THEN
                !-----------------------------------------------------------
                ! run parallel P_Nfreya remotely:
                ! beam timming is given in ufile 
                !(stored in beam_data%beam_times(:))
                ! assume satisfactory neutral density exists at this time
                ! power for each beamlet will b e taken as average value
                ! over the time interval 
                !         beam_sim_time_end - beam_sim_time_start
                ! which is passed in the run directives namelist
                !------------------------------------------------------------
                P_Nfreya_read  = .TRUE. ! Set only MC beam quantites in
                                        ! set_onetwo_vars
                P_Nfreya_call_no = P_Nfreya_call_no +1
        print *,' ************ P_Nfreya call no,time,beam_iteration: ',
     .                          P_Nfreya_call_no,time,beam_iteration 
 
                P_Nfreya_call_time = time
                beam_sim_time_start = P_Nfreya_call_time
                beam_sim_time_end   = beam_sim_time_start + pn_dt


 
                CALL setup_run_P_Nfreya(time,1)      ! P_Nfreya_rpc_interface.f90
c        print *,' ************ done setup_run_P_nfreya'

                P_Nfreya_read = .FALSE. ! make sure we dont interfere with
                                        ! possible other statefile processes
                  ! update ennub,tenub to current values that P_Nfreya
                  ! was called with

                  CALL copya (enx, ennub, nj)
                  CALL copya (te , tenub, nj)


                !-------------------------------------------------
                ! pick up source values from statefile for active beams
                ! these are the sources determined
                ! by P_Nfreya and converted to onetwo units
                !--------------------------------------------------
                do     jb=1,neut_beam%nbeams
                   ebkev(jb)              =   neut_beam%ebeam(1,jb)
                   IF(beam_data%beamlet_active(jb) == 1)THEN
                      do   ic=1,ke
                         do  j=1,nj             
                            sbsav(j,ic,jb)   = neut_beam%sb(j,ic,jb) ! particles/(cm3-s)   
                            neut_beam%prompt_sb(j,ic,jb) 
     .                                       = sbsav(j,ic,jb)
                            ! propt_sb is NOT adjusted for asymtotic value
                            ! but sbsav is (in tport0
                            qbsav(j,ic,jb)   = neut_beam%qb(j,ic,jb) ! w/cm^3
                            spbsav(j,ic,jb)  = neut_beam%spb(j,ic,jb) 
                            spbrsav(j,ic,jb) = neut_beam%spbr(j,ic,jb)
                            pb0(j,ic,jb)     = neut_beam%pb0(j,ic,jb) ! g cm/sec
                         end do
                      end do

                   ELSEIF(beam_data%beamlet_active(jb) == -1)THEN 
                      ! beamlet was on now off ==> zero source
                      sbsav(1:kj,1:ke,jb)          = 0.0_DP
                      neut_beam%prompt_sb(j,ic,jb) = 0.0_DP
                      qbsav(1:kj,1:ke,jb)          = 0.0_DP
                      spbsav(1:kj,1:ke,jb)         = 0.0_DP
                      spbrsav(1:kj,1:ke,jb)        = 0.0_DP
                      pb0(1:kj,1:ke,jb)            = 0.0_DP
                   ENDIF
                end do
                ENDIF run_pnf
                stop_timer(p_nf_index)  =.TRUE.
                CALL collect_stats(p_nf_index)
                stop_timer(p_nf_index)  =.FALSE.

             ENDIF  rp_NF
     
          !--------------------------------------------------------------
          ! P_Nfreya may or may not have been called on this time step
          ! either way we compute the thermalization sources now:
          !--------------------------------------------------------------
          ifirst = 1

          vionz(1:nj) = angrot(1:nj)*r2capi(1:nj)/rcap(1:nj)
          do   jb=1,neut_beam%nbeams
             IF(beam_data%beamlet_active(jb) .NE. 0 )THEN
  
                do ic=1,3
                   if (ibion .gt. 0) then
                      zsqf = zsq(1,ibion)
                   else
                      zsqf = 1.0
                   end if
                   ebkev_m = ebkev(jb)/ic

                   CALL fast_ion_parms (atw,atw_beam,ene,en,enn,
     .                          ebkev_m,ibcur,ibcx,ifirst,kj,nj,nion,
     .                          nneu,pb0(1,ic,jb),te,vionz,zsq,
     .                          zsqf,bke(1,ic,jb),bki(1,ic,jb),ecrit,
     .                          emzrat,bencap(1,ic,jb),fbe(1,ic,jb),
     .                          fbi(1,ic,jb),
     .                          fbth(1,ic,jb),taus,fionx,rtstcx)
                end do          ! ic =1,3
             ENDIF
          end do     
         


          do   jb  = 1,neut_beam%nbeams
             bmactv : IF(beam_data%beamlet_active(jb) .NE. 0)THEN 
                
                ! beamlet is on or was on and is now off:
                IF(dtt .GT. 0.0_DP)THEN 
                   dtslow = dtt
                ELSE
                   dtslow = time - beam_data%tbonac(jb)
                ENDIF


                IF(beam_data%beamlet_active(jb) == -1)THEN ! beam is off but was on
                    beam_data%iendbm(jb) = beam_data%iendbm(jb) +1
                    IF(beam_data%iendbm(jb) == 1 .OR. dtt .LE. 0._DP)
     .                                                           THEN
                       ! this is the first call for this beamlet after
                       ! it was turned off
                       dtslow = time - beam_data%tboffac(jb) 
                    ELSE
                       dtslow = dtt
                    ENDIF
                ELSEIF (beam_data%beamlet_active(jb) == 1)THEN ! beam is currently on
                   beam_data%istrtbm(jb)  = beam_data%istrtbm(jb)+1
                   IF(beam_data%istrtbm(jb) == 1 .OR. dtt .LE. 0._DP)
     .                                                           THEN
                       ! this is the first call for this beamlet after
                       ! it was turned on
                       dtslow = time - beam_data%tbonac(jb) 
                    ELSE
                       dtslow = dtt
                    ENDIF
                ENDIF
  


                do ic = 1,3
c       print *,'fast_ion_thermalization input'
c       print *,'beam no,ic =',jb,ic
c       print*,'bke(1:3,ic,jb)    = ',bke(1:3,ic,jb)
c        print*,'bencap(1:3,ic,jb) = ',bencap(1:3,ic,jb)

c       print*,'fbe(1:3,ic,jb)    = ',fbe(1:3,ic,jb)
c       print*,'spbrsav(1,ic,jb)  = ',spbrsav(1:3,ic,jb)
c       print*,'pprbsav(1,ic,jb)  = ',pprbsav(1:3,ic,jb) 
c       print*,'ppbsav(1:3,ic,jb) = ',ppbsav(1:3,ic,jb)
c       print*,'qbsav(1:3,ic,jb)  = ',qbsav(1:3,ic,jb)
c        print*,'sbsav(1:3,ic,jb)  = ',sbsav(1:3,ic,jb)
c       print*,'spbsav(1:3,ic,jb) = ',spbsav(1:3,ic,jb)
c        print*,'taus              = ',taus(1:3)
c       print*,'wbsav(1,ic,jb)    = ',wbsav(1:3,ic,jb)

                   CALL fast_ion_thermalization(
     .                          bke(1,ic,jb),bencap(1,ic,jb),    ! input
     .                          enbsav(1,ic,jb),fbe(1,ic,jb),      
     .                          spbrsav(1,ic,jb), pprbsav(1,ic,jb),
     .                          ppbsav(1,ic,jb),qbsav(1,ic,jb),
     .                          sbsav(1,ic,jb),spbsav(1,ic,jb),
     .                          taus,wbsav(1,ic,jb),
     .                          dtslow,ibcur,
     .                          nj,iangrot,
     .
     .                          enb(1,ic,jb),ppb(1,ic,jb),       ! output
     .                          qb(1,ic,jb),sb(1,ic,jb),
     .                          spb(1,ic,jb),taupb(1,ic,jb),
     .                          tauppb(1,ic,jb),taueb(1,ic,jb),
     .                          wb(1,ic,jb),pprb(1,ic,jb),
     .                          spbr(1,ic,jb))

c        print*,'fast_ion_thermalization output:'
 
c        IF(ic == 1 .and. jb ==1)
c     .        write(*,FMT='("b5out",6(1pe10.4,x))')
c    .         enb(1,ic,jb),sb(1,ic,jb),taupb(1,ic,jb),
c     .  enbsav(1,ic,jb),sbsav(1,ic,jb),time
c       print*,'ppb(1:3,ic,jb)      = ',ppb(1:3,ic,jb)
c       print*,'qb(1:3,ic,jb)       = ',qb(1:3,ic,jb)
c        print*,'sb(1:3,ic,jb)       = ',sb(1:3,ic,jb)
c       print*,'spb(1:3,ic,jb)      = ',spb(1:3,ic,jb)
c        print*,'taupb(1:3,ic,jb)    = ',taupb(1:3,ic,jb)
c       print*,'tauppb(1:3,ic,jb)   = ',tauppb(1:3,ic,jb)
c       print*,'taueb(1:3,ic,jb)    = ',taueb(1:3,ic,jb)
c        print*,'wb(1:3,ic,jb)       = ',wb(1:3,ic,jb)
c       print*,'pprb(1:3,ic,jb)     = ',pprb(1:3,ic,jb)
c       print*,'spbr(1:3,ic,jb)     = ',spbr(1:3,ic,jb)


c        print *, 'sb,pb0,fbe =',sb(1:3,1,jb),pb0(1:3,1,jb),fbe(1:3,1,jb)
c        print *, 'fbi,fbth,spbr =',fbi(1:3,1,jb),fbth(1:3,1,jb),
c     .                         spbr(1:3,1,jb)
c       print *, 'qb,bke,bki =',qb(1:3,1,jb),bke(1:3,1,jb),bki(1:3,1,jb)
c       print *, 'ppb,enb,bki =',ppb(1:3,1,jb),enb(1:3,1,jb),
c     .                          bki(1:3,1,jb)
c       print *,'r,eps,kappa =',r(1:3),eps(1:3),kappa
c       print *,'rmajor,zeff,angrot=',rmajor,zeff(1:3),angrot(1:3)

              IF (ibslow .NE. 0)THEN
                 CALL fi_thermal_source(atw_beam,vionz,r2capi,rcap,    
     .                      sb,qb,wb,pb0,fbe,fbi,fbth,spbr,bke,bki,
     .                      ppb,ibslow,enbmin,enb,kj,ke,kb,ic,jb,nj,
     .                      external_beam_cur,codeid,r,eps,delta,
     .                      kappa,rmajor,zeff,angrot,sbeam,sscxl,
     .                      qbbe,qbbi,qbeame_rot,qbeami_rot,
     .                      qbeame,qbeami,sprbeame,sprbeami,     
     .                      ssprcxl,enbeam,enbeams,wbeam,curbi,
     .                      curbe, curbet)


              ENDIF
c       print*,'fi_thermal_source output,ibslow,beam,ic=',ibslow,jb,ic
c       print*,'beam_data%beamlet_active(jb) =',
c     .                 beam_data%beamlet_active(jb)
c       print *,'on off time =',beam_data%tbonac(jb),
c     .                 beam_data%tboffac(jb)
c
c       print *,'enbeam(1:3),sbeam(1:3)=',enbeam(1:3),sbeam(1:3)
c       print *,'wbeam(1:3),qbeame(1:3),qbeami(1:3)=',wbeam(1:3),
c     .          qbeame(1:3),qbeami(1:3)
c      print *,'sprbeame(1:3),sprbeami(1:3)=',sprbeame(1:3),sprbeami(1:3)
c       print *,'ssprcxl(1:3),sscxl(1:3) =',ssprcxl(1:3),sscxl(1:3)
cc       print *,'curbi,curbe,curbet =',curbi(1:3),curbe(1:3),
c     .          curbet(1:3)
c       print *,'qbbe,qbbi next'
c       print *,'qbbe(1:3,ic,jb) =',qbbe(1:3,ic,jb)
c       print *,'qbbi(1:3,ic,jb) =',qbbi(1:3,ic,jb)

             END DO             ! ic =1,3
           ENDIF  bmactv
          END DO                ! jb=1,nbeams

  


          IF(beamlet_ct  .NE. 0)THEN !dont do this if beams were never on
             IF(ASSOCIATED(neut_beam%prompt_pwr_in_plasma))
     .                 DEALLOCATE(neut_beam%prompt_pwr_in_plasma)
   
           ALLOCATE
     .    (neut_beam%prompt_pwr_in_plasma(ke,neut_beam%nbeams))
             neut_beam%prompt_pwr_in_plasma(:,:) = 0.0_DP
             neut_beam%pwf_tot_source_intg = 0.0_DP
             DO jb = 1,neut_beam%nbeams
                IF(beam_data%beamlet_active(jb) == 1 )THEN
                   DO ic  = 1,ke
                call trapv(r,neut_beam%prompt_sb(1,ic,jb),
     .                  hcap,nj,neut_beam%prompt_pwr_in_plasma(ic,jb))
                      neut_beam%prompt_pwr_in_plasma(ic,jb) =
     .                   neut_beam%prompt_pwr_in_plasma(ic,jb)*
     .                               neut_beam%ebeam(ic,jb)
     .                 *4.0_DP * pi * pi*rmajor*1.6e-16             ! watts/cm^3
                       neut_beam%pwf_tot_source_intg =
     .                               neut_beam%pwf_tot_source_intg +
     .                          neut_beam%prompt_pwr_in_plasma(ic,jb) 
                   ENDDO
                ENDIF
             ENDDO

 

               
              call bproc (neut_beam%hicm, neut_beam%nbeams,
     .                    ke, nj, nbeams, nj, sbsav, sbcx, sbion)


c
c             --- thermalized fast ions are added to siadd:
c
              if (ibion .gt. 0) then
                 if (ineut(ibion) .ne. 0)  
     .                call copya (sbeam,siadd(1,ibion),nj)
              else
                 if (ineut(id)    .ne. 0)
     .              call addac (sbeam, siadd(1,id), nj,     fdbeam)
                 if (ineut(it)    .ne. 0)
     .              call addac (sbeam, siadd(1,it), nj, 1.0_DP-fdbeam)
              end if


              sione(:) = sbion(:)



c              write(*,FMT='("sbcx(1:3,1),sbion(1:3,1)=",6(x,1pe12.4))') ! 88888899999
c     .                                  sbcx(1:3,1),sbion(1:3)
c              write(*,FMT='("sbeam(1:3,1),enbeam(1:3)=",6(x,1pe12.4))') 
c     .                                  sbeam(1:3),enbeam(1:3)

          ENDIF
   
      elseif( .not. use_nubeam)then  beamif 
 
c -------------------------------------------------------------------------------
c            the old single pulse beam calcs
c            calculate the particle and energy sources due to neutral beams
c            if ibeam = -1  beam was on and has been turned off
c            if ibeam =  0  beam has never been on
c            if ibeam =  1  beam is now on  (set in chekdt)
c            if ibeam =  2  beam is now off (set in chekdt)
c            if ibeam =  3  beam is on ( as opposed to just having been
c                           turned on - which is signalled by ibeam = 1)
c            ibslow is set in input file inone (default = 1)
c            ibslow   =  1  means include beam slowing down effects
c            ibslow   =  0  neglect beam slowing down effects
c --------------------------------------------------------------------------------
c if beam is still off skip calculations:
c


      if (time .lt. beamon(1))  go to 2280    ! same as ibeam = 0
c
c if beam was on,but is now off and slowing down is negelected
c skip calculations(ibeam .le. 1 same as ibeam = -1 here):
c
      if (ibeam .le. 1 .and. ibslow .eq. 0)  go to 2280
c
c if beam is now off but slowing down source is to be calculated:
c  [ the way this method works is that the
c    assignment of values for sbsav,etc,which occurs below,is skipped
c    over if the beam is now off. (sbsav and friends are zeroed in
c    subroutine TPORT if the beam is off)
c    Otherwise,if the beam is still on then sbsav and friends are
c    redefined only if a new deposition is calculated in FREYA. hence
c    sbsav is the current true fast ion source rate and equals sb after a call
c    to FREYA. However after SLOW2 is called sb is not the true source
c    rate anymore. Instead sb is then defined as the asymptotic source
c    rate which would be required to support the current fast ion density
c    in steady state equilibrium. Sb is then used to calculate the particle
c    source rate in the ion density equation, etc. ] ... HSJ
c

      if (ibeam .lt. 1)  go to 2240  !change le to lt HSJ 11/7/03
c
c reach this point only if beam is on. don't recalculate the beam
c deposition if this is corrector step:
c
      if (istep .eq. 'corr')  go to 2240
c
c     If this is the 'init' step, and beams are already on,
c     we first want to compute a reasonable neutral profile.
c     initbm is used to control this process for the init step.
c     after the init step initbm is never changed
c     from its value of zero, defined at the start of source:
c
      if (istep .ne. 'init')  go to 2130
      if ( nneu .eq.  0    )  go to 2130
      initbm = initbm + 1
      if (initbm .eq. 1)  go to 2280    ! skip ahead only the first time
c
c     use timbplt, array of times to PLOT beam data, to also
c     control times of beam CALCULATION:
c
 2130 do ibt=1,ntimbplt
        timbm = timbplt(ibt)
        if (ABS (timbm-time) .lt. dtt*0.5  .and.
     .                 istep .eq. 'pred')  go to 2220
      end do



c     Decide if beam routine should be called
c     compute maximum
c     relative change in density and electron temperature since
c     beam routine was last called, delnub.  If delnub>relnub,
c     we call the beam routine.  For nneu = 2, we check average
c     of the two ion densities.
c     may have to check angular momentum here as well. Not done for now.
c
      CALL load_enx(ibion,nj,iother,nneu,id,it,enx)


 2150 if (icallnub .eq.  1    )  go to 2220
      if (   istep .eq. 'init')  go to 2220
      if (  ifreya .eq.  0    )  go to 2220


      CALL check_profiles(recall_nfreya,enx,ennub,te,tenub,nj,
     .                          delnub,relnub,delte,freyavb,ncrt)   

      IF(.NOT. recall_nfreya)go to 2232

      if (freyavb .gt. 0     ) then
         if (ABS (delnub-delte) .lt. 1.0e-7) then
            write (ncrt,'(" call FREYA: te changed more than allowed" /
     .         " delte =",1pe12.4," relnub = ",1pe12.4)')delte,relnub
         else
            write (ncrt,'(" call FREYA: thermal density of beam species"
     .                      " changed more than allowed" /
     .         " delnub =",1pe12.4," relnub = ",1pe12.4)')delnub,relnub
         end if
      end if
c
c ----------------------------------------------------------------------
c          Call the neutral beam routine
c PRENUB  translates information from transport grid to psi zone grid.
c POSTNUB smoothes out data from FREYA to prevent numerical problems.
c ----------------------------------------------------------------------
c 
 2220 call copya (enx, ennub, nj)  ! save enx in ennub for next time
      call copya (te , tenub, nj)
      inub   =  inub + 1
      imslmd = 'prenub'


      call prenub_pre (enbeams)


c
c     set up array pitchloss for orbit loss calcs
c
      losseval = -1                 ! prevents evaluation in GET_ORBLOSS
      if (iborb .eq. 2)
     .call get_orbloss (losseval,0,0,0,0,0,0,0,0,0) ! zero args not used
c
c     if iborb =3 freya will only be used to generate an
c     initial fast ion birth deposition distribution that mcgo will sample.
      call freya (nbeams,atw, codeid, kappa,nw,nh,nion,p,rmhdgrid,
     .     rin,rmax,zmhdgrid,zax,zmin,zmax,pbeam,ebeam,iexcit,enbeams,
     .     time,time0)
 
      imslmd = 'postnub'
c      write(6,FMT='("calling postnub")') ! 8888889999
      call postnub
c      write(6,FMT='("done calling freya")') ! 8888889999
      ifreya = ifreya + 1
c
      do 2225 i=1,npts
 2225 rpts(i) = SQRT (xpts(i)**2+ypts(i)**2)
c
      do     jb=1,nbeams
        do   ic=1,3
          do  j=1,nj
              sbsav(j,ic,jb) =   sb(j,ic,jb) !come out of postnub
              qbsav(j,ic,jb) =   qb(j,ic,jb) ! qb is in watts/cm^3 
             spbsav(j,ic,jb) =  spb(j,ic,jb)
            spbrsav(j,ic,jb) = spbr(j,ic,jb)
          end do
        end do
      end do

 
c
c ----------------------------------------------------------------------
c evaluate the slowing-down transfer functions
c ----------------------------------------------------------------------
c
 2232 ifirst = 1
c
c     Get the target ion speed in the axial direction in cylindrical
c     coordinate system by using conservation of angular momentum:
c                 <vphi*rmajor> = w*<rmajor**2>
c     which we assume can be approximated as
c          vionz = <vphi>=w*<rmajor**2>/<rmajor>
c
      do j=1,nj
        vionz(j) = angrot(j)*r2capi(j)/rcap(j)
      end do
c
      do   jb=1,nbeams
        do ic=1,3
           if (ibion .gt. 0) then
             zsqf = zsq(1,ibion)
           else
             zsqf = 1.0
           end if
c
                call slow1 (atw,atw_beam,ene,en,enn,ebkev(jb)/ic,ibcur,
     .                ibcx,ifirst,kj,nj,nion,pb0(1,ic,jb),te,vionz,zsq,
     .                zsqf,bke(1,ic,jb),bki(1,ic,jb),ecrit,
     .                emzrat,bencap(1,ic,jb),fbe(1,ic,jb),fbi(1,ic,jb),
     .                fbth(1,ic,jb),taus,fionx,rtstcx)


c     Redefine some quantities calculated in slow1 if mcgo was run.
c     Due to the MC nature of these numbers we could get zeros
c     in crucial places. We fall back on the analytinc rsults when that
c     happens (this should only be a problem if not enough
c     ions are followed in Mcgo).
           if (mcgo_info_available .eq. 1) then
              do j=1,nj !incomplete at this time HSJ
                 if (fbth_12_mcgo(j,ic,jb) .gt. 0.0)
     .                         fbth(j,ic,jb) = fbth_12_mcgo(j,ic,jb)
                 if (fbe_12_mcgo(j,ic,jb) .gt. 0.0)
     .                         fbe(j,ic,jb)  = fbe_12_mcgo(j,ic,jb)
                 if (fbi_12_mcgo(j,ic,jb) .gt. 0.0)
     .                         fbi(j,ic,jb)  = fbi_12_mcgo(j,ic,jb)
c
c                define bencap so that it gives the mcgo fast ion
c                density in steady state:
c
                 denom = taus(j)*sbsav(j,ic,jb)
                 if (denom .ne. 0.0 .and. density_12_mcgo(j,ic,jb).ne.0)
     .                  bencap(j,ic,jb) = density_12_mcgo(j,ic,jb)/denom
c
c                need bke here also . This requires some calcs not
c                currently verified in Mco. For now we assume bke
c                is the Callen value. given bke we can define
c                spb and spbsav here. This should be moved to
c                POSTNUB when the MCGO calls are sorted out:  HSJ
c
                 if (use_Callen .eq. 0) then
                    denom = taus(j) * ABS (bke(j,ic,jb))
                    if (denom .ne. 0.0) then
                      spb(j,ic,jb)= curdens_12_mcgo(j,ic,jb)*
     .                  2.99792458e9*atw_beam*xmassp/charge/denom
                      spbsav(j,ic,jb)=spb(j,ic,jb)
                    else
                      spb(j,ic,jb)=0.0
                      spbsav(j,ic,jb)=0.0
                    end if
                 end if
              end do
            end if ! mcgo related
          ifirst = 0
        end do ! ic =1,3
      end do   !j b=1,nbeams
      

c
c ----------------------------------------------------------------------
c account for beam slowing down. sum sources over components of beam
c ----------------------------------------------------------------------
c
c  compute deposition of slowed-down ions, parallel momentum, and
c     energy; convert the power density from W/cm3 to keV/cm3-s
c
 2240  continue

c
      do 2257 jb=1,nbeams
      do 2257 ic=1,3

      if (ibslow .eq. 0)  go to 2255
c
           dtslow = dtt
           if (time .eq. time0 .and. dtt .eq. 0.0)
     .                                dtslow = time - beamon(1)
 
        call slow2 (bke(1,ic,jb),dtslow,bencap(1,ic,jb),enbsav(1,ic,jb),
     .             fbe(1,ic,jb),ibcur,nj,ppbsav(1,ic,jb),qbsav(1,ic,jb),
     .             sbsav(1,ic,jb),spbsav(1,ic,jb),taus,wbsav(1,ic,jb),
     .             enb(1,ic,jb),ppb(1,ic,jb),qb(1,ic,jb),sb(1,ic,jb),
     .             spb(1,ic,jb),taupb(1,ic,jb),tauppb(1,ic,jb),
     .             taueb(1,ic,jb),wb(1,ic,jb),iangrot,pprb(1,ic,jb),
     .             spbr(1,ic,jb),spbrsav(1,ic,jb),pprbsav(1,ic,jb))

 
c
c      if (mcgo_info_available .eq. 1) then
c
c        results from Mcgo,define those quantities that would normally
c        come out of slow2:
c
c         do j=1,nj
c            enb(j,ic,jb)= density_12_mcgo(j,ic,jb)
c           ppb(j,ic,jb)= curdens_12_mcgo(j,ic,jb)*
c     .                      2.99792458e9*atw_beam*xmassp/charge
c          fast ion stored energy density w/cm3
c            wb(j,ic,jb)=1.5* (0.666*presprp_12_mcgo(j,ic,jb)+
c     .                         0.333*prespar_12_mcgo(j,ic,jb))
c         end do
c      end if
c
 2255 do 2257 j=1,nj
      erot      = 0.5 * atw_beam*xmassp*vionz(j)**2
      trot      = atw_beam*xmassp*vionz(j)*r2capi(j)/rcap(j)
      prat      = 1.0
      if (pb0(j,ic,jb) .ne. 0.0)
     .  prat    = 1.0 - atw_beam * xmassp * vionz(j) / pb0(j,ic,jb)
c
c --- fraction that doesn't thermalize is assumed lost due to
c ---  charge exchange . fbth is calculated in slow1 (as gth(j))
c --- and is taken as (1.0-(taus/taucx)*N ) where N is evaluated in
c --- function encapf and has the form
c ---     N = (taucx/taus)*(1-EXP (-tauf/taucx))
c --- which results when taucx is assumed independent of fast ion speed.
c --- Hence fscxl is simply
c        (taus/taucx) * N = 1.0 - EXP (-tauf/taucx)             (HSJ)
c
        fscxl   = 1.0  - fbth(j,ic,jb)
      fprscxl   = prat - bke (j,ic,jb) - bki(j,ic,jb)
c
c --- fraction (of fast ions) that do thermalize are a thermal ion source (HSJ):
c
      sbeam(j)  = sbeam(j) + (1.0 - fscxl) * sb(j,ic,jb)
 
c
c --- fast ion charge exchange rate(note that sscxl is not included
c --- as a particle source term. only the associated energy is
c --- accounted for (HSJ)
c
      sscxl(j)      = sscxl(j) + fscxl*sb(j,ic,jb)
      if (mcgo_info_available .eq. 0) then
            qbbe(j,ic,jb) = fbe(j,ic,jb)*qb(j,ic,jb)
     .        + bke(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07 ! w/cm3
            qbbi(j,ic,jb) = fbi(j,ic,jb)*qb(j,ic,jb)
     .        + bki(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07
     .        + fbth(j,ic,jb)*sb(j,ic,jb)*erot*1.0e-07
      else
            qbbe(j,ic,jb) = enere_12_mcgo(j,ic,jb) ! W/cm3
            qbbi(j,ic,jb) = eneri_12_mcgo(j,ic,jb)
      end if
      qbeame_rot(j) = qbeame_rot(j)
     .              + (bke(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07)
     .              * 0.62415064e16
      qbeami_rot(j) = qbeami_rot(j)
     .              + ( bki(j,ic,jb)*spbr(j,ic,jb)*angrot(j)*1.0e-07
     .              + fbth(j,ic,jb)*sb(j,ic,jb)*erot*1.0e-07)
     .              * 0.62415064e16
         if(test_xptor .eq. 1 .and. 
     .      allocated(qbeame_fixed) )then
             call copya(qbeame_fixed,qbeame,nj)  !check units???
             call copya(qbeami_fixed,qbeami,nj)

         else
             qbeame(j)     = qbeame(j) +
     .                  qbbe(j,ic,jb)*0.62415064e16 ! keV/(cm3 sec)
             qbeami(j)     = qbeami(j) + qbbi(j,ic,jb)*0.62415064e16
         endif

      sprbeame(j)   = sprbeame(j) + bke(j,ic,jb)*spbr(j,ic,jb)
      sprbeami(j)   = sprbeami(j) + bki(j,ic,jb)*spbr(j,ic,jb)
     .                            + fbth(j,ic,jb)*sb(j,ic,jb)*trot
      ssprcxl(j)    = ssprcxl(j)  + fprscxl*spbr(j,ic,jb)
     .                            + fscxl*sb(j,ic,jb)*trot
      if (ibslow .eq. 0)  go to 2257
      enb(j,ic,jb) = MAX(enb(j,ic,jb),enbmin)
      enbeam(j) = enbeam(j) + enb(j,ic,jb)
      enbeams(j)= enbeam(j)
      wbeam (j)  = wbeam(j) + 0.62415064e16*wb(j,ic,jb)  !kev/cm3




c
c     BEAM-DRIVEN CURRENT CALCULATIONS, ONETWO AND MCGO:
c
c ----------------------------------------------------------------------
c

         if(external_beam_cur .eq. 0)then
             curbi(j)  = curbi(j) + charge*ppb(j,ic,jb)
     .                       /(2.99792458e9*atw_beam*xmassp)
          else
             curbi(j) =0.0  
         endif
c
c             Compute beam-driven electron current per rational fit to
c             numerical results of D.F.H. Start and J.G. Cordey,
c             Phys. Fluids, 23, 1477 (1980).
c             The Mcgo value is determined by (in program Mcgo):
c
****          drvncur(j)=curdens(j,4)*
**** .             (1.0-(1.0/zef(j))*(1.0-((1.55+0.85/zef(j))
**** .             * SQRT (aspinv(j))-(0.20+1.55/zef(j))*aspinv(j))))
c
             curbe(j) = -curbi(j)/zeff(j)
             if (codeid .eq. 'onedee') then
                 delta = r(j)/(SQRT (kappa)*rmajor)
             else
c
c                eps is advanced in time in rhomesh. HSJ
c
****             delta = eps0(j)
****             if (itre .ne. 1)
**** .           delta = eps0(j) + (time-eqtim0)*(eps(j)-eps0(j))/dteq
                 delta = eps(j)
             end if
c

             If(external_beam_cur .eq. 0)then
               curbet(j) = -curbe(j)*((1.55+0.85/zeff(j)) * SQRT (delta)
     .                      -(0.20+1.55/zeff(j)) *       delta)
             else
                curbet(j) = 0.0 ! dont have this value from trasnp at present
             endif              !so we just use total beam current

c
 2257 continue  ! j,ic,jb end loops



c     smooth wbeam (required for pprime in mhd calcs near axis)
c     just set gradient in wbeam at mag axis equal to zero HSJ
c
      wbeam(1)=(wbeam(2)*(dr(1)+dr(2))*(dr(1)+dr(2))
     .                 -dr(1)*dr(1)*wbeam(3))/(dr(2)*(2*dr(1)+dr(2)))
c
c*HSJ don't set the gradient 5/13/97
c     set gradient to zero at magnetic axis, to give reasonable
c     bootstrap contribution near magnetic axis due to fast ion part:
c
c      call cubicextrp (enbeam(2), enbeam(3), enbeam(4),
c     .                 r(2), r(3), r(4), enbeam(1), 3)
c
c     separate fast beam ion sources due to ionization and charge exchange
c
      call bproc (hicm, kb, ke, kj, nbeams, nj, sbsav, sbcx, sbion)


c
c     Compute particle and energy sources due to fast ion birth.
c     Compute energy source due to secondary charge exchange
c     loss of fast beam ion (ignore particle source).
c     sbcx is source of thermal neutrals and also the source
c     of fast ions due to beam neutral, thermal ion charge exchange. HSJ
c
      do i=1,2
        do j=1,nj
          volsn(j,i) = sbcx(j,i)            ! thermal neutral and fast..
c                                           ..ion particle source,sink
c                                           ..for thermal ions
          qcx(j)     = qcx(j) + cximult* 1.5*ti(j)*sbcx(j,i)    ! loss from ion..
c                ..distribution due to charge exchange with beam neutral
          sbcx(j,i)  = -sbcx(j,i)
          if (ineut(i) .ne. 0) then
            fenn     = 1.0
            if (ineut(3-i) .ne. 0 .and. enn(j,1)+enn(j,2) .ne. 0.0)
     .        fenn   = enn(j,i) / (enn(j,1) + enn(j,2))
            qcx(j)   = qcx(j) - cximult* 1.5*tn(j,i)*fenn*sscxl(j)*ibcx
c
c           above is GAIN for ion distribution due to fast ion thermal
c           neutral charge exchange. sscxl is rate at which fast ions
c           charge exchange with thermal neutrals to form thermal ion
c           and fast neutral
c
          end if
        end do
      end do
c
      do j=1,nj
        sione(j) = sbion(j)
      end do
c
c --- thermalized fast ions are added to siadd:
c
      if (ibion .gt. 0) then
        if (ineut(ibion) .ne. 0)  call copya (sbeam,siadd(1,ibion),nj)
      else
        if (ineut(id)    .ne. 0)
     .      call addac (sbeam, siadd(1,id), nj,     fdbeam)
        if (ineut(it)    .ne. 0)
     .      call addac (sbeam, siadd(1,it), nj, 1.0-fdbeam)
      end if





      else    beamif  
!         use nubeam module 
c         don't recalculate the beam
c         deposition if this is corrector step:
c         If this is the 'init' step, and beams are already on,
c         we first want to compute a reasonable neutral profile.
c         initbm is used to control this process for the init step.
c         after the init step initbm is never changed
c         from its value of zero, defined at the start of source:
c

       
          pload_12 =0                         ! do not restore te,ti,from restart file
c             write(888,fmt='("nubeam_evolve,time =",x,i5,x,1pe12.6)')
c     .       nubeam_evolve,time
          if(nubeam_evolve .eq. 0) go to 2280 !avoid calling nubeam
                                              !during beam/thermal 
                                              !startup density iterations
                                              !(such iterations are only 
                                              !done with beam models other 
                                              !than nubeam. For nubeam it 
                                              !is required that the beam 
                                              !starts up during (or at the
                                              ! beginning of the simulation)

           IF(o12_index .Gt. 1) THEN
c             write(888,fmt='("o12 index =",i5)')o12_index
c             call stop("o12 index prob c309,l 3438",1) ! 8888889999
          ENDIF
                ! start collecting time info here
                  IF(.NOT. nubeam_mon_set)THEN  
                     nubeam_index = last_mon_index+1
                     last_mon_index = nubeam_index
                     nubeam_mon_set = .TRUE.
                     descrip_mon(nubeam_index) = "Nubeam elapsed  time"
c                  write(888,FMT='("start nubeam_index ",i5)')
c     .             nubeam_index  ! 88888889999999
                  ENDIF
                  start_timer(nubeam_index) =.TRUE.
                  stop_timer(nubeam_index)  =.FALSE.
                  CALL collect_stats(nubeam_index)
                  start_timer(nubeam_index) =.FALSE.        
c                  write(888,FMT='("start nubeam  3446 ",1pe14.6,x,i5)')
c     .             elapsed_time(nubeam_index),nubeam_index  ! 88888889999999

       IF(o12_index .Gt. 1) THEN
         write(888,fmt='("o12 index =",i5)')o12_index
         call stop("o12 index prob c309,l 3458",1)   ! 8888889999
        ENDIF
          if ( (nubeam_evolve .eq. -1) .and. 
     .         (nubeam_version .lt. 201107) )  then
 
             pload_12 = 1
             call get_12_fiprof(time,pload_12)
             pload_12 = 0
             !we are using a nubeam restart file
             curbe(:)        = 0.0    !because curb is recalculated from this
             curbet(:)       = 0.0    !in other routines
             curbi(:)        = curb(:)
             wb(:,1,1) = wbeam(:)/0.62415064e16  !only define for (Kj:1,1)
             enb(:,1,1) = enbeam(:)
             do j=1,SIZE( enb,dim=1)
               enb(j,1,1) = MAX(enb(j,1,1),enbmin) !zero doesnt work
                                                   !in curray
             enddo
             enbeams(:)     = enbeam(:)
 
           endif

!          if ( (nubeam_evolve .eq. -1) .and. 
!      .         (nubeam_version .lt. 201107) )  then

!             pload_12 = 0
!             call get_12_fiprof(time,pload_12)
!             wb(:,1,1) = wbeam(:)/0.62415064e16  !only define for (Kj:1,1)
!           enb(:,1,1) = enbeam(:)
!             do j=1,SIZE( enb,dim=1)
!               enb(j,1,1) = MAX(enb(j,1,1),enbmin) !zero doesnt work
                                                   !in curray
!             enddo
!             enbeams(:)= enbeam(:) 

!           endif

           !time +dt is time after corrector is done

          if(time  .le. nubeam_on -
     .       beam_data%beam_power_rise_time - time_tol ) go to 2280
           if(istep .ne. 'pred' .and. .not. nubeam_init)go to 2280
          nubeam_init = .true. 

c          if (istep .ne. 'init')  go to 2279
          if ( nneu .eq.  0    )  go to 2279
          initbm = initbm + 1
          if (initbm .eq. 1)  go to 2280    ! skip ahead only the first time
 2279     continue

          corrstep: if (istep .ne. 'corr' .and. nubeam_steps .eq.1)then

              if(freyavb .eq. 1)then
                    print *,'calling nubeam,time,dt =',time,dt
                    print *,'initbm,istep =',initbm,istep
              endif

              if (nubeam_version .lt. 201107) then 
                 if ((nubeam_restart .eq.  0) .or. 
     .               (nubeam_restart .eq.  -1) .or.  ! 888899999 hsj 10/9/13
     .               (nubeam_restart .eq. -2) .or.
     .               (nubeam_restart .eq. -99))
     .           call set_nubeam_init_profs !JMP END
                 call NTCC_driver
                !call write_restart_profs
                 call get_12_fiprof(time,pload_12)
              else
                 print *,'calling dnubeam_driver c309_nubeam,a'
                 call dnubeam_driver()
                 print *,'returned from d3d dnubeam driver a'
              endif

              !wbeam,enbeam are set in nubeam ( for time = time+dt )
              wb(:,1,1) = wbeam(:)/0.62415064e16  !only define for (Kj:1,1)
              enb(:,1,1) = enbeam(:)
              do j=1,SIZE( enb,dim=1)
                 enb(j,1,1) = MAX(enb(j,1,1),enbmin) !zero doesnt work in curray
              enddo
              enbeams(:) = enbeam(:)
              curbi(:) = curb(:)   
              curbe(:) = 0.0   !because curb is recalculated from this
              curbet(:) = 0.0  !in other routines

          else if(istep .ne. 'corr' .and. nubeam_calls(nubeam_steps-1)
     .                         -time .lt. 3.*time_tol )then  corrstep

             if (nubeam_version .lt. 201107) then 

                !save results from previous call
                call update_nubeam_profs

                call NTCC_driver
                !save for possible use as restart file
                !call write_restart_profs 

                !qbeame_nub,etc now contains values at the
                !future time stored in nubeam_calls(nubeam_steps-1)
                !current time will be .le. to  nubeam_calls(nubeam_steps-1)
                !interpolate profiles onto the current time:
                call get_12_fiprof(time,pload_12)
             else
                print *,'calling dnubeam_driver c309_nubeam,b'
                call dnubeam_driver()
                print *,'returned from d3d dnubeam driver b'
             endif

             !wbeam,enbeam are set in nubeam ( for time = time+dt )
             wb(:,1,1) = wbeam(:)/0.62415064e16  !only define for (Kj:1,1)
             enb(:,1,1) = enbeam(:)
             do j=1,SIZE( enb,dim=1)
                enb(j,1,1) = MAX(enb(j,1,1),enbmin) !zero doesnt work in curray
             enddo
             enbeams(:) = enbeam(:)
             curbi(:) = curb(:)   
             curbe(:) = 0.0  !because curb is recalculated from this
             curbet(:) = 0.0 !in other routines

          else  corrstep  !predictor or corrector step - set quantities 
                          !that are normally handled by slow1,slow2
                          !using time interpolation

             if (nubeam_version .lt. 201107) then 
                 !interpolate profiles onto the current time:
                 call get_12_fiprof(time,pload_12)
             else
                print *,'calling load_nubeam'
                 call load_nubeam(time)
                print *,'returned from load_nubeam'
             endif

             wb(:,1,1)   = wbeam(:)/0.62415064e16  !only define for (Kj:1,1)
             enb(:,1,1)  = enbeam(:)
             enbeams(:)  = enbeam(:)
             curbi(1:nj) = curb(1:nj)
             curbe(:)    = 0.0  ! not available directly from nubeam
             curbet(:)   = 0.0 ! not available directly from nubeam

          endif  corrstep

      !jmp.den start

      do i=1,2
        do j=1,nj
          volsn(j,i) = sbcx(j,i)
        end do
      end do

      if (ibion .gt. 0) then
        if (ineut(ibion) .ne. 0)
     .  	siadd(1:nj,ibion) = sbeam(1:nj) + sbcx(1:nj,1)
      else
        if (ineut(id)    .ne. 0)
     .      siadd(1:nj,id) = fdbeam*sbeam(1:nj) + sbcx(1:nj,1)
        if (ineut(it)    .ne. 0)
     .      siadd(1:nj,it) = (1.0-fdbeam)*sbeam(1:nj)
      end if
      
      sbcx(:,:) = 0.0 !jmp.ibm
      
      !jmp.den end
                stop_timer(nubeam_index)  =.TRUE.
                CALL collect_stats(nubeam_index)
                stop_timer(nubeam_index)  =.FALSE.
c        write(888,FMT='("stop nubeam 3610 ",1pe14.6,x,i5)')
c     .                   elapsed_time(nubeam_index),nubeam_index  ! 88888889999999

      endif  beamif    !end time_dep_beam,single pulse beam branches, nubeam branch
 2280      continue


c --- END NBI INJECTION




c-----------------------------------------------------------------------
c         thermal and beam fusion:

          call fusion12(initbm,palpha0, vzalpha)

 
c-----------------------------------------------------------------------


 2305 if (nneu .eq. 0)  go to 2500
c
c                     NEUTRAL TRANSPORT
c
c          Compute neutral reaction rates for charge exchange and
c          electron ionization.  ratef is a correction factor for
c          elongated plasmas (onedee).
c



      call setscr    ! set up scrape off layer if njs > nj
      ratef = raneut / r(nj)
      call rate (ratef)
c
c     compute neutral volume source due to radiative recombination
c
      do j=1,njs
        recomr = ratef*recrat(te(j))*ene(j)
        do i=1,nprim
          if (i .le. 2) then
            srecom(j,i) = recomr*z(j,i)*en(j,i)
            volsn (j,i) = volsn(j,i) + srecom(j,i)
          end if
        end do
      end do
c
c Compute the total rate at which ions are being added or lost
c due to beams and fusion
c
      do i=1,2
        call trapv (r,siadd(1,i),hcap,nj,snadd(i))
        snadd(i) = volfac*snadd(i)
        if (ineut(i) .ne. 0) then
          flxadd(i) = snadd(i) / sfarea
        end if
      end do
c
c     Compute the inward flux of neutrals at the plasma surface.
c     The neutrals come from recycled plasma and injected gas.
c     If ipcons(i) = 1 (constant number of ions in plasma), there is
c     also a correction for particles added in this time step.
c
c     Modified 7/23/83 by SMW to include a finite recycling
c     coefficient for the case ipcons(i) = 0. Note that snadd and
c     flxadd are adjusted to include losses to the wall for
c     recyc not equal to 1
c
c     Further modified 5/15/85 so that negative values of fluxb
c     don't recycle into negative neutral fluxes.
c
c     corrected  1/26/95 to properly allow simulation of one species and
c     analysis on the other HSJ.
c
****  if (    iten .eq. 0)  go to 2331               ! HSJ 1/26/96
      do 2330 i=1,2
      if (ineut(i) .eq. 0)  go to 2330
      if (itran(i) .eq. 0)  go to 2330               ! HSJ 1/26/96
      gflux = gasflx(1,i)
      if (gasflx(2,i) .eq. 0.0)  go to 2328
      call interp1(time,bctime,nbctim,gasflx(1,i),gflux)
cjmp.den 2328 sngas(i) = sfarea*gflux  ! #/sec of species i added by gas puff
 2328 continue
      !jmp.den start
      if (iperp) then 
         gflux = gflux/1.6e-19/sfarea 
      end if   
      sngas(i) = sfarea*gflux ! #/sec of species i added by gas puff 
      !jmp.den end
c
      do j=nj-2,nj-1
        ena       = 0.5 * (en(j,i) + en(j+1,i))
        flux(i,j) = ena*vpinch(j)
        do k=1,nk
          flux(i,j) = flux(i,j) - d(i,k,j)*dudr(k,j)
        end do
      end do
c
      call extrap (ra(nj-2), ra(nj-1), r(nj),
     .             flux(i,nj-2), flux(i,nj-1), fluxb(i))
      fluxb(i) = flux(i,nj-1) !jmp.den
      fluxb2(i) = flux(i,ni_index-1) !jmp.den
      !print *,'jmp.den.flux',fluxb2(i)
      reflux    = MAX (recyc(i)*fluxb(i), zero)
      fluxn (i) = reflux + gflux
      flxadd(i) = flxadd(i) + fluxn(i) - fluxb(i)
      snadd (i) =  snadd(i) + sfarea * (reflux-fluxb(i))
      if (ipcons(i) .eq. 1)  fluxn(i) = fluxn(i) - flxadd(i)
      call chkflx (i)
 2330 continue
c
 2331 if ( istep .eq. 'init')  go to 2350
      if ( istep .eq. 'corr')  go to 2380
      if (ineucg .eq.  0    )  go to 2350
****  if (icallneu .eq. 1 .or. iprt .eq. 1)  go to 2350   ! Bob Harvey
      if (icallneu .eq. 1 .or. iprt .eq. 1)  go to 2350   ! required HSJ
      if (  iprt .eq.  1    )  go to 2350
c
c     delneu is the maximum relative change in the density and
c     ion temperature since the neutral routine was last called.
c     If delneu > relneu we call the neutral routine.
c
      call maxrc (ti, tineu, nj, delneu)
      delneu = 0.25*delneu
      do i=1,2
        if (ineut(i) .ne. 0) then
          call maxrc(en(1,i),enneu(1,i),nj,deln)
          delneu = MAX (delneu,deln)
        end if
      end do
      if (delneu .le. relneu)  go to 2380
c
c          Call the neutral transport routine
c
 2350 do 2351 i=1,2
 2351 if (ineut(i) .ne. 0)   call copya (en(1,i),enneu(1,i),nj)
      call copya (ti,tineu,nj)
c      if (iten .ne. 0)  go to 2360           ! HSJ 1/26/96
      do 2355 i=1,2
        if (ineut(i) .eq. 0)  go to 2355
        if (itran(i) .eq. 0) then             ! HSJ 1/26/96
           call trapv (r,en(1,i),hcap,nj,fluxn(i))
           fluxn(i) = fluxn(i)/(hcap(nj)*r(nj)*taupin)
           !fluxn(i) = gasflx(1,i)/1.6e-19/sfarea !jmp.den 
        end if
 2355 continue
c
 2360 m1 = 1
      if (nneu .eq. 1)  m1 = in
      imslmd = 'neucg2'
      if (neucgvb .gt. 0)  write (6, '(" calling NEUCG2")')
      call neucg2 (njs,r,ene,en(1,m1),en(1,2),ti,
     .          volsn(1,m1),volsn(1,2),eionr,cexr(1,m1),cexr(1,2),cx12r,
     .          nneu,reqsp,twall,atw(m1),atw(2),reflec,reflec,
     .          fluxn(m1),fluxn(2),
     .          dn1(1,m1),dn1(1,2),dnv(1,m1),dn2(1,1),dn2(1,2),dnv(1,2),
     .          wn1(1,m1),wn1(1,2),wnv(1,m1),wn2(1,1),wn2(1,2),wnv(1,2))
      ineucg = ineucg + 1
      ineu   = ineu+1
c
c     normalize neutral densities to conserve particles under present conditions
c
 2380 if (neucgvb .gt. 0)  write (6, '(" calling NEUDEN")')
      call neuden
c
c     check for negative neutral densities:  HSJ
c
      do j=1,njs
         if (nneu .eq. 1) then
            if (enn(j,in) .lt. 0.0)
     .      write (6, *) " ERROR: enn(j,in),j =", enn(j,in), j
         else
            if (enn(j,1) .lt. 0.0 .or. enn(j,2) .lt. 0.0)
     .      write (6, *) " ERROR: enn(j,1), enn(j,2), j =",
     .                            enn(j,1), enn(j,2), j
         end if
      end do


c----------------------------------------------------------------------
c     if this is the first cycle of the init step initbm = 1
c     so go back and get the beam now:
c----------------------------------------------------------------------

 
      if (initbm .eq. 1)  go to 1000





**** .  write (6, *)  " enn(j,1), enn(j,2) =", enn(j,1), enn(j,2)
c
c     compute particle and energy sources due to recombination of ions
c     and ionization and charge exchange of neutrals
c
      do 2430 j=1,njs
      do 2430 i=1,nprim
      if (i .gt. 2)  go to 2430
      sione(j) = sione(j) - z(j,i)*srecom(j,i)
      qione(j) = qione(j) + z(j,i)*srecom(j,i)*1.5*te(j)
      qioni(j) = qioni(j) - srecom(j,i)*1.5*ti(j)
      if (inrad .eq. 0)  qrad(j) = qrad(j) + z(j,i)*srecom(j,i)*wion
      srecom(j,i) = -srecom(j,i)
      if (ineut(i) .eq. 0)  go to 2430
      sion(j,i) = enn(j,i)*eirate(j)
      sione(j) = sione(j) + z(j,i)*sion(j,i)
      qione(j) = qione(j) + z(j,i)*sion(j,i)*wion
      qioni(j) = qioni(j) + sion(j,i)*1.5*tn(j,i)
      qcx(j) = qcx(j) + cximult* 1.5*enn(j,i)*cexr(j,i)*en(j,i)*
     .                                             (ti(j)-tn(j,i))
      if (inrad .eq. 0)  qrad(j) = qrad(j) + z(j,i)*sion(j,i)*wrad
      if (nneu .eq. 1)  go to 2430
      iother = 3-i
      cxmix = en(j,i)*enn(j,iother)*cx12r(j)
      scx(j,i) = scx(j,i) - cxmix
      scx(j,iother) = scx(j,iother) + cxmix
      qcx(j) = qcx(j) + cximult* 1.5*cxmix*(ti(j)-tn(j,iother))
 2430 continue
c
      if(neucgvb .gt. 0)print *,'in source,neutral drag calcs'
      if (iangrot .eq. 0)  go to 2500
c
c --- neutral drag (i.e., charge exchange) and impact ionization sources
c --- of angular momentum.  Get the ion speed in the axial direction
c --- of the NEUCG2 cylindrical coordinate system by using conservation
c --- of angular momentum:
c
c                 <vphi*rmajor> = w*<rmajor**2>
c
c --- which we assume can be approximated as
c
c          vionz = <vphi>=w*<rmajor**2>/<rmajor>
c
      do 2390 j=1,nj
 2390 vionz(j) = angrot(j)*r2capi(j)/rcap(j)
c
c --- get the neutral axial speed VNEUT:
c
      if(neucgvb .gt. 0)print *,'in source,calling nuvel'
      call nuvel (vionz, enn, in, vneut)
      if(neucgvb .gt. 0)print *,'in source,done nuvel'
c
c --- source of ion angular momentum due to electron impact ionization
c --- of thermal neutrals (ion impact is neglected since neutral
c --- model is only valid for tn<5keV) is spreimpt. Source due to
c --- charge exchange terms (thermal neutrals with thermal ions) is
c --- sprcx.  ion energy sources (keV/cm**3*sec) sprcxe,sprcxree,spreimpe
c
      do 2440 j=1,nj
      do 2440 i=1,2
      if (ineut(i) .eq. 0)  go to 2440
      spreimpt(j) = spreimpt(j)+eirate(j)*enn(j,i)*atw(i)
     .    * xmassp*vneut(j,i)*rcap(j)
      spreimpe(j) = 0.5 * angrcple*kevperg*spreimpt(j)*vneut(j,i)
     .                  / rcap(j)
      sprcx(j) = sprcx(j)+enn(j,i)*cexr(j,i)*en(j,i)*atw(i)
     .    * xmassp*rcap(j)*(vneut(j,i)-vionz(j))
      sprcxe(j) = sprcxe(j) + 0.5 * angrcple * kevperg
     .          * ((rcap(j) / r2capi(j))**2)
     .          * enn(j,i) * cexr(j,i) * en(j,i) * atw(i) * xmassp
     .          * (vneut(j,i)**2-vionz(j)**2)
      if (nneu .eq. 1)  go to 2440
      iother = 3-i
      cxmix = en(j,i)*enn(j,iother)*cx12r(j)*xmassp*rcap(j)
      sprcx(j) = sprcx(j)+cxmix*(atw(iother)*vneut(j,iother)
     .        -atw(i)*vionz(j))
      sprcxe(j) = sprcxe(j)
     .          + 0.5 * angrcple*kevperg*((rcap(j)/r2capi(j))**2)
     .          * en(j,i)*cx12r(j)*enn(j,iother)*xmassp
     .          * (atw(iother)*vneut(j,iother)**2-atw(i)*vionz(j)**2)
 2440 continue
c
c ----------------------------------------------------------------------
c include additional source due to ionization of impurities
c ----------------------------------------------------------------------
c
 2500 if (nimp .eq. 0)  go to 2520
      do  i=1,nimp
      k = nprim+i
      do   j=1,nj
        sione(j) = sione(j)+dzdtim(j,i)*en(j,k)
      enddo
      enddo

c
c --- sink of angular momentum due to cx of thermal ions with fast neutrals
c --- and (if nneu .ne. 0) radiative recombination
c
 2520 if (iangrot .ne. 0) then
        do 2395 i=1,2
        do 2395 j=1,nj
        sprcxre (j) = sprcxre(j)-volsn(j,i)*r2capi(j)*angrot(j)*
     .                atw(i)*xmassp
 2395   sprcxree(j) = 0.5 * angrcple*kevperg*angrot(j)*sprcxre(j)
      end if
      do j=1,nj
           if(ABS(sione(j)) .gt. 1.d100)then
                 print *,'error in fast ion source calculation'
                 print *,'In source,sione,sionb= ', j,sione(j),sbion(j)
                 print *,' check beam input in inone'
                 call STOP('source , beam error',1)
           endif
      enddo
c
c ----------------------------------------------------------------------
c          RF HEATING
c ----------------------------------------------------------------------
c
c whether or not an RF module is called is hierarchically controlled by
c the following three variables:
c irf(model)  must be .ge. 2, indicating that the model is on at this time
c istep       must be the initial step, 'init', or a predicitor step, 'pred'.
c             RF Modules are not called during subsequent corrector
c             steps, 'corr'. When MHD calculations are not done there is only
c             one transport cycle (from time0 to timmax) and hence only one
c             'init' step. However when MHD calcs are done as well then
c             there will generally be many transport cycles (Each transport
c             cycle ends when a new MHD calculation is called for)
c             Transport cycles may be repeated if the MHD calcs did not
c             converge. Hence there will be many 'init' steps. We dont
c             call the RF modules on subsequent init steps unless relrf
c             signals that a call is necessary.
c relrf       if RF is on and the largest relative change in electron
c             temperature or density is greater than relrf then we call
c             the RF module.    HSJ
c 
c if   beam_iteration = .true. skip rf calls . (beam_iteration is
c             set to  .false. after initial beam startup in tport)
c ----------------------------------------------------------------------
c

      if(fusionvb .gt. 0)print *,'in source,start rf heat' 
      if(fusionvb .gt. 0)print *,'beam_iteration =',beam_iteration
      model = 0
      irfc  = 0 
      if(test_xptor .eq. 1 .and. 
     .      allocated(qrfe_fixed) )go to 2852 

      if(beam_iteration) go to 2852  
c

 2661 model = model + 1
 
      if (    model  .gt. krf)  go to 2850   ! exit from RF section here
      if(fusionvb .gt. 0)print *,'starting rf loop,model',
     .                            model,irf(model),irfmodel(model)
 
       IF (irf(model) .le. 1  )THEN
             qrfes(:,model)              = 0.0
             currfs(:,model)             = 0.0
             jtor_eccd(:,model)          = 0.0
             rfmodel_power_e(model)      = 0.0
             rfmodel_power_i(model)      = 0.0            
             rfmodel_cd(model)           = 0.0

          go to 2661                       ! skip this model because 
                                           ! it is off
       ENDIF

      ! if irf(model) == -1 then rf channel is off, we 
      ! let this go through here to zero the respective
      ! qrfes, currfs(j,model),jtor_eccd(j,model),etc arrays below

c
c     set flag for RF current
c
      if(irfcur(model) .ne. 0.0)irfc =irfc+1

c      irfc = irfc + IABS (irfcur(model))
c
      if(fusionvb .gt. 0)print *,'irfmodel=',irfmodel(model),model
      if      (irfmodel(model) .eq. 'ich'     ) then
        go to 2750
      else if (irfmodel(model) .eq. 'input'   ) then
        go to 2810
      else if (irfmodel(model) .eq. 'fb'      ) then
        go to 2950
      else if (irfmodel(model) .eq. 'ech'     ) then
        go to 2670
      else if (irfmodel(model) .eq. 'fastwave') then
        go to 3150
      else if (irfmodel(model) .eq. 'raytrace') then
        go to 3155
      else if (irfmodel(model) .eq. 'fastcd'  ) then
        go to 3185
      else if (irfmodel(model) .eq. 'genray'  ) then
        go to 3195
      end if
c
c     ECH model (uses separate TORAY 3d raytracing code)
c
 2670 if (istep .eq. 'corr')  go to 2820
****  if (istep .eq. 'init')  go to 2710
      !prevent multiple calls on startup
      if (istep .eq. 'init' .and. time .le. time0 
     .    .and. irfcnt(model) .eq. 0)go to 2710 

****  if (icallrf       .eq. 1)  go to 2710                 ! Bob Harvey
      if (irfcnt(model) .eq. 0)  go to 2710

      CALL check_prtlst(ech_run,model) ! toray will be called at prtlst times HSJ 9/22/09

c       write(940,FMT='("done check_printlist,ech_run,model=",
c     .                 x,i5,x,i5)') ech_run,model ! 888888999
c
c     decide if ECH should be called:
c     delrf is the maximum relative change in the electron
c     density and temperature since ECH was last called.
c     if  delrf > relrf, we call ECH again
c
      call maxrc (ene, enrf(1,model), nj, delrf)
      call maxrc (te , terf(1,model), nj, delte)
      delrf = MAX (delrf, delte)
c      write(940,FMT='(//,"delrf,relrf",2(x,1pe12.5))')delrf,relrf ! 888888899999

      ! if time dependent power input we check for change in power of
      ! each gyrotron. If power cchanged by more than relrf_pow then
      ! call ech for that gyrotron.
      ! if ech will be called because  of relrf or ech_run setting then
      ! we dont need to do this check because  rf will be called anyway
      IF(ech_input .ne. 'none' .AND. delrf .le. relrf .AND. 
     .          ech_run == 0 )THEN
         ! we must have previous data for comparison so do this
         ! only if ech was called at least onece before:

           IF(irfcnt(model) .Gt. 0)THEN
              pow_save = rfpow(model)
              CALL get_ech_params(time,model) ! get rfpow at t = time
c              write(940,FMT='("ech_run in 1 =",i5)')ech_run
c              write(940,fmt='("abs =",1pe12.4,i5)')
c     .          ABS((pow_save - rfpow(model))/MAX(pow_save,1.D0)),model
              IF(ABS((pow_save - rfpow(model))/MAX(pow_save,1.D0))
     .                .GT. relrf_pow) ech_run = 2  ! force call to ech 
              IF(ech_run == 2)THEN
                 
c                 write(940,fmt='("forcing call to ech with model =",
c     .                           i5)') model  ! 888889999
c                 write(940,FMT='("relrfpow,pow_save,rfpow(model) =",
c     .                 3(2x,1pe12.4))')relrf_pow,pow_save,rfpow(model)
              ENDIF
           ENDIF
      ENDIF
      if (delrf .le. relrf .AND. ech_run == 0 )  go to 2820
c
c      write (940,FMT= '(a, 2f12.8,i5)')  ' delrf, relrf,ech_run =', 
c     .                            delrf, relrf,ech_run
c
c --- call subroutine ECH 
c
 2710 call copya  (ene, enrf(1,model), nj)
      call copya  (te , terf(1,model), nj)
      call psirho (0)

      rfmodel_power_e(model) =0.0  !we will recalcualte the power HSJ
      rfmodel_cd(model) =0.0       !ditto for currrent drive
      rfmodel_power_i(model) =0.0  !never any ion heating
c
      write (6, '(/ a)') ' ---- calling subroutine ECH (from SOURCE)'
c
      ! start collecting time info here
      IF(.NOT. ech_mon_set)THEN  
         ech_index = last_mon_index+1
         last_mon_index = ech_index
         ech_mon_set = .TRUE.
         descrip_mon(ech_index) = "ech elapsed time"
c        write(888,FMT='("start ech_index = ",i5)')ech_index  ! 88888889999999
      ENDIF
      start_timer(ech_index) =.TRUE.
      stop_timer(ech_index)  =.FALSE.
      CALL collect_stats(ech_index)
      start_timer(ech_index) =.FALSE.
c        write(888,FMT='("start ech 4080",1pe14.6,x,i5)')
c     .                   elapsed_time(ech_index),ech_index  ! 88888889999999
      
 
      IF(ech_input .ne. 'none') THEN
        CALL get_ech_params(time,model)
      ELSE
        model_globl = model
      ENDIF

 


c      write(940,Fmt ='("cray309 calling ech")') ! 8888889999
c      write(940,FMT='("model =",i5)')model
c      write(940,FMT='("rfpow,rfon=",1pe14.8,2x,1pe14.8)')rfpow(model),
c     .   rfon(model)    ! 888888999999
c      write(940,FMT='("time =",1pe14.8)')time
         call ech (freq(model), rfpow(model), wrfo(model), idamp(model),
     .          gafsep, necsmth, codeid, xec(model), zec(model),
     .          nray(model), thetec(model), phaiec(model), hlwec(model),
     .          ratwec(model), nj, r, psir, ene, te, q, hcap, dr,
     .          qrfes(1,model), currfs(1,model), jtor_eccd(1,model),
     .          totecpe, totecc,
     .          ifixshap, time, irfplt, rmajor, btor, zeff, rf_output)

       write (6, '(a /)') ' ---- returned from subroutine ECH'
c      write(940,Fmt ='("return from ech")') ! 8888889999
c

         
         factor = turnon(time,rfon(model), turnonp(model),
     .     rftime(model),rframp_timeup(model),rframp_timedown(model))
         IF(ech_input .ne. 'none')factor = 1._DP
      do j=1,nj
        qrfes (j,model)    = 0.62415064e16 * qrfes (j,model)*factor
        currfs(j,model)    = irfcur(model) * currfs(j,model)*factor
        jtor_eccd(j,model) = irfcur(model) * jtor_eccd(j,model)*factor
      end do
 
c
 
      call addac (qrfes (1,model), qrfe , nj,factor)
c     .            turnon(time,rfon(model), turnonp(model),
c     .     rftime(model),rframp_timeup(model),rframp_timedown(model)))

      call addac (currfs(1,model), currf, nj,factor)
c      write(940,FMT='("added currfs to currf, model no = ",i5)')model
c      write(940,FMT='("max vals =",x,1pe12.4,x,1pe12.4)') ! 888899999
c      .    maxval(currf)
c     .            turnon(time,rfon(model), turnonc(model),
c     .     rftime(model),rframp_timeup(model),rframp_timedown(model)))
c
c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)

      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
c      print *,'rfmodel_power_e(model)= ',rfmodel_power_e(model)
c      print *,'rfmodel_power_i(model)= ',rfmodel_power_i(model)
c      print *,'rfmodel_cd(model)= ',rfmodel_cd(model)
       irfcnt (model) = irfcnt (model) + 1
       irfcalc(model) = irfcalc(model) + 1

c      write(969,FMT='("time ,factor,model",1pe14.8,2x,1pe12.4,2x,i5)')
c     .        time,factor,model ! 8888888999999

       stop_timer(ech_index)  =.TRUE.
       CALL collect_stats(ech_index)
       stop_timer(ech_index)  =.FALSE.
       go to 2661



c -----------------------------------------------------------------------------
c     ICH model (T.K. Mau, 9/82)
c -----------------------------------------------------------------------------
 2750 if (istep .eq. 'corr')  go to 2820
****  if (istep .eq. 'init')  go to 2760                           ! HSJ
      if (istep .eq. 'init' .and. time .le. time0
     .    .and. irfcnt(model) .eq. 0 )  go to 2760

****  if (icallrf       .eq. 1)  go to 2760                 ! Bob Harvey
      if (irfcnt(model) .eq. 0)  go to 2760
c
c     decide if ICH should be called:
c     delrf is the maximum relative change in the electron
c     density and temperature and ion temperature since ICH was last called.
c     if delrf > relrf, we call ICH again.
c
      call maxrc (ene, enrf(1,model), nj, delrf)
      call maxrc (te , terf(1,model), nj, delte)
      call maxrc (ti , tirf(1,model), nj, delti)
      delrf = MAX (delrf, delte, delti)
      if (delrf .le. relrf)  go to 2820
c
      write (6, '(a, 2f12.8)')  ' delrf, relrf =', delrf, relrf
c
c --- call ICH
c
 2760 call copya (ene, enrf(1,model), nj)
      call copya (te , terf(1,model), nj)
      call copya (ti , tirf(1,model), nj)
c
      write (6, '(/ a)') ' ---- calling subroutine ICH (from SOURCE)'
      call ich (freq(model), xkpar, nhigh, ykperp, iside, navg,
     .          ichmod, betalm, nrfrad, rfrad, rfrow, jrfmin, jrfmax,
     .          kj, nj, r, ene, en, te, ti,
     .          nprim, atw, z, rmajor, btor, hcap, rfpow(model),
     .          qrfes(1,model), qrfis(1,model))
      write (6, '(a /)') ' ---- returned from subroutine ICH'
c
         factor = turnon(time,rfon(model), turnonp(model),
     .     rftime(model),rframp_timeup(model),rframp_timedown(model))
      call addac (qrfes(1,model), qrfe, nj,factor)
c     .            turnon(time,rfon(model), turnonp(model),
c     .   rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (qrfis(1,model), qrfi, nj,factor)
c     .            turnon(time,rfon(model), turnonp(model),
c     .   rftime(model),rframp_timeup(model),rframp_timedown(model)))

c
c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)
      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c ----------------------------------------------------------------------
c INPUT heating model
c ----------------------------------------------------------------------
c
 2810 qfact = 1.0

c
      if (rfpow(model) .ne. 0.0 ) then
        if (include_adaptive .gt. 0)
     .  call wedge_model(qine,qini,nj,r,irfmodel,model)
        call trapv (r, qine(1,model), hcap, nj, facte)
        call trapv (r, qini(1,model), hcap, nj, facti)
        qfact = rfpow(model) / (volfac * (facte+facti))
      end if
c
c --- more than one wedge model can be active simultaneously.
c --- hence we modify the logic by introducing sdum ---- HSJ
c
      trfact = turnon (time, rfon(model), turnonp(model),
     .    rftime(model),rframp_timeup(model),rframp_timedown(model))
     .       * qfact * 0.62415064e16
      do j=1,nj
        sdum(j) = qine(j,model) * trfact
      end do
c
      call addac (qine(1,model), qrfe, nj, trfact)
      call addac (qini(1,model), qrfi, nj, trfact)
c
c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qine(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*trfact*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qini(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*trfact*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
c
      if (irfcur(model) .ne. 0.0) then
        call rfcur_simple (xnue, te, zeff, sdum, irfcur, model,
     .                     nj, kj, currfs)
        factor = turnon(time,rfon(model), turnonc(model),
     .   rftime(model),rframp_timeup(model),rframp_timedown(model))
        call addac (currfs(1,model), currf, nj,factor)
c     .              turnon(time,rfon(model), turnonc(model),
c     .   rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
      end if
      go to 2661
c
c --- new l87may7 current drive calculation (B. Harvey)
c
c             FBCUR - specify profiles of RF power or current drive.
c
 2950 if (istep .eq. 'corr')  go to 2820
****  if (istep .eq. 'init')  go to 2960
      if (istep .eq. 'init' .and. time .le. time0
     .    .and. irfcnt(model) .eq. 0)  go to 2960     ! HSJ

****  if (icallrf       .eq. 1)  go to 2960                 ! Bob Harvey
      if (irfcnt(model) .eq. 0)  go to 2960
c
c     decide if FISCHB should be called:
c     delrf is the maximum relative change in the electron
c     density and temperature and ion temperature since FISCHB was last called.
c     if delrf > relrf, we call FISCHB again.
c
      call maxrc (ene,enrf(1,model),nj,delrf)
      call maxrc (te,terf(1,model),nj,delte)
      call maxrc (ti,tirf(1,model),nj,delti)
      delrf = MAX (delrf,delte,delti)
      if (delrf .le. relrf)  go to 2820
c
      write (6, '(a, 2f12.8)')  ' delrf, relrf =', delrf, relrf
c
 2960 call copya (ene,enrf(1,model),nj)
      call copya (te ,terf(1,model),nj)
      call copya (ti ,tirf(1,model),nj)
c
      write (6, '(/a)') ' ---- calling subroutine FISCHB (from SOURCE)'
      call fischb (ifb, lmode, rfpow(model), rfcur, r, nj, ene, te,
     .             zeff, rnp(model), rmajor, hcap, ifbprof, alphaf,
     .             fbscrch, qrfes(1,model), currfs(1,model), itrapech)
      write (6, '(a/)') ' ---- returned from subroutine FISCHB'
c
      do j=1,nj
        qrfes (j,model) = 0.62415064e16 * qrfes (j,model)
        qrfis (j,model) = 0.62415064e16 * qrfis (j,model)
        currfs(j,model) = irfcur(model) * currfs(j,model)
      end do
c
      factor = turnon(time,rfon(model),turnonp(model),
     . rftime(model),rframp_timeup(model),rframp_timedown(model))
      call addac (qrfes(1,model),qrfe,nj,factor)
c     .            turnon(time,rfon(model),turnonp(model),
c     . rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (qrfis(1,model),qrfi,nj,factor)
c     .            turnon(time,rfon(model),turnonp(model),
c     . rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (currfs(1,model),currf,nj,factor)
c     .            turnon(time,rfon(model),turnonc(model),
c     . rftime(model),rframp_timeup(model),rframp_timedown(model)))
c


c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c --- end Fisch-Boozer calculation
c
c --- new l88june current drive calculation (B. Harvey/S.C.Chiu)
c
c             FASTWAVE - calls S. C. Chiu's slab, fast wave module
c
 3150 if (istep .eq. 'corr')  go to 2820
****  if (istep .eq. 'init'                      )  go to 3160
      if (istep .eq. 'init' .and. time .le. time0
     .         .and. irfcnt(model) .eq. 0 )  go to 3160     ! HSJ

****  if (icallrf       .eq. 1)  go to 3160                 ! Bob Harvey
      if (irfcnt(model) .eq. 0)  go to 3160
c
c     decide if FASTWAVE should be called:
c     delrf is the maximum relative change in the electron
c     density and temperature and ion temperature since FASTWAVE was last called
c     if delrf > relrf, we call FASTWAVE again.
c
      call maxrc (ene, enrf(1,model), nj, delrf)
      call maxrc (te , terf(1,model), nj, delte)
      call maxrc (ti , tirf(1,model), nj, delti)
      delrf = MAX (delrf, delte, delti)
      if (delrf .le. relrf)  go to 2820
c
      write (6, '(a, 2f12.8)')  ' delrf, relrf =', delrf, relrf
c
 3160 call copya (ene, enrf(1,model), nj)
      call copya (te , terf(1,model), nj)
      call copya (ti , tirf(1,model), nj)
c
      nspfw = nprim + nimp
      call my_ibcccu (p,rmhdgrid,nw,zmhdgrid,nh,cspln,nw,wnoperm,ier)
      write (6,'(/a)') ' ---- calling subroutine FASTWAVE (from SOURCE)'
      call fastwave (codeid, nscr, nfw, rmajor, kappa, btor, rbp, r,
     .               ra, nj, nspfw, te, ti, ene, en, zeff, z, atw,
     .               freqfw, rnpfw, rfpow(model), impath,
     .               iswchfw, lifw, nihfw, htsfw, zrffw, nzrffw, pzrffw,
     .               npsi, rmhdgrid, nw, zmhdgrid, nh, cspln, n2cspln,
     .               qrfes(1,model), qrfis(1,model), currfs(1,model),
     .               totfwpe, totfwpi, totfwc)
      write (6,'(a/)') ' ---- returned from subroutine FASTWAVE'
c
      do j=1,nj
        qrfes (j,model) = 0.62415064e16 * qrfes (j,model)
        qrfis (j,model) = 0.62415064e16 * qrfis (j,model)
        currfs(j,model) = irfcur(model) * currfs(j,model)
      end do
c
       factor = turnon(time,rfon(model),turnonp(model),
     . rftime(model),rframp_timeup(model),rframp_timedown(model))
      call addac (qrfes(1,model),qrfe,nj,factor)
c     .            turnon(time,rfon(model),turnonp(model),
c     . rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (qrfis(1,model),qrfi,nj,factor)
c     .            turnon(time,rfon(model),turnonp(model),
c     . rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (currfs(1,model),currf,nj,factor)
c     .            turnon(time,rfon(model),turnonc(model),
c     . rftime(model),rframp_timeup(model),rframp_timedown(model)))


c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor

      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c --- end FASTWAVE calculation

c ----------------------------------------------------------------------
c             RAYTRACE - calls Brambilla's extended ray tracing code
c ------------------------------Curray ---------------------------------
c
c
c     we get to here only if irf(model) .ne. 0 :
 3155 continue
      if (istep .eq. 'corr')  go to 2820
****  if (istep .eq. 'init'                      )  go to 3180
      if (istep .eq. 'init' .and. time .le. time0
     .       .and.   irfcnt(model) .eq. 0)  go to 3180     ! HSJ
****  if (icallrf       .eq. 1)  go to 3180                 ! Bob Harvey
      if (irfcnt(model) .eq. 0)  go to 3180
c
c     decide if RAYTRACE should be called:
c     delrf is the maximum relative change in the electron
c     density and temperature and ion temperature
c     since RAYTRACE was last called.
c     if  delrf > relrf, we call RAYTRACE again.
c
      call maxrc (ene, enrf(1,model), nj, delrf)
      call maxrc (te , terf(1,model), nj, delte)
      call maxrc (ti , tirf(1,model), nj, delti)
      delrf = MAX (delrf, delte, delti)
      if (delrf .le. relrf)  go to 2820
c
      write (6, '(a, 2f12.8)')  ' delrf, relrf =', delrf, relrf
c
 3180 call copya (ene, enrf(1,model), nj)
      call copya (te , terf(1,model), nj)
      call copya (ti , tirf(1,model), nj)
c
c --- renormalize powersrt to total power - added 26 Apr 94 by S.C.Chiu
c
      ptot0 = rfpow(model)/1.e6             !ptot0 in MW for curray
      powtotsp = 0.0
      do ijrt=1,krt
        powtotsp = powtotsp + powersrt(ijrt,indx_curray(model))
        nnkpar(ijrt)   = nnkparrt(ijrt,indx_curray(model))
        anzinf(ijrt)   = anzinfrt(ijrt,indx_curray(model))
        anzsup(ijrt)   = anzsuprt(ijrt,indx_curray(model))
        nnkpol(ijrt)   = nnkpolrt(ijrt,indx_curray(model))
        anpinf(ijrt)   = anpinfrt(ijrt,indx_curray(model))
        anpsup(ijrt)   = anpsuprt(ijrt,indx_curray(model))
      end do
      if (powtotsp .gt. 0.0 .and. rfpow(model) .gt. 0.0) then
        facrt = rfpow(model) / powtotsp / 1.0e+06
        do ijrt=1,krt
           powers(ijrt)   = powersrt(ijrt,indx_curray(model))*facrt
        end do
      end if
      height = heightrt(indx_curray(model))
      freqcy = freq(model)
      thgril  = thgrilrt(indx_curray(model))
      nthin   = nthinrt(indx_curray(model))
      islofa = islofart(indx_curray(model))
      psi0 =    psi_startrt(indx_curray(model))
      ichois = ichoisrt(indx_curray(model))
      idmpsw = idmpswrt(indx_curray(model))
      maxref = maxrefrt(indx_curray(model))
      nalfa = 1           !single fast ion species of one energy only !!
      ebeamrt = 0.0       ! not used, has meaning only for kalfa = 1    
      atmf = atw_beam     !will be composite for dt beam
      azf  = 1.0          !hard wired beam charge no.
      idrive = 0
      if(irfcur(model) .ne. 0.0)idrive = 1

c
      write (6,'(/a)') ' ---- calling subroutine RAYTRACE (from SOURCE)'
c******    TKM   9/99   Add 'thgrilrt' in argument list
      call raytrace (freqcy,ptot0,nalfa,ebeamrt,atmf,azf,
     .               krt, nthin,idrive,thgril,
     .               height,psi0,maxref,
     .               islofa, nscr, codeid, rmajor, rminor,
     .               btor, totcur, kappa, q(1), q(nj), r, hcap,
     .               nfwsmth, qrfes(1,model), qrfis(1,model),
     .               currfs(1,model), totrtpe, totrtpi, totrtc)
      write (6,'(a/)') ' ---- returned from subroutine RAYTRACE'
c
      do j=1,nj
        qrfes (j,model) = 0.62415064e16 * qrfes(j,model)
        qrfis (j,model) = 0.62415064e16 * qrfis(j,model)
        currfs(j,model) = irfcur(model) * currfs(j,model)
      end do
c
      factor = turnon(time,rfon(model), turnonp(model),
     .    rftime(model),rframp_timeup(model),rframp_timedown(model))
      call addac (qrfes(1,model), qrfe, nj,factor)
C     .            turnon(time,rfon(model), turnonp(model),
C     .    rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (qrfis(1,model), qrfi, nj,factor)
C     .            turnon(time,rfon(model), turnonp(model),
C     .    rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (currfs(1,model), currf, nj,factor)
C     .            turnon(time,rfon(model), turnonc(model),
C     .    rftime(model),rframp_timeup(model),rframp_timedown(model)))

c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c --- end RAYTRACE calculation
c
c
c
c
c     FASTCD - calls Ken Kupfer's FASTCD code
c
 3185 if (istep .eq. 'corr'                      )  go to 2820
      if (istep .eq. 'init' .and. time .le. time0)  go to 3190     ! HSJ
      if (               irfcnt(model) .eq. 0    )  go to 3190
c
c     decide if FASTCD should be called:
c     delrf is the maximum relative change in the electron density
c     and temperature and ion temperature since FASTCD was last called
c     if delrf > relrf, we call FASTWAVE again
c
      call maxrc (ene, enrf(1,model), nj, delrf)
      call maxrc (te , terf(1,model), nj, delte)
      call maxrc (ti , tirf(1,model), nj, delti)
      delrf = MAX (delrf, delte, delti)
      if (delrf .le. relrf)  go to 2820
c
      write (6, '(a, 2f12.8)')  ' delrf, relrf =', delrf, relrf
c
 3190 call copya (ene, enrf(1,model), nj)
      call copya (te , terf(1,model), nj)
      call copya (ti , tirf(1,model), nj)
c
      write (6,'(/a)') ' ---- calling subroutine FASTCD (from SOURCE)'
      call fastcd (codeid, nscr, eqdskin, freq(model), rfpow(model),
     .             nkfcd(model), xntor(1,model), rpant(1,model),
     .             gamloss(model), z(1,1), atw(1), nj, r, ene, te,
     .             zeff, rmajor, hcap, qrfes(1,model), qrfis(1,model),
     .             currfs(1,model), pefcd, pifcd, curfcd)
      write (6,'(a/)') ' ---- returned from subroutine FASTCD'
c
      do j=1,nj
        qrfes (j,model) = 0.62415064e16 * qrfes (j,model)
        qrfis (j,model) = 0.62415064e16 * qrfis (j,model)
        currfs(j,model) = irfcur(model) * currfs(j,model)
      end do
c
      factor =  turnon(time,rfon(model), turnonp(model),
     .  rftime(model),rframp_timeup(model),rframp_timedown(model))
      call addac (qrfes (1,model), qrfe , nj,factor)
c     .            turnon(time,rfon(model), turnonp(model),
c     .  rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (qrfis (1,model), qrfi , nj,factor)
c     .            turnon(time,rfon(model), turnonp(model),
c     .    rftime(model),rframp_timeup(model),rframp_timedown(model)))
      call addac (currfs(1,model), currf, nj,factor)
c     .            turnon(time,rfon(model), turnonc(model),
c     .   rftime(model), rframp_timeup(model),rframp_timedown(model)))
c

c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c --- end FASTCD calculation
c


c     GENRAY model (uses separate all-frequencies GENRAY 
c     3d raytracing code,  Bob Harvey, Jan 25, 2005)
c
 3195 if (istep .eq. 'corr')  go to 2820
      !prevent multiple calls on startup
      if (istep .eq. 'init' .and. time .le. time0 
     .    .and. irfcnt(model) .eq. 0)go to 4000

      if (irfcnt(model) .eq. 0)  go to 4000

c
c     decide if GENRAY should be called:
c     delrf is the maximum relative change in the electron
c     density and temperature since GENRAY was last called.
c     if  delrf > relrf, we call GENRAY again
c
      call maxrc (ene, enrf(1,model), nj, delrf)
      call maxrc (te , terf(1,model), nj, delte)
      call maxrc (ti , tirf(1,model), nj, delti)
      delrf = MAX (delrf, delte, delti)
      if (delrf .le. relrf)  go to 2820
c
      write (6, '(a, 2f12.8)')  'genray:delrf, relrf =', delrf, relrf
c
c --- call subroutine call_genray
c
 4000 call copya (ene, enrf(1,model), nj)
      call copya (te , terf(1,model), nj)
      call copya (ti , tirf(1,model), nj)

      rfmodel_power_e(model) =0.0  !we will recalculate the power HSJ
      rfmodel_cd(model) =0.0       !ditto for currrent drive
      rfmodel_power_i(model) =0.0
c
      write(6,'(/ a)') '-- calling subroutine call_genray (from SOURCE)'
c
      call call_genray ( model,qrfes(1,model),qrfis(1,model),
     .                   currfs(1,model),totgrpe,totgrpi,totgrc,totgrp)

      write (6,'(a /)') '-- returned from subroutine call_genray'
c

c     Scale output to rfpower(model) using input power, totgrp,
c     that was used by genray (from its input file).
      powfac=rfpow(model)/totgrp
      do j=1,nj
        qrfes (j,model) = powfac * 0.62415064e16 * qrfes (j,model)
        qrfis (j,model) = powfac * 0.62415064e16 * qrfis (j,model)
        currfs(j,model) = powfac * irfcur(model) * currfs(j,model)
      end do
c
      factor = turnon(time,rfon(model), turnonp(model),
     .     rftime(model),rframp_timeup(model),rframp_timedown(model))
c      print *,'factor =',factor
      call addac (qrfes (1,model), qrfe , nj,factor)
      call addac (qrfis (1,model), qrfi , nj,factor)
      call addac (currfs(1,model), currf, nj,factor)
c
c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
c      print *,'rfmodel_power_e(model)= ',rfmodel_power_e(model)
c      print *,'rfmodel_power_i(model)= ',rfmodel_power_i(model)
c      print *,'rfmodel_cd(model)= ',rfmodel_cd(model)
      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c
      write (6,'(a /)') '-- returned from subroutine call_genray'
c
      do j=1,nj
        qrfes (j,model) = 0.62415064e16 * qrfes (j,model)
        qrfis (j,model) = 0.62415064e16 * qrfis (j,model)
        currfs(j,model) = irfcur(model) * currfs(j,model)
      end do
c
         factor = turnon(time,rfon(model), turnonp(model),
     .     rftime(model),rframp_timeup(model),rframp_timedown(model))
c         print *,'factor =',factor
c      write(940,fmt='("factor =",1pe12.4)')factor
      call addac (qrfes (1,model), qrfe , nj,factor)
      call addac (qrfis (1,model), qrfi , nj,factor)
c      write(940,FMT='("currfs(1,model) = ",(5(1pe12.4,x)))')
c     .     currfs(1:10,model)
      call addac (currfs(1,model), currf, nj,factor)
c      write(940,FMT='("currf  = ",(5(1pe12.4,x)))')
c     .     currf(1:10)
c
c     load rfmodel_power_e(model),rfmodel_power_i(model),rfmodel_cd(model)
      call trapv (r,qrfes(1,model),hcap,nj,rfmodel_power_e(model))
      rfmodel_power_e(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_e(model)/0.62415064e16  !watts
      call trapv (r,qrfis(1,model),hcap,nj,rfmodel_power_i(model))
      rfmodel_power_i(model) = 4.0 * pi**2 * rmajor*factor*
     .                         rfmodel_power_i(model)/0.62415064e16  !watts
      call trapv (r,currfs(1,model),hcap,nj,rfmodel_cd(model))
      rfmodel_cd(model)= 2.*pi*rfmodel_cd(model)*factor
c      print *,'rfmodel_power_e(model)= ',rfmodel_power_e(model)
c      print *,'rfmodel_power_i(model)= ',rfmodel_power_i(model)
c      print *,'rfmodel_cd(model)= ',rfmodel_cd(model)
      irfcnt (model) = irfcnt (model) + 1
      irfcalc(model) = irfcalc(model) + 1
      go to 2661
c
c --- end GENRAY calculation
c



c
c     restore power deposition profiles from previous RF calculation
c
 2820 if(irfmodel(model) .eq. 'ech' .and. ech_input .ne. 'none')then
          factor =1._DP 
      else
          factor = turnon(time,rfon(model), turnonp(model),
     .     rftime(model),rframp_timeup(model),rframp_timedown(model))
      endif
      IF(ech_input .ne. 'none')factor = 1._DP
      call addac (qrfes(1,model), qrfe , nj,factor)

      call addac (qrfis(1,model), qrfi , nj,factor)



       call addac (currfs(1,model), currf, nj,factor)

 
c
      go to 2661
c
c     add some external RF heating and/or current drive
c

 2850 call get_external_rfcur
      call get_external_rfqe
      call get_external_rfqi
      if(fusionvb .gt. 0)print *,'in source,end rf heat + cur drive'

c------------------------------------------------------------------
c     for testing xptor fix the source for all times at the
c     value given in the iterdb_xptor file:
c------------------------------------------------------------------
 2852 if(test_xptor .eq. 1 .and. 
     .      allocated(qrfe_fixed) )then
         qrfe(:) = qrfe_fixed(:)
         qrfi(:) = qrfi_fixed(:)
      endif
      


c
c ----------------------------------------------------------------------
c          OHMIC HEATING AND CURRENT DRIVE
c ----------------------------------------------------------------------
         call ohacd(irfc)







c          CALCULATE NET SOURCE TERMS
c
c ----------------------------------------------------------------------
c calculate net particle sources (1/cm**3-s)
c ----------------------------------------------------------------------
c
       IEREXIT =0                       !HSJTEMP
      if(fusionvb .gt. 0)print *,'in source,net particles'
      do j=1,nj
        do 3860 k=1,nion
 3860   s(k,j) = 0.0
        if (ifus .eq. 0)  go to 3892
        if (ifus .eq. 2)  go to 3880
        if (ifus .lt. 0) then
c
c          single fluid fast ion dt mixture with separate d and t
c          thermal fluids:
c
           jk=3*nbeams+1
           if(use_nubeam) jk = SIZE(beam_thermaldth_tf(:,:),DIM= 2)
c
c          for  t_f(d_th,n)he4:
c
           s(id,j) = s(id,j) - (stfus(j) + beam_thermaldth_tf(j,jk))
c
c          for   d_f(t_th,n)he4
c
           s(it,j) = s(it,j) - (stfus(j) + beam_thermaltth_df(j,jk))
           go to 3890
        end if
c
c       ifus=1,dt mixture
c
        if (fd .eq. fdbeam) then  ! must have fd = fdbeam here ... HSJ
          s(idt,j) = s(idt,j) - 2.0*stfus(j) - 2.0*sbfus(j)
        else                      ! ignore beam part
          s(idt,j) = s(idt,j) - 2.0*stfus(j)
        end if
c
        go to 3890
c
c       ifus=2,d,t,separate,(one or the other or both)
c       which means beam is either d or t
c       but not a mixture of the two (fdbeam=1.0 for d beam
c       or fdbeam=0.0 for t beam HSJ) :
c
*3880   s(id,j)  = s(id,j) - stfus(j) - sbfus(j) ! changed 12/5/95 HSJ
*       s(it,j)  = s(it,j) - stfus(j) - sbfus(j)
c
 3880   kn = 3*nbeams + 1
        if(use_nubeam) kn  = SIZE(beam_thermaldth_tf(:,:),DIM= 2)
        if (id .ne. 0)         !thermal species is d
     .  s(id,j)  = s(id,j) - stfus(j) - beam_thermaldth_tf(j,kn) 

c
c       above  sbfus = tf(dth,n)he4, df(dth,n)he3 neglected ... HSJ
c
        if (it .ne. 0)
     . s(it,j)  = s(it,j) - stfus(j) - beam_thermaltth_df(j,kn)
c
c       above  sbfus(j) = df(tth,n)he4, tf(tth,2n)he4 neglected ... HSJ
c
 3890   if (ihe .eq. 0)  go to 3892
        s(ihe  ,j) = s(ihe  ,j) + sfus (j)
c
 3892   do 3895 i=1,2



 3895   s(i,j)     = s(i,j) + srecom(j,i) + sion(j,i)
     .             + scx(j,i) + sbcx(j,i)
        if (ibion .gt. 0) then
               s(ibion,j) = s(ibion,j) + sbeam(j)
        else                ! we have beam 'dt' with thermal 'd' and 't'
               s(id,j)= sbeam(j)*fdbeam     +s(id,j)
               s(it,j)= sbeam(j)*(1.-fdbeam)+s(it,j)
        end if
      end do

c       print *,'ibion,ifus,IT,IHE  =',ibion,ifus ,IT,IHE             !HSJTEMP
c       IF( IEREXIT .EQ.1)call stop('source ibion',1)
c
c ----------------------------------------------------------------------
c calculate net energy sources (keV/cm**3-s)
c energy in electron rotation is given to the ions
c ----------------------------------------------------------------------
c
      if(fusionvb .gt. 0)print *,'in source,net energy'
      do 3910 j=1,nj
        omegale(j) = iangrot*kevperg*angrcple*sprbeame(j)*angrot(j)
        s(nk-2-iangrot,j) = - qexch(j) + qohm(j) - qione(j) - qrad(j)
     . + qbeame(j) + qrfe(j) + qfuse(j) - omegale(j) 
        s(nk-1-iangrot,j) =   qexch(j) + qioni(j) - qcx(j) + qbeami(j)
     .                      + qfusi(j) + qrfi(j) + omegale(j)
     .                      + sprcxe(j)+sprcxree(j)+spreimpe(j)

        if (w2mix .lt. 0.0)  s(nk-2-iangrot,j) =
     .                       s(nk-2-iangrot,j) + qsawe(j)
        if (w3mix .lt. 0.0)  s(nk-1-iangrot,j) =
     .                       s(nk-1-iangrot,j) + qsawi(j)
c        print *,'dtt,beamon(1) =',dtt,beamon(1)
        if ( dtt .eq. 0.0   )  go to 3910
c       if (time .lt. beamon(1))  go to 3908
        if (time .lt. beamon(1) .and. .not. use_nubeam)  go to 3910    ! HSJ 03/03/05
        if(use_nubeam .and. (time  .le. nubeam_on -
     .       beam_data%beam_power_rise_time - time_tol) ) go to 3910
c
c       the stored energy density of electrons increases
c       directly due to fast ion density changes.  It is
c       assumed that the electrons appear with the average
c       electron thermal energy.
c       This term enters with
c       a minus sign on the source side of the equation:       HSJ
c
        enbs(j) = 0.0
        do 3905 ib=1,nbeams
        do 3905 ie=1,3
 3905   enbs(j) =  enbs(j) + enbsav(j,ie,ib)
 3908   enfast  = (enbeam(j)-enbs(j)) + 2.0*(enalp(j)-enasav(j))
        s(nk-2-iangrot,j) = s(nk-2-iangrot,j) -
     .                                   1.5*te(j)*enfast/dtt
c        if(j .eq. 1)
c     .   write(*,FMT='(a,4(1pe12.4,x)')
c     .    'source,enfast,enbs(1),enbeam(1),enp(1,1) storqueb  =',
c     .   enfast,enbs(1),enbeam(j),en(1,1),storqueb(6)

c
 3910 continue







c ----------------------------------------------------------------------
c calculate effective source (G/cm-s) in Faraday's law due to
c   beam-driven and rf-driven current;
c   note: current converted back to statamp/cm**2
c ----------------------------------------------------------------------
c
      kfar = nk - iangrot
      do j=1,nj
        scurdri(j) = 0.0
        s(kfar, j) = 0.0
      end do
c
      if (ibcur .eq. 0 .and. irfc .eq. 0)  go to 3922
      do j=1,nj
        dum(j) = cee * hcap(j) * etap(j) * (2.99792458e9 * curdri(j))
      end do
      do j=2,nj-1
c        s(kfar,j) = -derv2(r(j-1),r(j),r(j+1),dum(j-1),dum(j),dum(j+1))
c     .            / (hcap(j)*r(j))
         s(kfar,j) = -(dum(j+1)-dum(j-1))/(r(j+1)-r(j-1))
     .            / (hcap(j)*r(j))
      end do
      s(kfar,1) = -(1.0/hcap(1))*2.0*(dum(3)*r(2)-dum(2)*r(3)
     .           +  dum(1)*(r(3)-r(2)))/((r(3)-r(2))*r(3)*r(2))
      !at r =0 the gradient of the driven current should be zero
      !hence above line could be commented out !! HSJ 4/30/02
      s(kfar,nj) = -dernj(r(nj-2),r(nj-1),r(nj),dum(nj-2),
     .              dum(nj-1),dum(nj))/(hcap(nj)*r(nj))
      do j=1,nj
        scurdri(j) = s(kfar,j)    ! save for output
      end do
c
 3922 if (jhirsh .eq. 95 .or. jhirsh .eq.  96  .or.
     .    jhirsh .eq. 99 .or. jhirsh .eq. 100) then
c       the bootstrap current appears as a source term for these
c       models. For some models (jhirsh =2,89,110) this is done
c       in the original manner by incorporaing the contributions
c       into the diffusion matrixdirectly and it doesnt show up here.  HSJ
c  
        do j=1,nj
          dum(j) = cee * hcap(j) * etap(j) * (2.99792458e9 * curboot(j))
        end do
        do j=2,nj-1
          s(kfar,j)= -derv2(r(j-1),r(j),r(j+1),dum(j-1),dum(j),dum(j+1))
     .               /(hcap(j)*r(j)) + s(kfar,j)
        end do
        s(kfar,1) = -(1.0/hcap(1))*2.0*(dum(3)*r(2)-dum(2)*r(3)
     .             + dum(1)*(r(3)-r(2)))/((r(3)-r(2))*r(3)*r(2))
     .             + s(kfar,1)
      !at r =0 the gradient of the bootstrap  current should be zero
      !hence above line could be  commented out !! HSJ 4/30/02
        s(kfar,nj) = -dernj(r(nj-2),r(nj-1),r(nj),dum(nj-2),
     .                dum(nj-1),dum(nj))/(hcap(nj)*r(nj))
     .             + s(kfar,nj)
      end if
c
c add source term to Faraday's law to account
c for fast ion (and alpha) density gradient,
c so that the bootstrap depends on electron density gradient
c
c at mesh centers
c
 3950 do j=1,nj-1
        hcapa   = 0.5 * (hcap(j)+hcap(j+1))
        za1     = 0.5 * (z(j,1)+z(j+1,1))
        denfast = (enbeam(j+1)-enbeam(j)+2.0*enalp(j+1)-2.0*enalp(j))
     .          / (r(j+1)-r(j))
c
c if the Hirshman calculation of the bootstrap current is performed
c use the specific coefficient
c
        if (jhirsh .ne. 0) then
          dcoef = dfast(j) + dfion(j)
        else
          dcoef = d(kfar,1,j)/za1
        end if
        dum(j) = hcapa*ra(j)*dcoef*denfast
      end do
c
c add to source term
c   at edge, use slope at nj-1
c
      do j=2,nj-1
         s(kfar,j) = s(kfar,j) + (dum(j)-dum(j-1))/(ra(j)-ra(j-1))
     .               /(hcap(j)*r(j))
      end do
c
      s(kfar,nj) = s(kfar,nj)+(dum(nj-1)-dum(nj-2))/(ra(nj-1)-ra(nj-2))
     .                  /(hcap(nj)*r(nj))
      s(kfar,1) = s(kfar,1)+2.0*(d(kfar,1,1)                   !HSJ 4/30/02could be  commented out
     .    -(d(kfar,1,2)-d(kfar,1,1))*r(2)/r(3))/z(1,1)
     .    *2.0*(enbeam(3)*r(2)-enbeam(2)*r(3)+enbeam(1)*(r(3)-r(2))
     .    +2.0*enalp(3)*r(2)-2.0*enalp(2)*r(3)+2.0*enalp(1)*(r(3)-r(2)))
     .           /((r(3)-r(2))*r(3)*r(2))
      do j=1,nj
        scurfast(j) = s(kfar,j)-scurdri(j)
      end do
c
c end modified section 10/89
c
c ----------------------------------------------------------------------
c  calculate the net energy gain due to thermal fusion and the net
c  energy loss.  if the thermal gain exceeds the losses by a certain
c  fraction (tfusbb), set ibeam = 2  this will indicate that fusion
c  has been attained, and the neutral beams will be automatically
c  turned off (unless tfusbb = 0) at the next time step.
c  don't bother with this calculation if:
c    1)  this is a corrector step (dtt = dt), or
c    2)  fusion is not being done (ifus = 0) , or
c    3)  neutral beams are presently off (ibeam = -1), or
c    4)  there is no automatic beam cutoff (tfusbb = 0)
c ----------------------------------------------------------------------
c
      if (dtt .eq. dt .or. ifus .eq. 0)  go to 4030
      const = 2.0/r(nj)**2
      k = nion + 1
      call trap1(r, qione, const, nj, qie)
      call trap1(r, qrad , const, nj, qr )
      call divflx(flux, fluxb, hcap, r, ra, drr, k, nj, kk, dflux)
      call trap1(r, dflux, const, nj, dfae)
      k = nion + 2
      call trap1(r, qioni, const, nj, qii)
      call trap1(r, qcx  , const, nj, qc )
      call divflx(flux, fluxb, hcap, r, ra, drr, k, nj, kk, dflux)
      call trap1(r, dflux, const, nj, dfai)
      qloss = qie + qr + dfae + qii + qc + dfai
      call trap1(r, qtfuse, const, nj, qtfe)
      call trap1(r, qtfusi, const, nj, qtfi)
      qtfustot = qtfe + qtfi
****  if (tfusbb .eq. 0.0 .and. tfusrf .eq. 0.0)  go to 4020
      if (tfusbb .eq. 0.0                      )  go to 4020
      if (qtfustot .gt. (1.0 + tfusbb)*qloss) ibeam = -1
 4020 if (ignflg .eq. -1)  go to 4030
      ignflg = 0
      if (qtfustot .gt. qloss) ignflg = 1
 4030 continue
c
c --- angular momentum source term:
c --- beam must be on (ibeam = 3) for prompt spbolt torque ! HSJ
c
c      if (iangrot .ne. 0) then                            ! HSJ
         do j=1,nj
           if (ibeam .ne. 3 .or. use_nubeam)  spbolt(j) = 0.0
c           was storqueb determined in nubeam ?? :
           IF(.not.use_nubeam )
     .              storqueb(j) = sprbeame(j)+sprbeami(j)+
     .                                (1-nbeamtcx)*ssprcxl(j)
           storque (j) = storqueb(j)+spbolt(j) +smagtorque(j)
     .                                         +sntvtorque(j)      
           if (iangrot .ne. 0) then
             s(nk,j)    = spreimpt(j)+sprcx(j)+sprcxre(j)+storque(j)
             storque(j) = s(nk,j)
           end if
         end do
c      end if
c
c ----------------------------------------------------------------------
c calculate source terms which arise from special treatment
c   of certain time derivatives in 2-d code
c ----------------------------------------------------------------------
c
      do j=1,nj
        qe2d(j)    = 0.0
        qi2d(j)    = 0.0
        fday2d1(j) = 0.0    ! 2d source terms for Faraday's law
        fday2d2(j) = 0.0
        fday2d3(j) = 0.0    ! see subroutine IMPSRC for this one
        spr2d(j)   = 0.0
        do k=1,nion
          s2d(j,k) = 0.0
        end do
      end do
c
      if (codeid .eq. 'onedee'  .and.
     .   (nbctim .le. 1 .or. elong(2) .eq. 0.0))  go to 4231
      do j=1,nj
c
c ----------------------------------------------------------------------
c   calculate various time derivatives
c   dscrip is speed of normalized rho surface relative to mag. axis
c   it is saved for output.
c ----------------------------------------------------------------------
c
           dlnhdt = dhdt(j) / hcap(j) * dlnhdtmult
c
           if (include_adaptive .eq. 0) then
                 dnum      = 1.0 / (ascrip+2.0*bscrip*r(j))
                 dscrip(j) = -r(j)*(adot+bdot*r(j))*dnum
                 dlnrdt    = -(adot+bdot*r(j))*dnum*r(j)
                 dddrho    = -(adot+2.0*bdot*r(j))*dnum
     .                     + 2.0*r(j)*bscrip*(adot+bdot*r(j))*dnum*dnum
c                            (d/dr)dscrip
            else
                 dscrip(j)=drhodt_adaptive(j)
                 if (j .gt. 1) then
                        dlnrdt   = dscrip(j)
                        if (j .lt. nj) then
                            dddrho = derv2(r(j-1),r(j),r(j+1),
     .                             dscrip(j-1),dscrip(j),dscrip(j+1))
                        else
                            dddrho = dernj(r(nj-2),r(nj-1),r(nj),
     .                             dscrip(nj-2),dscrip(nj-1),dscrip(nj))
                        end if
                 else
                        dlnrdt =   dscrip(1)
                        dddrho =   der1(r(1),r(2),r(3),
     .                             dscrip(1),dscrip(2),dscrip(3))
                 end if
            end if
            dlnrdt = dlnrdt * dlnrdtmult
            drfght = r(j)*fcap(j)*gcap(j)*dhdt(j)
     .           +   r(j)*fcap(j)*dgdt(j)*hcap(j)
     .           +   r(j)*dfdt(j)*gcap(j)*hcap(j)
     .           + dlnrdt*fcap(j)*gcap(j)*hcap(j)
c
c ----------------------------------------------------------------------
c next calculate spatial derivatives which occur in these source terms
c ----------------------------------------------------------------------
c
           if (j .eq. 1) then
                 bpc     = 0.0
                 dlnhdr  = 0.0   ! not used for j = 1
                 dtedr   = 0.0
                 dtidr   = 0.0
                 drbpdr  = 0.0
                 dangrdr = 0.0
                 dr2idr  = 0.0
c
           else if (j .eq. nj) then
                 bpc    = rbp(j)/(fcap(j)*gcap(j)*hcap(j)*r(j))
                 dhdr   = derv2(r(j-2),r(j),r(j-1),hcap(j-2),
     .                                     hcap(j),hcap(j-1))
                 dlnhdr = dhdr/hcap(j) * dlnhdrmult
                 dtedr  = derv2(r(j-2),r(j),r(j-1),te(j-2),
     .                                       te(j),te(j-1))
                 dtidr  = derv2(r(j-2),r(j),r(j-1),ti(j-2),
     .                                       ti(j),ti(j-1))
                 rbp1 = rbp(j-2)/(fcap(j-2)*gcap(j-2)*hcap(j-2))
                 rbp2 = rbp(j)/(fcap(j)*gcap(j)*hcap(j))
                 rbp3 = rbp(j-1)/(fcap(j-1)*gcap(j-1)*hcap(j-1))
                 drbpdr = derv2(r(j-2),r(j),r(j-1),rbp1,rbp2,rbp3)
                 if (iangrot .ne. 0) then
                     dangrdr = derv2(r(j-2),r(j),r(j-1),
     .                          angrot(j-2),angrot(j),angrot(j-1))
                     dr2idr = derv2(r(j-2),r(j),r(j-1),r2capi(j-2),
     .                           r2capi(j),r2capi(j-1))
                 end if
           else
                 bpc = rbp(j)/(fcap(j)*gcap(j)*hcap(j)*r(j))
                 dhdr = derv2(r(j-1),r(j),r(j+1),hcap(j-1),
     .                                          hcap(j),hcap(j+1))
                 dlnhdr = dhdr/hcap(j)
                 dtedr = derv2(r(j-1),r(j),r(j+1),te(j-1),
     .                                              te(j),te(j+1))
                 dtidr = derv2(r(j-1),r(j),r(j+1),ti(j-1),
     .                                               ti(j),ti(j+1))
                 rbp1 = rbp(j-1)/(fcap(j-1)*gcap(j-1)*hcap(j-1))
                 rbp2 = rbp(j)/(fcap(j)*gcap(j)*hcap(j))
                 rbp3 = rbp(j+1)/(fcap(j+1)*gcap(j+1)*hcap(j+1))
                 drbpdr = derv2(r(j-1),r(j),r(j+1),rbp1,rbp2,rbp3)
                 if (iangrot .ne. 0) then
                      dangrdr = derv2(r(j-1),r(j),r(j+1),angrot(j-1),
     .                                         angrot(j),angrot(j+1))
                      dr2idr = derv2(r(j-1),r(j),r(j+1),r2capi(j-1),
     .                                          r2capi(j),r2capi(j+1))
                 end if
c
            end if
c
c ----------------------------------------------------------------------
c  evaluate density derivatives and density source terms
c ----------------------------------------------------------------------
c


            sumangr = 0.0
            sumangr1 = 0.0
            do k=1,nion
               if (j .eq. 1 )  go to 4090
               if (j .eq. nj)  go to 4200
               dendr(k) = derv2(r(j-1),r(j),r(j+1),en(j-1,k),
     .                                          en(j,k),en(j+1,k))
               go to 4210
c
 4090          dendr(k) = 0.0
               go to 4210
c
 4200          dendr(k) = derv2(r(j-2),r(j),r(j-1),en(j-2,k),
     .                                          en(j,k),en(j-1,k))
c
 4210          s2d(j,k) = -en(j,k)*dlnhdt
     .                           +dlnrdt*(en(j,k)*dlnhdr+dendr(k))
               if (iangrot .ne. 0) then
                   xmassi = atw(k)*xmassp
                   sumangr = sumangr+en(j,k)*xmassi
                   sumangr1 = sumangr1+xmassi*dendr(k)
               end if
            end do
c
c --- source term for angular momentum
c
            if (iangrot .ne. 0)
     .         spr2d(j) = -angrot(j)*sumangr*(dr2idt(j)+
     .                    dlnhdt*r2capi(j))
     .                    +dlnrdt*(angrot(j)*r2capi(j)*dlnhdr*sumangr
     .                    +r2capi(j)*sumangr*dangrdr
     .                    +angrot(j)*dr2idr*sumangr
     .                    +angrot(j)*r2capi(j)*sumangr1)
c
c ----------------------------------------------------------------------
c  now evaluate source terms for te,ti and rbp equations
c ----------------------------------------------------------------------
c
           sume1 = 0.0
           sume2 = 0.0
           sumi1 = 0.0
           sumi2 = 0.0
           do k=1,nion
               sume1 = sume1 + z(j,k)*dendr(k)
               sume2 = sume2 + en(j,k)*dzdte(j,k)
               sumi1 = sumi1 + en(j,k)
               sumi2 = sumi2 + dendr(k)
           end do
c
           qe2d(j) = -five_halfs_te * ene(j)*te(j)*dlnhdt + dlnrdt*
     .          (five_halfs_te * ene(j)*te(j)*dlnhdr + 1.5*te(j)*sume1
     .        +  1.5 * (ene(j) + te(j)*sume2)*dtedr)
c           qe2d(j) = qe2d(j) * qe2dmult 
c
           qi2d(j) = -five_halfs_ti*sumi1*ti(j)*dlnhdt + dlnrdt*
     .          (five_halfs_ti*sumi1*ti(j)*dlnhdr + 1.5*ti(j)*sumi2
     .        +  1.5*sumi1*dtidr)
           qi2d(j) = qi2d(j) * qi2dmult
           if (iangrot .ne. 0) then
              qi2d(j) = qi2d(j)-0.5 * kevperg*angrm2d(1)*sumangr
     .                  *r2capi(j) * angrot(j)**2*dlnhdt
              qi2d(j) = qi2d(j) + angrm2d(2) * 0.5 * kevperg*
     .                  angrot(j)*(spr2d(j) + angrot(j)*
     .                  (dr2idt(j) + r2capi(j)*dlnhdt)*sumangr)
              qi2d(j) = qi2d(j) + angrm2d(2) * 0.5 * kevperg*
     .                  r2capi(j)*dlnrdt * angrot(j)*dangrdr*sumangr
              qi2d(j) = qi2d(j)-angrm2d(3) * 0.5 * kevperg*angrot(j)**2
     .                  *sumangr * dr2idt(j)
              spr2d(j) = spr2d(j)*angrm2d(4)
           end if

c
c ----------------------------------------------------------------------
c  source term for Faraday's law (not needed for j = 1)
c ----------------------------------------------------------------------
c
           if (j .ne. 1) then
                fday2d1(j) =  bpc*drfght/(fcap(j)*gcap(j)*
     .                                        (r(j)*hcap(j))**2)
                fday2d2(j) = -bpc*dddrho/(hcap(j)*r(j))
           end if
c
      end do

c
c     add 2d source terms to source array; get these into siadd someday...
c
 4231 do 4240 j=1,nj
      sum2d(j) = 0.0
      do 4240 k=1,nion
 4240 sum2d(j) = sum2d(j) + s2d(j,k)
      do 4260 k=1,nion
      do 4260 j=1,nj
 4260 s(k,j) = s(k,j) + s2d(j,k)
c
      do j=1,nj
        s(nk-2-iangrot,j) = s(nk-2-iangrot,j) + qe2d(j)
        s(nk-1-iangrot,j) = s(nk-1-iangrot,j) + qi2d(j)
        s(nk  -iangrot,j) = s(nk  -iangrot,j) + fday2d1(j)*f2d1mult
     .                                        + fday2d2(j)*f2d2mult
c
c ---   add 2d source term to angular momentum sources
c
        if (iangrot .ne. 0) then
          s(nk,j)    = s(nk,j) + spr2d(j)
          storque(j) = s(nk,j)
        end if
      end do
c
c     integrate sources of added particles
c     snadd = number of ions added this step
c
      sedge_tot = 0.0 !jmp.den start
      do i=1,2

        call trapvp (r,srecom(1,i),hcap,ni_index,nj,sedge)
        sedge_tot = sedge_tot + volfac*sedge
        call trapvp (r,sion(1,i),hcap,ni_index,nj,sedge)
        sedge_tot = sedge_tot + volfac*sedge
        call trapvp (r,scx(1,i),hcap,ni_index,nj,sedge)
        sedge_tot = sedge_tot + volfac*sedge
        call trapvp (r,sbcx(1,i),hcap,ni_index,nj,sedge)
        sedge_tot = sedge_tot + volfac*sedge
        flux_out = sedge_tot + sfarea * fluxb2(i)
        snadd(i) =  snadd(i) + sfarea * fluxb(i) - flux_out
      end do !jmp.den start 

      do i=1,2
        sngas(i) = sngas(i) * dtt
        snadd(i) = snadd(i) * dtt
      end do

 
      if(fusionvb .gt. 0)print *,'leaving source'

      return
c
      end


      subroutine source_mod_stab(flag,njin,xke,xki,xkw)
c ----------------------------------------------------------------
c stabilizing flux used to stabilize turbulent transport
c models is treated implicitely in diffuse and is subtracted out
c explicitely here
c ---------------------------------------------------------------
     
      USE  nrtype,             ONLY  : DP,I4B
      USE  param
      USE  tcoef,              ONLY  : d,dbar,comp_term
      USE  geom,               ONLY  : hcap
      USe  mesh,               ONLY  : r,ra,dr
      USE numbrs,              ONLY  : nj,nion
      USE soln,                ONLY  : u,usave,ene,en
      USE sourc,               ONLY  : s 
      USE solcon_gcnmp,        ONLY  : dbar_stab
      USE common_constants,    ONLY : zeroc
      IMPLICIT  none
      INTEGER(I4B) j,i,flag,njin
      REAL(DP) hri,hrp,hrm,dup,dum,pert,dconst,
     .       enasum,enea,xke,xki,xkw
     




       IF(flag == 1)THEN
            dconst = dbar_stab
            i = nion +1
            dbar(i,njin) = dconst * xke 
            i = nion + 2
            dbar(i,njin) = dconst*xki
            i= nion+4
            dbar(i,njin) = dconst*xkw
      ELSEIF(flag == -1)THEN
            comp_term(:) = zeroc
            j = njin
            hri = hcap(j)*r(j)*(ra(j)-ra(j-1))
            hrp = (hcap(j+1)*r(j+1)+hcap(j)*r(j))*0.5D0 
            hrm = (hcap(j)*r(j)+hcap(j-1)*r(j-1))*0.5D0
            i =nion+1
                  dup           = (usave(i,j+1)- usave(i,j))/dr(j) 
                  dum           = (usave(i,j)  - usave(i,j-1))/dr(j-1)
                  comp_term(i)  = (dup*dbar(i,j)*hrp  - 
     .                                    dum*dbar(i,j-1)*hrm)/hri
            i =nion+2
                  dup           = (usave(i,j+1)- usave(i,j))/dr(j) 
                  dum           = (usave(i,j)  - usave(i,j-1))/dr(j-1)
                  comp_term(i)  = (dup*dbar(i,j)*hrp  - 
     .                                    dum*dbar(i,j-1)*hrm)/hri
            i =nion+4
                  dup           = (usave(i,j+1)- usave(i,j))/dr(j) 
                  dum           = (usave(i,j)  - usave(i,j-1))/dr(j-1)
                  comp_term(i)  = (dup*dbar(i,j)*hrp  - 
     .                                    dum*dbar(i,j-1)*hrm)/hri

      ENDIF

 
     
      RETURN

      END SUBROUTINE source_mod_stab 



      subroutine spreadqtfus (qtfus, qtfsmth, r, hcap, rmajor, nj,
     .                        xdebg, fact)
c
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c ----------------------------------------------------------------------
c --- to be replaced with a real routine in the future - HSJ
c ----------------------------------------------------------------------
c
      dimension  qtfus(*), hcap(*), qtfsmth(*), r(*), fact(*)
c
      fpisq = 39.4784176045
c
c --- first get the total thermal fusion power
c
      do j=1,nj
        fact(j) = fpisq*rmajor*hcap(j)
      end do
      call trapv (r,qtfus,fact,nj,qtot)
c
c --- now smooth qtfus
c
      call copya (qtfus,qtfsmth,nj)
      nqtfs = ABS (xdebg)
      do j=nqtfs+1,nj-nqtfs
        qsum = 0.0
        do k=j-nqtfs,j+nqtfs
          qsum = qsum+qtfsmth(k)
        end do
        qtfsmth(j) = qsum/(2*nqtfs+1)
      end do
c
c --- get fusion power from smoothed qtfus
c
      call trapv (r, qtfsmth, fact, nj, qsmthtot)
c
c --- normalize smoothed power to original power
c
      if (qsmthtot .ne. 0.0) then
        do j=1,nj
          qtfus(j) = qtfsmth(j)*qtot/qsmthtot
        end do
      end if
c
      return
c
      end

      subroutine testsol (k, ndum)
c
      USE param
      USE io 
      USE solcon
      USE soln
      USE numbrs
      USE mesh
      USE sourc
      USE geom
      USE flags
      USE tcoef
      USE bd_condtn,only : bctime,ub,fluxb,
     .    ub_save,ub_rho_edge,bctime_zone
      USE flx
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c      include 'param.i'
c      include 'flags.i'
c      include 'flx.i'
c      include 'bcon.i'
c      include 'geom.i'
c      include 'mesh.i'
c      include 'numbrs.i'
c      include 'solcon.i'
c      include 'soln.i'
c      include 'sourc.i'
      include 'storage.i'
c      include 'tcoef.i'
c      include 'io.i'
c
      dimension    dudt_lcl(kj), dflux(kj), ss(kj), swork(kj),
     .             srcint(kj), dudr_lcl(kk,kj)
      equivalence (dudt_lcl(1),xdum(1))
      equivalence (dflux(1),ydum(1))
      equivalence (ss(1),zdum(1))
      equivalence (swork(1),vdum(1))
      equivalence (srcint(1),wdum(1))
c
      ncalc = 0
c
      if (ncalc .eq. 0) then
      onemt = 1.0 - theta
      do 130 j=1,nj-1
      do 120 kl=1,nk                 ! nkl = nprim+nimp+3+iangrot
c
c     for impurities itran(k) is set to zero in cray101.f
c     itran(k) = 0 for analysis mode dependent variables
c
      du        = theta*(u(kl,j+1)-u(kl,j))
     .          + onemt*(usave(kl,j+1)-usave(kl,j))
      dudr_lcl(kl,j) = du/dr(j)                   ! at time point theta
c
 120  continue                        ! get all gradients first HSJ
      do kl=1,nk                      ! now apply these new gradientsa
c
         if (itran(kl) .eq. 1) then   ! see below for analysis mode
           flux(kl,j) = 0.0
           do i=1,nk
             flux(kl,j) = flux(kl,j) -
     .          d(kl,i,j) * dudr_lcl(i,j) ! flux is on half grid
           end do
           if (kl .le. nprim) then                ! HSJ 2/14/96
               ena=0.5*(theta*(u(kl,j+1)+u(kl,j))
     .                   +onemt*(usave(kl,j+1)+usave(kl,j)))
               flux(kl,j)=flux(kl,j) +ena*vpinch(j)
           end if
         end if
      end do
  130 continue
      end if
c
        call divflx (flux, fluxb, hcap, r, ra, drr, k, nj, kk, dflux)
c
      do j=1,nj
        dudt_lcl(j) = 0.0
        ss(j) = s(k,j)
        if (   dtt .ne. 0.0) then
          dudt_lcl(j) = (u(k,j)-usave(k,j))/dtt
        else
          dudt_lcl(j) = ss(j)-dflux(j)            ! HSJ 1/13/96
        end if
        if (  itimav .eq. 1)  dudt_lcl(j) = (uav(k,j)-uav0(k,j))*dtsumi
        if (  itimav .eq. 1)        ss(j) =  ss(j) + ssaw(j,k)
        swork(j) = ss(j) - dudt_lcl(j)            ! div flux
        if (itran(k) .eq. 0)  dflux(j) = swork(j) ! analysis mode..
c                                                 ..get dflux this way
      end do
c
      dflux(nj) = ss(nj) - dudt_lcl(nj)
c
c     srcint(j)=volume integral of(div flux)= #/sec ions leaving region j
c
      call trap3 (r, swork, nj, hcap, volfac, srcint)
      sum = 0.0
      call zeroa (swork, nj)
c
      do j=2,nj
        sum = sum + trapf(j,r,en(1,k),hcap,volfac)
        if (srcint(j) .ne. 0.0)  swork(j) = sum / srcint(j)
      end do
c
*%%%% write (6, *) '%%%% in subroutine PSOURC, calling EXTRAP'
      call extrap (r(2),r(3),r(1),swork(2),swork(3),swork(1))
c
      jprt = 1
      do 380 j=1,nj
        j1prt       = ((j-1)/jprt)*jprt
        if (j1prt .ne. j-1 .and. j .ne. nj)  go to 380
        err         = ss(j) - dudt_lcl(j) - dflux(j)
        write (6, 1155) j, r(j), roa(j), dudt_lcl(j), dflux(j),
     .                     ss(j), err, swork(j)
  380 continue
 1155 format (1x, i4, f6.1, f5.1, 1p9e12.3)
c
      return
c
      end

      real*8 function turnon (time, timeon, timec,timerf,timeu,timed)
c        timeon pulse start time
c        timerf length of pulse
c        timeu length of ramp up phase (linear model)
c        timed lengh of ramp down phase (linear model)
c        timec length of ramp up phase (cosine model)
c
c        for the linear model duration of flat top = timerf -timeu -timed
c        timerf can be set so no flattop is present:
c        timerf = timeu , timed =0.0
c     or timerf = timed,timeu =0.0
c     or timerf = timeu+timed
c
      implicit  integer (i-n), real*8 (a-h, o-z)

c
c --- function turnon gives smooth turn-on of RF current and power
c
      if(timeu .lt. 0.0 .and. timed .lt. 0.0 )then  !cosine ramp model
         if      (time .lt.  timeon       ) then
            turnon = 0.0
         else if (time .ge. (timeon+timec)) then
            turnon = 1.0
         else 
            turnon = 0.5 * (1.0
     .         - COS ((time-timeon) / timec * 4.0 * ATAN2 (1.0, 1.0)))
c
c IF ABOVE LINE IS CHANGED, MAKE A SIMILAR CHANGE IN FUNCTION TURNONMOD
c
          endif
      else !linear ramp up or ramp down situation
         if(time .lt.  timeon       ) then
              turnon = 0.0
         else if(timeon .le. time .and. time .le. timeon + timeu)then
              turnon = (time - timeon)/timeu
         else if(timeon + timeu .le. time .and. 
     .          time .le. timeon+timerf - timed ) then !flattop region
              turnon =1.0
         else if(timeon+ timerf -timed .le. time .and. 
     .                                 time .le. timeon + timerf)then
              turnon = (timeon + timerf -time)/timed
         else
              turnon = 0.0
         endif
      end if
      return
c
      end



      real*8 function turnonmod (time, timeon, timec, 
     .                                 timeoff,timerf,timeu,timed)
c        timeon pulse start time
c        timerf length of pulse
c        timeu length of ramp up phase (linear model)
c        timed lengh of ramp down phase (linear model)
c        timec length of ramp up phase (cosine model)
c
c        for the linear model duration of flat top = timerf -timeu -timed
c
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c --- function TURNONMOD is used to determine RF input power at t = time
c
      if(timeu .lt. 0.0 .and. timed .lt. 0.0 )then  !cosine ramp model
         if      (time .lt.  timeon       ) then
             turnonmod = 0.0
         else if (time .le. (timeon+timec)) then
            if (timec .eq. 0.0) then
                turnonmod = 1.0
             else
                 turnonmod = 0.5 *
     .          (1.0 - COS ((time-timeon)/timec*4.0*ATAN2 (1.0,1.0)))
             end if
c
c IF ABOVE LINE IS CHANGED, MAKE A SIMILAR CHANGE IN FUNCTION TURNON
c
         else if (time .le.  timeoff      ) then
             turnonmod = 1.0
         else
             turnonmod = 0.0
         end if
      else !linear ramp up or ramp down situation
         if(time .lt.  timeon       ) then
              turnon = 0.0
         else if(timeon .le. time .and. time .le. timeon + timeu)then
              turnon = (time - timeon)/timeu
         else if(timeon + timeu .le. time .and. 
     .          time .le. timeon+timerf - timed ) then !flattop region
              turnon =1.0
         else if(timeon+ timerf -timed .le. time .and. 
     .                                 time .le. timeon + timerf)then
              turnon = (timeon + timerf -time)/timed
         else
              turnon = 0.0
         endif
      endif  !linear versus cosine model
      return
c
      end

      subroutine wtypt (time)
c
      USE param
      USE numbrs
      USE tfact
      USE bd_condtn,only : bctime,ub,fluxb,
     .    ub_save,ub_rho_edge,bctime_zone
      implicit  integer (i-n), real*8 (a-h, o-z)
c
c --- interpolates for time-dependent w1typt,w2typt,w3typt,w4typt,vtypt
c
c      include 'param.i'
c      include 'bcon.i'
c      include 'numbrs.i'
c      include 'tfact.i'
c
      call find (i1, i2, time, bctime, nbctim)
      w1typt = 0.0
      w2typt = 0.0
      w3typt = 0.0
      w4typt = 0.0
      vtypt  = 0.0
c
c *** added 10/28/99 HSJ (this prevents old inone files from ***********
c     taking the STOP branch below. Instead we assume (as was
c     originally intended) that the wtyp parameters are constant
c     at the input value:
c
      if (nbctim .eq. 1 .and. i1 .eq. 0) then
        i1 =  1
        i2 = i1
      end if
c
c *** end of 10/28/99 mods HSJ *****************************************
c
      if (i1 .eq. 0)  call STOP ('subroutine WTYPT: I1 = 0', 43)
      w1typt = w1typ(1)
      w2typt = w2typ(1)
      w3typt = w3typ(1)
      w4typt = w4typ(1)
      vtypt  = vtyp (1)
      if (i2 .eq. i1)  return


c     added the if branch forr w1-4 below 6/26/01 HSJ
c     (this is to keep users from making a mistake in input where the
c      second value of w*typ(2) is not set but should have been):


      if(nbctim .gt. 1 .and. ABS(w1typ(2))  .lt. 1.e-14 )then
            w1typt = w1typ(1)
      else
             w1typt = w1typ(i1) +
     . (time-bctime(i1))*(w1typ(i2)-w1typ(i1)) / (bctime(i2)-bctime(i1))
      endif

      if(nbctim .gt. 1 .and. ABS(w2typ(2)) .lt. 1.e-14  )then
            w2typt = w2typ(1)
      else
             w2typt = w2typ(i1) +
     . (time-bctime(i1))*(w2typ(i2)-w2typ(i1)) / (bctime(i2)-bctime(i1))
      endif

      if(nbctim .gt. 1 .and. ABS(w3typ(2)) .lt. 1.e-14)then
            w3typt = w3typ(1)
      else
             w3typt = w3typ(i1) +
     . (time-bctime(i1))*(w3typ(i2)-w3typ(i1)) / (bctime(i2)-bctime(i1))
      endif

      if(nbctim .gt. 1 .and. ABS(w4typ(2)) .lt. 1.e-14)then
            w4typt = w4typ(1)
      else
             w4typt = w4typ(i1) +
     . (time-bctime(i1))*(w4typ(i2)-w4typ(i1)) / (bctime(i2)-bctime(i1))
      endif

      if(nbctim .gt. 1 .and. ABS(vtyp(2)) .lt. 1.e-14 )then
            vtypt = vtyp(1)
      else
             vtypt  = vtyp (i1) +
     . (time-bctime(i1))*(vtyp (i2)-vtyp (i1)) / (bctime(i2)-bctime(i1))
      endif

      return
c
      end

      SUBROUTINE load_enx(ibion,nj,iother,nneu,id,it,enx)
c--------------------------------------------------------------------
c -- load current thermal species that amtches beam into enx
c--------------------------------------------------------------------
      USE nrtype,                       ONLY : DP,I4B
      USE soln,                         ONLY : en

      IMPLICIT NONE
      INTEGER(I4b) j,nj,ibion,iother,nneu,id,it
      REAL(DP) enx(nj)


      if (ibion .gt. 0) then
          call copya (en(1,ibion), enx, nj) ! load enx w/thermal species
          if (nneu .ne. 2)  RETURN          ! corresponding to beam
          iother = 3-ibion

          DO  j=1,nj
             enx(j) = 0.5 * (enx(j)+en(j,iother))
          ENDDO
      else ! beam is dt mixture (single fluid), with separate thermal
c
c         D and T fluids
c

          do j=1,nj
            enx(j) = 0.5 * (en(j,id)+en(j,it))
          end do
      end if
c

      RETURN
      END


      SUBROUTINE check_profiles(recall_switch,enx,ennub,te,tenub,nj,
     .                          delnub,relnub,delte,freyavb,ncrt)
c----------------------------------------------------------------------
c --
c----------------------------------------------------------------------
      USE nrtype,                           ONLY : DP,I4B

      IMPLICIT NONE
      REAL(DP) enx(nj),ennub(nj),te(nj),tenub(nj)
      REAL(DP) delte,delnub,relnub
      INTEGER ncrt,freyavb,nj
      LOGICAL recall_switch

      recall_switch = .FALSE.

      call maxrc(enx,ennub,nj,delnub) ! ennub is previous enx
      call maxrc(te,tenub,nj,delte)
      delnub = MAX (delnub,delte)
      if ( delnub .ge. relnub) recall_switch = .TRUE.
      if (freyavb .gt. 0     ) then
         if (ABS (delnub-delte) .lt. 1.0e-7) then
           write (ncrt,'(" call FREYA: te changed more than allowed" /
     .       " delte =",1pe12.4," relnub = ",1pe12.4)')delte,relnub
         else
           write (ncrt,'(" call FREYA: thermal density of beam species"
     .                      " changed more than allowed" /
     .       " delnub =",1pe12.4," relnub = ",1pe12.4)')delnub,relnub
         end if
      end if

      RETURN
      END

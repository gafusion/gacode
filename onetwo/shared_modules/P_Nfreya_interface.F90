  MODULE P_nfreya_interface

        USE nrtype,                               ONLY : DP,SP,I4B,I2B
        USE beam_structure,                       ONLY : neutral_beam
        USE io_gcnmp,                             ONLY : ncrt,nlog
        USE error_handler,                        ONLY : lerrno,terminate,iomaxerr

        USE fast_ion_diffusion,                   ONLY : fidif

        USE common_constants,                     ONLY : izero,zeroc

        USE replace_imsl,                         ONLY : my_vsrta

        IMPLICIT NONE

        INTEGER,PARAMETER :: strlngth = 128
        INTEGER,PARAMETER :: kprim = 3
        INTEGER,PARAMETER,PUBLIC  :: mfi  = 2        ! # fast beam species
        INTEGER,PARAMETER,PUBLIC  :: ndifbep   = 20  ! size of fdifbe and edifbe
        INTEGER,PARAMETER,PUBLIC  :: nfusbb =8 
!
        !fus_tablebb_12(nfusbb) depends on reactions defined, 
        !see sub get_nboutput.f90
        LOGICAL,PUBLIC  :: nbi_init
        LOGICAL, PUBLIC :: nlbout
        LOGICAL,PUBLIC  :: nubeam_init
        CHARACTER(len = strlngth) ,PUBLIC :: runid ='not_set'
        CHARACTER(len = strlngth) ,PUBLIC :: z_georoot=' ' 
        CHARACTER(len = strlngth) ,PUBLIC :: z_fpproot=' '
        CHARACTER(len = strlngth) ,PUBLIC :: z_fppxtra=' '
        CHARACTER(len = strlngth) ,PUBLIC :: xp_eqdsk_name
        CHARACTER(len = 48)       ,PUBLIC :: fus_tablebb_12(nfusbb)
        CHARACTER(len = 256)      ,PUBLIC :: beam_data_ufile
        CHARACTER(len = 256)      ,PUBLIC :: beam_data_namelist
        CHARACTER(len = 256)      ,PUBLIC :: nubeam_state_path
        CHARACTER(len = 256)      ,PUBLIC :: nubeam_profile_path
        CHARACTER(len = 256)      ,PUBLIC :: profile_save_file
        CHARACTER(len = 256)      ,PUBLIC :: xplasma_save_file
        CHARACTER(len = 256)      ,PUBLIC :: state_save_file
        CHARACTER(len = 256)      ,PUBLIC :: xplasma_file
        CHARACTER(len = 256)      ,PUBLIC :: state_file
        CHARACTER(len = 256)      ,PUBLIC :: profile_file
        CHARACTER(len = 256)      ,PUBLIC :: nubeam_xplasma_path
        CHARACTER(len = 8 )       ,PUBLIC :: xp_namep(kprim) !length = namep length
        CHARACTER(len = 8 )       ,PUBLIC :: xp_namen(kprim) !length = namep length
        CHARACTER(len = 8 )       ,PUBLIC :: nameb_nubeam(mfi)
        CHARACTER(len=24)         ,PUBLIC :: nubeam_root
!
        !following need to be defined from input inone
        !first used in set_nbdims
        LOGICAL,PUBLIC :: nlfhe3,nlfhe4, nlfst,nlfsp, nlusf3
        LOGICAL,PUBLIC :: nlusfa,nlusft,nlusfp,nlfatom,nlbfpp
        LOGICAL,PUBLIC :: nlminsv,nlbbcx,nlebei,nlbcpa
        LOGICAL,PUBLIC :: nlbcde, nlbcoh,nlorbo,nlntmj
        LOGICAL,PUBLIC :: nlbflr,nlbgflr,nlfbon, nlcprb,nlfbmflr
        LOGICAL,PUBLIC :: nlfdep,nlsym2b,nlsawb,nlsawf,orbit_losses
        LOGICAL,PUBLIC,   DIMENSION(:),ALLOCATABLE  :: nlfbmfpp
!
!
!
!
        INTEGER,PARAMETER,PUBLIC  :: inzri = 10 !no of radial grid zones.
                                        !NOTE input nzones must be a multiple
                                        !of inzri, only inzri=10,20 are allowed
        INTEGER,PUBLIC :: nxskpb
        INTEGER,PUBLIC :: nsbeam,ng, nprim_tr,xp_nneu
        INTEGER,PUBLIC :: nmini,nerngfi,ncoils,nchdvp
        INTEGER,PUBLIC :: id_vol,id_cxarea,id_RBt
        INTEGER,PUBLIC :: nmcurb,nbbox,indx_neut,nneu_12
        INTEGER,PUBLIC :: nubeam_restart,save_nubeam_input
        INTEGER,PUBLIC :: nubeam_steps
        INTEGER,PUBLIC :: nzone_fp,nthrf,nubeam_nclass
        INTEGER,PUBLIC :: nefpdep,nxfpdep
        INTEGER,PUBLIC :: nseed,lunnbx,lunres
        INTEGER,PUBLIC :: mrstrt, nsigexc
        INTEGER,PUBLIC :: nptcls,nptclf,ndep0
        INTEGER,PUBLIC :: nmsigx,nkdifb,nrip,nsdbgb
        INTEGER,PUBLIC :: nxbox,nybox,nlbox,ndepbox
        INTEGER,PUBLIC :: nzones,avg_nubeam_torque
        INTEGER,PUBLIC :: xp_axi,xp_inr,xp_inz,xp_ierr,xp_nt1
        INTEGER,PUBLIC :: xp_rho_grid_size,xp_psi_grid_size ! size of rho
                                              !and psi  grid generated by
                                              ! call to eqm_fromgeqdsk 
        INTEGER,PUBLIC :: xp_got,xp_nj
        INTEGER,PUBLIC :: xp_magdim,xp_magfit,xp_cyldim
        INTEGER,PUBLIC :: id_rhonj,id_tflux
        INTEGER,PUBLIC :: xp_cylfit,xp_warn,xp_info,xp_npsi,xp_irz
        INTEGER,PUBLIC :: lcentr,ledge,lep1           !need to define these
                                                      !not used butr required
                                                      !for compilation for now.

        ! upper and lower bounds of arrays read in ufile:
        INTEGER,PUBLIC ::   ufx       ! UBOUND(F,1)
        INTEGER,PUBLIC ::   ufy       ! UBOUND(F,2) 
        INTEGER,PUBLIC ::   lfx       ! LBOUND(F,1)
        INTEGER,PUBLIC ::   lfy       ! LBOUND(F,2)
        INTEGER,PUBLIC ::   uxx       ! UBOUND(x,1)
        INTEGER,PUBLIC ::   lxx       ! LBOUND(x,1)
        INTEGER,PUBLIC ::   uyx       ! UBOUND(y,1)
        INTEGER,PUBLIC ::   lyx       ! LBOUND(y,1)




        INTEGER,PUBLIC :: nubeam_evolve
        INTEGER,PUBLIC, DIMENSION(:),ALLOCATABLE :: nbsbox
        INTEGER,PUBLIC, DIMENSION(:),ALLOCATABLE :: nbebox
!
        !nubeam crashes if the time step is too small.
        !nubeam_dtmin is approximate minimum time interval that 
        !nubeam can handle allowed for nubeam
        REAL (DP) ,PARAMETER,PUBLIC :: nubeam_dtmin = 1.e-4
        REAL (DP) ,PUBLIC :: xp_fdy,xp_cbdy,xp_rho_axis,xp_rho_bdry
        REAL (DP) ,PUBLIC :: xp_tor_fluxt ,nubeam_on
        REAL (DP) ,PUBLIC :: nubeam_restart_time
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_tor_flux
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_rhonj
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_rho_grid
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_psi_grid
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_qval
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_psi_zone
        REAL (DP) ,PUBLIC ,DIMENSION(:),ALLOCATABLE     :: xp_rho_zone
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: aimpj
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: omegag
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: phiprg
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: curt
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: vpoh
        REAL (DP) ,PUBLIC, DIMENSION(:,:),ALLOCATABLE   :: omega_neut
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: efpdep
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: xfpdep
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sscxl
!
!
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: qbth_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: qbth_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: qbeame_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: qbeami_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: qbeame_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: qbeami_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: curb_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: curb_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: storqueb_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: storqueb_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:,:), ALLOCATABLE  :: storque_nub_avg
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sprbeame_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sprbeame_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sprbeami_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sprbeami_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: wbeam_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: wbeam_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: enbeam_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: enbeam_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamdtn_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamdtn_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamddp_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamddp_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamddn_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamddn_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamtt2n_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_beamtt2n_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermaltth_df_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermaltth_df_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermalddp_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermalddp_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermalddn_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermalddn_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermaltt2n_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermaltt2n_nubp
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermaldth_tf_nub
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: beam_thermaldth_tf_nubp

        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sorbn0_nub !jmp.den
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sorbn0_nubp !jmp.den
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sorbh_nub !jmp.den
        REAL (DP) ,PUBLIC, DIMENSION(:),ALLOCATABLE     :: sorbh_nubp !jmp.den
!
!
!
        REAL (DP),PUBLIC :: qbeame_intg_nub,       qbeame_intg_nubp
        REAL (DP),PUBLIC :: qbeami_intg_nub,       qbeami_intg_nubp
        REAL (DP),PUBLIC :: qbth_intg_nub,         qbth_intg_nubp
        REAL (DP),PUBLIC :: curb_intg_nub,         curb_intg_nubp
        REAL (DP),PUBLIC :: storqueb_intg_nub,     storqueb_intg_nubp
        REAL (DP),PUBLIC :: sprbeame_intg_nub,     sprbeame_intg_nubp
        REAL (DP),PUBLIC :: sprbeami_intg_nub,     sprbeami_intg_nubp
        REAL (DP),PUBLIC :: wbeam_intg_nub,        wbeam_intg_nubp
        REAL (DP),PUBLIC :: enbeam_intg_nub,       enbeam_intg_nubp
!
        REAL (DP),PUBLIC :: pwf_tot_intg_nub,       pwf_tot_intg_nubp
        REAL (DP),PUBLIC :: beam_thermal_tt2ntot_nub
        REAL (DP),PUBLIC :: beam_thermal_tt2ntot_nubp
        REAL (DP),PUBLIC :: beam_thermal_ddptot_nub
        REAL (DP),PUBLIC :: beam_thermal_ddptot_nubp
        REAL (DP),PUBLIC :: beam_thermal_ddntot_nub
        REAL (DP),PUBLIC :: beam_thermal_ddntot_nubp
        REAL (DP),PUBLIC :: beam_thermal_dtntot_nub
        REAL (DP),PUBLIC :: beam_thermal_dtntot_nubp
        REAL (DP),PUBLIC :: beam_beam_tt2ntot_nub
        REAL (DP),PUBLIC :: beam_beam_tt2ntot_nubp
        REAL (DP),PUBLIC :: beam_beam_ddptot_nub
        REAL (DP),PUBLIC :: beam_beam_ddptot_nubp
        REAL (DP),PUBLIC :: beam_beam_ddntot_nub
        REAL (DP),PUBLIC :: beam_beam_ddntot_nubp
        REAL (DP),PUBLIC :: beam_beam_dtntot_nub
        REAL (DP),PUBLIC :: beam_beam_dtntot_nubp
!
        REAL (DP),PUBLIC :: goocon,gflr_min,nubeam_dt,nubeam0_dt
        REAL (DP),PUBLIC :: nubeam_back_delt,nubeam_fix_t,nubeam_back_average !JMP
        INTEGER,PUBLIC :: ifix_nubeam_dt !JMP
        REAL (DP),PUBLIC :: plfhe3,plfhe4,plfst,plfsp
        REAL (DP),PUBLIC :: cxsplt,dxbsmoo, wghta,dn0out
        REAL (DP),PUBLIC :: cxpcon,fppcon,dtn_orbit,xdepmod
        REAL (DP),PUBLIC :: xcfanbi,xdfanbi,xefanbi,xcfafus,xdfafus
        REAL (DP),PUBLIC :: xefafus
        REAL (SP),PUBLIC :: taurip,asrd,bsrd
        REAL (SP),PUBLIC :: fbemin,fbemax,fvpvmn,fshper,fshwid
        REAL (SP),PUBLIC :: tfshon,tfshof,fvpvmx,fbltim
        REAL (SP),PUBLIC :: xboxhw,yboxhw,xlbox1,xlbox2
        REAL (DP),PUBLIC :: plhgt,wrt_restart_file_time
        REAL (SP),PUBLIC :: edbfac,tbm1,tbm2,tsaw,dtmint
        REAL (DP),PUBLIC :: xdatsfa, xdatsf3, xdatsft,xdatsfp
        REAL (SP),PUBLIC :: CPXPGL,ZTIM2,ZTIM1
        REAL (SP),PUBLIC :: dt_nubeam_mult
        !fidffbe and edifbe are not allocatable because they
        !are namelist inputs:
        REAL (DP),PUBLIC, DIMENSION(ndifbep) :: fdifbe 
        REAL (DP),PUBLIC, DIMENSION(ndifbep) :: edifbe
!
!
        REAL (SP),PUBLIC, DIMENSION(:),ALLOCATABLE :: erngfi
        REAL (SP),PUBLIC, DIMENSION(15) :: gflr_op
        REAL (SP),PUBLIC, DIMENSION(:),ALLOCATABLE :: xzimpj
        REAL (SP),PUBLIC, DIMENSION(:),ALLOCATABLE :: tmjsm
        REAL (SP),PUBLIC, DIMENSION(:),ALLOCATABLE :: fracmini
        REAL (DP),PUBLIC, DIMENSION(:),POINTER :: nubeam_calls
!
!
        REAL (SP),PUBLIC, DIMENSION(:,:),ALLOCATABLE :: rhmin
        REAL (SP),PUBLIC, DIMENSION(:,:),ALLOCATABLE :: rhi



        REAL (DP) ,PUBLIC, DIMENSION(:,:),ALLOCATABLE     :: enbeam_species
        REAL (DP) ,PUBLIC, DIMENSION(:,:),ALLOCATABLE     :: enbeam_species_p
        REAL (DP) ,PUBLIC, DIMENSION(:,:),ALLOCATABLE     :: enbeam_species_c
!
        REAL (SP),PUBLIC,  DIMENSION(:),ALLOCATABLE :: xzmini
        REAL (SP),PUBLIC,  DIMENSION(:),ALLOCATABLE :: amini
        REAL (SP),PUBLIC, DIMENSION(:,:,:),ALLOCATABLE :: den0mn
        REAL (SP),PUBLIC, DIMENSION(:,:,:),ALLOCATABLE :: en0mn
        REAL (SP),PUBLIC, DIMENSION(:,:,:),ALLOCATABLE :: omg0mn
        REAL (SP),PUBLIC, DIMENSION(:,:,:),ALLOCATABLE :: rhbs
        REAL (SP),PUBLIC, DIMENSION(:,:,:),ALLOCATABLE :: rhix
!
!
       TYPE(neutral_beam),PUBLIC  :: beam_data

       TYPE(fidif),PUBLIC :: d_fast_ion
!
!

!
!

!
!
       DATA nubeam_steps /1/      !nubeam  restart files is created  on all calls
                                  !to nubeam. But The restart files are
                                  !read only if nubeam_steps >  1.
!
       DATA nubeam_root         /'nubeam_12'/
       DATA profile_save_file   /'none' /
       DATA state_save_file     /'none' / 
       DATA  xplasma_save_file  /'none' /
       DATA nubeam_init         /.FALSE./

       DATA nlfst               /.FALSE./
       DATA nlfhe3              /.FALSE./
       DATA nlfhe4              /.FALSE./
       DATA nlfsp               /.FALSE./
       DATA nlusf3              /.FALSE./
       DATA ufx,ufy,uxx,uyx     /-1,-1,-1,-1/
       DATA lfx,lfy,lxx,lyx     /-1,-1,-1,-1/

     CONTAINS 


       SUBROUTINE get_nf_beam_data (name_beam,use_ufile,read_ufile,    &
                                                 read_nubeam_namelist)
! --------------------------------------------------------------------------
! -- NOTE ONETWO calls get_beam_data(beam_data) and does not use  this routine
! -- This is the gateway to ufile type input.
! -- Read beam geometry info from file beam_data_namelist
! -- Read beam data from 2d ufile (beam_data_ufile)
! -- uses NTCC ufiles modules-libraries
! ---------------------------------------------  -----------HSJ 3/23/11----

         USE beam_structure,                        ONLY : neutral_beam, &
                                                           beam_structure_allocate

         USE solcon_gcnmp,                          ONLY : time0,time_max

         USE ions_gcnmp,                            ONLY : nprim,nion,nimp


         IMPLICIT NONE

         LOGICAL use_ufile,read_nubeam_namelist,read_ufile
         INTEGER,PARAMETER :: NSCMAX= 10           ! maximum number of scalars; 
         ! array dimension)
         INTEGER ndifbe
         INTEGER(I2b) get_next_io_unit
         REAL(SP) SCVAL (NSCMAX)                   ! (scalar data array)
         CHARACTER*4 TDEV                          ! (tokamak dev, eg DIII-D,etc
         CHARACTER*10 SHDATE                       ! (shot date)
         CHARACTER*10 SCLAB(3,nscmax)              ! (scalar labels array)
         CHARACTER(len = LEN_TRIM(beam_data_namelist)+3) :: beam_data_namelist_copy
         CHARACTER(len = LEN_TRIM(beam_data_namelist)+3) :: longpath,longfile
         REAL(SP),DIMENSION(:),ALLOCATABLE  :: X,y   !arrays to hold x,y)
         REAL(SP),DIMENSION(:,:),ALLOCATABLE :: F    !or REAL F(NFMAX), array to hold f
         CHARACTER*10 XLAB(3), YLAB(3), FLAB(3)  ! on the VAX (label arrays 
         !  for X, Y, and  F) 
         !(NOTE CHARACTER*30 XLAB,
         !FLAB will also work

         TYPE(neutral_beam)name_beam

         INTEGER ier,iostat,limit,ishot,iflag, &
                 iproc,nx,ny,nsc,itry, &
                 NXMAX,NYMAX,ierr,ngmax,nrhix,nbeam,nfast
         INTEGER(I2B) nluns,nlun,ntemp,ulun
         LOGICAL   namlst_exists, ufile_exists,nopened,read_com,uopened
         CHARACTER *64 path,prefix,extension     !64 is limit in ufiles routines !JMP
         INTEGER j,lp,nml_size


         INTERFACE

            SUBROUTINE sort_unique(a,km)
              USE nrtype,                                ONLY : DP
              REAL (DP), INTENT(INOUT),DIMENSION(:) :: a
              INTEGER, INTENT(OUT) :: km
            END SUBROUTINE sort_unique
            SUBROUTINE to_upper_case(string)
              USE nrtype,            ONLY : I4B
              IMPLICIT NONE
              INTEGER(I4B) l
              CHARACTER*(*), INTENT (INOUT) :: string
            END SUBROUTINE to_upper_case
! NOTE here we are using function overloading to select strip_path which is
! also defined in string_utils.f90 but has a different signature there HSJ
            SUBROUTINE strip_path(path,prefix,extension,filename, &
                              task,ishot,limit)
              IMPLICIT NONE
              INTEGER j,k,l,ll,lll,task
              INTEGER, INTENT (out) :: ishot
              CHARACTER*(*), INTENT(inout):: filename
              CHARACTER*(*), INTENT(out):: path,prefix,extension !JMP
              INTEGER,  INTENT(in):: limit      
            END SUBROUTINE strip_path



         END INTERFACE


         name_beam%data_allocated = .FALSE.

 

         ! -----------------------------------------------------------------------
         ! first we need to know if the beam namelist file and the ufile exist:
         ! they may be located in directories other than the current working directory
         ! -----------------------------------------------------------------------
         INQUIRE (file = beam_data_namelist, iostat = iostat,               &
              exist = namlst_exists, opened = nopened,number=nlun)
         INQUIRE (file = beam_data_ufile, iostat = iostat,               &
              exist = ufile_exists, opened = uopened,number=ulun)
         read_com = .FALSE.                      !dont read comment field in ufile




   naml:  IF(namlst_exists)THEN !  read beam_data_namelist
         ! ----------------------------------------------------------------------
         !  beam_data_namelist exists and will be read
         !  get available io unit no.,nlun and open file:
         ! ----------------------------------------------------------------------
            nlun = get_next_io_unit ()

            !open the file with the name obtained from ru directives input:
            OPEN(unit=nlun,file = beam_data_namelist,status ='OLD',IOSTAT = iostat)



       ios:     IF(iostat .EQ. 0)THEN
            !-----------------------------------------------------------
            ! strip comments from namelist file before processing:
            !-----------------------------------------------------------
               nml_size = LEN_TRIM(beam_data_namelist)
               nml_size = nml_size + 3  !for "_12", see below
               !          beam_data_namelist_copy(1:nml_size-3) = beam_data_namelist(1:nml_size-3)
               longfile(1:LEN(longfile))= ''
               longfile(1:nml_size-3) = beam_data_namelist(1:nml_size-3)
               limit = nml_size


               CALL strip_path(longpath,prefix,extension,longfile,1,&
                               ishot,limit)                  ! string_util.F90
               CALL to_upper_case(longfile)                  ! utils.F90

               lp = LEN_TRIM(longpath)+ LEN_TRIM(longfile)

               IF(lp .LE. LEN (beam_data_namelist_copy))THEN
                    beam_data_namelist_copy = ADJUSTL(longpath(1:LEN_TRIM(longpath)))//   &
                    ADJUSTL(longfile(1:LEN_TRIM(longfile)))
 
               ELSE
                  beam_data_namelist_copy(1:LEN_TRIM(longfile)) = ADJUSTL(longfile(1:LEN_TRIM(longfile)))

               ENDIF


               ntemp = get_next_io_unit ()
               OPEN   (unit = ntemp, file = beam_data_namelist_copy , status = 'UNKNOWN')
               !copy from unit nlun to unit ntemp, removing comments:
               CALL strip_comments (nlun, ntemp)

               !delete association with original file (connected to nlun)
              

               !close the stripped file and reopen it under the old name:
               !call giveupus(ntemp) ; 
               CLOSE  (unit = ntemp)

               !below we use only the stripped file,by changing the name here:

               beam_data_namelist = beam_data_namelist_copy
               !open the strippped file
               nluns  = get_next_io_unit ()
               OPEN(unit=nluns,file = beam_data_namelist,status ='OLD',IOSTAT = iostat)

               ! get size of some arrays by reading beam_data_namelist line by line

               CALL nblist_array_size(nluns,nbeam,ndifbe,ndifbep,ierr)         ! P_nfreya_interface.F90

               IF(ierr .GT. 0)THEN
                  PRINT *,'Error in reading file :',beam_data_namelist
                  PRINT *,'values found :'
!                  PRINT *,'ngmax =',ngmax
!                  PRINT *,'nrhix =',nrhix
                  PRINT *,'nbeam =',nbeam
                  PRINT *,'ndifbe =',ndifbe
                  lerrno = 248 + iomaxerr
                  CALL terminate(lerrno,nlog)
               ENDIF

               REWIND(nluns)     ! nluns (stripped namelist) will be  read again below
                                ! after array allocations

               !allocate data structure:
               nrhix =  nimp
               ngmax =  nion
               nfast =  2
 print *,'P_Nf_int l 465 nbeam =',nbeam
               CALL beam_structure_allocate(name_beam,nbeam,nrhix,ngmax,nfast) ! beam_structure.f90

               CALL get_beam_id (nlun,name_beam) ! get comment that ids the injector

               !set defaults for other parameters required by nubeam:
!!               CALL set_nubeam_misc_defaults

                ! set thermal species (nubeam has to know about these)
                ! name_beam%backz(1:ngmax)
                ! name_beam%aplasm(1:ngmax)
               CALL set_nubeam_thermal(name_beam)         ! P_nfreya_interface.F90

               ! set impurity species:
               ! name_beam%xzimpx(1:nrhix)     
               ! name_beam%aimpx(1:nrhix) 
               CALL set_nubeam_impure(name_beam)          ! P_nfreya_interface.F90


               !finally remaining  name_beam data structure
               ! is loaded by reading the namelist:
               CALL nblist_read(nluns,name_beam,ndifbe,ierr)             ! nblist_read.f90
               ! force a parsing of the namelist to pick up beam identifier
               ! comment line
               ! ierr = 1
 
            IF(ierr .GT. 0)THEN ! namelist read failed (probably due to incorrect writting of namelist)
               WRITE(nlog,7)
 7              FORMAT(2x,' ********************************',/, &
               '  namelist read failed,try parsing namelist'/,   &
                 ' ****************************************' )
               ! namelist read from file beam_data_namelist
               ! failed. This is most likely due to the fact that
               ! beam_data_namelist doesnt contain a valid  namelist
               ! but could also mean that the variables in the
               ! the namelist are bad. We cant protect agains the latter
               ! case at all but the former case may be treatable by
               ! parsing the file manually. The parser is not very robust
               ! however so this may or may not work:
               REWIND(nluns)
               CALL nblist_read_parse(nluns,name_beam,ierr)       ! nblist_read.f90
               ierr = 1 ! force error exit due to namelist read failure HSJ 2/22/12
                        ! even if parsing worked because of adiff_* problems
                        ! not handled currently in parser
               IF(nubeam0_dt .EQ. 0.0)nubeam0_dt = nubeam_dt
                  IF(ierr .GT. 0)THEN
                     PRINT *,'tried to read file ',beam_data_namelist


                     PRINT *,' twice, once as a namelist and '
                     PRINT *,' the second time as a manually parsed'
                     PRINT *,' file. Neither read was successful '
                  lerrno = 249 + iomaxerr
                  CALL terminate(lerrno,nlog)
                  ENDIF
             ENDIF

               IF(nbeam  .EQ. 0 )THEN
                  PRINT *,'zero beam case not allowed'
                  PRINT *,'ngmax =',ngmax
                  PRINT *,'nbeam =',nbeam
                  lerrno = 250 + iomaxerr
                  CALL terminate(lerrno,nlog)
               ENDIF

               !if name_beam%tbona and name_beam%tboffa are set only for
               !one beam but more than one beam is input then fix it here:
               DO j=2,name_beam%nbeam
                 IF(name_beam%tbona(j) .LT. -1.e6*time0 )          &
                       name_beam%tbona(j) = name_beam%tbona(j-1)
                  IF(name_beam%tboffa(j) .LT. -1.e6*time0 )         &
                      name_beam%tboffa(j) = name_beam%tboffa(j-1)
               ENDDO

 

               IF(ierr .NE. 0)read_com = .TRUE.
               read_nubeam_namelist = .TRUE.
            ELSE  ios
               read_com = .TRUE.
            ENDIF  ios



            !CALL giveupus(nlun)         !done with this file,give up the unit

            CLOSE(nluns)

            CLOSE(nlun)

            ! if nlbdat = true user sepecified that ufile be used so dont try to bypass it
 
            IF( .NOT. name_beam%nlbdat)THEN 
 
                CALL ufile_bypass(read_ufile)     ! do we need to read the ufile 
                                                  ! returns read_ufile T or F
                IF(read_ufile)THEN
                   ! fatal error here, ufile_bypass has detected that
                   ! ufile information (power,etc)is not in namelist input
                   ! and hence must be determined from ufile. But switch
                   ! name_beam%NLBDAT is set to not read the ufile.
                   ! hence cant proceed:
                   lerrno = 376 + iomaxerr ! ( 251 also used elsewhere for same ufile error)
                   CALL  terminate(lerrno,nlog)

                ENDIF

            ELSE
               IF(ufile_exists)THEN
                  read_ufile = .TRUE.
               ELSE
                  lerrno = 251 + iomaxerr ! ( 251 also used elsewhere for same ufile error)
                  CALL  terminate(lerrno,nlog)
               ENDIF
            ENDIF

   ELSE naml 

            ! beam_data_namelist doesnt exist we will get the info
            ! from ufile instead if available. Otherwise
            ! if user indicated that ufile should not be used 
            ! take an error exit:
            IF(.NOT. use_ufile )THEN
               lerrno = 297 + iomaxerr
               CALL  terminate(lerrno,nlog)
            ENDIF

            read_com = .TRUE.                 ! read ufile comment fields
            read_nubeam_namelist  = .FALSE.
            ! change logic so that nubeam namelist must always be read
            ! Hence getting to here is fatal error.
               lerrno = 316 + iomaxerr
               CALL  terminate(lerrno,nlog)

   ENDIF naml   ! beam data namelist read


  ! ------------------------------------------------------------------------
  ! name_beam data structure is now loaded except possibly 
  ! shot specific data (eg beam power,energy, full and half fractions)
  ! may  be fetched  from ufile ( current ufile has 32 channels which
  ! is 8 beams * these 4 items as a function of time.
  ! now process the ufile, read comments in ufile if read_com = T
  ! if use_ufile = F then call nfreya_load with  what we currently have
  ! otherwise get information from ufile and then  call nfreya_load
  ! ------------------------------------------------------------------------
  useufile: IF(use_ufile) THEN 
            DO j=1,name_beam%nbeam
               name_beam%tbona(j) = time0
            END DO
            
            IF(.NOT. name_beam%data_allocated) THEN
               IF(nbeam .NE. 0)THEN
                  nrhix =  nimp
                  ngmax =  nion
                  nfast = nbeam+2
                  CALL beam_structure_allocate(name_beam,nbeam,nrhix,ngmax,nfast)
               ENDIF
            ENDIF


            ! HERE WE ASSUME, FOR NOW ANYWAY, THAT NDIFBE AND THE ASSOCAITED
            ! INITIALIZATION OF TYPE fidif (MODULE FAST_ION_DIFFUSION)
            ! WAS SET ABOVE EVEN IF UFILE READS ARE USED. THIS IS BECAUSE
            ! I THINK UFILES DO NOT SUPPLY A VALUE FOR NIDFBE (BUT I MAY 
            ! BE WRONG - IF SO WE NEED TO DO A CALL TO FI_INIT HERE)


            NXMAX = 15000 ; NYMAX = 56
            ALLOCATE( X(NXMAX)) ;ALLOCATE(Y(NYMAX))
            ALLOCATE(F(NXMAX,NYMAX) )
            limit = LEN(path)
            iflag =0                               !use 2d form for F
            itry =0

            IF (ufile_exists .AND. uopened) CLOSE(ulun)

            IF(.NOT. ufile_exists .AND. read_ufile)THEN   !error         
               WRITE(ncrt,FMT='(2x,"Error : beam_data_ufile not found :",a)')beam_data_ufile
               lerrno = 251 + iomaxerr
               CALL terminate(lerrno,nlog)
            ENDIF


            !beam_data_ufile exists. open and process it.
            !get the path if it is part of the file specification:
            CALL strip_path(path,prefix,extension,beam_data_ufile,0,ishot,limit)


            !get available io unit no.,ulun :

            ulun = get_next_io_unit ()



            !call setup routine required for ufiles read:
            !UFSETR is used to set up the naming and location convention
            !you will use.  The disk and directory fields may be blank, in 
            !which case the files will default to the current working directory.  

            !call UFSETR(ulun,prefix,suffix,disk,directory)
            !          ulun - integer
            !          prefix - character, max length 16
            !          suffix - character, max length 16
            !          disk - character, max length 16
            !          directory - character, max length 64
            CALL UFSETR(ulun,prefix,extension,' ',path)

            !set the shot number :
100         CALL UFOPRD(ulun,ishot,ier)     !Open for READONLY access
            IF(ier .NE. 0)THEN
               WRITE(ncrt,1)ier
1              FORMAT(2x,'get_beam_data returned ier =',i5,/, &
                    2x,'while calling UFOPRD')
               lerrno = 252 + iomaxerr
               CALL terminate(lerrno,nlog)
            ENDIF

 
            !now do the actual reading:
            CALL  UF2DRD(ulun, TDEV, SHDATE, F, NXMAX, X, NXMAX, Y, NYMAX, IPROC, &
                 NX, NY, IFLAG, FLAB,XLAB, YLAB, NSCMAX, NSC,SCVAL,SCLAB,IER)



            IF(ier .NE. 0)THEN
               itry = itry + 1
               WRITE(ncrt,2)ier
2              FORMAT(2x,'get_beam_data returned ier =',i5,/, &
                    2x,'while calling UF2DRD')
               WRITE(ncrt,3)nx,nxmax,ny,nymax
3              FORMAT(2x,'nx, nxmax =',2(2x,i5),/, &
                    2x,'ny, nymax =',2(2x,i5))

               IF(itry .GT. 1) THEN
                  lerrno = 252 + iomaxerr
                  CALL terminate(lerrno,nlog)
               ELSE
                  WRITE(ncrt,4)
4                 FORMAT(2x,'Reallocating arrays,calling UF2DRD again')
                  IF(nx .NE. nxmax)THEN
                     DEALLOCATE(X)
                     ALLOCATE(X(nx))
                     nxmax = nx
                  ENDIF
                  IF(ny .NE. nymax)THEN
                     DEALLOCATE(y)
                     ALLOCATE(y(ny))
                     nymax = ny
                  ENDIF
                  DEALLOCATE(F)
                  ALLOCATE(F(nx,ny))
                  !CALL giveupus(ulun)              !give up the unit
                  CALL UFCLOS(ulun)                !Close the file
                  go to 100
               ENDIF
            ENDIF

            !CALL giveupus(ulun)              !give up the unit
            CALL UFCLOS(ulun)                !Close the file


            IF(NSC .NE. 1)THEN
               PRINT *,'UFILE read reports number of scalars =',nsc
               PRINT *,' Expected to read NSC =1 scalar'
               lerrno = 254 + iomaxerr
               CALL terminate(lerrno,nlog)
            ENDIF

            IF(name_beam%nbeam .NE. INT(scval(nsc)))THEN
               PRINT *,'UFILE read reports number of beams =',scval(nsc)
               PRINT *,'namelist read has nbeams =',name_beam%nbeam
               lerrno = 255 + iomaxerr
               CALL terminate(lerrno,nlog)
            ENDIF

            !process data for use in Onetwo:

            CALL set_beam_data(F,x,y,nx,ny,name_beam) ! set name_beam%beam_inject,
                                                      ! name_beam%beam_times,
                                                      ! name_beam%beam_chan

!            CALL  nbdrive_nubeam_checknaml(ierr,name_beam) ! nfreya_load.f90
            PRINT *,"Using ufile for beam power,energy,full,half,third fractions"
            WRITE(nlog,300)LEN_TRIM(beam_data_ufile)
300 FORMAT(2x,'Used ufile : ',a,' for beam power,energy,full,half,third fractions')

  ENDIF  useufile

         CALL  nbdrive_nubeam_checknaml(ierr,name_beam) ! nfreya_load.f90

         CALL nfreya_load_single_source(name_beam) ! nfreya_load.f90


200      IF(ALLOCATED(x)) DEALLOCATE(x) ;IF(ALLOCATED(y))DEALLOCATE(y) 
         IF(ALLOCATED(f)) DEALLOCATE(f)

         RETURN


       END SUBROUTINE get_nf_beam_data    ! return control to load_nfreya_input (.f90)




       SUBROUTINE nblist_array_size(lun,nbeam,ndifbe,ndifbep,ierr)
!  -------------------------------------------------------------------
!  get values of ngmax,nrhix,nbeam
!  nbeam = # beams
!  nfast = # fast ions 
!  ----------------------------------------------------HSJ-11/18/03----
   USE nrtype,                                       ONLY : DP,I4B,I2B
   USE string_util,                                  ONLY : set_integer_value

   IMPLICIT NONE
   !INTEGER,INTENT(OUT) :: nbeam,ierr,ndifbe
   INTEGER nbeam,ierr,ndifbe,ndifbep
   !INTEGER(I2B) , INTENT (in ) :: lun
   INTEGER(I2B) lun
   INTEGER ll,j,k,kk,i
   INTEGER n,inta
   CHARACTER(len=256) :: line

   nbeam = izero ;  ierr = izero ; ndifbe = izero
 

   DO WHILE(1 .GT. 0)
     READ(lun,FMT='(a)',ERR = 15,END=10)line
     line  = ADJUSTL(line)
     !line = to_upper_case(line)
     CALL to_upper_case(line)
     ll = LEN_TRIM(line)                    
     k = INDEX(line,'!')
     IF(k == 1)CYCLE                                !ignore comment lines
     IF(k == 0)k=ll                                 !string does not have '!'
     kk= INDEX(line(1:k),'NBEAM')
     IF(kk .NE. 0)                                            &
         CALL set_integer_value(k,kk,line,nbeam)
     kk= INDEX(line(1:k),'NDIFBE')
     IF(kk .NE. 0)                                            &
         CALL set_integer_value(k,kk,line,ndifbe)
   END DO
 
10 CONTINUE

    IF(ndifbe == izero)ndifbe = ndifbep   ! dimension not set in input file 
 
   RETURN

15 ierr = 1

   RETURN

   END SUBROUTINE nblist_array_size






    SUBROUTINE ufile_bypass(read_ufile)
! ------------------------------------------------------------
!   subroutine assumes beam_data_namelist was read and beam 
!   data sructure was loaded. Here we check the quantities 
!   nbeam, tbona(1:nbeam),tboffa(1:nbeam),
!   pinja(1:nbeam),einja(1:nbeam), ffulla(1:nbeam) and
!   fhalfa(1:nbeam)
!   for valid input. If this input is valid for all beams then set flag 
!   read_ufile = .false., indicating that the ufile should not be processed.
!   Otherwise read_ufile = .true. is returned and the ufile will have to
!   be read to get the inputs.
! -------------------------------------------------------------HSJ 12/03/03
    USE nrtype,                                ONLY : DP,I4B,SP

    USE solcon_gcnmp,                          ONLY : time0,time_max

    USE io_gcnmp,                              ONLY : ncrt,nlog

    IMPLICIT NONE
    INTEGER j,k,l,ll,nt,nchan,nx,ierr
    REAL(DP) tb,tmin
    REAL (DP),DIMENSION(:),ALLOCATABLE :: dummy
    LOGICAL,INTENT(OUT) :: read_ufile
    INTEGER kk,km,i,kmm



    read_ufile = .FALSE.

    !allow  0.0 as valid pinj
    !allow fhalfa = 0.0 for neg ion injection
    DO j =1,beam_data%nbeam

       IF (      beam_data%pinja(j)  .LT. zeroc           &
            .OR. beam_data%einja(j)  .LE. zeroc           &
            .OR. beam_data%ffulla(j) .LE. zeroc           )THEN

           read_ufile = .TRUE.
           EXIT
       ENDIF

       IF( beam_data%tbona(j) .GE.  beam_data%tboffa(j))THEN
          read_ufile = .TRUE.
          WRITE(ncrt,110)j,beam_data%tbona(j),beam_data%tboffa(j)
          WRITE(nlog,110)j,beam_data%tbona(j),beam_data%tboffa(j)
110       FORMAT(2x,'Error for beam number ',i5,/,2x,'tbona > tboffa',/, &
                   ' required, rbona ,tboffa =',2(2x,1pe12.6))
          EXIT
       ENDIF

    ENDDO

!  print *,'P_nfreya_interface,F90,line 865'  ! 8888899999
!  print *,'read_ufile =',read_ufile
!  print *,'beam_data%pinja =', beam_data%pinja
!  print *,'beam_data%einja =', beam_data%einja
!  print *,'beam_data%ffula =', beam_data%ffulla
!  print *,'beam_data%nbeam =', beam_data%nbeam
!  print *,'beam_data%tbona =', beam_data%tbona
!  print *,'beam_data%tboffa =', beam_data%tboffa



    IF(read_ufile)RETURN              !data not valid need to read ufile
                                      ! to get valid data


    !WE HAVE valid data, load beam_data structure:
    nchan = beam_data%nbeam * 4               !4 data elements per beam


    IF(ASSOCIATED( beam_data%beam_chan))THEN
                DEALLOCATE(beam_data%beam_chan)
                ALLOCATE(beam_data%beam_chan(nchan))
                DO j=1,nchan
                   beam_data%beam_chan(j) = j
                ENDDO
    ENDIF



    !check each tbona,tboffa 
    !the values in tbona,tboffa may not be unique
    !we turn them into unique arrays here by loading
    !the unique values into switch_on_time and switch_off_time

    k = SIZE(beam_data%tbona)
    IF(SIZE(beam_data%switch_on_time).LT. k )                    &
       CALL REALLOCATE1DD(beam_data%switch_on_time,k)
    beam_data%switch_on_time(:) = beam_data%tbona(:)
    !sort switch on times,eliminate duplicate times:
    CALL sort_unique(beam_data%switch_on_time,km)
    CALL REALLOCATE1DD(beam_data%switch_on_time,KM)



    k = SIZE(beam_data%tboffa)
    IF(SIZE(beam_data%switch_off_time).LT. K)                     &
       CALL REALLOCATE1DD(beam_data%switch_off_time,k)
    beam_data%switch_off_time(:) = beam_data%tboffa(:)
    !sort switch on times,eliminate duplicate times:
    CALL sort_unique(beam_data%switch_off_time,km)
    k=SIZE(beam_data%switch_off_time)
    IF( km .LT. k)                                                  &
           CALL REALLOCATE1DD(beam_data%switch_off_time,KM)

!    PRINT *,'unique beamlet switch_on times  =',beam_data%switch_on_time  ! 88889999
!    PRINT *,'unique beamlet switch_off times =',beam_data%switch_off_time ! 88889999


    IF(ASSOCIATED( beam_data%beam_times)) DEALLOCATE(beam_data%beam_times)
    IF(ASSOCIATED(beam_data%beam_inject)) DEALLOCATE(beam_data%beam_inject)
    tmin = MINVAL(beam_data%switch_on_time)
!    if(nubeam_restart .gt. 0)then
!       tmin = time0
!       DO j=1,SIZE(beam_data%switch_on_time)
!          IF(beam_data%switch_on_time(j) .lt. tmin)THEN
!             beam_data%switch_on_time(j) = tmin
!          ENDIF
!       ENDDO
!    endif


    !if beam comes on right at time0 reset beam on time to 
    !allow for small beam risetime (THIS is not for physics
    !reasons. It is to incorporate linear in time interpolation
    !of beam power. note that beam_power_rise_time =0.0 is valid only
    !if tmin = time0).
    IF(tmin .LT. time0 .AND. nubeam_restart == 0)THEN                                !beamon before time0
       PRINT *,'beam is not allowed to be on before time0'
       PRINT *,'time0, beam on time =',time0,tmin
       lerrno = 320 + iomaxerr
       CALL terminate(lerrno,nlog)
    ELSE                                                    !beamon after time0
       IF(tmin-time0 .LT. beam_data%beam_power_rise_time)THEN
          beam_data%beam_power_rise_time = 0.5 * (tmin-time0)
          beam_data%beam_power_rise_time =                        &
              MAX(beam_data%beam_power_rise_time,nubeam_dtmin)
       ENDIF
       k = SIZE(beam_data%switch_off_time)+SIZE(beam_data%switch_on_time)
       ALLOCATE(dummy(k))
       DUMMY(1:SIZE(beam_data%switch_on_time))=  beam_data%switch_on_time(:)
       DUMMY(SIZE(beam_data%switch_on_time)+1:k) = beam_data%switch_off_time(:)

       CALL sort_unique(dummy,km)

       nx = 3*km + 2



       ALLOCATE(beam_data%beam_times(nx))
       ALLOCATE(beam_data%beam_switch_times(SIZE(dummy)))
       l=1
       ll =0
       beam_data%beam_times(l) = time0
       DO j=1,SIZE(dummy)
          tb = dummy(j)
          IF(tb .GE. time_max)EXIT
          DO k=1,SIZE(beam_data%switch_on_time)
             IF(tb .EQ. beam_data%switch_on_time(k))THEN
                l=l+1
                beam_data%beam_times(l) = tb - beam_data%beam_power_rise_time
                l=l+1
                beam_data%beam_times(l) = tb

                l=l+1                             !3/13
                beam_data%beam_times(l) = tb +  beam_data%beam_power_rise_time

                ll =ll+1
                beam_data%beam_switch_times(ll) = tb
             ENDIF
          ENDDO
          beam_data%beam_power_decay_time = beam_data%beam_power_rise_time
          DO k=1,SIZE(beam_data%switch_off_time)
             IF(tb .EQ. beam_data%switch_off_time(k))THEN
                l=l+1
                beam_data%beam_times(l) = tb
                ll =ll+1
                beam_data%beam_switch_times(ll) = tb
                l=l+1
                beam_data%beam_times(l) = tb + beam_data%beam_power_decay_time
                l=l+1                              !3/13
                beam_data%beam_times(l) = tb + 2.*beam_data%beam_power_decay_time

             ENDIF
          ENDDO
       ENDDO 
       l=l+1
       beam_data%beam_times(l) = time_max

 

       IF(l .LT. SIZE(beam_data%beam_times))          &
                     CALL REALLOCATE1DD(beam_data%beam_times,l)
      !duplicate in beam_data%beam_times  may still exist due to duplicates in 
      !beam_data%switch_off_time and beam_data%switch_on_time. Eliminate them
      !now:
    CALL sort_unique(beam_data%beam_times,km)
    IF(km .LT. SIZE(beam_data%beam_times))          &
                     CALL REALLOCATE1DD(beam_data%beam_times,km)


       ALLOCATE(beam_data%beam_inject(km,4*beam_data%nbeam))
       DO j=1,SIZE(beam_data%beam_times)
          DO k=1,beam_data%nbeam
             beam_data%beam_inject(j,beam_data%nbeam+k)   = beam_data%einja(k)
             beam_data%beam_inject(j,2*beam_data%nbeam+k) = beam_data%ffulla(k)
             beam_data%beam_inject(j,3*beam_data%nbeam+k) = beam_data%fhalfa(k)
             IF(beam_data%beam_times(j) .LT. beam_data%tbona(k)      &
                     -0.5 * beam_data%beam_power_rise_time           &
                       .OR. beam_data%beam_times(j) .GT.             &
                      0.5*beam_data%beam_power_decay_time +          &
                                                beam_data%tboffa(k))THEN
                beam_data%beam_inject(j,k) = 0.0
             ELSE
                beam_data%beam_inject(j,k) =  beam_data%pinja(k)
             ENDIF
          ENDDO
       ENDDO
    ENDIF


    DEALLOCATE(dummy)
    DEALLOCATE(beam_data%switch_off_time)
    DEALLOCATE(beam_data%switch_on_time)

   

    RETURN
    END  SUBROUTINE ufile_bypass        




    SUBROUTINE sort_unique(a,km)
!--------------------------------------------------------------------
! sort array a in asceding order,eliminate duplicate entries
! -------------------------------------------------------------HSJ----
       USE nrtype,                            ONLY : DP,SP,I4B

       IMPLICIT NONE
       REAL(DP), INTENT(INOUT),DIMENSION(:) :: a
       INTEGER, INTENT(OUT) :: km
       INTEGER i,j,k,kmm
    


       k=SIZE(a)
       IF(k .GT. 1)THEN
!          CALL vsrta (a,k)   ! sort in increasing order
          CALL my_vsrta (a,k)   ! sort in increasing order
          km=k
          DO WHILE(1 .GT. 0 ) !lf95 doesnt like DO WHILE(1) 
             kmm=0
             DO j=2,km
                IF(a(j) .EQ. a(j-1))THEN
                   DO i=j+1,k
                      a(i-1) = a(i)
                   ENDDO
                   km = km-1
                   kmm=1
                   EXIT
                ENDIF
             ENDDO
             IF(kmm .EQ. 0) EXIT
          ENDDO
       ELSE
         km=1
       ENDIF
 
       RETURN

       END SUBROUTINE sort_unique

   
    SUBROUTINE  REALLOCATE1DD(A,KM)
!------------------------------------------------------------------------------
! REALLOCATE 1DIM DOUBLE ARRAY A
! CHANGE SIZE OF ARRAY A TO KM
!------------------------------------------------------------------------------
      USE nrtype,                                        ONLY : DP,I4B,SP

      IMPLICIT NONE
      REAL(DP), DIMENSION(:),POINTER :: a
      REAL (DP), DIMENSION(:),ALLOCATABLE :: dummy
      INTEGER, INTENT(IN) ::  km
      INTEGER sizea
      sizea  = SIZE(a)
      ALLOCATE(dummy(sizea))
      dummy(:) = a(:)
!      DEALLOCATE(a)   !deallocastion of pointer not allowed in lf95
                       !according to f90 nadbook because a is a pointer array
                       !we do not have to deallocate it.
                       !(pg 181,Adams ,et al "Fortran 95 ahndbook")
      ALLOCATE(a(km))
      IF(KM .GT. sizea)THEN   !increase size of a
         a(1:sizea) = dummy(1:sizea)
         a(sizea+1:km) =0.0d0
      ELSE                     !decrease size of a
         a(1:km) = dummy(1:km)
      ENDIF
      DEALLOCATE(dummy)
      RETURN

      END SUBROUTINE  REALLOCATE1DD


   SUBROUTINE  set_beam_data(F,x,y,nx,ny,name_beam)
!  ------------------------------------------------------------------
!  The 2d UFILE  contains nx time points in x,
!  the channel no in y
!  ---------------------------------------------------HSJ-11/18/03---
   USE nrtype,                            ONLY : DP,I4B,SP
   
   IMPLICIT NONE
   REAL(SP) , INTENT (IN),DIMENSION(:,:) ::     F
   REAL(SP)  , INTENT (IN),DIMENSION(:) :: x,y
   INTEGER, INTENT (IN) :: nx,ny
   INTEGER k,j,l,m
   TYPE(neutral_beam) :: name_beam


   ufx = UBOUND(F,1)
   ufy = UBOUND(F,2) 
   lfx = LBOUND(F,1)
   lfy = LBOUND(F,2)
   uxx = UBOUND(x,1)
   lxx = LBOUND(x,1)
   uyx = UBOUND(y,1)
   lyx = LBOUND(y,1)

   IF(ufx .NE. uxx .OR. ufy .NE. uyx .OR. lfx .NE. lxx .OR. lfy .NE. lyx) THEN 
      PRINT *,'UFILE error in dimensions'
      PRINT *,'ufx,ufy,lfx,lfy =',ufx,ufy,lfx,lfy
      PRINT *,'uxx,lxx,uyx,lyx =',  uxx,lxx,uyx,lyx
      lerrno = 300 + iomaxerr
      CALL terminate(lerrno,nlog)
   ENDIF

   IF( ASSOCIATED(name_beam%beam_times))  &
      DEALLOCATE(name_beam%beam_times)
      ALLOCATE(name_beam%beam_times(nx))
   IF( ASSOCIATED(name_beam%beam_inject))  &
      DEALLOCATE(name_beam%beam_inject)
      ALLOCATE(name_beam%beam_inject(nx,ny))
   IF( ASSOCIATED( name_beam%beam_chan))  &
      DEALLOCATE(name_beam%beam_chan)
      ALLOCATE(name_beam%beam_chan(ny))

   ! note F,X,Y are type Sp. We work with type Dp 
   ! in remainder of code. So convert  here:
   name_beam%beam_inject(:,:) = DBLE(f(1:nx,1:ny))
   name_beam%beam_times(1:nx) = DBLE(x(1:nx))
   name_beam%beam_chan(1:ny)  = DBLE(y(1:ny))

   RETURN
   END SUBROUTINE  set_beam_data
   

    SUBROUTINE    set_nubeam_impure(name_beam)
! -----------------------------------------------------------------
! define nrhix, the number of impurity species
! and associated charge,mass no
! xzimpx,aimpx
! ------------------------------------------------------------------

      USE ions_gcnmp,                                ONLY : namei,nimp 

      INTEGER nrhix,j
      TYPE(neutral_beam) :: name_beam

       IF(name_beam%nrhix .GE. nimp)THEN
             name_beam%nrhix = nimp
       ELSE
          PRINT *,'name_beam%nrhix =',name_beam%nrhix
          PRINT *,'nrhix =',name_beam%nrhix
          lerrno = 311 + iomaxerr
          CALL terminate(lerrno,nlog)
       ENDIF

!impurity ions:


        DO j=1,name_beam%nrhix 
           SELECT CASE(TRIM(namei(j)))   !Name   of ith impurity ion species  
              CASE( 'he')                ! helium     
                   name_beam%xzimpx(j) = 2.
                   name_beam%aimpx(j)  = 4.002
              CASE(  'c')                !carbon                         
                   name_beam%xzimpx(j) = 6.
                   name_beam%aimpx(j)  = 12.011
                   name_beam%aimpx(j)  = 12.000
              CASE('o' )                 ! oxygen 
                   name_beam%xzimpx(j) = 8.
                   name_beam%aimpx(j)  = 15.9994
              CASE( 'si')                !silicon 
                   name_beam%xzimpx(j) = 14.            
                   name_beam%aimpx(j)  = 28.0855       
              CASE('ar')                 ! argon 
                   name_beam%xzimpx(j) = 18.
                   name_beam%aimpx(j)  = 39.948
              CASE( 'ti')                ! titanium                      
                   name_beam%xzimpx(j) = 22.            
                   name_beam%aimpx(j)  = 47.88
              CASE('cr')                 !  chromium                    
                   name_beam%xzimpx(j) = 24.
                   name_beam%aimpx(j)  = 51.9961
              CASE('fe')                 ! iron 
                   name_beam%xzimpx(j) = 26.    
                   name_beam%aimpx(j)  = 55.847
              CASE('ni')                 ! nickel 
                   name_beam%xzimpx(j) = 28.              
                   name_beam%aimpx(j)  = 58.6934          
              CASE('kr')                 ! krypton 
                   name_beam%xzimpx(j) = 36.       
                   name_beam%aimpx(j)  = 83.80
              CASE('mo')                 !molybdenum  
                   name_beam%xzimpx(j) = 42.    
                   name_beam%aimpx(j)  = 95.94
              CASE('w')                  ! tungsten   
                   name_beam%xzimpx(j) = 74.
                   name_beam%aimpx(j)  = 183.84
              CASE DEFAULT
                   lerrno = 312 + iomaxerr
                   CALL terminate(lerrno,nlog)
           END SELECT
        ENDDO

    END  SUBROUTINE set_nubeam_impure



    SUBROUTINE set_nubeam_thermal(name_beam)
! -----------------------------------------------------------------
! define ngmax, the number of thermal primary ion species and
! associated charge,mass no
! backz and aplasm
! ------------------------------------------------------------------


      USE ions_gcnmp,                                ONLY : namep,nprim,atw,atomno


      IMPLICIT NONE
      INTEGER ngmax,j
      TYPE(neutral_beam) :: name_beam

      ngmax =0
      DO j=1,nprim
         IF (namep(j) .NE. 'dt')  THEN
            ngmax = ngmax+1
            name_beam%backz(ngmax)  = atomno(j)
            name_beam%aplasm(ngmax) = atw(j)
 
         ELSE
            ngmax = ngmax+1                      !deuterium
            name_beam%backz(ngmax) =1.
            name_beam%aplasm(ngmax) = 2.0
            ngmax = ngmax+1                      !tritium
            name_beam%backz(ngmax) =1.
            name_beam%aplasm(ngmax) = 3.0       
         ENDIF
       ENDDO
       IF(name_beam%ngmax .GE. ngmax)THEN
             name_beam%ngmax = ngmax
       ELSE
          PRINT *,'name_beam%ngmax =',name_beam%ngmax
          PRINT *,'ngmax =',ngmax
          lerrno = 310 + iomaxerr
          CALL terminate(lerrno,nlog)
       ENDIF


      RETURN
    END  SUBROUTINE set_nubeam_thermal


   END MODULE P_nfreya_interface

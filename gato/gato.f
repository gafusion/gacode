c   ADD PLOT FOR EQUILIBRIUM FIELD LINE ANGLES AT EACH FLUX SURFACE IN PHI,CHI SPACE
c   Fix FILE INQUIRE TO CHECK IF FILE IS EMPTY AND QUIT IF SO
c
      program gato1
c
c===============================================================
c
c Mapping to non-orthogonal flux surface coordinate system
c
c===============================================================
c
c
c    Modification history
c    ------------ -------
c
c    06/18/1980:
c    Added ncase option:
c      ncase=0: full xsi in kinetic energy normalization.
c      ncase=1: div.xsi=0 with Y excluded in kinetic energy.
c
c    09/24/1980:
c    Added non-equidistant psi-mesh with subroutine mesh.
c    Added changes for 129x129 equilibrium
c
c    07/28/1981:
c    Changes for analytical fit to equilibrium and added npfit to namelist.
c
c    05/27/1982:
c    Added parameters nmod and nev in namelist and corrected ipsj.
c
c    07/12/1982:
c    Added cuschk to fix p<0 with cubic spline.
c    Added print for psi and rcell(z=0) values.
c
c    07/14/1982:
c    Modifications to calculate true beta with mantle.
c
c    05/03/1983:
c    Change hbf to linear interpolation outside limiter for fixed
c      boundary equilibrium (defined by ipestg=4).
c
c    01/26/1984:
c    Change to automatically set psisep = psimax.
c
c    09/01/1989:
c    Rewritten eqdmap and eqdcell to place flux surface integration grid with
c      points naturally concentrated around the tips of elongated flux surfaces.
c    Fixed ftpf to calculate qaxe in a transparent manner.
c    Fixed qmerc and calculation of qaxis corresponding to input
c      qlim to eliminate sqrt of negative quantities.
c
c    04/03/1990:
c    Rewritten eqdmap to compute equal arc and pest chi poloidal angles on the
c      (rcell,zcell) flux mesh for both cases igrid=0 and igrid = 1 and to store
c      these angles chiarcl and chipest in common/ort5/   and  write them in the
c      egta binary output file.
c
c    04/03/1990:
c    Added a Version number to be passed through ort1 and written in the egta file.
c
c    07/13/1990:
c    Modified heading to allow more than one word.
c
c    01/31/1991:
c    Modified namelist and header input and egta output to be consistent with
c      Version 12/90.
c    Called remove after cntour in eqdmap.
c    Modified sintrp to use quasi-periodic boundary conditions on arc(arcc).
c    Corrected version of uertst.
c    Modified variable dimensions in remove.
c
c    08/30/1991:
c    Added option added through idnsty in namelist to read in the density profile
c      from the eqdsk file.  Also read but not used are the EFITD q profile,
c      boundary and limiter points.
c    Modified plotg and mapbox to include plots of the density profile.
c
c    09/04/1991:
c    Mapping modified in eqdmap such that the integrations around flux surfaces
c      are carried out on 3 point centred grids.  This allowed simpsons rule to
c      be used for the q profile integration.  A third option was also added to
c      use guassian integration in garcq and used as a comparison with simpsons
c      and trapezoidal integrations.
c    Normalized chiarcl and chipest in eqdcell to 2pi with arcsurf and pestchi
c      remaining in their original units.
c
c    01/31/1992:
c    Conversion code modifications made to cft77 to enable runs in unicos, 2-92.
c
c    05/31/1992:
c    Restructured plotting routines as stand-alone routines.
c
c    08/31/1992:
c    New packing routine inserted with packing at optional surfaces defined
c      by plpak, npak, pkfrac, and qpfrac.
c
c    09/30/1992:
c    Added poloidal variable chihaml calculation with chipest corresponding to
c      the Hamiltonian-like poloidal angle.  Associated changes made to the
c      output egta file and some restructuring of the common blocks also made.
c    Placed several variables required by subroutine cntour in namelist, with
c      associated changes in names and commons.
c
c    12/04/1992:
c    Added checks to rdeqd to print warnings if nx .ne. nz  or negative pressure.
c
c    04/18/1994:
c    Reordered subroutines, realigned and cleaned up mapping routines
c      ortog, volint, .....
c    Eliminated calls to fortlib open and create and replaced them with calls
c      to standard fortran open.
c    Read and write unit numbers and file attributes placed in common.
c
c    12/02/1994:
c    Restructured main coding through ortog and volint to make code modular.
c      Split subroutine filec into fileset, readnml, writnml, and plotnml.
c      Split subroutine rdeqd into rdeqdsk and reseteq.
c      Split subroutine ortog split into setgrid, setmesh, ortogray, rescale,
c        surface, checkeq, maprz, symmetry, and writout, with subroutines
c        qmerc and mesh called from main, ftpf split into setprof and
c        setaxs0 and called from main, and surf called from surface.
c      Added new common /naml/ to transfer all namelist variables not used
c        in mapping.
c
c    12/08/1994:
c    Added options to completely bypass the mapping from (r,z) to (psi,chi)
c      and use instead an interpolation of all the required equilibrium
c      quantities from an inverse equilibrium code.
c
c    12/14/1994:
c    Recalculated first point of each flux surface in eqdmap from runkut using
c      Newtons iteration as used in cntour, so as to eliminate the numerical
c      offset of the first point and stabilize the surface integration.
c
c    04/18/1995:
c    Added option to input ratio of specific heats as a variable.
c
c    04/28/1995:
c    Added an option to calculate mapping quantities from the spline of the
c      inverse equilibrium r(psi,theta), and z(psi,theta) instead of reading
c      them all from input.
c
c    07/18/1995:
c    Added new working packing option from meshpak.
c
c    11/22/1995:
c    Added option for constant factor wall using parameter irext.
c
c    02/28/1996:
c    Added switches neqtyp (namelist) for TOQ style input and neqsym (eqdsk)
c      for up-down asymmetry.
c
c    03/01/1998:
c    Modifications to consistently calculate Fk and mesh quantities at
c      the boundary.
c    Implemented new version to write data including the edge in the tgta file.
c
c    05/28/2000:
c    Fixed error checking so that the maximum error printed out is
c      normalized the same way as the errors printed on the mesh.
c    Added ndskopt, norign, tolbtor, tolsymm, and pvansh to namelist.
c    Modified definitions of irext to consistently refer to the
c      point the wall extension is subtended from for each iwal option.
c    Fixed symmetry checks to call abortjob with different parameters
c      when multiple errors are present.
c    Added njedge to namelist to include the plasma boundary in arrow plots.
c    Renamed dpltfac and disfac and separated definitions into dsplnrm,
c      dpltfac, and psiscal in splt.
c    Added unit numbers for plot routine.
c    Added a warning if the three estimates for q disagree and selected
c      an average of the two closest if one is singnificantly different.
c    Added comments defining the equilibrium quantities Fk.
c    Corrected abortjob with arbitrary character lengths.
c    Added arrays to store local equilibrium errors for both equilibrium types.
c    Corrected double summation of global equilibrium error.
c    Density read option changed to test if density data is available.
c    Fixed imsl declaration in ibcdcu.
c    Commented out unused etime, times in timeused.
c    Fixed sintrp by cleaning up and modifying it so that ibdy does not overwrite
c      the calling data since this might be fixed.  Also added error set to
c      ier = -1 if ibdy is out of range.
c
c    08/09/2000:
c    Added vacuum error calculation with printout of bad points within a box
c      bounding the plasma.
c    Reformatted equilibrium error print out into table form.
c    Added plot of the equilibrium errors.
c    Modified calculation of maximum error in vacuum and plasma to search
c      all points, not just those exceeding delac etc.
c    Added independent setting for global (plasma or vacuum) average surface
c      and local errors.
c    Fixed construction of surfaces for averaging surface error to work in
c      all cases for any surface mesh definition.
c    Added wall time calculation and date and time stamps.
c    Added timing options for reading and writing ugta files in eigenvalue solver.
c    Rewrote parab and psifit in F77 and added namelist parameters for psifit
c      for maximum loop iterations, maximum search sizes, etc.
c    Modified call to plotpak to plot only if packing was done.
c
c    11/02/2000:
c    Modifications to packing options and meshpak:
c      Added pspak option to specify packing at prescribed psi values plus minor
c        modifications to packing routine meshpak.
c      Added option for npak < 0 to pack at specified n*q locations with npak > 0
c        reserved for packing at specified q locations.
c      Renamed several local variables.
c      Added warning when reordering packing surfaces.
c      Corrections to set interpolation coefficients when interpolations
c        failed and use iabs(npak) instead of npak.
c      Edge packing width limit from swidmn removed.
c      Common/mpak/ renamed common/rpak/ to avoid conflict with new namelist
c        variable mpak.
c    Modified abortjob to accept status level < -1 and print the status.
c
c    08/01/2001:
c    Renamed ortgray as ortogray consistently.
c    Added toroidal phase shift parameters ntphase and torphase to namelist.
c    Added plot suppression parameter plsuprs to namelist.
c    Corrected reversal of toroidal field in rdtoqmp so that the reversal is
c      independent of the reversal in psi and is only done if the signs of btor
c      and sf(npsi) are inconsistent.  This no longer conflict with the reversal
c      in reseteq.
c    Added a warning in reseteq if the sign of btor and sf are switched.
c    Corrected logic for deciding which q value to use in maparc and changed
c      some cases to use binary averages when two estimates are close.
c    Added option to read psival mesh from previous runs using the egta file
c      the tgta file, or a formatted table.  Added opens for new mgta and ngta
c      files and added variables mmesh and krdmgta and krdngta to set the option
c      and flag when the mgta and ngta files exist.
c    Minor corrections to remove f90 warnings:
c      Final do loop at statement 2040 in furplm terminated by continue.
c      Mixed arithmetic specifications in bispline defining variables one
c        and two corrected.
c      Mixed arithmetic in plotfpj defining variable nzax corrected.
c      Eliminated unreferenced variables ier in ortogray, rvalcb in toqcell, 
c      and arctp0 in maparc.
c      Eliminated unreferenced variable f1 in volint and call to abortjob
c        from call to sterpl.
c
c    01/18/2002:
c    Added integer*4 specification for nowdate and wallmsec in timeused for
c      compatibility with SUN systems.
c    Corrected print to unit 7 in uertst and replaced it by print to unit 6.
c    Added namelist variables nxuplt, nxrplt, nxpplt, nxdplt, nbiplt, nbuplt,
c      nbrplt, and nbpplt to control plotting of different representations of
c      the displacement and derivatives and the perturbed field and redefined
c      nxiplt to just control the orthogonal displacement representation to be
c      consistent with changes in splt from 10/10/2001 and 11/06/2001.
c    Added namelist variables iodbvp, iolnbp, and ioffbp to control arrow plots
c      line plots and fourier plots of the components of the perturbed field to
c      be consistent with changes in splt from 10/10/2001 and 11/06/2001.
c
c    03/13/2002:
c    Added new version of furpl rewritten to exit cleanly when mapping fails
c    Replaced default shear used in setting edge packing width by actual shear
c      to reproduce the packing from before 11/02/2000.
c
c    04/03/2002:
c    Added coding to iterate over boundary mapping decrement by adding calls
c      from main to setauxp and setdpsi which set up initial data needed before calls
c      to setgdrz and setgdpc and then iterate over decrement in boundary flux.
c    Switched around calls to setgdrz and setgpc0 in main before reseteq
c      and moved setting of ntmax earlier into setauxp.
c    Created new routine tempmsh called from setdpsi to set up temporary meshes for
c      psival needed to obtain the final start positions for the surface.
c    Added new calls to eqdmap and toqmap in setdpsi and added new argument
c      maperr to eqdmap and toqmap to flag failure.
c    Added new variables psimax0 psilim0 delpsir0 and psimax1 psilim1 and delpsir1
c      to distinguish between read in values and adjusted values after calling
c      setgrid.  All interpolations of input profiles are done using adjusted
c      values from mesh to keep stuff within range.  Only psimax should be
c      changed from recomputing the magnetic axis in magax.
c      This causes a change in the output of the profiles for psimsh(1) since
c      reseteq is now called and prints psimsh  after the magnetic axis has been
c      recomputed in setgdrz but no change in the final output.
c    Rewritten mercier subroutine
c    Added new common/pldf/   with default plot size x0min x0max y0min and y0max
c      passed through all plot routines and used in plotnml.
c    Added new variable ndoublt to force non doublet mapping and set
c      psisep = psimax instead of psisep = psilim for inverse equilibria.
c    Added source name and date with version and redefined datestamp and
c      timestamp as character*16.
c    Split title page and namelist input plot pages and rearranged both pages.
c    Increased header line size to 5 character*8 words.
c    Replaced etitl(i),i=1,4 by etitl(it),it=1,nft where nft is 5 in plottxt and
c      used etitl(it) in place of etitl(i) everywhere.
c    Added new subroutine writeql to write the input equilibrium data.
c    Reset default ncphip off.
c    Added namelist variable ndoublt to namelist and common.
c    Added namelist variables mapmaxd maxcutc norient dresolv dlclose pntshft
c      from new furplm mapping to namelist and common.
c    Added new variables dpsisd and mapmaxd to control surface mapping iterations
c      to namelist and common.
c    Reordered namelist variables npfit npcmin numstp nwtmag endtol cnvmag
c      and qptol in namelist and in common /mapd/.
c    Corrected setting of eaxe in setaxs1 to input axddxz instead of axddx
c    Removed unused paramater kmap from mapangl
c    Added option to read JSOLVER equilibria
c      Added new subroutine rdjsvmp to read equilibria.
c      Distinguished between kmap = nmap for type of equilibrium read and ktype
c      for direct or inverse equilibrium.
c      Reorganized rdtoqmp
c
c    04/03/2002:
c    Added edge option to revert to using global default width or local width
c      from local shear for edge packing and reset default nedge value to
c      automatically include the edge and use the local shear to ensure maximum
c      edge packing.
c
c    07/10/2003:
c    Added subroutine empty to empty file buffers.
c    Modified subroutine fileclos to empty buffers for proper file
c    termination prior to stop.
c    Modified subroutine abortjob to empty buffers for fatal error.
c
c    21/10/2004:
c    Added analerr to analyze equilibrium errors
c    Minor format fixes
c    New source date
c    Modified error for nx .ne. nxx to make it fatal error
c
c    16/06/2005:
c    Modified meshpak to modulate the packing for strongly negative central shear.
c    Added variables nppack and nqpack.
c    For now these are controlled by nrat but they need to be put into namelist.
c    if nppack .ne. 0 the weights of the rational q (not edge and not set by plpak)
c    are modified to eliminate those in the negative shear region (nppack > 0) or
c    those in the positive shear region (nppack < 0).
c
c    if nqpack .ne. 0 the weights of the distribution in q is modified to be evenly
c    distributed in (s**nqpack)*q.
c
c    Modified meshpak so that nrepeat now counts all the prescribed surfaces
c    but sets a flag jrepeat when prescribed surfaces are repeated.  The packing
c    weight is then switched off when packing weights are constructed.
c    Added a new common variable sweight which contains the weight of the
c    packing function at each packing point along with swidth, which contains
c    the inverse width.  sweight is now computed only once in the loop to obtain
c    the normalization and is stored and then used in the loop over packing mesh points.
c    sweight and jrepeat added to common/rpak/.
c    lratnl was changed everywhere to nratnl.
c
c    11/12/2005:
c    Added namelist variables: nsrcheg,nppack,nqpack,maptrace,precisn,nerstop,
c      maxitek,iwalsym
c    Added namelist variables: naiplt,nauplt,narplt,napplt,dspldbv,dspldav,
c      iodavp,iolnap,ioffap,iodlap
c    Switched order of nskpi nskpj
c    Fixed edge rational search to use nsrcheg instead of sign of nedge.
c    Fixed diagnostic options for furplm
c    Added new surface integral calculations:
c      Removed spline surface integration for q and sfq to new subroutine surfint
c      Added new variables f23 = S and f24 = T - S
c      Added new variables sint0 sint1 sint2 sint3 sint4(np1) to store the surface
c        integrals and renamed sint and cost as sinv cosv in subroutine restart
c      Added new variables sv0 sv1 sv2 sv3 sv4 and csveq for the surface integrands
c        and interpolation coefficients
c      Defined new integrands sv0 etc in maparc and called surfint for each in maparc
c      Defined local shear and T = j.B/grad(psi)**2 - S in eqdcell and toqcell
c      Defined surface averaged S and T from sint0 sint1 sint2 sint3 and sint4 in
c        eqdcell and toqcell
c    Passed q and fqpi integrated value through svint array through eqdmap toqmap and maparc
c    Redefined qdel as derivative of q pn psivl0 mesh
c    Modified writout to always print equilibrium and surface integral profiles
c    Added namelist variables ndnxp0 ndnxp1 and ndnxp2 to control density profile
c    Modified construction of density profile to allow forcing on axis and on edge
c    Corrected dnnorm for case when idnsty < 0:  idnsty now controls only the type
c      of density profile not the exponents
c    Added namelist variable ncorr for numerical destabilization correction
c    Corrected instance of ncase .eq. 1 to ncase .gt. 0
c    Corrected format error in printing equilibrium error symbols
c    Reordered all namelist variables into consistent groups
c    Added bfieldf to namelist and common (for rdjslv)
c    Replaced common/ort6 / by /smsh/ and added new /ort6/ with surface integrals
c    Replaced internal loop parameter ival in maparc by ivp running around the
c      surface from 1 to ntmsh1 since ival generally refers to the poloidal mesh index
c    Corrected output of maximum equilibrium error on a mesh point to distinguish
c      direct and inverse equilibria
c    Added calculation of dlnlval for inverse equilibria in toqcell:  NOTE: this is not
c      yet actually calculated but is set to 1 temporarily.
c    Modified checking of spline position values in toqcell and modified  toqcell
c    to check position values used in equilibrium quantities are unchanged from
c      spline values: Equilibrium quantities use 1D splined values but cell position
c      values use 2D spline values in toqcell:  this is not the same as in eqdcell.
c    Added nccellr to switch between using 1D and 2D splie evaluation of r,z
c      in equilibrium quantities.  Replaced default nerstop = 20 by nerstop = 10.
c    Added calculation for rst and zst in setpsim for inverse equilibria and used
c      rst(1) and zst(1) in place of seqrps(npsi,1) and seqzps(npsi,1) in surfmap
c
c    20/01/2006:
c    Added parameters nekdefn and iouta
c    Corrected factors of amu = mu0 in the averaged local shear definitions
c    Replaced amu*ppvalp constructions in eqdcell by predefined amuppv and amugp as
c      done in toqmap
c    Replaced factor ffpvalu in savge and tavge definitions in toqcell and eqdcell
c      by corrected fpvalu and divided by sint0(j).
c
c    18/02/2006:
c    Reordered namelist variables and added descriptive definitions:
c      Switched order of dsplnrm, dpltfac, and  arrow scales
c      Moved ntdecr and ntmmin to general parameter section
c      Moved errsep to tolerances and reset to 0.1 e-04 from 0.3e-04
c      Set rmantl to zero from 0.02
c
c    17/03/2006:
c    Saved qprime from savge and passed qprime and dlnlval through egta
c    Corrected comment definitions of f4, f7, and f14
c    Added namelist variable corrfac and reordered ncorr in namelist
c    Corrected calculation of redge in setgpc0 to ensure redge > 0
c    Modified input axis pressure and density check to count zero as well as
c      negative values and to distinguish between zero and negative axis values
c    Modified furplm to add new diagnostic information when multiple or no grid
c      cell exits are found
c
c    31/03/2006:
c    Modified furplm to prevent flipping direction but instead only skip the cell
c      to the next one over and removed special logic for curve moving down.
c      Deleted iflip logic in furplm
c    Replaced error checking of dimensions in rdtoqmp and rdjsvmp to use variables
c      nppd and nttd instead of parameters npp and ntt
c    Modified reseteq to check for sign inconsistency in btor and sf and
c      reset btor accordingly
c    Added output comments when reading in mesh with nmesh < 0
c    Added checks for consistency of input namelist with vacuum calculation
c
c    26/07/2006:
c    Replaced calls to setlch in setting characters for pointc by appropriate call
c      to setpch with additional kspace parameters set
c    Added a vertical shift of zma to plot of plasma equilibrium map 
c    Renamed subroutine setgpc0 to setgdpc to be consistent with setgdrz
c    Added plot of plasma boundary to plot of plasma equilibrium map
c      Added variable zlowr set in setgdrz and setgdpc to set
c      lower boundary of the mesh for use in setting the box in plotmap and ploterr.
c    Reset the r and z grid in setgdrz to uset zlowr.  For a standard direct
c      equilibrium file zlowr is set automatically at -0.5*zdim
c    Modified error diagnostics in case of misordered tp array in maparc
c
c    Corrected option for npst = 1 to use sf and sp to calculate ffprime and pprime
c      For npst = 1 spp and sffp are ignored.  In reseteq spp and sffp are reset
c        to be correct from differentiating sp and sf but ignored.
c        An option can be set to use these values subsequently instead of 
c        recalculating values from sp and sf.  
c      Corrected bug in reset eq where zffp was set using undefined f(jvl) instead
c        of zf(jvl)
c      Corrected plotfpj to calculate sffp and spp consistently from sp and sf
c      Modified plotfpj to plot sf(psi) and sp(psi) for npst = 1
c      Corrected setaxs0 and surface to calculate sffp and spp consistently from
c        sp and sf at the axis and limiter
c      Corrected mercier to use spp consistently from sp at the axis 
c      Modified calculations for npst = 1 and error messaging.
c      Modified ipestg input to force ipestg = 3 if input is less than or equal to zero
c      Added warning message when setting npst = 1
c      Added printouts of npst in writout and reseteq
c     Reorganized setaxs0 to decide which qaxis to use on basis of which is determined
c      to be valid
c
c    30/10/2006:
c    Replaced ncase consistency check with density profile by check on ncase
c
c    18/01/2007:
c    Added new parameters ndivert, plossmx, lineplt,lampplt, npowr to namelist
c      and accordingly to common
c    Created new source date for 18 January 2007
c    Reordered namelist parameters iowalp iomshp and ioeqlp
c    Corrected psifit to handle alternative profiles: wrote sterp2 to compute
c      second derivatives
c    Modified plotfpj:  redge -> xl and changed plot size
c    Modified plotint to fit scales for save and tave when > 10**5
c    Some realignment of statements in rhbf zhbf and runkut
c    Revamped rdtoqmp to parallel rdjsvmp:
c      Changed rdtoqmp to do same order as rdjsvmp (reset units early)
c      Set abortjob to -1 for discrepancies in sreqps (1,ii) etc.
c      Moved write statements after abortjob calls and remove 'Warning'
c      Checked dimensions
c      Set nprofl nthet and nthp1 early
c      Switchd jkm0  and jkp0   and also jkm1 and jkp1
c      Summed the discrepancies in testing on axis and symmetry
c      Set xlim and zlim xsep zsep in both rdtoqmp and rdjsvmp
c      Used rndofr etc in testing for smallness - especially of seqrps etc.
c    Enforced p(nprofl) = 0.0 in rdjsvmp
c
c    01/05/2007:
c    Cleaned up coding in eqdmap:
c      Moved parameter initialization to beginning of eqdmap
c      Corrected mistype error flag (ker1 to ker2) in eqdmap
c      Modified resorting in eqdmap to flag when resorting occurs
c    Corrected several bugs in furplm:
c      Added possibility of cutting through initial grid point
c      Added new tag idnti indicating grid entry option taken
c      Corrected diagnostic printout to distinguish current (i,j) from the
c      (i,j) actually used in fitting the point
c      Corrected redefinition of ix and jy when curve passes through a grid point
c      Added new warnings when curve passes through a grid point and when
c      curve is outside the range and moved back in slightly off a grid point
c      Reset pntshft to reduce this shift
c    Modified procedure for resorting mapping points in sorter:
c      Added error diagnostics
c      Added warnings when order is reversed
c      Replaced test for reordering sign(dot/cross) by sign(dot*cross)
c    Modified error messaging in furplm to usually print out jsurf and np
c    Modified error messaging to terminate when flux surface mapping fails
c    Moved eaxe calculations in rdjsvmp to setaxs1 for any inverse equilibrium
c      mapping
c    Put elong from neighbouring axis elongation in common
c    Added parameter nqaxis to force axis fit to either option in setaxs0
c    Added array for rstp(np2) and zstp(np2) containing the actual flux surface 
c      starting points
c    Moved call to restart in eqdmap to before hbf since hbf finds the grid point
c      closest to the starting point which should be redifined first.
c    Corrected call to hbf from eqdmap to set search initialization at rs1,zs1
c      instead of (r1,z1) = (xma,zma)
c    Moved namelist parameters bigno and roundff from common /mapd/ to
c      common /cnst/ and passed into subroutine restart
c    Corrected warning and error messaging in eqdmap and sorter to print warnings
c      only when reversing sense or making a large reordering by more than a few
c      points
c    Renamed r1,z1,is, and js in eqdmap to rcn1,zcn1,ist0, and jst0
c    Modified fatal error when npc < npfit to a warning
c    Redefined small for checking insignificant values in sorter as errsep*dx**2
c    Reset nptt larger to 2401 to accomodate a large number of rational surfaces
c
c    26/07/2007:
c    Modified output to print a history of the individual surface mapping steps
c      including whether cntour or furplm was used:
c      Summary printed from maprz and mappc
c      Passed map identifier mapid
c      Renamed idmap as maponly
c      Passed npcb (formerly npcd) and npcf counters for number of points before
c        removal and from first pass with furplm through common / sarc/
c      Deleted write from within eqdmap for when furplm mapping is replaced by
c        cntour mapping
c    Reset ntmmin as the minimum of nlx/2 and 2*jpsi and ntdecr as narcmx/100
c    Corrected error message printing for tp and tpp in maparc to use the original
c      total number of points instead of the new reset number ntmsh
c    Corrected namelist defaults for nismax njplot and niplot
c    Added printout of original negative pressure from sp and sdns
c
c    12/09/2007:
c    Added option idnsty > 2 to read just nmass without kvtor.
c    Added arrays psinitl qpinitl rsinitl and zsinitl to store and compare initial
c       mapping with final mapping.
c    Moved print of q profile to new standalone routine prqprof for both direct
c      and inverse equilibrium options.
c      Code now prints out:
c        Only q in standard out but for both initial and final mapping
c        Both psi and q into the ascii output file for initial and final mapping.
c        q difference and fqpi into the ascii output file for final mapping.
c    Rewrote error messaging in ortogray and added parameter to subroutine call
c      to print detailed error data on call from main program.
c      Modified initialization of runkut call for Dee and Doublet.
c      Extensively modified error messaging for Dee case.
c    Completely rewrote runkut Runge Kutta integration:
c      Replaced iteration over target with test by a simple loop.
c      Replaced multiple changes in direction by simpler sequential logic.
c      Added kuttop, nrkmax0, and nrkmax1 to namelist and common to control new
c        options and loop limits.
c      Redefined numstp to now set the maximum number of steps taken per target
c        value inside subroutine runkut.  nrkmax0 is now used to set the maximum
c        number of attempts at setting a step size for subroutine runkut.
c      Reorganized error messaging.
c      Renamed internal variables.
c      Renamed rhbf as rkuttar and zhbf as rkuttaz.
c      Added options using kuttaop to perform proper Runge-Kutta integration in radial
c        direction (recalculation of mid interval gradient was previously bypassed)
c        and resetfirst point as exact start point in place of the slightly
c        displaced point used to avoid finding zero gradient.
c      Added internal loop to determine initial step far enough to obtain a meaningful
c        gradient but small enough to avoid passing the first target surface.
c      Rewrote error messaging to trap and handle errors. 
c    Completely rewrote  rkuttar and rkuttaz:
c      Added smallness parameter and error flag.
c      Modified error messaging to reduce text and instead pass main message to
c        calling routine.
c      Clarified coding to make Runge-Kutta algorithm explicit.
c      Reduced overwriting of internal variables for simplified debugging.
c    Completely rewrote hbf:
c      Reorgaized coding and error messaging.
c    Corrections to error messaging in maparc when tp or tpp grid is misordered:
c      Renamed variables in maparc.
c      ntry replaced by missd.
c      ktry replaced by ntry.
c      Added separate error messages for missd < 0 (ntmsh .lt. ntmmin) and
c        missd > 0 (ntry > ntrymx).
c      Corrected reduction of ntmsh when new ntmsh < ntmmin.
c      Corrected error message when both tp and tpp are misordered.
c      Rorganized output from error messaging when points misordered.
c    Added print out of direct equilibrium mesh.
c    Minor reformatting of output.
c    Modified abortjob:
c      Allow termination with message but not explicitly as an error.
c      Distinguish serios warnings from important warnings.
c      Line up error messaging.
c      Call fileclose on termination with timing information printed.
c    Modified furplm to print different warnings when point is slightly
c      outside grid cell or in next grid cell or well outside range.
c    Modified error message when npc < npcmin compared to npc < npfit.
c
c    12/10/2007:
c    Corrected rstp and zstp to properly save rst and zst before being
c      modified by eqdmap.
c    Initialized calculated psi functions in setauxp.
c    Modified and corrected symmetry checking
c      Corrected symmetry of f23 and f24 for up-down symmetric cases:  f23
c        and f24 are both symmetric with up-down symmetry.
c      Modified symmetry test to print maximum discrepancy when it exceeds
c        the tolerance.
c      Added namelist variables nerprnt and tolaugm to control printing of
c        large arrays as a diagnostic of a failure in the symmetry check.
c    Modified the check of f23 and f24 surface averages to print the check
c      differences as well as the ratios.
c    Modified timing to be called from within first and final subroutines
c      fileset and fileclose
c    Renamed subroutine fileclos as fileclose for consistency across code.
c    Modified warning for edge packing using global shear to print the data
c      as a comment rather than a warning.
c    Modified setaxs1 to use the sign of nqaxis to choose which estimate of
c      qaxe to use and the value of nqaxis to choose which estimate of the
c      axis elongation to use.
c
c    14/11/2007:
c    Rewrote subroutine fit with full error checking
c    Replaced variables v and p in subroutine furplm by vp and pvl.
c    Replaced common variables vp and ap by vpm and apm.
c    Corrected error in runkut setting drg and dzg from psifn and psist
c    Added new namelist variables nwtfitp,  nwtfitm, tolnwtp, and tolnwtm for
c      control of fit routine
c        Added to namelist and to common and passed in ortogray and eqdmap to
c          runkut and furplm.
c
c    19/02/2008:
c    Restructured dimensioning of Linear Algebra routines and psi spline arrays:
c      Rewrote icsici  ludecp  luelmp vmulfm  vtprof  viprff dbcevl ofima3
c      Consistently dimensioned spline array cspln1 as 3D array taking account of
c        third dimension really being 2,nzd:
c      Added dimension of r and z direction as parameter in subroutine calls to
c        magax, cntour, and restart.
c      Rewrote dimensioning in all calling routines
c      Removed error flagging in setaxs0 for nx .ne. nz.  Flag for avoiding calls to
c        psifit is retained but the conditions should never occur.
c    Restructured dimensioning of cspl1 and the work array wk internally in
c      subroutine ibcccu so that wk is divided into two separate work arrays work0
c      and vork0 and dimensioned consistently within ibcccu  and the dimensions of
c      cspl1 are switched by equivalence with cspl1p so it can be used intenally
c      in ibcccu and ibcdcu
c      Eliminated parameter nwk and replaced by new parameter nw2 = 2*nxx
c    Differentiated work array wk used in ofima3 and subsequent routines as wkx
c     and dimensioned locally
c    Renamed kdo as maptyp
c    Performed substantial local code realignment and cleanup
c    Rewrote subroutine cuschk to rename variables to avoid confusion
c        and include flag if coeeficients are reset.
c    Rewrote subroutine cubic
c    Added new namelist variables prfrac and zeffect
c    Added calculation of betax0 and betax1 in volint
c      Set pcutoff at pvansh in volint and moved pvansh from common/naml/   to
c        common/volm/
c      Renamed pfactr as punits in rdtoqmp to avoid confusion
c    Reordered check of equilibrium errors to print warnings first if the errors
c      exceed the maxima and then print the values
c    Moved print output from volint to writout and moved call to writout to after
c      call to volint
c    Replaced error output in uertst by call to abortjob with appropriate error
c      string
c    Renamed wk1 and vk1 as work1 and vork1 and corrected dimensioning in some
c      of the calls to feqint and feqins using (npx,ncx) instead of (np1,nc1)
c    Removed unused parameter jpvv in feqins
c    Replaced use of csx, csz, cseq1, and cseq2 in computing integrals btave,
c      bpave, volme, and betat by arrays bavet, bavep, pvolm, and betav
c    Added constants boltzm, echarg, and pmass to default and common for use in splt
c
c    21/09/2008:
c    Added ifastp and betaf to namelist and common
c    Added read in of fast particle pressure profile from file fastp.dat
c    Added open for fastp.dat
c    Added parameters kufst filfst 
c    Added new arrays spsis and sfast containing fast particle pressure profile as
c      read in and dimension nfast
c    Added new arrays sfstp and csfst for fast particle pressure profile splined to
c      psimsh
c    Added new array pfast for fast particle pressure profile splined to psival
c    Added new variables pfaxe pflim and pfnorm containing axis and limiter values,
c     and normalization
c    Added new version and new source date
c    Added namelist variables iodjvp, iolnjp, ioffjp and iodljp to control arrow
c      plots line plots and fourier plots of the components of the perturbed
c      current density to be consistent with changes in splt
c    Added namelist variables nddplt  njiplt njuplt njrplt and njpplt to control
c      plots of the components of the perturbed current density to be consistent
c      with changes in splt.
c    Modified uertst to print ier1 instead of ier
c    Added print out of axis and limiter values of profiles to subroutine writeout
c    Added print out of normalizations dnnorm and pfnorm
c    Reset al0max at -0.10e-09
c    Cleaned up comments in definition of namelist quantities.
c    Replaced namelist plot pages by three pages.
c    Added constants boltzm, echarg, and pmass
c    Pass new variables to mapping file: arcnorm, dnaxe, pfaxe, qppaxe, dlnaxe, arcaxe,
c      pfnorm, savgax, tavgax, sntax0, sntax1, sntax2, sntax3, sntax4
c    Added namelist variable ioutt to control print output from diagnostic code splt
c    Fixed ibcccu and ibcdcu dimensioning.
c    Corrected dimensioning in runkut and calls to hbf, fcn, rkuttar, and rkuttaz
c      Passed nwd as well as nhd through each.
c
c    21/10/2008:
c    Modified option for ifastp to include options for columnwise input files and input
c      as a function of normalized psi
c      Switched options for profile in kPa and in Pa
c    Modified option for ifastp to include options for input in MPa or as a beta profile
c      (units 2*mu0/B**2)
c    Moved fast particle pressure read and calculation to new routine rdfastp to be called
c      independently of the type of equilibrium file.
c    Replaced default betaf to betaf = 1.0
c    Modified reseteq to reset input pressure, density, and fast ion pressure to zero when
c      negative
c
c    31/01/2009:
c    Corrected ibcdcu for spline calculation to enable non square direct equilibria and
c      equilibrium dimensions exceeding the data size
c    Replaced loop in setdpsi by iterative loop
c      Replaced dpsisv inside setdpsi by dpsisw set to dpsisv after the calculation is successful
c    Added capability for bisection search of the last closed flux surface up to mapmaxd or until
c      the difference in increments is below dpsisd
c    Rewrote tempmsh with dummy variables for psival, psivl0, and jsep while passing jpsi1,
c      ndoublt, numax, psipak, and psincr
c    Corrected Doublet jpsi = jpsi - 1 followed by jpsi = jpsi + 1
c    Replaced mesh calculation in setmsh by call to tempmsh
c    Renamed tempmsh as compmsh
c    Corrected all timeused calculations to add a day if the date changed
c    Removed warning for ndivert = 0 (limiter) with direct equilibria
c
c    Replaced fqi everywhere by fqpi.
c    Moved npowr from common/naml/   to common/inpd/   to use in plotting
c      qprime profile
c    Added jpsi2 to common
c    Added calculation of fqim = (fqpi - qp)/f to common and output
c    Replaced fqaxe by fqiaxe and added fqmaxe and fqmlim
c    Corrected print out of fqpi on axis
c
c    20/02/2009:
c    Added new routines mshcomp psicomp ratcomp and intcoef to compute radial
c      flux functions
c      Added new routines qprplot rhoplot and drhplot to plot the radial flux
c        functions and derivatives
c      Added new commons auxmsh ratnl and labels containing the radial flux
c        functions, their derivatives, and the rational surface values
c      Renamed psivl1 as psivl0 and added new array psivl1 with psi counted
c        from the magnetic axis to the edge.
c      Eliminated psiplt in favour of psvmsh and psivl1
c      Redefined psivalu as the poloidal flux set at zero on axis instead of
c        the edge and redefined psivalq accordingly
c      Corrected definition of shear using psivalq in shearps
c    Added output to new data file filgrd containing the grid psivalu, psivolm,
c      and the rcell, zcell points
c      Added variables filgrd and kugrd
c      Added new routine writgrd to write to filgrd
c    Corrected all calls to fcn to detect error from out of bounds index
c    Modified all calls to abortjob to allow integer locations > 100 and
c      36 character strings
c    Moved calls to ncarcgm and plote to plotg from filset
c    Cleaned up fileset
c    Extended data array initialization to full dimension of array
c    Modified setmesh to read in jpsi and reset jpsi if different from namelist input
c      Added error trapping for insufficient or inconsistent data
c    Corrected multiple bound and initialization errors:
c      Use of qaxe intstead of qax0 and eax0 in qaxtol, eaxtol, qaxerr, and eaxerr
c        in setaxs0
c      npsi and nthet in maparc replaced by n1pts and n2pts set as nx,nz or npsi,nthet
c        depending on mapping type
c        Added common eqd1 and parameters nxx, nxz,nh2, nw2, and nvk0 to maparc to pass
c          nx and nz
c      Added parameters ipg and pslim to rkuttar and rkuttaz calls to pass through to hbf
c      Added initialization of psifn in runkut
c      Dimension of xp and zp in furplm reset to npmax instead of np
c      Defined rst1 and zst1 in eqdmap from restart for use on mapping failure
c      Moved print of xlim and zlim from writeql to writout since it is not defined
c        until orthog in direct equilibrium case
c      Added initialization of psmmgta and pslmgta in setmesh
c      Added initialization of intval1 in subroutine fit
c      Corrected initialization of mapsuccs in setdpsi
c      Added dimension ypi(1) in maparc to be consistent with sintrp call
c      Corrected checkeq to define jmin, jmax in terms of npsi only for inverse mapping
c      Set initialization of arrays to run over the full dimension
c        Initialization of eqerror and tqerror in checkeq
c        Initialization of psi and profile arrays 
c      Added initialization of all calculated flux functions and equilibrium functions
c        in setauxp
c      Defined smap(2) for non doublet case
c      Corrected all calls to alog and alog10 to avoid arguments less than or equal
c        to zero
c      Corrected plotmap to plot poloidal angles all the way out to the boundary
c      Renamed npsiq as numbqs to avoid naming conflicts with npsi and renamed
c       psimx1, psimx2, psimn1, and psimn2 as psmax1, psmax2, psmin1, and psmin2
c       to avoid naming conflicts with psimx(1) and psimx(2)
c      Restricted calculation in maprz and mappc of axis surface integral values to 
c        kcell = 1 only
c      Replaced loop over jpsi by  jpsi1 in setpsim for calculation of psim1 and psim2 
c      Moved fval calculation in toqmap and set fval = sf(nprofl) for
c        jval = 0 to avoid call to sterpl before csf is defined
c      Defined sfqi for inverse equilibria as sf*sqvl in rdtoqmp and rdjsvmp
c      Moved test for nx odd and calculation of delar to after return for
c       inverse equilibria in volint
c      Added initialization of volume and well arrays apm, vpm, vdpsi, well,
c        pvolm, and vcurnt in volint
c      Added initialization of beta and bave, bpornl, allim, deltal, pmantl, welln
c        scalars in volint 
c      Moved calculation of q0surf in volint to initialization to ensure
c       calculation for inverse equlibria
c      Defined dmx dmz and zlowr in setgdpc
c      Added ndim1  and ndim2  to common/ort1/
c        Set in setgdrz as nx,nz and in setgdpc as npsi,nthet
c      Removed stop in mercier for nx .ne. nz
c      Reorganized plotfpj slightly to differentiate data needed only for direct
c        equilibrium plots
c
c
c    20/07/2009:
c    Added new equilibrium quantities f15, f16, f17, f18, f19, f21, f25, f26, f27,
c      and f28
c    Replaced tval(1) = J by tval(1) = 1/J in derivpsi
c    Rewrote eqdcell and toqcell to be clearer, simpler, and more consistent
c      with comment definitions
c    Rewrote eqdcell and toqcell to compute Jacobians,  nonorthogonality for
c      arclength angle, PEST angle, and Hamiltonian angle in new subroutine
c      betachi
c    Added sv5 to contain integrand of dlog(r**2)/dpsi [normal]: 
c      dlog(r**2)/dpsi = (2/r)dr/dpsi = (2/r)*dpsi/dr*(1/grad(psi))
c    Added calculation of derivative of the normalization dpnlval and dhnlval
c      with dlnlval for the PEST and Hamiltonian angles
c    Replaced up-down symmetry check for two-dimensional arrays with call to new
c      routine symchek
c    Corrected definition of st2 from maparc as r/grad(psi) * (1/Jham) and all
c      definitins of fqpi to be consistently the same as q when Jham = Jpest
c      Jham  = (fqpi/f)*((r**nham1)*(Bpol**nham2)*(Btot**nham3))
c    Added argument jval to cntour call to track fatal error from not closing
c      the contour
c    Modified output to add explanations
c    Added global error count for total number of acceptable and unacceptable
c      errors in the plasma and vacuum separately
c    Modified eqdmap to handle errors and failures
c      Readjust npfit when both furplm and cntour fail and then reattempt the
c        mapping with halved npfit
c      Added a warning in eqdmap when the first surface inside the boundary is
c        mapped with cntour
c      Modified the check for when the surface being mapped by cntour is too
c        close to the plasma boundary: too close is redefined from dpsisv to
c        delpsir/jpsi1.
c    Added NetCDF output from writnova
c    Renamed writout, writgrd, and writmap as writeout, writegrd, and writemap
c    Added new subroutine rdqsvmp to read q solver equilibria from unformatted
c      file with fixed dimensions with nmap = -2
c    Modified rdjsvmp slightly to use neqtyp = 1 in place of nmap = -2 for reading
c      aj3 and aj0
c    Rewrote subroutine fileset:
c      Split fileset to open namelist input first so namelist can be read before
c        opening other files
c      Redefined krdmgta krdngta and krdfast so they are set in readnml according to
c        nmesh and ifastp and then used in fileset to decide whether to open the files
c
c    Replaced all main program calls to routines with argument nmap with no argument
c      Routines all set kmap  =  nmap from common
c    Added common variable nmtype and set ktype = nmtype when used to distinguish
c      equilibrium type (direct or equilibrium)
c    Corrected analerr to use ktype = nmtype instead of ktype = nmap so that inverse
c      equilibria with nmap < 0 are treated
c    Added ratio of delstr and rtside to equilibrium error printout
c    Added rdefolt to namelist and common to set rcnt if none comes from the equilibrium
c    Replaced nonorthogonality for the surface by local value instead of betachi calculation
c      in the c&ase of inverse equilibria
c      Added dpedg1 and dpedg2 to common to specify the psi equilibrium mesh
c        increment for the last two cells
c      Replaced test for closeness to the boundary in eqdmap as dedg1 in place of delpsir/jpsi1
c    Added pstnorm and hamnorm to writemap output
c    Added pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv to writemap output
c    Added psivalu, psirhov, psitorf, psivolm, dpsirho, dpsitor, dpsivol to writemap output
c    Added psivlq,  qprimq, qvalue, psirhoq, psitorq, psivolq, dpsirhq, dpsitfq,
c      dpsivlq to writemap output
c    Added shearps, shearrh, sheartf, shearvl, epslrh1, shearrh1, shearfrh, epslvl1, shearvl1,
c      shearfvl to writemap output
c    Created new version = 'vs 09/09' and new sourcdat
c
c    Added warning in setaux for psimax > psilim
c    Added warnings to runkut for including additional diagnostic data when initial
c      step fails to find an appropriate step size
c      Replaced setp by step0 and step0 by stepp in runkut
c
c    20/01/2010:
c    Added read option for binary QSOLVER   file equilibrium format
c      Option set by nmap = -2 (direct     access) or
c                    nmap = -3 (sequential access)
c    Added read option for binary CORSICA i-file equilibrium format
c      Option set by nmap = -4 (sequential access)
c    Defined krdeqlb to set ASCII or binary file read access
c    Added check in setaxs1 for case where no input axis elongation is available
c    Replaced arclength construction in maparc by a call to a new routine
c      arclng for both the real contour and rescaled contour
c    Replaced all references to 'imaginary' surface by 'rescaled' surface
c
c    26/04/2010:
c    Added argument for rndoff to all calls to sterpl, sterpp, and sterp2, set to
c      namelist input roundff
c      Added argument rndff to fqintp,feqint, and feqins
c    Added arclength calculation for input inverse equilibrium with check on
c      equal arclength for nmap = +1, +2, -1, -2, and -3 and with reset to equal
c      arc mesh for nmap = -4 (i.e. for TEQ i-files)
c      Added reset to arclength for nmap = +1, +2, -1, -2, and -3 if discrepancy
c        is large
c    Replaced local variable tolqpl by tolqpr and tolqpv everywhere to avoid
c      confusion with tolqp1
c    Added namelist variable tolbchi for error checking of nonorthogonality
c      for inverse equilibria
c    Replaced normalization for nonorthogonality check by maximum of local value
c      and global value
c    Skipped check of nonorthogonality and jacobian for inverse equilibria
c      for surfaces close to the edge
c    Used nonorthogonality calculated locally consistently for inverse equilibria
c      for surfaces close to the edge
c    Added namelist parameter mpreset to force resetting of input equal arc inverse
c      equilibrium to calculated equal arc mesh
c    Reset nck to nlx from np1
c    Modified abortjob to print integers to i8  to account for matrix addresses
c    Corrected reset of ndivert and npowr when inconsistent
c    Renamed fqi1 as fqpi1 for consistency with splt
c    Corrected definition of log plot of qprime to revert to just qprime when
c      npowr = 0
c    Corrected plotqpp to correctly handle log plot for qprime and revert to
c      (1-s)*qprime when npowr = 0
c      Switched curve labels for q and qprime: q is now 'q' and qprime '+' with
c        the modified qprime as 'm'
c    Reset default ncorr from zero to one so that numerical restabilization is
c      the default
c    Added new routine chkprof to check consistency of input profiles
c      Added new namelist variables nspbc0 and nspbc1 to define spline
c        nonperiodic boundary conditions
c    Corrected error in messaging from cuschk
c    Replaced print of midplane values in writeout by input data for EFIT
c      fixed boundary calculation
c    Added data print out in betachi when discrepancy in r1 and r1p found
c    Added print out of pprime and dnsty normalization for plot of pprime and
c      dnsty and corrected setting for maximum pprime
c    Corrected meshpak to properly handle the case where nrat >= jpsi for which
c      zfrac2 and zfrac3 were otherwise zero
c    Corrected definition of fqpi and fqim to be properly defined and reduce to
c      fqpi  = qp and fqim   = 0 for the case with nham1 = +2, nham2 = nham3 = 0
c    and to the previous definition of fqim when nham1 = nham2 = 0 and nham3 = -2
c      Reset the default nham3 = -2 from +2 to properly treat the hamiltonian case
c      Redefined the axis values of fqpi and fqim
c      Redefined fqim to be dimensionally consistent for all options.
c    Added namelist parameter novap to control output for NOVA-K
c    Modified construction of initial flux surface mesh to add a finite element
c      node within psincr*delpsir/jpsi of the magnetic axis for standard Dee in
c      order to better mimic the uniform mesh used in other codes such as NOVA
c      Reset default psincr to zero to bypass placing the additional point as the
c        default case when psipak = 2.0 since otherwise the first off-axis mesh
c        point is too close to the axis and the first step in runkut fails
c    Modified the definition of psincr for the Doublet case so that the initial step
c      near the Doublet separatrix is now 1.0 - psincr
c    Corrected logic error in fileset checking format of input mesh files and fast
c      ion file 
c    Moved calculation of individual electron and ion density and temperature profiles
c      to separate new subroutine kinetic and saved the variables in new common/kinetc/
c      Added print of kinetic profiles to NOVA output
c    Modified runkut to print a serious warning if the initial interpolated point
c      on axis is past the target point and reset it to the actual axis value and
c      to quit whenever the target psi value is less that the previous value
c    Modified abortjob slightly to replace 'Important Warning' by Serious Warning'
c      when status number is .lt. -2
c
c
c====================================================================
c
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nft=5)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
      parameter (nhd1=5,nhd2=3)
      parameter (nck=nlx)
      parameter (nbd=1600,nbl=1200)
      parameter (nsm=13)
      parameter (nvn=7)
c
      character*1   symbl,eqsymbl,tqsymbl
      character*1   symchar
      character*1   lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst ,lbchvl, lbchsv
      character*8   headr
      character*8   etitl,date
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*8   pclab,  tclab,  labpsi, 
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      character*16  sourcnam,sourcdat
      character*16  datestamp,timestamp
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/naml/  norm,nmod,nlt,nlim,toldrdz,
     &              iwal,iwalsym,nwall,
     &              irext,norign,nekdefn,maxitek,
     &              rext,rexmax,rcutoff,
     &              nrestrt,ndskopt,ndsktim,ndsksz,buffact,
     &              nev,neigmax,nforce,nreslv,nbrmax,
     &              nismax,ncymax,nitmax,ncyfin,mxdcomp,
     &              al0,dal0,al0bas,al0min,al0max,epschy,epscon,
     &              lineplt,lampplt,njplot,niplot,nskpj,nskpi,njedge,
     &              ntphase,ncont,ncplot,mshpsi,mshchi,nxisgn,
     &              nxiplt,nxuplt,nxrplt,nxpplt,nxdplt,ncphip,
     &              nbiplt,nbuplt,nbrplt,nbpplt,
     &              naiplt,nauplt,narplt,napplt,
     &              ndpplt,njiplt,njuplt,njrplt,njpplt,nvfft,
     &              torphase,dpltfac,dsplnrm,dspldbv,dspldav,
     &              psiscal,plsuprs,
     &              iomshp,ioeqlp,iowalp,
     &              ioeigp,iodbvp,iodavp,iodjvp,iopsip,
     &              iolinp,iolnbp,iolnap,iolnjp,
     &              iofftp,ioffbp,ioffap,ioffjp,
     &              ioconp,iodlbp,iodlap,iodljp,iodlwp,
     &              ioutw,iouta,ioute,ioutt,ioutp
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/cntd/  nbpmx,nwtmx,nslmx,nhfmx,bperr,dang,arcl,
     &              serrs,serrt,delgp,stfrac,rnderr,
     &              xaxd,yaxd,xmin,xmax,ymin,ymax
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/rpak/  nratnl,nwtot,cs(np1),
     &              qnval(np1),ldone(npk),mdone(npk),
     &              swgt (nptt), wght (nptt),
     &              dwds (nptt), qwgt (nptt),
     &              srat  (nrtdm),qrat   (nrtdm),dqds (nrtdm),
     &              swidth(nrtdm),sweight(nrtdm),jqrat(nrtdm),
     &              jplpak(nrtdm),jrepeat(nrtdm)
      common/dstr/  eqderor(nxx,nxz),toqeror(npp,ntt),surfpsi(nck),
     &              surferr(nck),surfcur(nck),nsrferr(nck),ksrferr(nck),
     &              toteror,toterov
      common/anal/  kntdlf(nsm),dlfac(nsm),symbl(nsm),
     &              eqsymbl(nxx,nxz),tqsymbl(npp,ntt)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/kinetc/pfactr,tfactr,dfactr,pffact,deutp,dmass,dnnova(np2),
     &              pfnova(np2), ptnova(np2), prnova(np2),pbnova(np2), 
     &              tenova(np2), tinova(np2), denova(np2),dinova(np2)
      common/psft/  rpsi,zpsi,rj0,rjp,rj3,rj5,rj7,sa0,sa2,sa3,sa4,
     &              sb2,sb3,sb4
      common/labels/lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst, lbchvl, lbchsv,
     &              pclab,  tclab,  labpsi,
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      common/pldf/  x0min,x0max,y0min,y0max
      common/tcpu/  timcpu,timiop,timsys,timwal,datestamp,timestamp,
     &              tim0c,tim0i,tim0s,tim0w,tim1c,tim1i,tim1s,tim1w
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c     Equilibrium Quantity Definitions:
c     ----------- -------- -----------
c
c     chiarcl =   Arclength normalized to 2pi
c     chipest =   Pest poloidal angle
c     chihaml =   Hamiltonian poloidal angle
c     xjcarcl =   Jacobian for arclength normalized to 2pi
c     xjcpest =   Jacobian for Pest poloidal angle
c     xjchaml =   Jacobian for Hamiltonian poloidal angle
c     alfarcl =   Nonorthogonality for arclength normalized to 2pi
c     alfpest =   Nonorthogonality for Pest poloidal angle
c     alfhaml =   Nonorthogonality for Hamiltonian poloidal angle
c     arcnorm =   Period for arclength coordinate on surface (Total arclength)
c     pstnorm:    Period for PEST coordinate on surface (Set to 2pi)
c     hamnorm:    Period for Hamiltonian coordinate on surface (Set to 2pi)
c
c     dlnlval:    Logarithmic derivative of the arclength   normalization:
c                 [dL/dpsi / L]  (L = arclength normalization)
c     dpnlval:    Logarithmic derivative of the pest angle  normalization:
c                 [dP/dpsi / P]  (P = PEST normalization = q/f)
c     dhnlval:    Logarithmic derivative of the Hamiltonian normalization:
c                 [dH/dpsi / H]  (H = Hamiltonian normalization = fqi/f)
c     sint0 =     integral[r/grad(psi)]dl
c     sint1 =     integral[((1/(r**2)) * (r/grad(psi))]dl
c     sint2 =     integral[(d/dpsi(log(grad(psi)**2)) / r**2) * (r/grad(psi))]dl
c     sint3 =     integral[(1/(grad(psi)**2)) * (r/grad(psi))]dl
c     sint4 =     integral[(1/(r**2 * grad(psi)**2)) * (r/grad(psi))]dl
c     savge =     Surface averaged local shear S
c     tavge =     Surface averaged T - 0.5*S   (T = mu0*j.B/(grad(psi)**2)
c     qprime:     d/dpsi(q) from savge*sint0
c
c     f3      =   f / (r**2)
c     f4      =   -(mu0*jtor) / (r*Bpol)**2
c     f5      =   f * [d/dpsi(J/(r**2))](constant chi)
c     f7      =   2J{ ((mu0*jtor)/(r*Bpol))**2                           +
c                     ((mu0*jtor)/((r**2)*Bpol))*[d/dpsi(r*Bpol)]normal  -
c                     ((mu0*p'/r)*[dr/dpsi]normal }
c             =   2J{ ((mu0*jtor)/(r*Bpol))**2                           +
c                     ((mu0*jtor)/(r*Bpol))*[d/dpsi(Bpol)]normal         +
c                     ((ff'/r**3)*[dr/dpsi]normal }
c     f8      =   1 / [J*(r*Bpol)**2]
c     f9      =   J*(Bpol**2)
c     f10     =   (r**2) / J
c     f11     =   (mu0*gamma*p) / J
c     f12     =   (f*J) / (r**2)
c     f13     =   J (Jacobian)
c     f14     =   [dJ/dpsi](constant chi)
c     f15     =   [dJ/dchi](constant psi)
c     f16     =    d/dpsi(grad(psi)**2)normal
c     f17     =    d/dchi[grad(psi)**2]
c     f18     =    d/dchi[grad(psi).grad(chi)]
c     f19     =    d/dchi[(dchi/dpsi)normal]
c     f20     =   -(grad(psi).grad(chi)) / (grad(psi)**2)
c                  (-nonorthogonality: [-dchi/dpsi]normal)
c     f21     =   2*[(r**2)/f] * [d/dpsi(log(r)]]normal         = [1/f] * [dr**2/dpsi]normal
c     f22     =   2*[(r**2)/f] * [d/dchi(log(r))](constant psi) = [1/f] * [dr**2/dchi](constant psi)
c     f23     =   S = (f/r**2)*[del*(psi) - d/dpsi[grad(psi)**2]normal)] / grad(psi)**2)  -
c                                                     f'/r**2  (Local shear)
c     f24     =   T - S  =  mu0*j.B/(grad(psi)**2) - S
c                        = (f/r**2)*[d/dpsi[grad(psi)**2]normal) -  2*del*(psi)] / grad(psi)**2)
c     f25     =   +[darcl/dpsi]normal) (i.e. (nonorthogonality) for arclength angle
c     f26     =   +[dpest/dpsi]normal) (i.e. (nonorthogonality) for PEST angle
c     f27     =   +[dpest/darcl]constant psi
c     f28     =   +[dpest/dpsi ]constant arcl
c
c     The array psival is stored in reverse order so that psival(j) are the mesh
c       points for j = 1,jpsi.
c       Then psival(  1  ) is the first grid point just inside the plasma boundary,
c            psival(jpsi ) is the first grid point just after the magnetic axis,
c       and  psival(jpsi1) = psimax in smap.
c     This is then written into egta in reverse order from j=jpsi,1,-1 followed by
c       psilim so that the array is read back into the subsequent parts of the code
c       in normal order and includes psilim as the last point.
c       Then psival(  1  ) is the first grid point just after the magnetic axis,
c            psival(jpsi ) is the first grid point just inside the plasma boundary,
c       and  psival(jpsi1) = psilim in swnw, seig, and splt.
c
c
c
c
c 1.0 Set up the input namelist file and begin timing
c
      call fileset(0)
c
c
c 1.1 Read and write namelist input
c
      call readnml
      call writnml
c
c
c
c 2.0 Set up the remainder of the files
c
      call fileset(1)
c
c
c
c 3.0 Read equilibrium data
c
c 3.1 Read equilibrium files
c
      if(nmap .eq.  0)                     call rdeqdsk
      if(nmap .eq. +1  .or.  nmap .eq. +2) call rdtoqmp
      if(nmap .eq. -1)                     call rdjsvmp
      if(nmap .eq. -2  .or.  nmap .eq. -3) call rdqsvmp
      if(nmap .eq. -4)                     call rdiflmp
c
c
c 3.2 Check or reset the poloidal angle mesh to equal arclength
c
      if(nmap .ne. 0) call setarcl(nmap)
c
c
c 3.3 Read the fast ion profile
c
      call rdfastp
c
c
c
c 4.0 Construct the grids
c
c 4.1 Set the equilibrium auxiliary parameters and check input
c
      call setauxp
      call chkprof
c
c
c 4.2 Set up the equilibrium grid and print the input equilibrium data
c
c 4.2.1 Set the grid
c
      if(nmap .eq. 0) call setgdrz
      if(nmap .ne. 0) call setgdpc
c
c 4.2.2 Print out the input equilibrium
c
      call writeql
c
c
c 4.3 Find the plsama last closed flux surface
c
      call setdpsi
c
c
c 4.4 Reset the equilibrium according to namelist input and to the
c     new last closed flux surface
c
      call reseteq
c
c
c 4.5 Set up the initial flux grid
c
      call setmesh
c
c
c 4.6 Initialize the mapping
c
      call setprof
      if(nmap .eq. 0) call setaxs0
      if(nmap .ne. 0) call setaxs1
c
c
c 4.7 Rescale the profiles as needed and reset the axis values
c
      call rescaleq(kset)
      if(kset .eq. 1) call setprof
c
c
c
c 5.0 Construct the cell coefficients
c
c 5.1 Compute the surface and check the equilibrium condition
c
c 5.1.1 Compute the surface
c
      if(nmap .eq. 0) call ortogray(1)
      if(nmap .ne. 0) call setpsim
      call surface(0)
c
c 5.1.2 Check the equilibrium force balance
c
      call checkeq
c
c 5.1.3 Analyze the equilibrium errors
c
      call analerr
c
c
c 5.2 Compute an initial map and recompute the mesh
c
      initmap  = 0
      if(mmesh .gt. 0) then
        if(nmap  .eq. 0) call maprz(0)
        if(nmap  .ne. 0) call mappc(0)
c
        call prqprof(0,initmap)
c
        initmap  = 1
        call meshpak
        call setprof
c
        if(nmap .eq. 0) call ortogray(2)
        if(nmap .ne. 0) call setpsim
      endif
c
c
c 5.3 Compute the final mapping
c
c 5.3.1 Compute the final plasma surface
c
      call surface(1)
c
c 5.3.2 Compute the final flux surfaces
c
      if(nmap  .eq. 0) call maprz(1)
      if(nmap  .ne. 0) call mappc(1)
c
      call prqprof(1,initmap)
c
c 5.3.3 Impose symmetry
c
      if(isym  .ge. 1) call symetry
c
c
c
c 6.0 Compute auxiliary mapping quantities
c
c 6.1 Compute radial flux functions
c
      call mshcomp
      call psicomp
      call ratcomp
c
c
c 6.2 Compute Mercier stability and the volume and line integrals
c
      call mercier
      call volint
      call kinetic
c
c
c
c 7.0 Write and plot output
c
c 7.1 Write out the mapping data
c
      call writeout
      call writegrd
c
c
c 7.2 Write map file
c
      call writemap
c
c
c 7.3 Write the NetCDF file
c
      if(novap .ne. 0) call writnova
c
c
c 7.4 Plot equilibrium mapping and profiles
c
      if(iplotm .ne. 0) call plotg(mmesh)
c
c
c 8.0 Finish
c
c 8.2 Calculate time used, clean up and close files
c
      call fileclose
c
c
c 8.3 End program
c
      stop 'Normal Termination'
      end
      subroutine fileset(kset)
c
c -------------------------------------------------------------
c  Initialize files:
c  For kset = 0 Initialize timing and file data and open Namelist
c               input and Standard output file
c  For kset = 1 Open all remaining files as needed
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
c
      logical       xistinp,xisteql,xistrdm,xistrdn,xistfst
      logical       openinp,openeql,openrdm,openrdn,openfst
      character*16  forminp,formeql,formrdm,formrdn,formfst
      character*16  aceseql
c
      character*16  datestamp,timestamp
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/tcpu/  timcpu,timiop,timsys,timwal,datestamp,timestamp,
     &              tim0c,tim0i,tim0s,tim0w,tim1c,tim1i,tim1s,tim1w
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
c
c
c 1.0 Start timing
c
      if(kset .eq. 0) then
c
         call timeused(tim0c,tim0i,tim0s,tim0w,datestamp,timestamp)
c
c
c
c 2.0 Set up file names, attributes, and unit numbers
c
c 2.1 Unit numbers
c
         kuout   = 3
         kuinp   = 5
         kutty   = 6
         kueql   = 7
         kumap   = 8
         kugrd   = 9
         kurdm   = 10
         kurdn   = 11
         kufst   = 12
c
c
c 2.2 File names
c
         filout  = 'o1gta'
         filinp  = 'ingta'
         fileql  = 'eqgta'
         filmap  = 'egta'
         filgrd  = 'grid.dat'
         filrdm  = 'mgta'
         filrdn  = 'ngta'
         filfst  = 'fastp.dat'
         filplt  = 'gato1.cgm'
c
c
c
c 3.0 Open standard formatted I/O files
c
c 3.1 Open the standard output file
c
         open (unit = kuout, file   = filout,   form  = 'formatted'
     &                     , status = 'unknown'                    )
c
c
c 3.2 Open the namelist input file
c
c 3.2.1 Check the namelist input file exists
c
         ierinp   = 0
         xistinp  = .false.
         openinp  = .false.
         forminp  = 'unknown'
c
         inquire(file = filinp, exist = xistinp, opened = openinp
     &                                         , iostat = ierinp)
c
c 3.2.2 Print a warning if it does not exist or is already open
         if    (.not. xistinp) then
             call abortjob
     &        ('fileset ',  1,   'Namelist input file was not found   '
     &        ,'kuinp   ', kuinp,    'ierinp  ', ierinp,   +1)
         elseif(   xistinp   ) then
           if    (ierinp .ne. 0) then
             call abortjob
     &        ('fileset ',  2,   'Inquiry error in Namelist input file'
     &        ,'kuinp   ', kuinp,    'ierinp  ', ierinp,   -1)
           elseif(ierinp .eq. 0  .and.  openinp   ) then
             call abortjob
     &        ('fileset ',  3,   'Namelist input file was left open   '
     &        ,'kuinp   ', kuinp,    'ierinp  ', ierinp,   -1)
           endif
         endif
c
c
c 3.3 Open the file if it is valid
c
c 3.3.1 Open the file
c
         if(.not. openinp) then
           open (unit = kuinp, file   = filinp,   form  = 'formatted'
     &                                        ,   status = 'old'    )
         endif
c
c 3.3.1 Check the format if the file exists
c
         inquire(file = filinp, form  = forminp, iostat = ierinp)
         if    (ierinp .ne. 0) then
           call abortjob
     &        ('fileset ',  4,   'Inquiry error in Namelist input file'
     &        ,'kuinp   ', kuinp,    'ierinp  ', ierinp,   -1)
         endif
c
         if    (forminp .ne. 'formatted'    .and.
     &          forminp .ne. 'FORMATTED')      then
           if    (forminp .eq. 'unformatted'  .or.
     &            forminp .eq. 'UNFORMATTED')    then
             call abortjob
     &        ('fileset ',  5,   'Namelist input file is unformatted  '
     &        ,'kuinp   ', kuinp,    'ierinp  ', ierinp,   +1)
c
           else
             call abortjob
     &        ('fileset ',  6,   'Namelist file format not recognized '
     &        ,'kuinp   ', kuinp,    'ierinp  ', ierinp,   -1)
           endif
         endif
c
c
c 3.4 Return for kset = 0
c
         return
      endif
c
c
c
c 4.0 Open the input equilibrium file
c
c 4.1 Check the input equilibrium file exists
c
      if(kset .eq. 1) then
         iereql   =  0
         xisteql  = .false.
         openeql  = .false.
         formeql  = 'unknown'
         aceseql  = 'unknown'
c
         inquire(file = fileql, exist = xisteql, opened = openeql
     &                                         , iostat = iereql)
c
         if    (.not. xisteql) then
             call abortjob
     &        ('fileset ',  7,   'Equilibrium input file was not found'
     &        ,'kueql   ', kueql,    'iereql  ', iereql,   +1)
         elseif(    xisteql  .and.     openeql   ) then
             call abortjob
     &        ('fileset ',  8,   'Equilibrium input file was left open'
     &        ,'kueql   ', kueql,    'iereql  ', iereql,   -1)
         elseif(    xisteql  .and.  iereql .ne. 0) then
             call abortjob
     &        ('fileset ',  9,   'Error in equilibrium file inquiry   '
     &        ,'kueql   ', kueql,    'iereql  ', iereql,   -1)
         endif
c
c
c 4.2 Open the file
c
         if    (krdeqlb .eq. 0) then
           open (unit = kueql, file   = fileql
     &                       , form   = 'formatted'
     &                       , status = 'old'       )
         elseif(krdeqlb .gt. 0) then
           open (unit = kueql, file   = fileql
     &                       , form   = 'unformatted'
     &                       , status = 'old'       )
         elseif(krdeqlb .lt. 0) then
           open (unit = kueql, file   = fileql
     &                       , form   = 'unformatted'
     &                       , access = 'direct', recl   = 8
     &                       , status = 'old'       )
         endif
c
c
c 4.3 Check the format is correct
c
c 4.3.1 Inquire as to the format
c
         inquire(file = fileql, form  = formeql, access = aceseql
     &                                         , iostat = iereql)
         if(iereql .ne. 0) then
             call abortjob
     &        ('fileset ', 10,   'Error in equilibrium file inquiry   '
     &        ,'kueql   ', kueql,    'iereql  ', iereql,   -1)
         endif
c
c 4.3.2 Check the format is correct for the equilibrium type
c
         if    (krdeqlb .eq. 0) then
            if(formeql .ne. 'formatted'      .and.
     &         formeql .ne. 'FORMATTED')        then            
              if(formeql .eq. 'unformatted'    .or.
     &           formeql .eq. 'UNFORMATTED')      then
                 call abortjob
     &        ('fileset ', 11,   'Input equilibrium file unformatted  '
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  +1)
              else
                 call abortjob
     &        ('fileset ', 12,   'Equilibrium format is not recognized'
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              endif
            endif
c
         elseif(krdeqlb .gt. 0) then
            if(formeql .ne. 'unformatted'    .and.
     &         formeql .ne. 'UNFORMATTED')      then
              if(formeql .eq.   'formatted'    .or.
     &           formeql .eq.   'FORMATTED')      then
                 call abortjob
     &        ('fileset ', 13,   'Input equilibrium file is formatted '
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              else
                 call abortjob
     &        ('fileset ', 14,   'Equilibrium format is not recognized'
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              endif
            endif
c
            if(aceseql .ne. 'sequential'     .and.
     &         aceseql .ne. 'SEQUENTIAL'     )  then
              if(aceseql .eq. 'direct'         .or.
     &           aceseql .eq. 'DIRECT'     )        then
                 call abortjob
     &        ('fileset ', 15,   'Input equilibrium file direct access'
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              else
                 call abortjob
     &        ('fileset ', 16,   'Equilibrium access type unrecognized'
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              endif
            endif
c
         elseif(krdeqlb .lt. 0) then
            if(formeql .ne. 'unformatted'    .and.
     &         formeql .ne. 'UNFORMATTED')      then
              if(formeql .eq.   'formatted'    .or.
     &           formeql .eq.   'FORMATTED')      then
                 call abortjob
     &        ('fileset ', 17,   'Input equilibrium file is formatted '
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              else
                 call abortjob
     &        ('fileset ', 18,   'Equilibrium format is not recognized'
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              endif
            endif
c
            if(aceseql .ne. 'direct'         .and.
     &         aceseql .ne. 'DIRECT'     )      then
              if(aceseql .eq. 'sequential'     .or.
     &           aceseql .eq. 'SEQUENTIAL' )        then
                 call abortjob
     &        ('fileset ', 19,   'Input equilibrium sequential access '
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              else
                 call abortjob
     &        ('fileset ', 20,   'Equilibrium access type unrecognized'
     &        ,'kueql   ', kueql,    'krdeqlb ', krdeqlb,  -1)
              endif
            endif
         endif
c
c
c
c 5.0 Open the output mapping and grid files
c
c 5.1 Open the unformatted output mapping file
c
         open (unit = kumap, file   = filmap,  form  = 'unformatted'
     &                     , status = 'unknown'                     )
c
c
c 5.2 Open the formatted output grid mapping file
c
         open (unit = kugrd, file   = filgrd,  form   = 'formatted'
     &                     , status = 'unknown'                     )
c
c
c
c 6.0 Open the mapping file for reading a previously constructed mesh
c
c 6.1 Open the unformatted file
c
         if(krdmgta .gt. 0) then
c
c 6.1.1 Check whether the previous unformatted mapping file exists
c
           ierrdm   = 0
           xistrdm  = .false.
           openrdm  = .false.
           formrdm  = 'unknown'
c
           inquire(file = filrdm, exist = xistrdm, opened = openrdm
     &                                           , iostat = ierrdm)
c
c 6.1.2 Set a flag if the file does not exist
c
           if    ( .not. xistrdm ) then
             krdmgta  = -1
             call abortjob
     &        ('fileset ', 21,   'Unformatted map file does not exist '
     &        ,'kurdm   ', kurdm,    'krdmgta ', krdmgta,  -1)       
c
c 6.1.3 Print warnings if there is an error or the file was already open
c
           elseif(       xistrdm ) then
c
c 6.1.3.1 Check for inquiry file errors
             if    (ierrdm .ne. 0) then
               krdmgta  = -2
               call abortjob
     &        ('fileset ', 22,   'Inquiry error in unformatted file   '
     &        ,'kurdm   ', kurdm,    'ierrdm  ', ierrdm,   -1)
c
c 6.1.3.2 Check open status if no status error
             elseif(ierrdm .eq. 0) then
               if    ( openrdm ) then
                 call abortjob
     &        ('fileset ', 23,   'Input mapping file was already open '
     &        ,'krdmgta ', krdmgta,  'ierrdm  ', ierrdm,   -1)
c
c 6.1.4 Open the file if it exists and is closed
c         Set the flag to indicate it was valid
c
               elseif( .not. openrdm ) then
                 krdmgta  =  +2
                 open   (unit = kurdm,         file  = filrdm
     &                  ,form = 'unformatted', status = 'old' )
               endif
             endif
c
c 6.1.5 Check the format status of the file if it exists
c
c 6.1.5.1 Inquire as to the format
             inquire(file = filrdm, form  = formrdm, iostat = ierrdm)
             if    (ierrdm .ne. 0) then
               krdmgta  = -3
               call abortjob
     &        ('fileset ', 24,   'Inquiry error in unformatted file   '
     &        ,'kurdm   ', kurdm,    'ierrdm  ', ierrdm,   -1)
             endif
c
c 6.1.5.2 Check the format status
             if    (formrdm .ne. 'unformatted'  .and.
     &              formrdm .ne. 'UNFORMATTED')    then
               if    (formrdm .eq. 'formatted'    .or.
     &                formrdm .eq. 'FORMATTED'  )    then
                 call abortjob
     &        ('fileset ', 25,   'Input mapping file is formatted     '
     &        ,'krdmgta ', krdmgta,  'ierrdm  ', ierrdm,   -1)
c
               else
                 krdmgta  = -4
                 call abortjob
     &        ('fileset ', 26,   'Mapping file format not recognized  '
     &        ,'kurdm   ', kurdm,    'ierrdm  ', ierrdm,   -1)
               endif
             endif
           endif
         endif
c
c
c
c 6.2 Open the formatted file
c
         if(krdngta .gt. 0) then
c
c 6.2.1 Check whether the formatted mapping file exists
c
           ierrdn   = 0
           xistrdn  = .false.
           openrdn  = .false.
           formrdn  = 'unknown'
c
           inquire(file = filrdn, exist = xistrdn, opened = openrdn
     &                                           , iostat = ierrdn)
c
c 6.2.2 Set a flag if the file does not exist
c
           if    ( .not. xistrdn ) then
             krdngta  = -1
             call abortjob
     &        ('fileset ', 27,   'Formatted map file does not exist   '
     &        ,'kurdn   ', kurdn,    'krdngta ', krdngta,  -1)       
c
c 6.2.3 Print warnings if there is an error or the file was already open
c
           elseif(       xistrdn ) then
c
c 6.2.3.1 Check for inquiry file errors
             if    (ierrdn .ne. 0) then
               krdngta  = -2
               call abortjob
     &        ('fileset ', 28,   'Inquiry error in formatted map file '
     &        ,'kurdn   ', kurdn,    'ierrdn  ', ierrdn,   -1)
c
c 6.2.3.2 Check open status if no status error
             elseif(ierrdn .eq. 0) then
               if    ( openrdn ) then
                 call abortjob
     &        ('fileset ', 29,   'Input mapping file was already open '
     &        ,'krdngta ', krdngta,  'ierrdn  ', ierrdn,   -1)
c
c 6.2.4 Open the file if it exists and is closed
c         Set the flag to indicate it was valid
c
               elseif( .not. openrdn ) then
                 krdngta  =  +2
                 open   (unit = kurdn,         file  = filrdn
     &                  ,form = 'formatted',   status = 'old' )
               endif
             endif
c
c 6.2.5 Check the format status of the file if it exists
c
c 6.2.5.1 Inquire as to the format
             inquire(file = filrdn, form  = formrdn, iostat = ierrdn)
             if    (ierrdn .ne. 0) then
               krdngta  = -3
               call abortjob
     &        ('fileset ', 30,   'Inquiry error in formatted map file '
     &        ,'kurdn   ', kurdn,    'ierrdn  ', ierrdn,   -1)
             endif
c
c 6.2.5.2 Check the format status
             if    (formrdn .ne. 'formatted'    .and.
     &              formrdn .ne. 'FORMATTED')      then
               if    (formrdn .eq. 'unformatted'  .or.
     &                formrdn .eq. 'UNFORMATTED')    then
                 call abortjob
     &        ('fileset ', 31,   'Input mapping file is unformatted   '
     &        ,'krdngta ', krdngta,  'ierrdn  ', ierrdn,   -1)
c
               else
                 krdngta  = -4
                 call abortjob
     &        ('fileset ', 32,   'Mapping file format not recognized  '
     &        ,'kurdn   ', kurdn,    'ierrdn  ', ierrdn,   -1)
               endif
             endif
           endif
         endif

c
c
c 6.3 Print status of the file options for reading the mesh
c
c 6.3.1 Display status for unformatted file
c
         if(krdmgta .ne. 0) then
           if    (krdmgta .gt.  0) then
             if(krdmgta .eq. +1) call abortjob
     &        ('fileset ', 33,   'Unformatted file was already opened '
     &        ,'krdmgta ', krdmgta,  'ierrdm  ', ierrdm,   -1)
             write(kutty,1000) formrdm,filrdm,xistrdm,openrdm,nmesh
c
           elseif(krdmgta .lt.  0) then
             mmesh    = 0
             call abortjob
     &        ('fileset ', 34,   'Unformatted file could not be used  '
     &        ,'krdmgta ', krdmgta,  'ierrdm  ', ierrdm,   -1)
             write(kutty,1010) formrdm,filrdm,xistrdm,openrdm,nmesh
     &                                                       ,mmesh
           endif
         endif
c
c 6.3.2 Display status for formatted file
c
         if(krdngta .ne. 0) then
           if    (krdngta .gt.  0) then
             if(krdngta .eq. +1) call abortjob
     &        ('fileset ', 35,   'Formatted file was already opened   '
     &        ,'krdngta ', krdngta,  'ierrdn  ', ierrdn,   -1)
             write(kutty,1100) formrdn,filrdn,xistrdn,openrdn,nmesh
c
           elseif(krdngta .lt.  0) then
             mmesh    = 0
             call abortjob
     &        ('fileset ', 36,   'Formatted file could not be used    '
     &        ,'krdngta ', krdngta,  'ierrdn  ', ierrdn,   -1)
             write(kutty,1110) formrdn,filrdn,xistrdn,openrdn,nmesh
     &                                                       ,mmesh
           endif
         endif
c
c
c
c 7.0 Open the fast ion pressure file if it exists
c
         if(krdfast .gt. 0) then
c
c
c 7.1 Check whether the previous formatted mapping file exists
c
           ierfst   = 0
           xistfst  = .false.
           openfst  = .false.
           formfst  = 'unknown'
c
           inquire(file = filfst, exist = xistfst, opened = openfst
     &                                           , iostat = ierfst)
c
c
c 7.2 Set a flag if the file does not exist
c
           if    ( .not. xistfst ) then
             krdfast  = -1
             call abortjob
     &        ('fileset ', 37,   'Fast ion profile file does not exist'
     &        ,'kufst   ', kufst,    'krdfast ', krdfast,  -1)       
c
c
c 7.3 Print warnings if there is an error or the file was already open
c
           elseif(       xistfst ) then
c
c 7.3.1 Check for inquiry file errors
c
             if    (ierfst .ne. 0) then
               krdfast  = -2
               call abortjob
     &        ('fileset ', 38,   'Inquiry error in fast ion profile   '
     &        ,'kufst   ', kufst,    'ierfst  ', ierfst,   -1)
c
c 7.3.2 Check open status if no status error
c
             elseif(ierfst .eq. 0) then
               if    ( openfst ) then
                 call abortjob
     &        ('fileset ', 39,   'Fast ion profile file already open  '
     &        ,'krdfast ', krdfast,  'ierfst  ', ierfst,   -1)
c
c
c 7.4 Open the file if it exists and is closed
c      Set the flag to indicate it was valid
c
               elseif( .not. openfst ) then
                 krdfast  =  +2
                 open   (unit = kufst,         file  = filfst
     &                  ,form = 'formatted',   status = 'old' )
               endif
             endif
c
c 7.5 Check the format status of the file if it exists
c
c 7.5.1 Inquire as to the format
c
             inquire(file = filfst, form  = formfst, iostat = ierfst)
             if    (ierfst .ne. 0) then
               krdfast  = -3
               call abortjob
     &        ('fileset ', 40,   'Fast ion profile file inquiry error '
     &        ,'kufst   ', kufst,    'ierfst  ', ierfst,   -1)
             endif
c
c 7.5.2 Check the format status
c
             if    (formfst .ne. 'formatted'    .and.
     &              formfst .ne. 'FORMATTED')      then
               if    (formfst .eq. 'unformatted'  .or.
     &                formfst .eq. 'UNFORMATTED')    then
                 call abortjob
     &        ('fileset ', 41,   'Input mapping file is unformatted   '
     &        ,'krdfast ', krdfast,  'ierfst  ', ierfst,   -1)
c
               else
                 krdfast  = -4
                 call abortjob
     &        ('fileset ', 42,   'Fast ion file format not recognized '
     &        ,'kufst   ', kufst,    'ierfst  ', ierfst,   -1)
               endif
             endif
           endif
         endif
c
c
c 7.4 Display status for fast ion file
c
         if(krdfast .ne. 0) then
           if    (krdfast .gt.  0) then
             if(krdfast .eq. +1) call abortjob
     &        ('fileset ', 43,   'Fast ion file was already opened    '
     &        ,'krdfast ', krdfast,  'ierfst  ', ierfst,   -1)
             write(kutty,2000) formfst,filfst,xistfst,openfst,ifastp
c
           elseif(krdfast .lt.  0) then
             ifasti    = ifastp
             ifastp    = 0
             call abortjob
     &        ('fileset ', 44,   'Fast ion file could not be used     '
     &        ,'krdfast ', krdfast,  'ierfst  ', ierfst,   -1)
             write(kutty,2010) formfst,filfst,xistfst,openfst,ifasti
     &                                                       ,ifastp
           endif
         endif
c
c
c
c 8.0 Return and end for kset = 1
c
         return
      endif
c
 1000 format(/,10x,'Reading psi mesh from',1x,a16,1x,'file',1x,a16
     &      ,/,10x,'Existence status = ',l1
     &         ,5x,'Original open status = ',l1
     &         ,5x,'nmesh   = ',i5)
 1010 format(/,10x,'Reading psi mesh from',1x,a16,1x,'file',1x,a16
     &      ,/,10x,'Existence status = ',l1
     &         ,5x,'Original open status = ',l1
     &         ,5x,'nmesh   = ',i5
     &      ,/,10x,'Resetting mmesh   = ',i5)
 1100 format(/,10x,'Reading psi mesh from',1x,a16,1x,'file',1x,a16
     &      ,/,10x,'Existence status = ',l1
     &         ,5x,'Original open status = ',l1
     &         ,5x,'nmesh   = ',i5)
 1110 format(/,10x,'Reading psi mesh from',1x,a16,1x,'file',1x,a16
     &      ,/,10x,'Existence status = ',l1
     &         ,5x,'Original open status = ',l1
     &         ,5x,'nmesh   = ',i5
     &      ,/,10x,'Resetting mmesh   = ',i5)
 2000 format(/,10x,'Reading fast ion profile from',1x,a16,1x,'file'
     &         ,1x,a16
     &      ,/,10x,'Existence status = ',l1
     &         ,5x,'Original open status = ',l1
     &         ,5x,'nfast    = ',i5)
 2010 format(/,10x,'Reading fast ion profile from',1x,a16,1x,'file'
     &         ,1x,a16
     &      ,/,10x,'Existence status = ',l1
     &         ,5x,'Original open status = ',l1
     &         ,5x,'ifastp   = ',i5
     &      ,/,10x,'Resetting ifastp   = ',i5)
      end
      subroutine fileclose
c
c -------------------------------------------------------------
c  Clean up and close files
c -------------------------------------------------------------
c
      character*16  datestamp,timestamp
      character*16  datestmp1,timestmp1
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/tcpu/  timcpu,timiop,timsys,timwal,datestamp,timestamp,
     &              tim0c,tim0i,tim0s,tim0w,tim1c,tim1i,tim1s,tim1w
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
c
c 1.0 Calculate and print the time used
c
      call timeused(tim1c,tim1i,tim1s,tim1w,datestmp1,timestmp1)
      if(datestmp1 .eq. datestamp) addaday  = 0.0
      if(datestmp1 .ne. datestamp) addaday  = 86400.0
      timcpu  = tim1c - tim0c
      timiop  = tim1i - tim0i
      timsys  = tim1s - tim0s
      timwal  = tim1w - tim0w + addaday
      write(kutty,1000) timcpu,timiop,timsys,timwal
      write(kuout,1000) timcpu,timiop,timsys,timwal
c
c
c
c 2.0 Close the flies
c
c 2.1 Empty the buffers
c
      call empty(kutty)
      call empty(kuout)
c
c
c
c 3.0 Return and end
c
      return
 1000 format(/,1x,'Total times used:'
     &      ,/,1x,'cpu  time =',e13.6,1x,'sec.'
     &      ,/,1x,'i/o  time =',e13.6,1x,'sec.'
     &      ,/,1x,'sys  time =',e13.6,1x,'sec.'
     &      ,/,1x,'wall time =',e13.6,1x,'sec.',/)
      end
      subroutine readnml
c
c -------------------------------------------------------------
c  Read namelist
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
      parameter (nhd1=5,nhd2=3)
      parameter (nlx=1441)
c
      character*8   headr
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*16  sourcnam,sourcdat
      character*16  datestamp,timestamp
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/naml/  norm,nmod,nlt,nlim,toldrdz,
     &              iwal,iwalsym,nwall,
     &              irext,norign,nekdefn,maxitek,
     &              rext,rexmax,rcutoff,
     &              nrestrt,ndskopt,ndsktim,ndsksz,buffact,
     &              nev,neigmax,nforce,nreslv,nbrmax,
     &              nismax,ncymax,nitmax,ncyfin,mxdcomp,
     &              al0,dal0,al0bas,al0min,al0max,epschy,epscon,
     &              lineplt,lampplt,njplot,niplot,nskpj,nskpi,njedge,
     &              ntphase,ncont,ncplot,mshpsi,mshchi,nxisgn,
     &              nxiplt,nxuplt,nxrplt,nxpplt,nxdplt,ncphip,
     &              nbiplt,nbuplt,nbrplt,nbpplt,
     &              naiplt,nauplt,narplt,napplt,
     &              ndpplt,njiplt,njuplt,njrplt,njpplt,nvfft,
     &              torphase,dpltfac,dsplnrm,dspldbv,dspldav,
     &              psiscal,plsuprs,
     &              iomshp,ioeqlp,iowalp,
     &              ioeigp,iodbvp,iodavp,iodjvp,iopsip,
     &              iolinp,iolnbp,iolnap,iolnjp,
     &              iofftp,ioffbp,ioffap,ioffjp,
     &              ioconp,iodlbp,iodlap,iodljp,iodlwp,
     &              ioutw,iouta,ioute,ioutt,ioutp
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/tcpu/  timcpu,timiop,timsys,timwal,datestamp,timestamp,
     &              tim0c,tim0i,tim0s,tim0w,tim1c,tim1i,tim1s,tim1w
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
      namelist/inputd/ntor,ncase,norm,nmod,nlt,nlim,idnsty,ifastp
     &               ,ndnxp0,ndnxp1,ndnxp2,bfieldf,rdefolt,qxin,btdes
     &               ,qsurf,gamma,rmantl,betaf,zeffect
     &               ,nmap,neqtyp,mpreset,ndoublt,ndivert,ncorr,corrfac
     &               ,jpsi,itht,isym,igrid,nham1,nham2,nham3
     &               ,nmesh,npak,mpak,nedge,npkmax,nrat,nrepeat,nppack
     &               ,nqpack,nsrcheg,ncutedg,minpak,maxpak,incpak
     &               ,psipak,chiwth,cspak,psincr,pkfrac,qpfrac,epsrat
     &               ,sedg0,sedg1,plpak,pspak,epspak,spakmn
     &               ,swidmn,swidmx
     &               ,mapmaxd,dpsisl,dpsisd
     &               ,nqaxis,nspbc0,nspbc1,nwtmag,nfitmax,nfitpts
     &               ,ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs
     &               ,maxerlp,maxerlv,delbox,delboz,delac,delav
     &               ,delstsf,delstlp,delstlv,prfrac
     &               ,nerstop,nerprnt,qptol,tolspln,tolbchi
     &               ,tolbtor,tolsymm,tolaugm,errsep
     &               ,toldrdz,pvansh,precisn,plossmx,roundff,bigno
     &               ,narcmx,ntrymx,ntdecr,ntmmin
     &               ,nccellr,peqpk0,peqpk1,peqpk2,npfit,npcmin,kuttaop
     &               ,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm
     &               ,stepfac,flxstp,psispl,tolnwtp,tolnwtm
     &               ,delpakf,delpakc,delpkf,delpkc,psichek,boxtnd
     &               ,maptrace,norient,maxcutc
     &               ,dresolv,dlclose,pntshft,endtol
     &               ,narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax
     &               ,bperor,sersnm,sertnm,arcmin,delgap,stepcut
     &               ,iwal,iwalsym,nwall,irext,norign,nekdefn,maxitek
     &               ,rext,rexmax,rcutoff
     &               ,nrestrt,ndskopt,ndsktim,ndsksz,buffact
     &               ,nev,neigmax,nforce,nreslv,nbrmax
     &               ,nismax,ncymax,nitmax,ncyfin,mxdcomp
     &               ,al0,dal0,al0bas,al0min,al0max,epschy,epscon
     &               ,lineplt,lampplt,njplot,niplot,nskpj,nskpi,njedge
     &               ,ntphase,npowr,ncont,ncplot,mshpsi,mshchi,nxisgn
     &               ,nxiplt,nxuplt,nxrplt,nxpplt,nxdplt,ncphip
     &               ,nbiplt,nbuplt,nbrplt,nbpplt
     &               ,naiplt,nauplt,narplt,napplt
     &               ,ndpplt,njiplt,njuplt,njrplt,njpplt,nvfft
     &               ,torphase,dpltfac,dsplnrm,dspldbv,dspldav
     &               ,psiscal,plsuprs
     &               ,iomshp,ioeqlp,iowalp
     &               ,ioeigp,iodbvp,iodavp,iodjvp,iopsip
     &               ,iolinp,iolnbp,iolnap,iolnjp
     &               ,iofftp,ioffbp,ioffap,ioffjp
     &               ,ioconp,iodlbp,iodlap,iodljp,iodlwp
     &               ,novap,iplotm,ioutm,ioutw,iouta,ioute,ioutt
     &               ,ioutp
c
c
c                             Namelist Definitions:
c     Physical Case:
c     ntor:       Toroidal mode number.
c     ncase:      Set = 0 for full compressible. Set = 1 for incompressible.
c     norm:       Set KE norm:
c                   For full KE norm                                          Set =  0
c                   For normal displacement X/grad(psi) with Jacobian factor: Set =  1 
c                   For normal displacement X/grad(psi) only:                 Set =  2
c                   For normal displacement X with Jacobian factor:           Set =  3
c                   For normal displacement X only:                           Set =  4
c                   For original alternative norm:                            Set = -1.
c     nmod:       Set = 1 to force zero displacement for q < 1. Set = 2 to
c                   treat vacuum as plasma mantle.
c     nlt:        Set = 0 for ideal wall boundary conditions. Set = 1 for line
c                   tying at nlt'th poloidal grid point when p(psi) = 0.
c     nlim:       Set = 0 for standard boundary conditions. Set .ne. 0 for
c                   limiter boundary condition at poloidal grid point nlim.
c     idnsty:     Set density profile:
c                   idnsty = 0: Set density constant
c                   idnsty > 0: Read density profile if set = 1 or 2 or
c                   idnsty < 0: Set density profile from ndnxp0, ndnxp1,
c                               and ndnxp2.
c     ifastp:     Set fast particle pressure profile:
c                   ifastp = 0: Set fast particle pressure zero
c                   ifastp > 0: Read fast particle pressure
c                         ifastp =  +1 read in row form: profile in  Pa versus psi
c                         ifastp =  +2 read in row form: profile in kPa versus psi
c                         ifastp =  +3 read in row form: profile in MPa versus psi
c                         ifastp =  +4 read in row form: profile in 2mu0/B**2 versus psinorm
c                         ifastp =  +5 read in row form: profile in  Pa versus psinorm
c                         ifastp =  +6 read in row form: profile in kPa versus psinorm
c                         ifastp =  +7 read in row form: profile in MPa versus psinorm
c                         ifastp =  +8 read in row form: profile in 2mu0/B**2 versus psi
c                         ifastp =  +9 read in column form: profile in  Pa versus psi
c                         ifastp = +10 read in column form: profile in kPa versus psi
c                         ifastp = +11 read in column form: profile in MPa versus psi
c                         ifastp = +12 read in column form: profile in 2mu0/B**2 versus psi
c                         ifastp = +13 read in column form: profile in  Pa versus psinorm
c                         ifastp = +14 read in column form: profile in kPa versus psinorm
c                         ifastp = +15 read in column form: profile in MPa versus psinorm
c                         ifastp = +16 read in column form: profile in 2mu0/B**2 versus psinorm
c                   ifastp < 0: Set  fast particle pressure from thermal pressure in Pa
c                     as pressure**iabs(ifastp).
c     ndnxp0:     Set density profile as (psi**ndnxp0)(1-psi**ndnxp1)**ndnxp2.
c     ndnxp1:     Set density profile as (psi**ndnxp0)(1-psi**ndnxp1)**ndnxp2.
c     ndnxp2:     Set density profile as (psi**ndnxp0)(1-psi**ndnxp1)**ndnxp2.
c     bfieldf:    Set overall normalization for magnetic field.
c     rdefolt:    Set default nominal major radius value
c     qxin:       Rescale q0 to qxin and Btor accordingly if non zero.
c     btdes:      Rescale Btor to btdes and q0 accordingly if non zero.
c     qsurf:      Calculate q0 value required for q at edge equal qsurf.
c     gamma:      Adiabatic factor Cp/Cv.
c     rmantl:     Fraction of edge plasma treated as cold mantle in calculation
c                   of beta.
c     betaf:      Scale factor for final diagnostic fast particle pressure from
c                   thermal pressure.
c     zeffect:    Ratio of ion and electron densities.
c
c     Equilibrium type:
c     nmap:       Set =  0 for standard equilibrium.
c                 Set = +1 for inverse TOQ equilibrium (equilibrium mapping
c                          functions calculated.
c                 Set = +2 for inverse TOQ equilibrium (equilibrium mapping
c                          functions read).
c                 Set = -1 for inverse JSOLVER equilibrium.
c                 Set = -2 for inverse QSOLVER direct access equilibrium.
c                 Set = -3 for inverse QSOLVER sequential    equilibrium.
c                 Set = -4 for inverse I-file equilibria from CORSICA.
c     neqtyp:     With nmap > +1 then set = 0 for old style TOQ input. Set = 1 for
c                   new style TOQ input with date and title included.
c                 With nmap = -2 or -3 then set = 0 for not reading the aj3 and aj0 files
c                                           Set = 1 for     reading the aj3 and aj0 files.
c     mpreset:    Force input inverse equilibrium to be reset to calculated equal
c                   arclength mesh if set nonzero.
c     ndoublt:    Set = 0 for Dee shape coding options.  Set = 1 if doublet
c                   equilibrium.
c     ndivert:    Set = 0 for limiter edge.  Set = 1 for diverted edge
c
c     Numerical correction:
c     ncorr:      Set = 0 for standard delta-W construction.  Set .ne. 0 for
c                   numerical restabilization corrections.
c     corrfac:    Factor for numerical restabilization corrections.
c
c     Mesh Construction:
c     jpsi:       Number of flux surfaces.
c     itht:       Number of poloidal angles.
c     isym:       Set = 0 for up-down asymmetry. Set = 1 for up-down symmetric
c                   case.
c     igrid:      Set = 0 for equalarc poloidal angle. Set = 1 for PEST angle.
c     nham1:      Alternative output angle defined by Jacobian
c                   Jham = (r**nham1)(Bpol**nham2)(B**nham3).
c     nham2:      Alternative output angle defined by Jacobian Jham.
c     nham3:      Alternative output angle defined by Jacobian Jham.
c
c     Mesh Packing:
c     nmesh:      Set = 1 for repacking mesh. Set  = 0 for no packing. Set < 0
c                   to read mesh.
c     npak:       Number of  values for additional packing. Set > 0 (> 0) to pack
c                   at npak q (n*q) surfaces specified from plpak.
c     mpak:       Number of  values for additional packing. Set > 0 (< 0) to pack
c                   at mpak s=psi (s=psi**cspak) surfaces specified from pspak.
c     nedge:      Set > 0 to force additional edge packing. Set <= 0 for no
c                   edge packing.  Set nonzero value to control default and
c                   additional edge packing. 
c     npkmax:     Maximum total number of rational and prescribed surfaces
c                   packed.
c     nrat:       Number of flux surfaces reserved for packing.
c     nrepeat:    Set > 0 to pack only the nrepeat'th occurrence of a surface
c                   in plpak. Set < 0 to skip packing of the nrepeat'th
c                   occurrence of a surface.
c     nppack:     Set > 0 to eliminate packing at rational surfaces in
c                   negative shear region. Set < 0 to eliminate packing at
c                   rational surfaces in positive shear region.
c     nqpack:     Set > 0 to set q packing weights evenly distributed in
c                   (s**nqpack) x q. 
c     nsrcheg:    Set > 0 to include search for rational surfaces in last cell
c                   near edge of initial mapping .
c     ncutedg:    Use linear interpolation in packing within ncutedg grid
c                   points of edge.
c     minpak:     Minimum value for variable number of points in packing
c                   distribution mesh between packing surfaces.
c     maxpak:     Initial value for variable number of points in packing
c                   distribution mesh between packing surfaces.
c     incpak:     Value for fixed number of points in packing distribution
c                   mesh between packing surfaces.
c     psipak:     Set initial psi distribution evenly spaced in psi**psipak.
c     chiwth:     Set weighting for poloidal coordinate distribution
c                    (NOT IMPLEMENTED).
c     cspak:      Set distribution for underlying final mesh distribution to
c                   be evenly spaced in psi**cspak.
c     psincr:     For simply connected Dee mesh initial psi mesh increment 
c                   is psincr*(psilim-psimax)/jpsi.
c                 For doublet mesh increment for constructing initial psi mesh near Doublet
c                   separatrix is 1.0 - psincr.
c     pkfrac:     Fraction of flux surfaces reserved for packing at specific
c                   surfaces (rational or pre-specified).
c     qpfrac:     Fraction of flux surfaces reserved for distributing evenly
c                   in (s**nqpack) x q.
c     epsrat:     Cutoff value to ignore packing fraction.
c     sedg0:      Inverse width of packing weight distribution at edge.
c     sedg1:      Amplitude of packing weight distribution at edge.
c     plpak(k,l): Additional packing for specified q: k=(value, width, weight).
c     pspak(k,l): Additional packing for specified s: k=(value, width, weight).
c     epspak:     Tolerance for two packing points close enough to ignore gap
c                   in constructing weight mesh.
c     spakmn:     Minimum packing weight for any packed point.
c     swidmn:     Minimum (inverse) width in special surface packing.
c     swidmx:     Maximum (inverse) width in special surface packing.
c
c     Boundary Mapping:
c     mapmaxd:    Maximum number of plasma boundary mapping attempts.
c     dpsisl:     Move plasma surface dpsisl on initial boundary map attempt.
c     dpsisd:     Decrement dpsisl by dpsisd*(2**k) on each k'th boundary
c                   mapping attempt.
c
c     Magnetic Axis Fitting:
c     nqaxis:     Force use of axis fit from fitaxe or axis derivatives and jphi
c                   nqaxis =  0 Use default choice
c                   nqaxis = -1 Use equilibrium fit from fitaxe
c                   nqaxis = +1 Use axis fit from axis derivatives and jphi
c                   nqaxis < -1 Use weight 1/iabs(nqaxis) on fitaxe equilibrium
c                               fit
c                   nqaxis > +1 Use weight 1/iabs(nqaxis) on fit from axis
c                               derivatives
c     nspbc0:     Define nonperiodic spline boundary conditions for the profile
c                   consistency check
c                   nspbc0  =  0 Use natuaral boundary conditions
c                   nspbc0  = +1 Set the second derivative of the endpoints
c                                to the value numerically computed from fitting a
c                                quadratic
c                   nspbc0  = +2 Set the second derivative of the endpoints
c                                to the value numerically computed from linearly
c                                extrapolating from the subsequent two points by
c                                fitting a quadratic to each
c                   nspbc0  > +2 For nspbc0 large set the second derivative of the
c                                second derivative of the first point in to the
c                                value numerically computed from fitting a quadratic
c                                and leave the second derivative of the endpoints floating
c                   nspbc0  <  0 For abs(nspbc0) large apply the same boundary conditions
c                                as for nspbc0 > 2 but only at the axis and leave natural
c                                boundary conditions at the plasma boundary
c     nspbc1:     Define nonperiodic spline boundary conditions for the arcmax(psival),
c                   pstmax(psival) and hammax(psival) arrays for nmap = +2 cases:
c                   nspbc1  =  0 Use natuaral boundary conditions
c                   nspbc1  = +1 Set the second derivative of the endpoints
c                                to the value numerically computed from fitting a
c                                quadratic
c                   nspbc1  = +2 Set the second derivative of the endpoints
c                                to the value numerically computed from linearly
c                                extrapolating from the subsequent two points by
c                                fitting a quadratic to each
c                   nspbc1  > +2 For nspbc1 large set the second derivative of the
c                                second derivative of the first point in to the
c                                value numerically computed from fitting a quadratic
c                                and leave the second derivative of the endpoints floating
c                   nspbc1  <  0 For abs(nspbc1) large apply the same boundary conditions
c                                as for nspbc1 > 2 but only at the axis and leave natural
c                                boundary conditions at the plasma boundary
c     nwtmag:     Maximum number of Newton iterations for magnetic axis.
c     nfitmax:    Maximum number of searches to find points to fit at axis.
c     nfitpts:    Sets minimum number of points in fit to axis.
c     ifitrng:    Radial grid point range in search for direct equilibrium axis
c                   fit.
c     jfitrng:    Axial grid point range in search for direct equilibrium axis fit.
c     jfitchk:    Flux grid point range in search for direct equilibrium axis fit.
c     fitchek:    Sets number of grid cells in search for direct equilibrium axis
c                   fit.
c     cnvmag:     Convergence criterion for magnetic axis iterations.
c     epsaxs:     Tolerance for axis position compared to input.
c
c     Equilibrium Accuracy:
c     maxerlp:    Maximum number of poor convergence error reports in plasma.
c     maxerlv:    Maximum number of poor convergence error reports in vacuum.
c     delbox:     Radial increment for extending plasma error checking.
c     delboz:     Axial  increment for extending plasma error checking.
c     delac:      Global error criterion for input plasma equilibrium accuracy.
c     delav:      Global error criterion for input vacuum equilibrium accuracy.
c     delstsf:    Surface average error criterion for input equilibrium
c                   accuracy.
c     delstlp:    Pointwise error criterion for plasma input equilibrium
c                   accuracy.
c     delstlv:    Pointwise error criterion for vacuum input equilibrium
c                   accuracy.
c
c     Profile Fitting:
c     prfrac:     Constraint in deciding if spline fit for pressure is unstable:
c                   spline value is reset as linear interpolation if evaluation
c                   of cubic is below prfrac*min(p) over the local grid interval
c
c     Mapping and Vacuum Tolerances:
c     nerstop:    Maximum number of error messages of each type printed.
c     nerprnt:    Number of specific error occurences needed to invoke full
c                   diagnostic dump.
c     qptol:      Tolerance for interpolated input and calculated values.
c     tolspln:    Allowed tolerance in spline calculations of surface (r,z)
c                   values.
c     tolbchi:    Tolerance for alternative local and surface integrated
c                   calculations of nonorthogonality and jacobian for inverse
c                   equilibria.
c     tolbtor:    Tolerance in equality of input btdes and equilibrium btor
c                   before resetting btor = btdes.
c     tolsymm:    Equilibrium up-down symmetry tolerance (isym=1).
c     tolaugm:    Factor above which tolerance failures invoke serious warning.
c     errsep:     Tolerance for equality of initial and final contour point.
c     toldrdz:    General tolerance criterion for defining equality of two
c                   wall positions.
c     pvansh:     Criterion for negligible pressure on flux surface taken as
c                   plasma boundary with mantle outside.
c     precisn:    Input precision for iterative elliptic integral.
c     plossmx:    Maximum allowed recision loss for iterative elliptic integral.
c     roundff:    General roundoff parameter for testing equality.
c     bigno:      General largest number possible.
c
c     General Mapping:
c     narcmx:     Maximum number of arclength points in flux surface mapping.
c     ntrymx:     Maximum attempts to eliminate mapping failure by decrementing
c                   number of points on contour.
c     ntdecr:     Decrement number of contour points by 2*ntdecr per failure.
c     ntmmin:     Minimum number of points taken as sufficient in contour
c                   definition after multiple decrementing.
c
c     Inverse Equilibrium Mapping:
c     nccellr:    Use (r,z) from cell values (set < 0) 2D spline (set = 0) or
c                   1D spline (set > 0) in constructing equilibrium Fk
c                   functions for inverse equilibria.
c     peqpk0:     Set psi coordinate for interpolation of (r,z) as
c                   psi**peqpk0 for inverse equilibria.
c     peqpk1:     Set psi coordinate for interpolation of input equilibrium Fk
c                   functions as psi**peqpk0 for k = 3,4,5,7,8,9,10 for
c                   inverse equilibria.
c     peqpk2:     Set psi coordinate for interpolation of input equilibrium Fk
c                   functions as psi**peqpk0 for k = 11,12,13,14,20,21,22 for
c                   inverse equilibria.
c
c     Direct Equilibrium Mapping:
c     npfit:      Minimum points acceptable on direct rectangular equilibrium
c                   map. Otherwise force polar map.
c     npcmin:     Minimum points from mapping surface for fatal quit.
c     kuttaop:    Option for choosing full Runge-Kutta radial integration with
c                   no first step in first stored point (kuttaop  = +1) or
c                   original coding with approximate Runge-Kutta in radial
c                   direction and first stored point displacesd a half step
c                   (kuttaop = 0).
c     nrkmax0:    Number of tries allowed to find orthogional ray from
c                   Runge Kutta integration with modified stepfac.
c     nrkmax1:    Maximum number of attempts at finding initial step size for
c                   Runge Kutta searches.
c     numstp:     Maximum number of Runge Kutta steps in search for target psi
c                   value.
c     nwtfitp:    Maximum number of bisection iterations before initiating
c                   Newton iteration for fitting r(z) and z(r) in runkut and
c                   furplm.
c     nwtfitm:    Maximum number of Newton iteration fitting routine for
c                   r(z) and z(r) in runkut and furplm.
c     stepfac:    Initial step factor for Doublet Runge Kutta integration of
c                   outboard ray.
c     flxstp:     Vertical flux step for Runge Kutta integration of outboard
c                   ray in low percentage flux Doublets. 
c     psispl:     Force polar mapping of flux surface for direct equilibrium
c                   when psi < psispl.
c     tolnwtp:    Tolerance criterion for bisection iteration before initiating
c                   Newton iteration for fitting r(z) or z(r) in runkut and
c                   furplm.
c     tolnwtm:    Tolerance criterion for Newton iteration fitting routine for
c                   r(z) and z(r) in runkut and furplm.
c     delpakf:    Minimum ratio between adjacent points of spacing from
c                   rectangular map.
c     delpakc:    Minimum ratio between adjacent points of spacing from polar
c                   map.
c     delpkf:     Minimum spacing between contour points from rectangular map.
c     delpkc:     Minimum spacing between contour points from polar map.
c     psichek:    Tolerance between input psi for contour starting point and
c                   psi obtained from interpolation of start point.
c     boxtnd:     Extension in (r,z) of individual flux surfaces to find
c                   approximate elongation of flux surface.
c
c     Rectangular Mesh Contour Mapping:
c     maptrace:   Set > 0 to trace rectangular grid mapping for surface
c                   maptrace. Set trace for plasma boundary contour if
c                   maptrace < 0.
c     norient:    Set orientation priority of search for multiple exits of
c                   grid cell.
c     maxcutc:    Maximum number of excised points allowed in full contour.
c     dresolv:    Tolerance for whether the contour passes through grid points.
c     dlclose:    Tolerance for deciding if surface contour is closed.
c     pntshft:    Allowed shift in mapped point to move back into grid cell.
c     endtol:     Tolerance of interpolated total arclength vs interpolation
c                   input.
c
c     Polar Mesh Contour Mapping:
c     narcln:     Set initial arclength step relative to previous surface by a
c                   factor of 1/narcln.
c     nangax:     Set maximum angular increment for contours near axis as
c                   1/nangax.
c     nanglm:     Set maximum angular increment for contours near boundary as
c                   1/nanglm.
c     nbpmax:     Maximum number of contour restarts allowed.
c     nwtmax:     Maximum Newtons iterations for intersections of ray with
c                   contour.
c     nslmax:     Maximum sliding interval searches for contour.
c     nhfmax:     Maximum number of angular increment divisions for contour
c                   points.
c     bperor:     Allowed point to point change in Bpol in polar mapping.
c     sersnm:     Newtons Method convergence failure before printing warning.
c     sertnm:     Newtons Method convergence failure before termination.
c     arcmin:     Minimum point to point arclength in polar mapping.
c     delgap:     Gap permitted in closing contour.
c     stepcut:    Fractional reduction in step size imposed when test for
c                   bperor fails.
c
c     Wall and Vacuum:
c     iwal:       Defines wall option.  Set = 2 for old default DIII-D wall.
c     iwalsym:    Option for read in symmetric or asymmetric wall.
c     nwall:      Number of points used to construct wall (iwal =0, 2) or for
c                   input wall (iwal = 1).
c     irext:      Wall option to set center of wall.
c     norign:     Defines origin of coordinates used to interpolate final wall
c                   points.
c     nekdefn:    Force use of elliptic integral expansion (< 0) or iterative
c                   method (> 0) or default (= 0).
c     maxitek:    Maximum number of iterations for iterative elliptic integral
c                   method.
c     rext:       Expand default wall factor rext.  Set = 1.0 for wall on
c                   plasma (iwal = 0) or input wall (iwal = 1,2).
c     rexmax:     Maximum wall expansion for equivalent infinite vacuum.
c     rcutoff:    Minimum major radius for inboard toroidal wall.
c
c     Eigenvector File Handling:
c     nrestrt:    Restart eigenvalue iterations from restart file (Set = 1).
c     ndskopt:    Set temporary storage of decomposed matrix in multiple files
c                   (set = 0) or single (set = 1) file.
c     ndsktim:    Control printing of eigenvalue solver timing details.
c     ndsksz:     Set maximum size for single disk file if set .ne. 0.
c                   Otherwise, if set = 0 then set no size limit.
c     buffact:    Scale factor to scale buffer size in word addressable I/O.
c
c     Eigenvalue Search:
c     nev:        Compute nev'th eigenvalue.
c     neigmax:    Maximum number of eigenvalues for any given guess.
c     nforce:     Set = +/-1 to force convergence to one degenerate pair
c                   eigenvalue.
c     nreslv:     Set = 0 to ignore degenerate eigenvalues. Set .ne. 0  to
c                   resolve upper (> 0) or lower (< 0) eigenvalue.
c     nbrmax:     Maximum number of bracket iterations for eigenvalue search.
c     nismax:     Maximum number of isolation iterations for eigenvalue search.
c     ncymax:     Maximum number of Cholesky iterations for eigenvalue search.
c     nitmax:     Maximum number of inverse iterations for eigenvalue search.
c     ncyfin:     Set = 1 for Cholesky decomposition with final eigenvalue.
c     mxdcomp:    Maximum total permitted Cholesky decompositions.
c     al0:        Initial eigenvalue guess.
c     dal0:       Scale factor for incrementing al0 in bracket search.
c     al0bas:     Offset for scaling bracket search.
c     al0min:     Minimum allowed eigenvalue.
c     al0max:     Maximum allowed eigenvalue.
c     epschy:     Convergence criterion for Cholesky iterations.
c     epscon:     Convergence criterion for inverse iterations.
c
c     Plot Parameters:
c     lineplt:    Plot line plots versus flux surface or poloidal ray or both.
c     lampplt:    Plot line plots of quantity itself or amplitude and phase
c                   or both.
c     njplot:     Plot line plot versus of njplot'th surface. Plot outermost
c                   surface if set = 0.
c     niplot:     Plot line plot versus of niplot'th poloidal angle. Plot
c                   midplane if set = 0.
c     nskpj:      Skip every nskpj'th surface in displacement vector plot.
c     nskpi:      Skip every nskpi'th angle in displacement vector plot.
c     njedge:     Include or exclude plasma edge in plot normalizations.
c     ntphase:    Set toroidal phase of final eigenvector.
c     npowr:      Set the transformation for plotting of logarithmically
c                   divergent quantities in order to fit in reasonable scale:
c                   npowr .lt. -1: qt(psi) -> log(qt**2)
c                   npowr .eq. -1: qt(psi) -> qt/(1.0 +  abs(log(psi-ps0)))
c                   npowr .eq.  0: qt(psi) -> qt     (unchanged)
c                   npowr .gt.  0: qt(psi) -> qt/(1.0 + (abs(1.0/psi-ps0))**npowr
c     ncont:      Number of contours in contour plots.
c     ncplot:     Number of contours in perturbed flux surfaces.
c     mshpsi:     Specify radial coordinate in Fourier and line plots.
c     mshchi:     Specify poloidal angle in Fourier analysis and line plots.
c     nxisgn:     Reset sign of eigenvector (set = -1) or retain original
c                   sign (set = +1).
c     nxiplt:     Set = +1,+2,+3 to add normal, poloidal, toroidal component
c                   displacement plots. Set = -1,-2,-3 to plot just one.
c     nxuplt:     Set = +1,+2,+3 to add component displacement plots X U and Y.
c                 Set = -1,-2,-3 to plot just one.
c     nxrplt:     Set = +1,+2,+3 to add radial, axial, toroidal  component
c                   displacement plots. Set = -1,-2,-3 to plot just one.
c     nxpplt:     Set = +1,+2,+3 to add normal, perpendicular, and parallel
c                   component displacement plots. Set = -1,-2,-3 to plot
c                   just one.
c     nxdplt:     Set = +1,+2,+3,+4 to add dX/dpsi dX/dchi dU/dchi dY/dchi.
c                 Set = -1,-2,-3,-4 to plot just one.
c     ncphip:     Set = +1 to plot perturbed electric potential contours.
c     nbiplt:     Set = +1,+2,+3 to add normal, poloidal, toroidal component
c                   perturbed field plots. Set = -1,-2,-3 to plot just one.
c     nbuplt:     Set = +1,+2,+3 to add component perturbed field plots dBX
c                   dBU and dBY. Set = -1,-2,-3 to plot just one.
c     nbrplt:     Set = +1,+2,+3 to add radial, axial, toroidal  component
c                   perturbed field plots. Set = -1,-2,-3 to plot just one.
c     nbpplt:     Set = +1,+2,+3 to add normal, perpendicular, and parallel
c                   component perturbed field plots. Set = -1,-2,-3 to plot
c                   just one.
c     naiplt:     Set = +1,+2,+3 to add normal, poloidal, toroidal component
c                   vector potential plots. Set = -1,-2,-3 to plot just one.
c     nauplt:     Set = +1,+2,+3 to add component perturbed field plots dAX
c                   dAU and dAY. Set = -1,-2,-3 to plot just one.
c     narplt:     Set = +1,+2,+3 to add radial, axial, toroidal  component
c                   vector potential plots. Set = -1,-2,-3 to plot just one.
c     napplt:     Set = +1,+2,+3 to add normal, perpendicular, and parallel
c                   component vector potential plots. Set = -1,-2,-3 to plot
c                   just one.
c     ndpplt:     Set = nonzero to add perturbed scalar pressure plots.
c     njiplt:     Set = +1,+2,+3 to add normal, poloidal, toroidal component
c                   perturbed current density plots. Set = -1,-2,-3 to plot just one.
c     njuplt:     Set = +1,+2,+3 to add component perturbed field plots djX
c                   djU and djY. Set = -1,-2,-3 to plot just one.
c     njrplt:     Set = +1,+2,+3 to add radial, axial, toroidal  component
c                   perturbed current density plots. Set = -1,-2,-3 to plot just one.
c     njpplt:     Set = +1,+2,+3 to add normal, perpendicular, and parallel
c                   component perturbed current density plots. Set = -1,-2,-3 to plot
c                   just one.
c     nvfft:      Specify number of Fourier harmonics as 2nfft.  Set = 0 for
c                   maximum specified in dimensions.
c     torphase:   Add toroidal phase to default phase of computed eigenvector.
c
c     Plot Scale Factors:
c     dpltfac:    Overall scale factor for real space eigenvector plots.
c     dsplnrm:    Scale factor for displacement vector arrows.
c     dspldbv:    Scale factor for delta-B vector relative to displacement.
c     dspldav:    Scale factor for delta-A vector relative to displacement.
c     psiscal:    Scale factor for perturbed flux surface displacement plots.
c     plsuprs:    Suppress plots of fourier components below plsuprs.
c
c     Plot Control:
c     iomshp:     Force on (set=+2), off (set=-2), or use default (set=0) mesh
c                   plots.  Set = +1 to force calculation and print only.
c     ioeqlp:     Force on (set=+2),off (set=-2), or use default (set=0)
c                   equilibrium plots.  Set = +1 to force calculation and
c                   print only.
c     iowalp:     Force on (set=+2), off (set=-2), or use default (set=0) wall
c                   and plasma surface plots.  Set = +1 to force calculation
c                   and print only.
c     ioeigp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   displacement arrow plots.  Set = +1 to force calculation
c                   and print only.
c     iodbvp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   delta-B arrow plots.  Set = +1 to force calculation and
c                   print only.
c     iodavp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   delta-A arrow plots.  Set = +1 to force calculation and
c                   print only.
c     iodjvp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   delta-j arrow plots.  Set = +1 to force calculation and
c                   print only.
c     iopsip:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   perturbed surface plots.  Set = +1 to force calculation
c                   and print only.
c     iolinp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   line plots.  Set = +1 to force calculation and print only.
c     iolnbp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   line plots.  Set = +1 to force calculation and print only.
c     iolnap:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   line plots.  Set = +1 to force calculation and print only.
c     iolnjp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   line plots.  Set = +1 to force calculation and print only.
c     iofftp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   fourier analysis plots.  Set = +1 to force calculation
c                   and print only.
c     ioffbp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   fourier analysis plots.  Set = +1 to force calculation
c                   and print only.
c     ioffap:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   fourier analysis plots.  Set = +1 to force calculation
c                   and print only.
c     ioffjp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   fourier analysis plots.  Set = +1 to force calculation
c                   and print only.
c     ioconp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   contour plots.  Set = +1 to force calculation and print
c                   only.
c     iodlbp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   contour plots.  Set = +1 to force calculation and print
c                   only.
c     iodlap:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   contour plots.  Set = +1 to force calculation and print
c                   only.
c     iodljp:     Force on (set=+2), off (set=-2), or use default (set=0)
c                   contour plots.  Set = +1 to force calculation and print
c                   only.
c     iodlbw:     Force on (set=+2), off (set=-2) or use default (set=0)
c                   contour plots.  Set = +1 to force calculation and print
c                   only.
c
c     Output Control:
c     novap:      Control output of mapping data for NOVA-K.
c                   For novap  = 0  No output.
c                   For novap  = 1  Write output files for NOVA-K input.
c     iplotm:     Control default number of plots from mapping code. Set=9 for
c                   all plots.
c     ioutm:      Control debug output from mapping code. Set = 0 for minimum
c                   output.
c     ioutw:      Control debug output for vacuum and wall. Set = 0 for
c                   minimum output.
c     iouta:      Control debug output for matrix pattern. Set = 0 for
c                   minimum output.
c     ioute:      Control debug output from eigenvalue solver. Set = 0 for
c                   minimum output.
c     ioutt:      Control print output from diagnostic code.
c     ioutp:      Control plot output from diagnostic code. Set = 21 for all plots.
c
c
c
c 1.0 Define constants and default parameters
c
c 1.1 Set the Source name and date and Version identification.
c
      sourcnam = 'Smap:'
      sourcdat = '15 May 10'
c
      version  = 'vs 09/09'
      verold0  = 'vs 21/08'
      verold1  = 'vs 12/05'
      verold2  = 'vs 03/98'
      verold3  = 'vs 09/95'
      verold4  = 'vs 04/94'
      verold5  = 'vs 10/92'
      verold6  = 'vs 09/91'
c
c
c 1.2 Set the parameters as variables to allow printing
c
      npxdm    =  npx
      ncxdm    =  ncx
      npkdm    =  npk
      nlxdm    =  nlx
c
c
c 1.3 Initialize constants
c
      pi       =  3.1415926535897932385
      twopi    =  2.0*pi
      hlfpi    =  pi/2.0
      amu      =  4.0*pi*1.0e-07
      boltzm   =  1.38e-23
      echarg   =  1.60e-19
      pmass    =  1.67e-27
c
c
c 1.4 Set namelist defaults
c
c 1.4.1 Physical Case:
c
      ntor     =  1
      ncase    =  0
      norm     =  0
      nmod     =  0
      nlt      =  0
      nlim     =  0
      idnsty   =  0
      ifastp   =  0
      ndnxp0   =  0
      ndnxp1   =  2
      ndnxp2   =  2
      bfieldf  =  1.00
      rdefolt  =  1.696
      qxin     =  0.00
      btdes    =  0.00
      qsurf    =  2.00
      gamma    =  5.0/3.0
      rmantl   =  0.0
      betaf    =  1.0
      zeffect  =  1.0
c
c 1.4.2 Equilibrium type:
c
      nmap     =  0
      neqtyp   =  1
      mpreset  =  0
      ndoublt  =  0
      ndivert  =  1
c
c 1.4.3 Numerical correction:
c
      ncorr    =  1
      corrfac  =  1.0
c
c 1.4.4 Mesh construction:
c
c 1.4.4.1 Mesh dimensions:
      jpsi     =  npxdm
      itht     =  ncxdm
      isym     =  0
      igrid    =  0
      nham1    = +0
      nham2    = +0
      nham3    = -2
c
c 1.4.4.2 Mesh packing:
      nmesh    =  1
      npak     =  0
      mpak     =  0
      nedge    = +4
      npkmax   = npxdm
      nrat     = npxdm/3 + 1
      nrepeat  =  0
      nppack   =  1
      nqpack   =  0
      nsrcheg  = +1
      ncutedg  =  0
      minpak   =  1
      maxpak   =  4
      incpak   =  4
      psipak   =  2.0
      chiwth   =  0.0
      cspak    =  0.5
      psincr   =  0.0
      pkfrac   =  2.0/3.0
      qpfrac   =  1.0/3.0
      epsrat   =  0.10e-09
      sedg0    =  0.0
      sedg1    =  0.0
      do 50 kp = 1,npk
      plpak(1,kp) = 0.0
      plpak(2,kp) = 0.0
      plpak(3,kp) = 0.0
      pspak(1,kp) = 0.0
      pspak(2,kp) = 0.0
      pspak(3,kp) = 0.0
  50  continue
      epspak   =  0.10e-01
      spakmn   =  0.10
      swidmn   =  1.000
      swidmx   =  100.0
c
c 1.4.5 Mapping initialization:
c
c 1.4.5.1 Boundary mapping:
      mapmaxd  =  10
      dpsisl   =  0.00
      dpsisd   =  0.50e-05
c
c 1.4.5.2 Axis fitting:
      nqaxis   =  0
      nspbc0   =  +1
      nspbc1   =  +1
      nwtmag   =  25
      nfitmax  =  10
      nfitpts  =  14
      ifitrng  =  2
      jfitrng  =  10
      jfitchk  =  5
      fitchek  =  10.0
      cnvmag   =  0.10e-09
      epsaxs   =  0.10e-06
c
c 1.4.5.3 Equilibrium accuracy checking:
      maxerlp  =  200
      maxerlv  =  100
      delbox   =  0.10e-01
      delboz   =  0.10e-01
      delac    =  0.10e-02
      delav    =  delac
      delstsf  =  delac
      delstlp  =  0.10e-01
      delstlv  =  0.10e-01
c
c 1.4.5.4 Profile Fitting:
      prfrac   =  0.20
c
c 1.4.5.5 Tolerances:
      nerstop  =  10
      nerprnt  =   3
      qptol    =  0.10e-01
      tolspln  =  0.10e-03
      tolbchi  =  0.10e-00
      tolbtor  =  0.10e-06
      tolsymm  =  0.10e-06
      tolaugm  =  10.0
      errsep   =  0.10e-04
      toldrdz  =  0.10e-05
      pvansh   =  0.10e-07
      precisn  =  0.10e-13
      plossmx  =  0.25e-00
      roundff  =  0.10e-10
      bigno    =  1.00e+30
c
c 1.4.6 Flux surface mapping:
c
c 1.4.6.1 General mapping:
      narcmx   =  nlx
      ntrymx   =  10
      ntdecr   =  max0(1,narcmx/100)
      ntmmin   =  max0(2,min0(narcmx/2,2*jpsi))
c
c 1.4.6.2 Inverse equilibrium mapping:
      nccellr  =  +1
      peqpk0   =  0.5
      peqpk1   =  0.5
      peqpk2   =  0.5
c
c 1.4.6.2 Direct equilibrium mapping:
      npfit    =  120
      npcmin   =  5
      kuttaop  =  0
      nrkmax0  =  10
      nrkmax1  =  10
      numstp   =  640
      nwtfitp  =  2
      nwtfitm  =  100
      stepfac  =  0.020
      flxstp   =  0.150
      psispl   =  0.100
      tolnwtp  =  0.20
      tolnwtm  =  1.0e-05
      delpakf  =  0.000
      delpakc  =  0.000
      delpkf   =  0.100
      delpkc   =  0.010
      psichek  =  0.10e-07
      boxtnd   =  0.10e-00
c
c 1.4.6.3 Grid mesh contour mapping:
      maptrace =  0
      norient  =  0
      maxcutc  =  5
      dresolv  =  1.0e-08
      dlclose  =  3.0e-04
      pntshft  =  1.0e-08
      endtol   =  0.10
c
c 1.4.6.4 Polar contour mapping:
      narcln   =  120
      nangax   =  144
      nanglm   =  360
      nbpmax   =  5
      nwtmax   =  20
      nslmax   =  10
      nhfmax   =  4
      bperor   =  0.01
      sersnm   =  0.10e-08
      sertnm   =  0.10e-07
      arcmin   =  0.002
      delgap   =  0.1
      stepcut  =  0.5
c
c 1.4.7 Wall and vacuum:
c
      iwal     =  0
      iwalsym  =  0
      nwall    =  0
      irext    =  0
      norign   =  0
      nekdefn  =  0
      maxitek  =  10
      rext     =  1.00
      rexmax   =  1.0e+03
      rcutoff  =  0.10e-02
c
c 1.4.8 Eigenvalue solver:
c
c 1.4.8.1 Eigenvector file handling:
      nrestrt  =  0
      ndskopt  =  0
      ndsktim  =  0
      ndsksz   =  0
      buffact  =  0.3
c
c 1.4.8.2 Eigenvalue search:
      nev      =  1
      neigmax  =  100
      nforce   =  0
      nreslv   =  0
      nbrmax   =  10
      nismax   =  10
      ncymax   =  2
      nitmax   =  20
      ncyfin   =  1
      mxdcomp  =  20
      al0      = -0.10e-03
      dal0     = +10.0
      al0bas   =  0.00
      al0min   = -1.00
      al0max   = -0.10e-09
      epschy   =  0.10e-04
      epscon   =  0.10e-04
c
c 1.4.9 Diagnostic plotting:
c
c 1.4.9.1 Plot parameters:
      lineplt  =  0
      lampplt  =  0
      njplot   =  0
      niplot   =  0
      nskpj    =  1
      nskpi    =  1
      njedge   =  1
      ntphase  =  0
      npowr    = -2
      ncont    = 10
      ncplot   = 10
      mshpsi   = 12
      mshchi   =  3
      nxisgn   = +1
      nxiplt   = +1
      nxuplt   = +1
      nxrplt   =  0
      nxpplt   =  0
      nxdplt   =  0
      ncphip   =  0
      nbiplt   =  0
      nbuplt   =  0
      nbrplt   =  0
      nbpplt   =  0
      naiplt   =  0
      nauplt   =  0
      narplt   =  0
      napplt   =  0
      ndpplt   =  0
      njiplt   =  0
      njuplt   =  0
      njrplt   =  0
      njpplt   =  0
      nvfft    =  0
      torphase =  0.00
c
c 1.4.9.2 Plot scale factors
      dpltfac  = 0.10
      dsplnrm  = 0.10
      dspldbv  = 1.00
      dspldav  = 1.00
      psiscal  = 0.4
      plsuprs  = 1.0e-02
c
c 1.4.9.3 Plotting options:
      iomshp   =  0
      ioeqlp   =  0
      iowalp   =  0
      ioeigp   =  0
      iodbvp   =  0
      iodavp   =  0
      iodjvp   =  0
      iopsip   =  0
      iolinp   =  0 
      iolnbp   =  0
      iolnap   =  0
      iolnjp   =  0
      iofftp   =  0
      ioffbp   =  0
      ioffap   =  0
      ioffjp   =  0
      ioconp   =  0
      iodlbp   =  0
      iodlap   =  0
      iodljp   =  0
      iodlwp   =  0
c
c 1.4.9.4 Ouput:
      novap    =  1
      iplotm   =  9
      ioutm    =  0
      ioutw    =  0
      iouta    =  0
      ioute    =  0
      ioutt    =  1
      ioutp    = +21
c
c
c
c 2.0 Read namelist input file
c
c 2.1 Read in the heading
c
      do 100 k2  = 1,nhd2
      read (kuinp,1000) (headr(k1,k2),k1=1,nhd1)
  100 continue
c
c
c 2.2. Read the namelist
c
      read (kuinp,inputd)
c
c
c
c 3.0 Check namelist input for consistency
c
c 3.1 Check dimensions
c
c 3.1.1 Check the input number of surfaces does not exceed the dimension
c
      if(jpsi   .gt. npxdm) then
        call abortjob
     &        ('readnml ',  1,   'jpsi greater than the dimension     '
     &        ,'jpsi    ', jpsi,     'npxdm   ', npxdm,    -1)
        jpsi    = npxdm
      endif
c
c 3.1.2 Check the number of poloidal angles does not exceed the dimension
c
      if(itht   .gt. ncxdm) then
        call abortjob
     &        ('readnml ',  2,   'itht greater than the dimension     '
     &        ,'itht    ', itht,     'ncxdm   ', ncxdm,    -1)
        itht    = ncxdm
      endif
c
c 3.1.3 Check the arclength array does not exceed the dimension
c
      if(narcmx .gt. nlxdm) then
        call abortjob
     &        ('readnml ',  3,   'narcmx greater than dimension       '
     &        ,'narcmx  ', narcmx,   'nlxdm   ', nlxdm,    -1)
        narcmx  = nlxdm
      endif
c
c 3.1.4 Check the packing arrays do not exceed the dimension
c
      if(npkmax .gt. npkdm) then
        call abortjob
     &        ('readnml ',  4,   'npkmax greater than dimension       '
     &        ,'npkmax  ', npkmax,   'npkdm   ', npkdm,    -1)
        npkmax  = npkdm
      endif
c
c
c 3.2 Check for consistency of input parameters
c
c 3.2.1 Check the dimension is sufficient for the vacuum equivalences
c
      if(ncxdm .lt. 10)  call abortjob
     &        ('readnml ',  5,   'Too few points for equivalences:    '
     &        ,'ncxdm   ', ncxdm,    'itht    ', itht,     -1)
c
c 3.2.2 Check itht is even when isym = 1.  Otherwise coding for setting
c       2 times the number of angles may be inconsistent in the matrix
c       construction  (2(itht/2 + 1 should equal itht + 2)
c
      itht2s   = 2*(itht/2 + 1)
      itht2x   =    itht   + 2
      if(isym .eq. 1  .and.  itht2s .ne. itht2x)  then
        call abortjob
     &        ('readnml ',  6,   'itht is odd for up-down symmetry    '
     &        ,'ithts   ', ithts,    'itht2x  ', itht2x,   -1)
        itht  = itht - 1
      endif
c
c 3.2.3 Check ncase is non-negative
c
      if(ncase .lt. 0) then
        call abortjob
     &        ('readnml ',  7,   'ncase nonnegative: reset to zero    '
     &        ,'ncase   ', ncase,    'norm    ', norm,      0)
        ncase  = 0
      endif
c
c 3.2.4 Check for valid norm option
c
      if(norm .gt. 4  .or.  norm .lt. -1) then
         call abortjob
     &        ('readnml ',  8,   'Invalid norm in alternate KE        '
     &        ,'norm    ', norm,     'ncase   ', ncase,    -1)
      endif
c
c 3.2.5 Check parameters are consistent with ndivert
c
      if(ndivert .ne. 0  .and.  nmap  .ne. 0) then
         call abortjob
     &        ('readnml ',  9,   'Reset ndivert=0: Inverse equilibrium'
     &        ,'ndivert ', ndivert,  'nmap    ', nmap,     -1)
         ndivert  = 0
      endif
c
      if(ndivert .eq. 0  .and.  npowr .ne. 0) then
         if   (nmap .eq. 0) then
            call abortjob
     &        ('readnml ', 10,   'npowr is inconsistent with limiter  '
     &        ,'ndivert ', ndivert,  'npowr   ', npowr,    -1)
         elseif(nmap .ne. 0) then
            call abortjob
     &        ('readnml ', 11,   'npowr reset to zero for limiter case'
     &        ,'ndivert ', ndivert,  'npowr   ', npowr,    -1)
            npowr    = 0
         endif
      endif
c
      if(ndivert .ne. 0  .and.  npowr .eq. 0) then
         call abortjob
     &        ('readnml ', 12,   'npowr inconsistent with divertor    '
     &        ,'ndivert ', ndivert,  'npowr   ', npowr,    -1)
         npowr    = -2
      endif
c
c
c 3.3 Check validity of input mapping parameters
c
      if(dpsisd .lt. 0.0) then
        call abortjob
     &        ('readnml ', 13,   'Negative dpsisd:  Resetting > 0     '
     &        ,'nmap    ', nmap,     'mapmaxd ', mapmaxd,  -1)
        dpsisd   = 0.0
      endif
c
c
c
c 4.0 Set auxiliary input according to the namelist
c
c 4.1 Set required quantities defined by input
c
c 4.1.1 Set the equilibrium type and file format type
c
c 4.1.1.1 Set the equilibrium type
c         For standard direct  equilibria  nmtype =  0
c         For standard inverse equilibria  nmtype = +1
c         For inverse equilibria  with all equilibrium quantities nmtype = +2
      if(nmap .eq. +2) nmtype  =  +2
      if(nmap .eq. +1) nmtype  =  +1
      if(nmap .eq.  0) nmtype  =   0
      if(nmap .eq. -1) nmtype  =  +1
      if(nmap .eq. -2) nmtype  =  +1
      if(nmap .eq. -3) nmtype  =  +1
      if(nmap .eq. -4) nmtype  =  +1
c
c 4.1.1.2 Set the equilibrium input file format
c         For ASCII equilibrium input                 krdeqlb  =  0
c         FOR binary sequential equilibrium input     krdeqlb  = +1
c         FOR binary direct access equilibrium input  krdeqlb  = -1

      if(nmap .eq. +2) krdeqlb  =  0
      if(nmap .eq. +1) krdeqlb  =  0
      if(nmap .eq.  0) krdeqlb  =  0
      if(nmap .eq. -1) krdeqlb  =  0
      if(nmap .eq. -2) krdeqlb  = -1
      if(nmap .eq. -3) krdeqlb  = +1
      if(nmap .eq. -4) krdeqlb  = +1
c
c 4.1.1.3 Set to the default if the equilibrium input type is unrecognized
      if(nmap .lt. -4  .or.  nmap .gt. +2) then
         call abortjob
     &        ('readnml ', 14,   'Equilibrium mapping option invalid  '
     &        ,'nmap    ', nmap,     'neqtyp  ', neqtyp,   -1)
         nmap      = 0
         nmtype    = 0
         krdeqlb   = 0
      endif

c 4.1.2 Set physical constants
c
      if(ncase .eq. 0) gamav = gamma
      if(ncase .gt. 0) gamav = 1.0e-10
c
c
c 4.2 Set mmesh according to nmesh and set the krdmgta and krdngta flags
c
c 4.2.1 Set defaults
c
      mmesh     = nmesh
      krdmgta   = 0
      krdngta   = 0
c
c 4.2.2 Check mmesh is valid
c
      if(mmesh .lt. -8) then
         call abortjob
     &        ('readnml ', 15,   'nmesh < -8 is not recognized option '
     &        ,'nmesh   ', nmesh,    'npak    ', npak,     -1)
        mmesh    = 0
      endif
c
c 4.2.3 Set  mesh options for nmesh non-negative
c       nmesh = -1 or -2: Set krdmgta > 0 to read unformatted file
c       nmesh < -2      : Set krdngta > 0 to read formatted file
c
      if(mmesh .lt. 0) then
        if(mmesh .eq. -1) krdmgta  = +1
        if(mmesh .eq. -2) krdmgta  = +1
        if(mmesh .lt. -2) krdngta  = +1
      endif
c
c
c 4.3 Check fast particle flag is valid
c
c 4.3.1 Check fast particle flag is consistent with existence of input file
c
      if(ifastp .le. 0) krdfast =  0
      if(ifastp .gt. 0) krdfast = +1
c
c 4.3.2 Check fast particle flag is recognized
c
      if(ifastp .gt. 16) then
        call abortjob
     &        ('readnml ', 16,   'Parameter ifastp not recognized     '
     &        ,'ifastp  ', ifastp,   'krdfast ', krdfast,  -1)
        ifastp   = 0
      endif
c
c
c
c 5.0 Return and end
c
      return
 1000 format(5a8)
      end
      subroutine writnml
c
c -------------------------------------------------------------
c  Write namelist
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
      parameter (nhd1=5,nhd2=3)
c
      character*8   headr
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*16  sourcnam,sourcdat
      character*16  datestamp,timestamp
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/naml/  norm,nmod,nlt,nlim,toldrdz,
     &              iwal,iwalsym,nwall,
     &              irext,norign,nekdefn,maxitek,
     &              rext,rexmax,rcutoff,
     &              nrestrt,ndskopt,ndsktim,ndsksz,buffact,
     &              nev,neigmax,nforce,nreslv,nbrmax,
     &              nismax,ncymax,nitmax,ncyfin,mxdcomp,
     &              al0,dal0,al0bas,al0min,al0max,epschy,epscon,
     &              lineplt,lampplt,njplot,niplot,nskpj,nskpi,njedge,
     &              ntphase,ncont,ncplot,mshpsi,mshchi,nxisgn,
     &              nxiplt,nxuplt,nxrplt,nxpplt,nxdplt,ncphip,
     &              nbiplt,nbuplt,nbrplt,nbpplt,
     &              naiplt,nauplt,narplt,napplt,
     &              ndpplt,njiplt,njuplt,njrplt,njpplt,nvfft,
     &              torphase,dpltfac,dsplnrm,dspldbv,dspldav,
     &              psiscal,plsuprs,
     &              iomshp,ioeqlp,iowalp,
     &              ioeigp,iodbvp,iodavp,iodjvp,iopsip,
     &              iolinp,iolnbp,iolnap,iolnjp,
     &              iofftp,ioffbp,ioffap,ioffjp,
     &              ioconp,iodlbp,iodlap,iodljp,iodlwp,
     &              ioutw,iouta,ioute,ioutt,ioutp
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/tcpu/  timcpu,timiop,timsys,timwal,datestamp,timestamp,
     &              tim0c,tim0i,tim0s,tim0w,tim1c,tim1i,tim1s,tim1w
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
      namelist/inputd/ntor,ncase,norm,nmod,nlt,nlim,idnsty,ifastp
     &               ,ndnxp0,ndnxp1,ndnxp2,bfieldf,rdefolt,qxin,btdes
     &               ,qsurf,gamma,rmantl,betaf,zeffect
     &               ,nmap,neqtyp,mpreset,ndoublt,ndivert,ncorr,corrfac
     &               ,jpsi,itht,isym,igrid,nham1,nham2,nham3
     &               ,nmesh,npak,mpak,nedge,npkmax,nrat,nrepeat,nppack
     &               ,nqpack,nsrcheg,ncutedg,minpak,maxpak,incpak
     &               ,psipak,chiwth,cspak,psincr,pkfrac,qpfrac,epsrat
     &               ,sedg0,sedg1,plpak,pspak,epspak,spakmn
     &               ,swidmn,swidmx
     &               ,mapmaxd,dpsisl,dpsisd
     &               ,nqaxis,nspbc0,nspbc1,nwtmag,nfitmax,nfitpts
     &               ,ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs
     &               ,maxerlp,maxerlv,delbox,delboz,delac,delav
     &               ,delstsf,delstlp,delstlv,prfrac
     &               ,nerstop,nerprnt,qptol,tolspln,tolbchi
     &               ,tolbtor,tolsymm,tolaugm,errsep
     &               ,toldrdz,pvansh,precisn,plossmx,roundff,bigno
     &               ,narcmx,ntrymx,ntdecr,ntmmin
     &               ,nccellr,peqpk0,peqpk1,peqpk2,npfit,npcmin,kuttaop
     &               ,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm
     &               ,stepfac,flxstp,psispl,tolnwtp,tolnwtm
     &               ,delpakf,delpakc,delpkf,delpkc,psichek,boxtnd
     &               ,maptrace,norient,maxcutc
     &               ,dresolv,dlclose,pntshft,endtol
     &               ,narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax
     &               ,bperor,sersnm,sertnm,arcmin,delgap,stepcut
     &               ,iwal,iwalsym,nwall,irext,norign,nekdefn,maxitek
     &               ,rext,rexmax,rcutoff
     &               ,nrestrt,ndskopt,ndsktim,ndsksz,buffact
     &               ,nev,neigmax,nforce,nreslv,nbrmax
     &               ,nismax,ncymax,nitmax,ncyfin,mxdcomp
     &               ,al0,dal0,al0bas,al0min,al0max,epschy,epscon
     &               ,lineplt,lampplt,njplot,niplot,nskpj,nskpi,njedge
     &               ,ntphase,npowr,ncont,ncplot,mshpsi,mshchi,nxisgn
     &               ,nxiplt,nxuplt,nxrplt,nxpplt,nxdplt,ncphip
     &               ,nbiplt,nbuplt,nbrplt,nbpplt
     &               ,naiplt,nauplt,narplt,napplt
     &               ,ndpplt,njiplt,njuplt,njrplt,njpplt,nvfft
     &               ,torphase,dpltfac,dsplnrm,dspldbv,dspldav
     &               ,psiscal,plsuprs
     &               ,iomshp,ioeqlp,iowalp
     &               ,ioeigp,iodbvp,iodavp,iodjvp,iopsip
     &               ,iolinp,iolnbp,iolnap,iolnjp
     &               ,iofftp,ioffbp,ioffap,ioffjp
     &               ,ioconp,iodlbp,iodlap,iodljp,iodlwp
     &               ,novap,iplotm,ioutm,ioutw,iouta,ioute,ioutt
     &               ,ioutp
c
c
c
c 1.0 Write out heading and namelist input
c
c 1.1 Write the heading
c
      write(kutty,1000) sourcnam,sourcdat,version,datestamp,timestamp
      write(kuout,1010) sourcnam,sourcdat,version,datestamp,timestamp
      do 100 k2  = 1,nhd2
      write(kutty,1020) (headr(k1,k2),k1=1,nhd1)
      write(kuout,1030) (headr(k1,k2),k1=1,nhd1)
  100 continue
c
c
c 1.2 Write the namelist
c
      write(kuout,inputd)
c
c
c
c 2.0 Return and end
c
      return
 1000 format(6x,a8,2x, 'Source Date: ',a16,2x,'Version:  ',a8,/
     &            ,16x,'Run Date:    ',a10,8x,'Run Time: ',a10,/)
 1010 format(6x,a8,2x, 'Source Date: ',a16,2x,'Version:  ',a8,/
     &            ,16x,'Run Date:    ',a10,8x,'Run Time: ',a10,/)
 1020 format(1x,5a8)
 1030 format(1x, 5a8)
      end
      subroutine rdeqdsk
c
c -------------------------------------------------------------
c  Read eqgta file
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nft=5)
      parameter (nbd=1600,nbl=1200)
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension efitq(nxx),efitbdy(nbd),efitlim(nbl)
c
c
c
c 1.0 Read in the equilibrium
c
c 1.1 Read the title line and check the dimensions
c
c 1.1.1 Read the first line
c
      read(kueql,1000) (etitl(it),it=1,nft),date,ipestg,nx,nz
c
c 1.1.2 Check the parameters are consistent with dimensions
c
c 1.1.2.1 Set the actual storage dimensions
      nxd    = nxx
      nzd    = nxz
c
c 1.1.2.2 Check the paramaters are consistent with storage
      if(   nx  .gt. nxd) call abortjob
     &        ('rdeqdsk ',  1,   'nx exceeds allowed dimension nxd    '
     &        ,'nx      ', nx,       'nxd     ', nxd,      +1)
c
      if(   nz  .gt. nzd) call abortjob
     &        ('rdeqdsk ',  2,   'nz exceeds allowed dimension nzd    '
     &        ,'nz      ', nz,       'nzd     ', nzd,      +1)
c
      if(ipestg .ne. +3) then
        if    (ipestg .lt.  0 ) then
          call abortjob
     &        ('rdeqdsk ',  3,   'ipestg from equilibrium negative    '
     &        ,'ipestg  ', ipestg,   'nx      ', nx,       -1)
          ipestg   = +3
c
        elseif(ipestg .eq.  0 ) then
          call abortjob
     &        ('rdeqdsk ',  4,   'ipestg from equilibrium is zero     '
     &        ,'ipestg  ', ipestg,   'nx      ', nx,       -1)
          ipestg   = +3

        elseif(ipestg .gt.  0 ) then
          call abortjob
     &        ('rdeqdsk ',  5,   'ipestg from equilibrium not =  3    '
     &        ,'ipestg  ', ipestg,   'nx      ', nx,       -1)
          ipestg   = min0(ipestg,+4)
         endif
       endif
c
c 1.1.3 Check for consistency with the profile dimensions
c
      nprofl   = nx
      if(nprofl .gt. npp) call abortjob
     &        ('rdeqdsk ',  6,   'nx exceeds profile dimension npp    '
     &        ,'nprofl  ', nprofl,   'npp     ', npp,      +1)
c
c
c 1.2 Read the equilibrium constants
c
      read(kueql,1010) xdim,zdim,rcnt,redge
      read(kueql,1010) xma,zma,psimax,psilim,btor
      read(kueql,1010) totcur,psimx(1),psimx(2),xax(1),xax(2)
      read(kueql,1010) zax(1),zax(2),psisep,xsep,zsep
c
c
c 1.3 Read the equilibrium profiles
c
      read(kueql,1010) (sf  (kk),  kk = 1,nprofl)
      read(kueql,1010) (sp  (kk),  kk = 1,nprofl)
      read(kueql,1010) (sffp(kk),  kk = 1,nprofl)
      read(kueql,1010) (spp (kk),  kk = 1,nprofl)
c
c
c 1.4 Read the poloidal flux
c
      read(kueql,1010) ((psarray(ii,jj), ii = 1,nx), jj = 1,nz)
c
c
c 1.5 Set up the density profile
c
c 1.5.1 Set the density to a constant if not read
c
      if    (idnsty .le. 0) then
         do 100 kk = 1,nprofl
         sdns(kk)  = 1.0
  100    continue
c
c 1.5.2 Read the density profile for standard eqdsk files
c
      elseif(idnsty .eq. 1) then
c
c 1.5.2.1 Read the equilibrium q profile
         read(kueql,1010) (efitq(kk), kk = 1,nprofl)
c
c 1.5.2.2 Read and check the boundary and limiter dimensions
         read(kueql,1020) neftbd,neftlm
c
         nefbdy   =  2*neftbd
         neflim   =  2*neftlm
         if(nefbdy .gt. nbd) call abortjob
     &        ('rdeqdsk ',  7,   'nefbdy exceeds allowed dimension    '
     &        ,'nefbdy  ', nefbdy,   'nbd     ', nbd,      +1)
c
         if(neflim .gt. nbl) call abortjob
     &        ('rdeqdsk ',  8,   'neflim exceeds allowed dimension    '
     &        ,'neflim  ', neflim,   'nbl     ', nbl,      +1)
c
c 1.5.2.3 Read the boundary and limiter data
         read(kueql,1010) (efitbdy(ll),ll = 1,nefbdy)
         read(kueql,1010) (efitlim(ll),ll = 1,neflim)
c
c 1.5.2.4 Read the density profile
         read(kueql,1010) (sdns(kk),  kk = 1,nprofl)
c
c 1.5.3 For alternative eqdsk files read the rotation data also
c
      elseif(idnsty .gt. 1) then
c
c 1.5.3.1 Read the equilibrium q profile
         read(kueql,1010) (efitq(kk), kk = 1,nprofl)
c
c 1.5.3.2 Read and check the boundary and limiter dimensions
         read(kueql,1020) neftbd,neftlm
         nefbdy   =  2*neftbd
         neflim   =  2*neftlm
         if(nefbdy .gt. nbd) call abortjob
     &        ('rdeqdsk ',  9,   'nefbdy exceeds allowed dimension    '
     &        ,'nefbdy  ', nefbdy,   'nbd     ', nbd,      +1)
         if(neflim .gt. nbl) call abortjob
     &        ('rdeqdsk ', 10,   'neflim exceeds allowed dimension    '
     &        ,'neflim  ', neflim,   'nbl     ', nbl,      +1)
c
c 1.5.3.3 Read the boundary and limiter data
         read(kueql,1010) (efitbdy(ll),ll = 1,nefbdy)
         read(kueql,1010) (efitlim(ll),ll = 1,neflim)
c
c 1.5.3.4 Read the density fit data and the rotation data if present
         if(idnsty .eq. 2) read(kueql,1030) kvtor,rvtor,nmass
         if(idnsty .gt. 2) read(kueql,1035) nmass
c
c 1.5.3.5 Read the density profile
c
c 1.5.3.5.1 Read the density profile if nmass is set to indicate data is available
         if    (nmass .ge. 1) then
            read(kueql,1010) (sdns(kk),  kk = 1,nprofl)
c
c 1.5.3.5.2 If nmass is not set correctly, print a warning and set the density constant
         elseif(nmass .le. 1) then
            call abortjob
     &        ('rdeqdsk ', 11,   'Density data is not available       '
     &        ,'nmass   ', nmass,    'idnsty  ', idnsty,   -1)
            do 150 kk = 1,nprofl
            sdns(kk)  = 1.0
  150       continue
         endif
      endif
c
c
c
c 2.0 Set up the default flux mesh
c
c 2.1 Set the option for sffp sffp = f*fprime or = f*f
c
      if    (ipestg .ge. 3) then
        npst   = 0
      elseif(ipestg .lt. 3) then
        npst   = 1
        call abortjob
     &        ('rdeqdsk ', 12,   'Use derivative p, f for pp, ffp     '
     &        ,'ipestg  ', ipestg,   'npst    ', npst,     -1)
      endif
c
c
c 2.2 Set up flux mesh for interpolation of equilibrium profiles
c
      dpsrct          = (psilim-psimax)/(nprofl-1.0)
      do 200 kk       = 1,nprofl
      psimsh(kk)      = psimax + (kk-1.0)*dpsrct
  200 continue
      psimsh(   1  )  = psimax
      psimsh(nprofl)  = psilim
c
c
c
c 3.0 Return and end
c
      return
c
 1000 format(6a8,3i4)
 1010 format(5e16.9)
 1020 format(2(1x,i4))
 1030 format(i5,e16.9,i5)
 1035 format(i5)
      end
      subroutine rdtoqmp
c
c -------------------------------------------------------------
c  Read inverse equilibrium file from TOQ or TEQ
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Set parameters
c
      nppd      = npp
      nttd      = ntt
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
      keqtype = neqtyp
c
      if(kmap .le.  0) then
         call abortjob
     &        ('rdtoqmp ',  1,   'Incorrect equilibrium file type     '
     &        ,'kmap    ', kmap,     'ktype   ', ktype,    -1)
         return
      endif
c
      if(ktype .le.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('rdtoqmp ',  2,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Set basic roundoff parameter
c
      rndoff    = roundff

c
c
c 1.4 Set the conversion factors
c
      punits    = 1.0
c
c
c
c 2.0 Read in the inverse equilibrium scalar data
c
c 2.1 For new style equilibrium
c
      if    (keqtype .eq. 0) then
c
c 2.1.1 Read the heading and date         (new style)
c
        read (kueql,1000) date
        read (kueql,1000) (etitl(it),it=1,nft)
c
c 2.1.2 Read the dimensions               (new style)
c
        read (kueql,1010) npsi,ntht,neqsym
c
c
c 2.2 For old-style up-down symmetric equilibrium
c
      elseif(keqtype .ne. 0) then
c
c 2.2.1 Set the default heading and date  (old style)
c
        date      = 'unknown'
        do 10 it  = 1,nft
        etitl(it) = ' '
   10   continue
c
        if(nft .ge. 3) then
           etitl(1) = 'Equilibr'
           etitl(2) = 'ium from'
           etitl(3) = 'TOQ'
        endif
c
c 2.2.2 Read the dimensions                (old style)
c
c 2.2.2.1 Read npsi and ntht
        read (kueql,1020) npsi,ntht
c
c 2.2.2.2 Set default for up-down symmetric equilibrium
        neqsym  = 1
      endif
c
c
c 2.3 Check for incorrect dimensions
c
      if(neqsym .eq. 0) nth2        =    ntht
      if(neqsym .eq. 1) nth2        = 2*(ntht-1) + 1
c
      if((npsi   .le. 0) .or. (npsi   .gt. nppd)) call abortjob
     &        ('rdtoqmp ',  3,   'npsi outside allowed dimensions     '
     &        ,'npsi    ', npsi,     'nppd    ', nppd,     +1)
c
      if((nth2   .le. 0) .or. (nth2   .gt. nttd)) call abortjob
     &        ('rdtoqmp ',  4,   'nth2 outside allowed dimensions     '
     &        ,'nth2    ', nth2,     'nttd    ', nttd,     +1)
c
      if((neqsym .lt. 0) .or. (neqsym .gt.  1 )) call abortjob
     &        ('rdtoqmp ',  5,   'neqsym is neither zero nor one      '
     &        ,'neqsym  ', neqsym,   'npsi    ', npsi,     +1)
c
c
c 2.4 Read the equilibrium scalar data
c
      read (kueql,2000) rcnt,xma,zma,btor
      if(keqtype .eq. 0) read (kueql,2000) totcur,axddxz
      if(keqtype .eq. 1) read (kueql,2000) totcur,axddxz,dnnorm
c
c
c
c 3.0 Read the equilibrium quantities
c
c 3.1 Read the profiles
c
      read (kueql,2000) (psimsh (jj), jj = 1,npsi)
      read (kueql,2000) (sf     (jj), jj = 1,npsi)
      read (kueql,2000) (sffp   (jj), jj = 1,npsi)
      read (kueql,2000) (sp     (jj), jj = 1,npsi)
      read (kueql,2000) (spp    (jj), jj = 1,npsi)
      read (kueql,2000) (sqvl   (jj), jj = 1,npsi)
      read (kueql,2000) (sdns   (jj), jj = 1,npsi)
c
c
c 3.2 Read the inverse mapping r(psii,theta), and z(psi,theta)
c
c 3.2.1 Read the derivatives of the poloidal flux around the boundary
c         Note: the input may have this switched!
c
      read (kueql,2000) (seqdpdr(ii), ii = 1,ntht)
      read (kueql,2000) (seqdpdz(ii), ii = 1,ntht)
c
c 3.2.2 Read the inverse equilibrium (r,z)
c
      read (kueql,2000) ((seqrps(jj,ii), jj = 1,npsi), ii = 1,ntht)
      read (kueql,2000) ((seqzps(jj,ii), jj = 1,npsi), ii = 1,ntht)
c
c
c 3.3 Read all the necessary mapping data for kmap = 2
c
      if(kmap .eq. +2) then
c
c 3.3.1 Read the arclength array
c
        read (kueql,2000) ((seqarc(jj,ii), jj = 1,npsi), ii = 1,ntht)
c
c 3.3.2 Read the required equilibrium functions
c
        read (kueql,2000) ((seqf3 (jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf4 (jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf5 (jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf7 (jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf8 (jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf9 (jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf10(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf11(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf12(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf13(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf14(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf15(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf16(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf17(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf18(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf19(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf20(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf21(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf22(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf23(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf24(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf25(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf26(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf27(jj,ii), jj = 1,npsi), ii = 1,ntht)
        read (kueql,2000) ((seqf28(jj,ii), jj = 1,npsi), ii = 1,ntht)
c
c 3.3.3 Read the PEST poloidal angle
c
        read (kueql,2000) ((seqpst(jj,ii), jj = 1,npsi), ii = 1,ntht)
      endif
c
c
c 3.4 Set the dimensions
c
c 3.4.1 Set the profile dimensions
c
      nprofl   = npsi
      npst     = 0
c
c 3.4.2 Set the full number of poloidal angles
c
c 3.4.2.1 For up-down asymetric case:
      if    (neqsym .eq. 0) then
        nthet         =    ntht
c
c 3.4.2.2 For up-down symmetric case
c
      elseif(neqsym .eq. 1) then
        nthet         = 2*(ntht-1) + 1
        nthp1         = ntht + 1
      endif
c
c
c
c 4.0 Reset the conventions if nonstandard
c
c 4.1 Set roundoff parameters
c
      bfield0   = abs(btor)
      if(bfield0 .eq. 0.0) bfield0 = bfieldf
      psifact   = bfield0
      prsfact   = (bfield0*bfield0)/amu
c
      rndofbf   = rndoff*bfield0
      rndofps   = rndoff*psifact
      rndofpr   = rndoff*prsfact
      rndofr    = rndoff*rcnt
c
c 4.2 Modify the units
c
c 4.2.1 Reset the pressure units
c
      do 100 jj   = 1,nprofl
      sp   (jj)   = sp   (jj)/punits
      spp  (jj)   = spp  (jj)/punits
  100 continue
c
c
c 4.3 Reverse signs if input has alternate psi convention
c
      if(psimsh(1) .gt. psimsh(nprofl)) then
c
c 4.3.1 For kmap = 1 reverse signs of psimsh and psi derivatives
c
c 4.3.1.1 Print a warning
        if    (kmap .eq. +1) then
          call abortjob
     &        ('rdtoqmp ',  6,   'Reversing convention for psi        '
     &        ,'kmap    ', kmap,     'nprofl  ', nprofl,   -1)
c
c 4.3.1.2 Reverse the signs
          do 150 jj  = 1,nprofl
          psimsh(jj) = -psimsh(jj)
          sffp  (jj) = -sffp  (jj)
          spp   (jj) = -spp   (jj)
  150     continue

c
c 4.3.2 For kmap = 2 print a warning:  the seqfnm quantities need
c       to be reversed where appropriate
c
        elseif(kmap .eq. +2) then
          call abortjob
     &        ('rdtoqmp ',  7,   'Cannot reverse btor for kmap = 2    '
     &        ,'kmap    ', kmap,     'nprofl  ', nprofl,   -1)
        endif
      endif
c
c
c 4.4 Check the signs of btor and sf are consistent
c
c 4.4.1 Check the signs for btor and sf(nprofl)
c
        sfedge     = sf(nprofl)
c
        if(btor   .lt. 0.0) ibsign  = -1
        if(btor   .eq. 0.0) ibsign  =  0
        if(btor   .gt. 0.0) ibsign  = +1
c
        if(sfedge .lt. 0.0) ifsign  = -1
        if(sfedge .eq. 0.0) ifsign  =  0
        if(sfedge .gt. 0.0) ifsign  = +1
c
c 4.4.2 Print a warning if btor or sfedge is zero
c
        if(ibsign .eq. 0) call abortjob
     &        ('rdtoqmp ',  8,   'sign of btor is zero                '
     &        ,'ibsign  ', ibsign,   'ifsign  ', ifsign,   -1)
c
        if(ifsign .eq. 0) call abortjob
     &        ('rdtoqmp ',  9,   'sign of sfedge is zero              '
     &        ,'ibsign  ', ibsign,   'ifsign  ', ifsign,   -1)
c
c 4.4.3 Switch the sign of btor if it is inconsistent
c
        if(ibsign .ne. ifsign) then
          call abortjob
     &        ('rdtoqmp ', 10,   'btor and sf are different sign      '
     &        ,'ibsign  ', ibsign,   'ifsign  ', ifsign,   -1)
c
          btor      = -btor
        endif
c
c
c 4.5 Check the sign conventions of btor and totcur are consistent
c
c 4.5.1 Check the signs of btor and totcur
c
        if(btor   .lt. 0.0) ibsign  = -1
        if(btor   .eq. 0.0) ibsign  =  0
        if(btor   .gt. 0.0) ibsign  = +1
c
        if(totcur .lt. 0.0) itsign  = -1
        if(totcur .eq. 0.0) itsign  =  0
        if(totcur .gt. 0.0) itsign  = +1
c
c 4.5.2 Switch the sign of totcur if the convention is reversed
c
        if(ibsign .lt. 0  .and.  itsign .lt. 0) then
          call abortjob
     &        ('rdtoqmp ', 11,   'btor and conventions switched       '
     &        ,'ibsign  ', ibsign,   'itsign  ', itsign,   -1)
          totcur     = -totcur
        endif
c
c     
c
c 5.0 Set up the auxiliary quantities
c
c 5.1 Set scalar magnetic axis values
c
      psimax          = psimsh( 1 )
      psilim          = psimsh(nprofl)
      psisep          = psimax
c
      xax(1)          = xma
      xax(2)          = 0.0
      zax(1)          = zma
      zax(2)          = 0.0
      psimx(1)        = psimax
      psimx(2)        = 0.0
c
      xlim            = seqrps(npsi,1)
      zlim            = seqzps(npsi,1)
      xsep            = 0.0
      zsep            = 0.0
c
c
c 5.2 Check for consistent input
c
      if(neqsym .eq. 0  .and.  isym .ne. 0) call abortjob
     &        ('rdtoqmp ', 12,   'Asymmetric equilibrium with isym = 1'
     &        ,'neqsym  ', neqsym,   'isym    ', isym,     -1)
      if(neqsym .ne. 0  .and.  isym .eq. 0) call abortjob
     &        ('rdtoqmp ', 13,   'neqsym and isym are inconsistent    '
     &        ,'neqsym  ', neqsym,   'isym    ', isym,      0)
c
c
c 5.3 Set sfqi equal to sf*sqvl
c
        do 180 jj     = 1,npsi
        sfqi(jj)      = sf(jj)*sqvl(jj)
  180   continue
c
c
c
c 6.0 Set the number of poloidal angles and complete arrays
c     for up-down symmetry
c
c 6.1 Fill the r and z arrays for up-down symmetry
c
      if(neqsym .eq. 1) then
c
c 6.1.1 Ensure the magnetic axis is on the midplane
c
c 6.1.1.1 Check for discrepancy
        if(abs(zma) .gt. 0.0) then
          if(abs(zma) .le. rndofr) call abortjob
     &        ('rdtoqmp ', 14,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,     0)
          if(abs(zma) .gt. rndofr) call abortjob
     &        ('rdtoqmp ', 15,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,    -1)
          write(kuout,3000) xma,zma
        endif
c
c 6.1.1.2 Reset the axis on the midplane
        zma           = 0.0
c
c
c 6.2 Ensure the first flux surface is at the magnetic axis
c
c 6.2.1 Check for discrepancy
c
        ikr0          = 0
        ikr1          = 0
        ikz0          = 0
        ikz1          = 0
        suminr        = 0.0
        suminz        = 0.0
        do 200 ii     = 1,ntht
c
c 6.2.1.1 Check the r value is the axis value
        dscinr        = seqrps(1,ii) - xma
        suminr        = suminr + abs(dscinr)
        if(abs(dscinr) .ne. 0.0) then
          if(abs(dscinr) .le. rndofr) ikr0   = ikr0 + 1
          if(abs(dscinr) .gt. rndofr) ikr1   = ikr1 + 1
        endif
c
c 6.2.1.2 Check the z value is the axis value
        dscinz        = seqzps(1,ii) - zma
        suminz        = suminz + abs(dscinz)
        if(abs(dscinz) .ne. 0.0) then
          if(abs(dscinz) .le. rndofr) ikz0   = ikz0 + 1
          if(abs(dscinz) .gt. rndofr) ikz1   = ikz1 + 1
        endif
c
  200   continue
c
c 6.2.1.3 Find the mean discrepancy
        suminr        = suminr / float(ntht)
        suminz        = suminz / float(ntht)
c
c 6.2.2 Print error message if any discrepancy
c
        if(ikr0 .gt. 0  .or.  ikr1 .gt. 0  .or.  ikz0 .gt. 0  .or.
     &                                           ikz1 .gt. 0) then
          if(ikr0 .gt. 0) call abortjob
     &        ('rdtoqmp ', 16,   'Small Discrepancy in seqrps(1)      '
     &        ,'ikr0    ', ikr0,     'neqsym  ', neqsym,    0)
          if(ikz0 .gt. 0) call abortjob
     &        ('rdtoqmp ', 17,   'Small Discrepancy in seqzps(1)      '
     &        ,'ikz0    ', ikz0,     'neqsym  ', neqsym,    0)
          if(ikr1 .gt. 0) call abortjob
     &        ('rdtoqmp ', 18,   'Large Discrepancy in seqrps(1)      '
     &        ,'ikr1    ', ikr1,     'neqsym  ', neqsym,   -1)
          if(ikz1 .gt. 0) call abortjob
     &        ('rdtoqmp ', 19,   'Large Discrepancy in seqzps(1)      '
     &        ,'ikz1    ', ikz1,     'neqsym  ', neqsym,   -1)
          write(kuout,3100) npsi,ntht,suminr,suminz
          if(ikr1 .gt. 0  .or.  ikz1 .gt. 0) then
            write(kuout,3110)
            write(kuout,3120) (iii, seqrps(1,iii), seqzps(1,iii),
     &                              iii=1,ntht)
          endif
        endif
c
c 6.2.3 Reset the first flux surface identically to the axis values
c
        do 210 ii     = 1,ntht
        seqrps(1,ii)  = xma
        seqzps(1,ii)  = zma
  210   continue
c
c
c 6.3 Ensure that the first and last ray lay along the midplane
c
c 6.3.1 Check for discrepancy
c
        jkm0          = 0
        jkm1          = 0
        jkp0          = 0
        jkp1          = 0
        sumray1       = 0.0
        sumrayn       = 0.0
        do 220 jj     = 1,npsi
c
c 6.3.1.1 Check the first ray is on the midplane
        dscray1       = seqzps(jj,  1 ) - zma
        sumray1       = sumray1 + abs(dscray1) 
        if(abs(dscray1) .ne.   0.0 ) then
          if(abs(dscray1) .le. rndofr) jkm0   = jkm0 + 1
          if(abs(dscray1) .gt. rndofr) jkm1   = jkm1 + 1
        endif
c
c 6.3.1.2 Check the last  ray is on the midplane
        dscrayn       = seqzps(jj,ntht) - zma
        sumrayn       = sumrayn  +  abs(dscrayn)
        if(abs(dscrayn) .ne.   0.0 ) then
          if(abs(dscrayn) .le. rndofr) jkp0   = jkp0 + 1
          if(abs(dscrayn) .gt. rndofr) jkp1   = jkp1 + 1
        endif
  220   continue
c
c 6.3.1.3 Find the mean discrepancy
        sumray1       = sumray1 / float(npsi)
        sumrayn       = sumrayn / float(npsi)
c
c 6.3.2 Print error message if any discrepancy
c
        if(jkm0 .gt. 0  .or.  jkp0 .gt. 0  .or.  jkm1 .gt. 0  .or.
     &                                           jkp1 .gt. 0) then
          if(jkm0 .gt. 0) call abortjob
     &        ('rdtoqmp ', 20,   'First ray slightly off midplane     '
     &        ,'jkm0    ', jkm0,     'neqsym  ', neqsym,    0)
          if(jkp0 .gt. 0) call abortjob
     &        ('rdtoqmp ', 21,   'Last  ray slightly off midplane     '
     &        ,'jkp0    ', jkp0,     'neqsym  ', neqsym,    0)
          if(jkm1 .gt. 0) call abortjob
     &        ('rdtoqmp ', 21,   'First ray is not on the midplane    '
     &        ,'jkm1    ', jkm1,     'neqsym  ', neqsym,   -1)
          if(jkp1 .gt. 0) call abortjob
     &        ('rdtoqmp ', 22,   'Last  ray is not on the midplane    '
     &        ,'jkp1    ', jkp1,     'neqsym  ', neqsym,   -1)
          write(kuout,3200) npsi,ntht,sumray1,sumrayn
          if(jkm1 .gt. 0  .or.  jkp1 .gt. 0) then
            write(kuout,3210)
            write(kuout,3220) (jjj, seqrps(jjj,  1 ), seqzps(jjj,  1 ),
     &                              seqrps(jjj,ntht), seqzps(jjj,ntht),
     &                                                jjj=1,npsi)
          endif
        endif
c
c 6.3.3 Reset the rays along the midplane
c
        do 230 jj       = 1,npsi
        seqzps(jj,  1 ) = 0.0
        seqzps(jj,ntht) = 0.0
  230   continue
c
c
c 6.4 Fill the complete r and z arrays
c
        do 250 ii     = nthp1,nthet
        i1            = ii
        i0            = nthet + 1 - i1
c
        do 240 jj     = 1,npsi
        seqrps(jj,i1) = +seqrps(jj,i0)
        seqzps(jj,i1) = -seqzps(jj,i0)
  240   continue
  250   continue
      endif
c
c
c
c 7.0 Set the necessary auxilliary quantities for kmap = 2
c
      if(kmap .eq. +2) then
c
c 7.1 Set sfqi equal to sqvl and the Hamiltonian angle equal to
c     the PEST angle
c
c 7.1.1 Set sfqi equal to sf*sqvl
c
        do 320 jj     = 1,npsi
        sfqi(jj)      = sf(jj)*sqvl(jj)
c
c 7.1.2 Set the Hamiltonian angle to the PEST angle
c
        do 310 ii     = 1,ntht
        seqham(jj,ii) = seqpst(jj,ii)
  310   continue
  320   continue
c
c
c 7.2 Temporarily set the PEST and hamiltonian angles on axis
c     to nonzero values
c
        if(seqpst(1,ntht) .eq. 0.0) then
          do 400 ii     = 1,ntht
          seqpst(1, ii) = seqpst(2, ii)
          seqham(1, ii) = seqham(2, ii)
  400     continue
        endif
c
c
c 7.3 Reset unit and sign conventions
c
        do 440 jj     = 1,npsi
        do 420 ii     = 1,ntht
c
c 7.3.1 Flip the sign of the non-orthogonality
c
        seqf20(jj,ii) = -seqf20(jj,ii)
  420   continue
  440   continue
c
c
c 7.4 Reset the ratio of specific heats according to the namelist input
c
        gamatoq       = 5.0/3.0
        gamainp       = gamav
        gamarat       = gamainp/gamatoq
c
        do 520 jj     = 1,npsi
        do 500 ii     = 1,ntht
        seqf11(jj,ii) = gamarat*seqf11(jj,ii)
  500   continue
  520   continue
c
c
c 7.5 Fill the complete equilibrium arrays for up-down symmetry
c
        if(neqsym .eq. 1) then
          do 600 ii     = nthp1,nthet
          i1            = ii
          i0            = nthet + 1 - i1
          seqdpdr(i1)   = +seqdpdr(i0)
          seqdpdz(i1)   = -seqdpdz(i0)
c
          do 550 jj     = 1,npsi
          seqrps(jj,i1) = +seqrps(jj,i0)
          seqzps(jj,i1) = -seqzps(jj,i0)
          seqf3 (jj,i1) = +seqf3 (jj,i0)
          seqf4 (jj,i1) = +seqf4 (jj,i0)
          seqf5 (jj,i1) = +seqf5 (jj,i0)
          seqf7 (jj,i1) = +seqf7 (jj,i0)
          seqf8 (jj,i1) = +seqf8 (jj,i0)
          seqf9 (jj,i1) = +seqf9 (jj,i0)
          seqf10(jj,i1) = +seqf10(jj,i0)
          seqf11(jj,i1) = +seqf11(jj,i0)
          seqf12(jj,i1) = +seqf12(jj,i0)
          seqf13(jj,i1) = +seqf13(jj,i0)
          seqf14(jj,i1) = +seqf14(jj,i0)
          seqf15(jj,i1) = -seqf15(jj,i0)
          seqf16(jj,i1) = +seqf16(jj,i0)
          seqf17(jj,i1) = -seqf17(jj,i0)
          seqf18(jj,i1) = +seqf18(jj,i0)
          seqf19(jj,i1) = +seqf19(jj,i0)
          seqf20(jj,i1) = -seqf20(jj,i0)
          seqf21(jj,i1) = +seqf21(jj,i0)
          seqf22(jj,i1) = -seqf22(jj,i0)
          seqf23(jj,i1) = +seqf23(jj,i0)
          seqf24(jj,i1) = +seqf24(jj,i0)
          seqf25(jj,i1) = -seqf25(jj,i0)
          seqf26(jj,i1) = -seqf26(jj,i0)
          seqf27(jj,i1) = +seqf27(jj,i0)
          seqf28(jj,i1) = -seqf28(jj,i0)
c
          seqarc(jj,i1) = -seqarc(jj,i0) + 2.0*seqarc(jj,ntht)
          seqpst(jj,i1) = -seqpst(jj,i0) + 2.0*seqpst(jj,ntht)
          seqham(jj,i1) = -seqham(jj,i0) + 2.0*seqham(jj,ntht)
  550     continue
  600     continue
        endif
      endif
c
c
c
c 8.0 Return and end
c
      return
c
 1000 format(6a8)
 1010 format(3i5)
 1020 format(2i5)
 2000 format(1p4e19.12)
 3000 format(/,1x,'xma    = ',e16.9,4x,'zma    = ',e16.9)
 3100 format(/,10x,'npsi    = ',i5,    2x,'ntht    = ',i5,/
     &        ,10x,'suminr  = ',e16.9, 4x,'suminz  = ',e16.9)
 3110 format(/, 4x,'ii',6x,'seqrps(1,ii)',5x,'seqzps(1,ii)')
 3120 format((1x,i5,2x,2(1x,e16.9)))
 3200 format(/,10x,'npsi    = ',i5,    2x,'ntht    = ',i5,//
     &        ,10x,'sumray1 = ',e16.9, 4x,'sumrayn = ',e16.9)
 3210 format(/, 4x,'jj',6x,'seqrps(jj,  1 )',2x,'seqzps(jj,  1 )'
     &                ,2x,'seqrps(jj,ntht)',2x,'seqzps(jj,ntht)')
 3220 format((1x,i5,2x,4(1x,e16.9)))
      end
      subroutine rdjsvmp
c >>>> Replace half grid cell shift by sintrp interpolation, using averaged
c >>>> derivatives from pprime and fprime
c >>>> Set totcur
c
c -------------------------------------------------------------
c  Read inverse equilibrium file from JSOLVER
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension sqvlp(npp)
      dimension sg1  (npp), sg2  (npp), sg3  (npp), sg4  (npp)
      dimension seqaj0(npp,ntt), seqaj3(npp,ntt)
c
      equivalence (sqvlp ( 1 ),sfqi  ( 1 ))
      equivalence (seqaj0(1,1),seqarc(1,1)) , (seqaj3(1,1),seqpst(1,1))
      equivalence (sg1   ( 1 ),seqf4 (1,1)) , (sg2   ( 1 ),seqf5 (1,1)),
     &            (sg3   ( 1 ),seqf7 (1,1)) , (sg4   ( 1 ),seqf8 (1,1))
c
c
c
c 1.0 Initialization
c
c 1.1 Set the dimensions
c
      nppd      = npp
      nttd      = ntt
c
c
c 1.2 Check the equilibrium type
c
      kmap    = nmap
      ktype   = nmtype
      keqtype = neqtyp
c
      if(kmap .ne.  -1) then
         call abortjob
     &        ('rdjsvmp ',  1,   'Incorrect equilibrium file type     '
     &        ,'kmap    ', kmap,     'ktype   ', ktype,    -1)
         return
      endif
c
      if(ktype .ne.  +1) then
         call abortjob
     &        ('rdjsvmp ',  2,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Set the conversion factors
c
      if(bfieldf .ne. 0.0) bfield0   = bfieldf
      if(bfieldf .eq. 0.0) bfield0   = 1.0
      psifact   =  bfield0
      prsfact   = (bfield0*bfield0)/amu
c
c
c 1.4 Set basic roundoff parameter
c
      rndoff    = roundff
c
c
c 1.5 Set the adjustment in labeling used in JSOLVER
c
      ntadjst   = 2
      npadjst   = 0
c
c
c 1.6 Set the default heading and date
c
      date      = 'unknown'
      do 10 it  = 1,nft
      etitl(it) = ' '
   10 continue
c
      if(nft .ge. 3) then
         etitl(1) = 'Equilibr'
         etitl(2) = 'ium from'
         etitl(3) = 'JSOLVER'
      endif
c
c
c
c 2.0 Read in the inverse equilibrium scalar data
c
c 2.1 Read and check the dimensions
c
c 2.1.1 Read the input values
c
      read (kueql,1000) nthd1,npsd1,ntht,npsi,neqsym,dlr,dlt
c
c 2.1.2 Set the theta dimension according to up-down symmetry
c
c 2.1.2.1 Check for invalid symmetry switch
c
      if((neqsym .lt. 0) .or. (neqsym .gt.  1 )) then
         call abortjob
     &        ('rdjsvmp ',  3,   'neqsym is neither zero nor one      '
     &        ,'neqsym  ', neqsym,   'npsi    ', npsi,     -1)
         if(neqsym .lt. 0) neqsym  = 0
         if(neqsym .gt. 1) neqsym  = 1
      endif
c
c 2.1.2.2 Set the full theta array size
      if(neqsym .eq. 0) nth2        =    ntht
      if(neqsym .ne. 0) nth2        = 2*(ntht-1) + 1
c
c 2.1.3 Set sizes for excess zero values included in the input file
c
c 2.1.3.1 Set the size differences
      ntinpt    = nthd1   - ntht
      npinpt    = npsd1   - npsi
      nremt     = nthd1   - nttd
      nremp     = npsd1   - nppd
c
c 2.1.3.2 Set the last valid theta index from the JSOLVER indexing
      ntbegin   = ntadjst + 1
      ntlast    = ntht    + ntbegin
      ntlst2    = nth2    + ntbegin
      ntroom    = nttd    - ntlst2
      npbegin   = npadjst + 1
      nplast    = npsi    + npbegin - 1
      nproom    = nppd    - nplast
c
c 2.1.3.3 Check for invalid input dimensions
c
      if( ntinpt .lt. ntadjst) call abortjob
     &        ('rdjsvmp ',  4,   'ntht + ntadjst > dimension nthd1    '
     &        ,'ntht    ', ntht ,    'nthd1   ', nthd1,    +1)
c
      if( npinpt .lt. npadjst) call abortjob
     &        ('rdjsvmp ',  5,   'npsi + npadjst > dimension npsd1    '
     &        ,'npsi    ', npsi ,    'npsd1   ', npsd1,    +1)
c
c 2.1.3.4 Print a warning if the input array sizes are too large for the
c         dimensions
      if((nth2   .le. 0) .or. (ntlst2 .gt. nttd)) call abortjob
     &        ('rdjsvmp ',  6,   'nth2 outside allowed dimensions     '
     &        ,'nth2    ', nth2,     'nttd    ', nttd,     +1)
c
      if((npsi   .le. 0) .or. (nplast .gt. nppd)) call abortjob
     &        ('rdjsvmp ',  7,   'npsi outside allowed dimensions     '
     &        ,'npsi    ', npsi,     'nppd    ', nppd,     +1)
c
      if (nthd1  .gt. nttd) call abortjob
     &        ('rdjsvmp ',  8,   'nthd1 is larger than dimension      '
     &        ,'nthd1   ', nthd1,    'nttd    ', nttd,      0)
c
      if( npsd1  .gt. nppd) call abortjob
     &        ('rdjsvmp ',  9,   'npsd1 is larger than dimension      '
     &        ,'npsd1   ', npsd1,    'nppd    ', nppd,      0)
c
c
c 2.2 Read the equilibrium scalar data
c
      read (kueql,1100) rcnt,prnorm,psilimp,psiminp
c
c
c
c 3.0 Read the equilibrium quantities
c
c 3.1 Read the profiles
c
c 3.1.1 Read profiles up to the full input dimension written if the
c       available dimension is sufficient
c       sffp here is just sfp
c
      if    (nremp .le. 0) then
        read (kueql,2000)  (sp     (jj), jj = 1,npsd1)
        read (kueql,2000)  (spp    (jj), jj = 1,npsd1)
        read (kueql,2000)  (sqvl   (jj), jj = 1,npsd1)
        read (kueql,2000)  (sqvlp  (jj), jj = 1,npsd1)
        read (kueql,2000)  (sf     (jj), jj = 1,npsd1)
        read (kueql,2000)  (sffp   (jj), jj = 1,npsd1)
        read (kueql,2000)  (sg1    (jj), jj = 1,npsd1)
        read (kueql,2000)  (sg2    (jj), jj = 1,npsd1)
        read (kueql,2000)  (sg3    (jj), jj = 1,npsd1)
        read (kueql,2000)  (sg4    (jj), jj = 1,npsd1)
        read (kueql,2000)  (psimsh (jj), jj = 1,npsd1)
c
c 3.1.2 Read the profiles up to the available dimension and discard
c       the rest if the available dimension is insufficient
c
      elseif(nremp .gt. 0) then
        read (kueql,2000)  (sp     (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (spp    (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sqvl   (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sqvlp  (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sf     (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sffp   (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sg1    (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sg2    (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sg3    (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (sg4    (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
        read (kueql,2000)  (psimsh (jj), jj = 1,nppd )
     &                    ,(sdummy     , kk = 1,nremp)
      endif
c
c
c 3.2 Read the inverse mapping r(psii,theta), and z(psi,theta)
c
c 3.2.1 Read the inverse equilibrium (r,z)
c
c 3.2.1.1 Read the mapping up to the full input dimensions written if
c         the available dimensions are sufficient
      if    (nremp .le. 0  .and.  nremt .le. 0) then
         read (kueql,2000) ((seqrps(jj,ii), ii = 1,nthd1)
     &                                    , jj = 1,npsd1)
         read (kueql,2000) ((seqzps(jj,ii), ii = 1,nthd1)
     &                                    , jj = 1,npsd1)
c
c 3.2.1.2 Read the mapping up to the available dimension and discard
c         the rest if the available dimension in psi is insufficient
      elseif(nremp .gt. 0  .and.  nremt .le. 0) then
         read (kueql,2000) ((seqrps(jj,ii), ii = 1,nthd1)
     &                                    , jj = 1,nppd )
     &                    ,((sdummy       , ii = 1,nthd1)
     &                                    , kk = 1,nremp)
         read (kueql,2000) ((seqzps(jj,ii), ii = 1,nthd1)
     &                                    , jj = 1,nppd )
     &                    ,((sdummy       , ii = 1,nthd1)
     &                                    , kk = 1,nremp)
c
c 3.2.1.3 Read the mapping up to the available dimension and discard
c         the rest if the available dimension in theta is insufficient
      elseif(nremp .le. 0  .and.  nremt .gt. 0) then
         read (kueql,2000) ((seqrps(jj,ii), ii = 1,nttd )
     &                    , (sdummy       , ll = 1,nremt)
     &                                    , jj = 1,npsd1)
         read (kueql,2000) ((seqzps(jj,ii), ii = 1,nttd )
     &                    , (sdummy       , ll = 1,nremt)
     &                                    , jj = 1,npsd1)
c
c 3.2.1.4 Read the mapping up to the available dimension and discard
c         the rest if both available dimensions are insufficient
      elseif(nremp .gt. 0  .and.  nremt .gt. 0) then
         read (kueql,2000) ((seqrps(jj,ii), ii = 1,nttd )
     &                    , (sdummy       , ll = 1,nremt)
     &                                    , jj = 1,nppd )
     &                    ,((sdummy       , ii = 1,nttd )
     &                    , (sdummy       , ll = 1,nremt)
     &                                    , kk = 1,nremp)
         read (kueql,2000) ((seqzps(jj,ii), ii = 1,nttd )
     &                    , (sdummy       , ll = 1,nremt)
     &                                    , jj = 1,nppd )
     &                    ,((sdummy       , ii = 1,nttd )
     &                    , (sdummy       , ll = 1,nremt)
     &                                    , kk = 1,nremp)
      endif
c
c 3.2.2 Read all the Jacobian for keqtype = 1
c
      if(keqtype .ne. 0) then
c
c 3.2.2.1 Read the Jacobian up to the full input dimensions written if
c         the available dimensions are sufficient
         if    (nremp .le. 0  .and.  nremt .le. 0) then
            read (kueql,2000) ((seqaj3(jj,ii), ii = 1,nttd )
     &                                       , jj = 1,nppd )
            read (kueql,2000) ((seqaj0(jj,ii), ii = 1,nttd )
     &                                       , jj = 1,nppd )
c
c 3.2.2.2 Read the Jacobian up to the available dimension and discard
c         the rest if the available dimension in psi is insufficient
         elseif(nremp .gt. 0  .and.  nremt .le. 0) then
            read (kueql,2000) ((seqaj3(jj,ii), ii = 1,nttd )
     &                                       , jj = 1,nppd )
     &                       ,((sdummy       , ii = 1,nttd )
     &                                       , kk = 1,nremp)
            read (kueql,2000) ((seqaj0(jj,ii), ii = 1,nttd )
     &                                       , jj = 1,nppd )
     &                       ,((sdummy       , ii = 1,nttd )
     &                                       , kk = 1,nremp)
c
c 3.2.2.3 Read the Jacobian up to the available dimension and discard
c         the rest if the available dimension in theta is insufficient
         elseif(nremp .le. 0  .and.  nremt .gt. 0) then
            read (kueql,2000) ((seqaj3(jj,ii), ii = 1,nttd )
     &                       , (sdummy       , ll = 1,nremt)
     &                                       , jj = 1,nppd )
            read (kueql,2000) ((seqaj0(jj,ii), ii = 1,nttd )
     &                       , (sdummy       , ll = 1,nremt)
     &                                       , jj = 1,nppd )
c
c 3.2.2.4 Read the Jacobian up to the available dimension and discard
c         the rest if both available dimensions are insufficient
         elseif(nremp .gt. 0  .and.  nremt .gt. 0) then
            read (kueql,2000) ((seqaj3(jj,ii), ii = 1,nttd )
     &                       , (sdummy       , ll = 1,nremt)
     &                                       , jj = 1,nppd )
     &                       ,((sdummy       , ii = 1,nttd )
     &                       , (sdummy       , ll = 1,nremt)
     &                                       , kk = 1,nremp)
            read (kueql,2000) ((seqaj0(jj,ii), ii = 1,nttd )
     &                       , (sdummy       , ll = 1,nremt)
     &                                       , jj = 1,nppd )
     &                       ,((sdummy       , ii = 1,nttd )
     &                       , (sdummy       , ll = 1,nremt)
     &                                       , kk = 1,nremp)
         endif
      endif
c
c
c 3.3 Set the quantities that were not explicitly read in
c
c 3.3.1 Set the basic integer parameters
c
      nprofl      = npsi
      nthet       = nth2
      nthp1       = ntht + 1
c
c 3.3.2 Set the density profile
c
      dnnorm      = 1.0
      do 50 jj    = 1,nprofl
      sdns(jj)    = dnnorm
  50  continue
c
c
c
c 4.0 Modify the units
c
c 4.1 Set roundoff parameters
c
      rndofps     = rndoff*psifact
      rndofpr     = rndoff*prsfact
      rndofr      = rndoff*rcnt
c
c 4.2 Conversion factors
c
      radfact     = rcnt
      btffact     = radfact*bfield0
c
c
c 4.3 Reset the poloidal flux to Wb/m**2
c
c 4.3.1 Reset the end values
c
      psimaxa     = bfield0*psiminp/twopi
      psilima     = bfield0*psilimp/twopi
c
c 4.3.2 Reset the flux array
c
      do 100 jj   = 1,nprofl
      psimsh(jj)  = psifact*psimsh(jj)
  100 continue
c
c 4.3.3 Check the psi values are consistent
c
      psimax      = psimsh(1)
      psilim      = psimsh(nprofl)
      psmaxdf     = abs(psimax - psimaxa)
      pslimdf     = abs(psilim - psilima)
c
      if(psmaxdf .ge. rndofps) then
         call abortjob
     &        ('rdjsvmp ', 10,   'psi mesh and psimax inconsistent    '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
         write(kuout,3000) psimax,psimaxa,psmaxdf,rndofps
      endif
c
      if(pslimdf .ge. rndofps) then
         call abortjob
     &        ('rdjsvmp ', 11,   'psi mesh and psilim inconsistent    '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
         write(kuout,3010) psilim,psilima,pslimdf,rndofps
      endif
c
c
c 4.4 Reset the pressure and toroidal field units and shift the pressure
c     and toroidal field to the grid points
c
c 4.4.1 Reset the pressure and pprime units
c
      prnorm      = prsfact*prnorm
c
      do 120 jj   = 1,nprofl
      sp   (jj)   =  prsfact         *sp   (jj)
      spp  (jj)   = (prsfact/psifact)*spp  (jj)
  120 continue
c
c 4.4.2 Reset the toroidal field function and units
c
      fbnorm      = 1.0*btffact
c
      do 130 jj   = 1,nprofl
      sf   (jj)   =  fbnorm         *sf   (jj)
      sffp (jj)   = (fbnorm/psifact)*sffp (jj)
  130 continue
c
c 4.4.3 Reset the remaining input profile units
c
      do 140 jj   = 1,nprofl
      sqvlp(jj)   = (1.0/psifact)              *sqvlp(jj)
      sg1  (jj)   = (btffact/radfact)          *sg1  (jj)
      sg2  (jj)   = (btffact/(psifact*radfact))*sg2  (jj)
      sg3  (jj)   =  psifact                   *sg3  (jj)
      sg4  (jj)   =  1.0                       *sg4  (jj)
  140 continue
c
c 4.4.4 Shift the pressure, toroidal field function, and sg3 
c       half a grid call
c
c 4.4.4.1 Shift interior points
      do 150 jj   = 2,nprofl
      jjp         = nprofl - jj + 2
      spj1        = sp (jjp-1)
      spj2        = sp ( jjp )
      sfj1        = sf (jjp-1)
      sfj2        = sf ( jjp )
      sgj1        = sg3(jjp-1)
      sgj2        = sg3( jjp )
      sp (jjp)    = 0.5*(spj1 + spj2)
      sf (jjp)    = 0.5*(sfj1 + sfj2)
      sg3(jjp)    = 0.5*(sgj1 + sgj2)
  150 continue
c
c 4.4.4.2 Set the axis values
      sp(1)       = prnorm
      sf(1)       = sg1(1)*sqvl(1)
c
c 4.4.4.3 Enforce p = 0.0 at the edge
      pedge       = sp(nprofl)
      if(abs(pedge) .gt. rndoff*prnorm) then
         call abortjob
     &        ('rdjsvmp ', 12,   'Adjusted edge pressure not zero     '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
         sp(nprofl)  = 0.0
      endif
c
c 4.4.5 Reset the sffp to f*fprime
c
      do 160 jj   = 1,nprofl
      sffp (jj)   = sf   (jj)*sffp (jj)
  160 continue
c
c
c 4.5 Readjust the storage of the 2D mapping quantities
c
c 4.4.1 Readjust the storage of the mapping quantities seqrps and seqzps
c
      do 170 jj     = 1,nprofl
c
c 4.5.1.1 Store the excess points
      rrps1         = seqrps(jj,1)
      rrps2         = seqrps(jj,2)
      rrps3         = seqrps(jj,ntlast)
      zzps1         = seqzps(jj,1)
      zzps2         = seqzps(jj,2)
      zzps3         = seqzps(jj,ntlast)
c
c 4.5.1.2 Shift the index
      do 165 ii     = 1,ntht
      iip           = ii + ntadjst
      seqrps(jj,ii) = seqrps(jj,iip)
      seqzps(jj,ii) = seqzps(jj,iip)
  165 continue
c
c 4.5.1.3 Add the excess points to the end of the array if space exists
      if(ntroom .ge. 0) then
         seqrps(jj,ntht+1) = rrps3
         seqrps(jj,ntht+2) = rrps2
         seqrps(jj,ntlast) = rrps1
         seqzps(jj,ntht+1) = zzps3
         seqzps(jj,ntht+2) = zzps2
         seqzps(jj,ntlast) = zzps1
      endif
  170 continue
c
c 4.5.2 Readjust the storage of the Jacobian quantities
c
      if(keqtype .ne. 0) then
         do 180 jj     = 1,nprofl
c
c 4.5.2.1 Store the excess points
         a3ps1         = seqaj3(jj,1)
         a3ps2         = seqaj3(jj,2)
         a3ps3         = seqaj3(jj,ntlast)
         a0ps1         = seqaj0(jj,1)
         a0ps2         = seqaj0(jj,2)
         a0ps3         = seqaj0(jj,ntlast)
c
c 4.5.2.2 Shift the index
         do 175 ii     = 1,ntht
         iip           = ii + ntadjst
         seqaj3(jj,ii) = seqaj3(jj,iip)
         seqaj0(jj,ii) = seqaj0(jj,iip)
  175    continue
c
c 4.5.2.3 Add the excess points to the end of the array if space exists
         if(ntroom .ge. 0) then
            seqaj3(jj,ntht+1) = a3ps3
            seqaj3(jj,ntht+2) = a3ps2
            seqaj3(jj,ntlast) = a3ps1
            seqaj0(jj,ntht+1) = a0ps3
            seqaj0(jj,ntht+2) = a0ps2
            seqaj0(jj,ntlast) = a0ps1
         endif
  180    continue
      endif
c
c
c 4.5.4 Check for consistency of seqrps and seqzps on axis
c
c 4.5.4.1 Compute the average of seqrps and seqzps on axis
      seqraxs     = 0.0
      seqzaxs     = 0.0
      do 200 ii   = 1,ntht
      seqraxs     = seqraxs + seqrps(1,ii)
      seqzaxs     = seqzaxs + seqzps(1,ii)
  200 continue
c
      seqraxs     = seqraxs/float(ntht)
      seqzaxs     = seqzaxs/float(ntht)
c
c 4.5.4.2 Check for discrepancies
      ircnt       = 0
      izcnt       = 0
      do 250 ii   = 1,ntht
      seqrdif     = abs(seqrps(1,ii) - seqraxs)
      seqzdif     = abs(seqzps(1,ii) - seqzaxs)
      if(seqrdif .ge. rndofr) ircnt  = ircnt + 1
      if(seqzdif .ge. rndofr) izcnt  = izcnt + 1
  250 continue
c
      if(ircnt .gt. 0) then
         call abortjob
     &        ('rdjsvmp ', 13,   'Input r is  not constant on axis    '
     &        ,'ntht    ', ntht ,    'ircnt   ', ircnt,    -1)
         write(kuout,3100) ntht
         write(kuout,3110) (seqrps(1,ii),ii=1,ntht)
      endif
c
      if(izcnt .gt. 0) then
         call abortjob
     &        ('rdjsvmp ', 14,   'Input z is  not constant on axis    '
     &        ,'ntht    ', ntht ,    'izcnt   ', izcnt,    -1)
         write(kuout,3200) ntht
         write(kuout,3210) (seqzps(1,ii),ii=1,ntht)
      endif
c
c
c 4.6 Set the scalar data
c
c 4.6.1 Set the axis and limiter positions
c
      xma         = seqraxs
      zma         = seqzaxs
      xlim        = seqrps(npsi,1)
      zlim        = seqzps(npsi,1)
c
c 4.6.2 Set the toroidal field and current
c
c 4.6.2.1 Set the total current
c         This needs to be set properly
      totcur      = bfield0
      call abortjob
     &        ('rdjsvmp ',  0,   'Total current is not set for this   '
     &        ,'nmap    ', nmap,     'npsi    ', npsi,     -1)
c
c 4.6.2.2 Set sfedge and btor
      sfedge      = sf(nprofl)
      btor        = sfedge/rcnt
c
c 4.6.2.3 Set the input axis elongation temporarily
      axddxz      = 0.0
c
c
c
c 5.0 Reset the conventions if nonstandard
c
c 5.1 Reverse signs of psimsh and psi derivatives if input has
c     the alternate psi convention
c
      if(psimsh(1) .gt. psimsh(nprofl)) then
c
c 5.1.1 Print a warning
c
         call abortjob
     &        ('rdjsvmp ', 15,   'Reversing sign convention of psi    '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
c
c 5.1.2 Reverse the signs
c
         do 300 jj  = 1,nprofl
         psimsh(jj) = -psimsh(jj)
         sffp  (jj) = -sffp  (jj)
         spp   (jj) = -spp   (jj)
  300    continue
      endif
c
c
c 5.2 Check the sign convention of btor
c
c 5.2.1 Check the signs of btor and totcur
c
        if(btor   .lt. 0.0) ibsign  = -1
        if(btor   .eq. 0.0) ibsign  =  0
        if(btor   .gt. 0.0) ibsign  = +1
c
c 5.2.2 Print a warning if btor is zero
c
        if(ibsign .eq. 0) call abortjob
     &        ('rdjsvmp ', 16,   'Sign of btor from sf(npsi) zero     '
     &        ,'ibsign  ', ibsign,   'nprofl  ', nprofl,   -1)
c
        if(totcur .lt. 0.0) itsign  = -1
        if(totcur .eq. 0.0) itsign  =  0
        if(totcur .gt. 0.0) itsign  = +1
c
c 5.2.3 Switch the sign of totcur if the convention is reversed
c
        if(ibsign .lt. 0  .and.  itsign .lt. 0) then
          call abortjob
     &        ('rdjsvmp ', 17,   'Switched btor and current signs     '
     &        ,'ibsign  ', ibsign,   'itsign  ', itsign,   -1)
          totcur     = -totcur
        endif
c
c
c 5.3 Set sfqi equal to sf*sqvl
c
        do 350 jj     = 1,npsi
        sfqi(jj)      = sf(jj)*sqvl(jj)
  350   continue
c     
c
c
c 6.0 Set up the auxiliary quantities
c
c 6.1 Set scalar quantities
c
c 6.1.1 Set the profile switch npst
c
      npst        = 0
c
c 6.1.2 Set the magnetic axis values
c
      psisep      = psimax
      xsep        = 0.0
      zsep        = 0.0
c
      xax(1)      = xma
      xax(2)      = 0.0
      zax(1)      = zma
      zax(2)      = 0.0
      psimx(1)    = psimax
      psimx(2)    = 0.0
c
c
c 6.2 Check for consistent input
c
      if(neqsym .eq. 0  .and.  isym .ne. 0) call abortjob
     &        ('rdjsvmp ', 18,   'Asymmetric equilibrium with isym = 1'
     &        ,'neqsym  ', neqsym,   'isym    ', isym,     -1)
      if(neqsym .ne. 0  .and.  isym .eq. 0) call abortjob
     &        ('rdjsvmp ', 19,   'neqsym and isym are inconsistent    '
     &        ,'neqsym  ', neqsym,   'isym    ', isym,      0)
c
c
c
c 7.0 Set the number of poloidal angles and complete arrays
c     for up-down symmetry
c
c 7.1 Fill the r and z arrays for up-down symmetry
c
      if    (neqsym .eq. 1) then
c
c 7.1.1 Ensure the magnetic axis is on the midplane
c
c 7.1.1.1 Check for discrepancy
c
        if(abs(zma) .gt. 0.0) then
          if(abs(zma) .le. rndofr) call abortjob
     &        ('rdjsvmp ', 20,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,     0)
          if(abs(zma) .gt. rndofr) call abortjob
     &        ('rdjsvmp ', 21,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,    -1)
          write(kuout,4000) xma,zma
        endif
c
c 7.1.1.2 Reset the axis on the midplane
c
        zma             = 0.0
c
c
c 7.2 Ensure the first flux surface is at the magnetic axis
c
c 7.2.1 Check for discrepancies
c
        ikr0            = 0
        ikr1            = 0
        ikz0            = 0
        ikz1            = 0
        suminr          = 0.0
        suminz          = 0.0
        do 400 ii       = 1,ntht
c
c 7.2.1.1 Check the r value is the axis value
        dscinr          = seqrps(1,ii) - xma
        suminr          = suminr + abs(dscinr)
        if(abs(dscinr) .ne. 0.0) then
          if(abs(dscinr) .le. rndofr) ikr0   = ikr0 + 1
          if(abs(dscinr) .gt. rndofr) ikr1   = ikr1 + 1
        endif
c
c 7.2.1.2 Check the z value is the axis value
        dscinz          = seqzps(1,ii) - zma
        suminz          = suminz + abs(dscinz)
        if(abs(dscinz) .ne. 0.0) then
          if(abs(dscinz) .le. rndofr) ikz0   = ikz0 + 1
          if(abs(dscinz) .gt. rndofr) ikz1   = ikz1 + 1
        endif
c
  400   continue
c
c 7.2.1.3 Find the mean discrepancy
        suminr          = suminr / float(ntht)
        suminz          = suminz / float(ntht)
c
c 7.2.2 Print error message if any discrepancy
c
        if(ikr0 .gt. 0  .or.  ikr1 .gt. 0  .or.  ikz0 .gt. 0  .or.
     &                                           ikz1 .gt. 0) then
          if(ikr0 .gt. 0) call abortjob
     &        ('rdjsvmp ', 22,   'Small Discrepancy in seqrps(1)      '
     &        ,'ikr0    ', ikr0,     'neqsym  ', neqsym,    0)
          if(ikz0 .gt. 0) call abortjob
     &        ('rdjsvmp ', 23,   'Small Discrepancy in seqzps(1)      '
     &        ,'ikz0    ', ikz0,     'neqsym  ', neqsym,    0)
          if(ikr1 .gt. 0) call abortjob
     &        ('rdjsvmp ', 24,   'Large Discrepancy in seqrps(1)      '
     &        ,'ikr1    ', ikr1,     'neqsym  ', neqsym,   -1)
          if(ikz1 .gt. 0) call abortjob
     &        ('rdjsvmp ', 25,   'Large Discrepancy in seqzps(1)      '
     &        ,'ikz1    ', ikz1,     'neqsym  ', neqsym,   -1)
c
          write(kuout,4100) npsi,ntht,suminr,suminz
          if(ikr1 .gt. 0  .or.  ikz1 .gt. 0) then
            write(kuout,4110)
            write(kuout,4120) (iii, seqrps(1,iii), seqzps(1,iii),
     &                              iii=1,ntht)
          endif
        endif
c
c 7.2.3 Reset the first flux surface identically to the axis values
c
        do 410 ii       = 1,ntht
        seqrps(1,ii)    = xma
        seqzps(1,ii)    = zma
  410   continue
c
c
c 7.3 Ensure that the first and last ray lay along the midplane
c
c 7.3.1 Check for discrepancy
c
        jkm0            = 0
        jkm1            = 0
        jkp0            = 0
        jkp1            = 0
        sumray1         = 0.0
        sumrayn         = 0.0
        do 420 jj       = 1,npsi
c
c 7.3.1.1 Check the first ray is on the midplane
        dscray1         = seqzps(jj,  1 ) - zma
        sumray1         = sumray1 + abs(dscray1) 
        if(abs(dscray1) .ne.   0.0 ) then
          if(abs(dscray1) .le. rndofr) jkm0   = jkm0 + 1
          if(abs(dscray1) .gt. rndofr) jkm1   = jkm1 + 1
        endif
c
c 7.3.1.2 Check the last  ray is on the midplane
        dscrayn         = seqzps(jj,ntht) - zma
        sumrayn         = sumrayn  +  abs(dscrayn)
        if(abs(dscrayn) .ne.   0.0 ) then
          if(abs(dscrayn) .le. rndofr) jkp0   = jkp0 + 1
          if(abs(dscrayn) .gt. rndofr) jkp1   = jkp1 + 1
        endif
  420   continue
c
c 7.3.1.3 Find the mean discrepancy
        sumray1         = sumray1 / float(npsi)
        sumrayn         = sumrayn / float(npsi)
c
c 7.3.2 Print error message if any discrepancy
c
        if(jkm0 .gt. 0  .or.  jkp0 .gt. 0  .or.  jkm1 .gt. 0  .or.
     &                                           jkp1 .gt. 0) then
          if(jkm0 .gt. 0) call abortjob
     &        ('rdjsvmp ', 26,   'First ray slightly off midplane     '
     &        ,'jkm0    ', jkm0,     'neqsym  ', neqsym,    0)
          if(jkp0 .gt. 0) call abortjob
     &        ('rdjsvmp ', 27,   'Last  ray slightly off midplane     '
     &        ,'jkp0    ', jkp0,     'neqsym  ', neqsym,    0)
          if(jkm1 .gt. 0) call abortjob
     &        ('rdjsvmp ', 28,   'First ray is not on the midplane    '
     &        ,'jkm1    ', jkm1,     'neqsym  ', neqsym,   -1)
          if(jkp1 .gt. 0) call abortjob
     &        ('rdjsvmp ', 29,   'Last  ray is not on the midplane    '
     &        ,'jkp1    ', jkp1,     'neqsym  ', neqsym,   -1)
c
          write(kuout,4200) npsi,ntht,sumray1,sumrayn
          if(jkm1 .gt. 0  .or.  jkp1 .gt. 0) then
            write(kuout,4210)
            write(kuout,4220) (jjj, seqrps(jjj,  1 ), seqzps(jjj,  1 ),
     &                              seqrps(jjj,ntht), seqzps(jjj,ntht),
     &                                                jjj=1,npsi)
          endif
        endif
c
c 7.3.3 Reset the rays along the midplane
c
        do 430 jj       = 1,npsi
        seqzps(jj,  1 ) = 0.0
        seqzps(jj,ntht) = 0.0
  430   continue
c
c
c 7.4 Fill the complete r and z arrays
c
        do 450 ii       = nthp1,nthet
        i1              = ii
        i0              = nthet + 1 - i1
c
        do 440 jj       = 1,npsi
        seqrps(jj,i1)   = +seqrps(jj,i0)
        seqzps(jj,i1)   = -seqzps(jj,i0)
  440   continue
  450   continue

c
c
c 7.5 Fill the complete Jacobian arrays
c
        if(keqtype .ne. 0) then
          do 470 ii     = nthp1,nthet
          i1            = ii
          i0            = nthet + 1 - i1
c
          do 460 jj     = 1,npsi
          seqaj0(jj,i1) = +seqaj0(jj,i0)
          seqaj3(jj,i1) = +seqaj3(jj,i0)
  460     continue
  470     continue
        endif
      endif
c
c
c
c 8.0 Return and end
c
      return
 1000 format(5(1x,i4),2(1x,e11.4))
 1100 format(4e16.8)
 2000 format(5e16.8)
 3000 format(/,10x,'psimax  = ',e20.13,4x,'psimaxa = ',e20.13
     &      ,/,10x,'psmaxdf = ',e16.9,8x, 'rndofps = ',e16.9)
 3010 format(/,10x,'psilim  = ',e20.13,4x,'psilima = ',e20.13
     &      ,/,10x,'pslimdf = ',e16.9,8x, 'rndofps = ',e16.9)
 3100 format(/,5x,'seqrps(1,ii),ii=1,',i5)
 3110 format(5(1x,e16.9))
 3200 format(/,5x,'seqzps(1,ii),ii=1,',i5)
 3210 format(5(1x,e16.9))
 4000 format(/,10x,'xma     = ',e16.9, 4x,'zma     = ',e16.9)
 4100 format(/,10x,'npsi    = ',i5,   15x,'ntht    = ',i5,/
     &        ,10x,'suminr  = ',e16.9, 4x,'suminz  = ',e16.9)
 4110 format(/, 4x,'ii',6x,'seqrps(1,ii)',5x,'seqzps(1,ii)')
 4120 format((1x,i5,2x,2(1x,e16.9)))
 4200 format(/,10x,'npsi    = ',i5,   15x,'ntht    = ',i5,/
     &        ,10x,'sumray1 = ',e16.9, 4x,'sumrayn = ',e16.9)
 4210 format(/, 4x,'jj',6x,'seqrps(jj,  1 )',2x,'seqzps(jj,  1 )'
     &                ,2x,'seqrps(jj,ntht)',2x,'seqzps(jj,ntht)')
 4220 format((1x,i5,2x,4(1x,e16.9)))
      end
      subroutine rdqsvmp
c >>>> Replace half grid cell shift by sintrp interpolation, using averaged
c >>>> derivatives from pprime and fprime
c >>>> Set totcur
c
c -------------------------------------------------------------
c  Read inverse equilibrium file from QSOLVER
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
c
      character*8   etitl,date
      character*8   string
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension sqvlp(npp)
      dimension sg1  (npp), sg2  (npp), sg3  (npp), sg4  (npp)
      dimension seqtmp(ntt)
      dimension seqaj0(npp,ntt), seqaj3(npp,ntt)
c
      dimension string(59)
c
      equivalence (sqvlp ( 1 ),sfqi  ( 1 ))
      equivalence (seqaj0(1,1),seqarc(1,1)) , (seqaj3(1,1),seqpst(1,1))
      equivalence (sg1   ( 1 ),seqf4 (1,1)) , (sg2   ( 1 ),seqf5 (1,1)),
     &            (sg3   ( 1 ),seqf7 (1,1)) , (sg4   ( 1 ),seqf8 (1,1))
c
c
c
c 1.0 Initialization
c
c 1.1 Set the dimensions
c
c 1.1.1 Storage dimensions
c
      nppd      = npp
      nttd      = ntt
c
c 1.1.2 Set the fixed input values for the q solver
c
      npsidm    = 180
      nthtdm    = 198
      ntotdm    = npsidm*nthtdm
      npsi      = 121
      ntht      = 95 - 4
      ntleng    = 59
c
c
c 1.2 Initialize error flags and roundoff parameters
c
      kerr      = 0
      kerp      = 0
      kerpp     = 0
      kerq      = 0
      kerqp     = 0
      kerf      = 0
      kerfp     = 0
      kerg1     = 0
      kerg2     = 0
      kerg3     = 0
      kerg4     = 0
      kerps     = 0
      kerrp     = 0
      kerzp     = 0
      kerj3     = 0
      kerj0     = 0
c
      rndoff    = roundff
c
c
c 1.3 Check the equilibrium type
c
      kmap    = nmap
      ktype   = nmtype
      keqtype = neqtyp
      if(kmap .ne.  -2  .and.  kmap .ne.  -3) then
         call abortjob
     &        ('rdqsvmp ',  1,   'Incorrect equilibrium file type     '
     &        ,'kmap    ', kmap,     'ktype   ', ktype,    -1)
         return
      endif
c
      if(ktype .ne.  +1) then
         call abortjob
     &        ('rdqsvmp ',  2,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
      endif
c
c
c 1.4 Set the adjustment in labeling used in QSOLVER
c

      neqsym    = 1
      npadjst   = 0
      ntadjst   = 2
      nshift    = 0
c
c
c 1.5 Check the equilibrium type is appropriate
c
      if(iabs(krdeqlb) .ne. +1) then
         call abortjob
     &        ('rdqsvmp ',  3,   'rdqsvmp called for invalid krdeqlb  '
     &        ,'krdeqlb ', krdeqlb,  'nmap    ', nmap,     -1)
      endif
c
c
c 1.6 Set the conversion factors
c
      if(bfieldf .ne. 0.0) bfield0   = bfieldf
      if(bfieldf .eq. 0.0) bfield0   = 1.0
      psifact   =  bfield0
      prsfact   = (bfield0*bfield0)/amu
c
c
c 2.0 Set the default heading and date
c
c 2.1 Initialize the title and date
c
      date      = 'unknown'
      do 10 it  = 1,nft
      etitl(it) = ' '
   10 continue
c
c
c 2.2 Read the title from the equilibrium file
c       For krdeqlb > 0 the file is sequential
c       For krdeqlb < 0 the file is direct access
c       This is done in line since the title is a character string and needs
c       special attention
c
c 2.2.1 Read from sequential file
c
      nstart    =  1 + nshift
      kerc      =  0
      if    (krdeqlb .gt. 0) then
        if(nstart .ne. 1) read(kueql) string(1)
        read(kueql, err = 20) (string(it),it=1,ntleng)
        kerc    = ntleng
c
c 2.2.2 Read the first string from the direct access file and reset the new addres
c
      elseif(krdeqlb .lt. 0) then
        do 15 ir = 1,ntleng
        it       = ir
        ird      = ir + nstart - 1
        read(kueql,rec=ird, err = 20) string(it)
        kerc     = ird
   15   continue
      endif
c
c 2.2.3 Print a warning if a read error occured
c
   20 continue
      naddrs = nstart + ntleng
c
      if(kerc .ne. ntleng) then
         call abortjob
     &        ('rdqsvmp ',  4,   'Error reading title from q solver   '
     &        ,'ntleng  ', ntleng,   'kerc    ', kerc,     -1)
      endif
c
c
c 2.3 Place the read string in etitl
c
      do 25 it  = 1,nft
      etitl(it) = string(it)
   25 continue
c
c
c
c 3.0 Read in the inverse equilibrium scalar data
c
c 3.1.2 Set the theta dimension according to up-down symmetry
c
c 3.1.2.1 Set for up-down symmetry as the only option available for the q solver
c
       if(neqsym .ne. 1) then
          call abortjob
     &        ('rdqsvmp ',  5,   'Equilibrium up-down symmetry imposed'
     &        ,'neqsym  ', neqsym,   'isym    ', isym,     -1)
          neqsym  = 1
       endif
c
c 3.1.2.2 Set the full theta array size
      if(neqsym .eq. 0) nth2        =    ntht
      if(neqsym .ne. 0) nth2        = 2*(ntht-1) + 1
c
c 3.1.3 Set the dimensions for the profiles to be read in
c
c 3.1.3.1 Set the last valid theta index from the JSOLVER indexing
      nplast    = npsi    +   npadjst
      ntlast    = ntht    + 2*ntadjst
      ntlst2    = nth2    + 2*ntadjst
c
c 3.1.3.2 Print a warning if the input array sizes are too large for the
c         dimensions
      if (npsi   .le. 0) call abortjob
     &        ('rdqsvmp ',  6,   'npsi is outside allowed dimensions  '
     &        ,'npsi    ', npsi,     'nppd    ', nppd,     +1)
c
      if (nth2   .le. 0) call abortjob
     &        ('rdqsvmp ',  7,   'nth2 is outside allowed dimensions  '
     &        ,'nth2    ', nth2,     'nttd    ', nttd,     +1)
c
      if (nplast  .gt. nppd) call abortjob
     &        ('rdqsvmp ',  8,   'nplast larger than allowed dimension'
     &        ,'nplast  ', nplast,   'nppd    ', nppd,     +1)
c
      if (ntlst2  .gt. nttd) call abortjob
     &        ('rdqsvmp ',  9,   'ntlst2 larger than allowed dimension'
     &        ,'ntlst2  ', ntlst2,   'nttd    ', nttd,     +1)
c
      if (npsidm  .gt. nppd) call abortjob
     &        ('rdqsvmp ', 10,   'npsidm larger than allowed dimension'
     &        ,'npsidm  ', npsidm,   'nppd    ', nppd,     +1)
c
      if (nthtdm  .gt. nttd) call abortjob
     &        ('rdqsvmp ', 11,   'nthtdm larger than allowed dimension'
     &        ,'nthtdm  ', nthtdm,   'nttd    ', nttd,     +1)
c
c
c
c 4.0 Read the equilibrium quantities
c
c 4.1 Read the profiles
c     sffp here is just sfp
c
      if(krdeqlb .gt. 0) krdtp  = 0
      if(krdeqlb .lt. 0) krdtp  = 1
c
      call readabs(krdtp,kueql,naddrs,npsidm,sp,    kerp)
      if (kerp  .ne. 0) call abortjob
     &        ('rdqsvmp ', 12,   'Error in reading pressure profile   '
     &        ,'krdtp   ', krdtp,    'kerp    ', kerp,     -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,spp,   kerpp)
      if (kerpp .ne. 0) call abortjob
     &        ('rdqsvmp ', 13,   'Error in reading pressure profile   '
     &        ,'krdtp   ', krdtp,    'kerpp   ', kerpp,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sqvl,  kerq)
      if (kerq  .ne. 0) call abortjob
     &        ('rdqsvmp ', 14,   'Error reading safety factor profile '
     &        ,'krdtp   ', krdtp,    'kerq    ', kerq,     -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sqvlp, kerqp)
      if (kerqp .ne. 0) call abortjob
     &        ('rdqsvmp ', 15,   'Error reading safety factor gradient'
     &        ,'krdtp   ', krdtp,    'kerqp   ', kerqp,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sf,    kerf)
      if (kerf  .ne. 0) call abortjob
     &        ('rdqsvmp ', 16,   'Error reading toroidal field profile'
     &        ,'krdtp   ', krdtp,    'kerf    ', kerf,     -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sffp,  kerfp)
      if (kerfp .ne. 0) call abortjob
     &        ('rdqsvmp ', 17,   'Error reading toroidalfield gradient'
     &        ,'krdtp   ', krdtp,    'kerfp   ', kerfp,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sg1,   kerg1)
      if (kerg1 .ne. 0) call abortjob
     &        ('rdqsvmp ', 18,   'Error reading sg1 profile           '
     &        ,'krdtp   ', krdtp,    'kerg1   ', kerg1,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sg2,   kerg2)
      if (kerg2 .ne. 0) call abortjob
     &        ('rdqsvmp ', 19,   'Error reading sg2 profile           '
     &        ,'krdtp   ', krdtp,    'kerg2   ', kerg2,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sg3,   kerg3)
      if (kerg3 .ne. 0) call abortjob
     &        ('rdqsvmp ', 20,   'Error reading sg3 profile           '
     &        ,'krdtp   ', krdtp,    'kerg3   ', kerg3,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,sg4,   kerg4)
      if (kerg4 .ne. 0) call abortjob
     &        ('rdqsvmp ', 21,   'Error reading sg4 profile           '
     &        ,'krdtp   ', krdtp,    'kerg4   ', kerg4,    -1)
c
      call readabs(krdtp,kueql,naddrs,npsidm,psimsh,kerps)
      if (kerps .ne. 0) call abortjob
     &        ('rdqsvmp ', 22,   'Error reading poloidal flux values  '
     &        ,'krdtp   ', krdtp,    'kerps   ', kerps,    -1)
c
c
c 4.2 Read the inverse mapping r(psii,theta), and z(psi,theta)
c
c 4.2.1 Read the inverse equilibrium r grid
c       The equilibrium is stored with theta in the first dimension
c       and must be read in accordingly
c
c 4.2.1.1 Read the array one flux surface at a time
      krderr      = 0
      jperr       = 0
      do 50 jpin  = 1,npsidm
        jj          = jpin
        call readabs(krdtp,kueql,naddrs,nthtdm,seqtmp,kerrp)
        if(kerrp .ne. 0) then
          krderr  = krderr + 1
          jperr   = jj
        endif
        do 45 itin    = 1,nthtdm
        ii            = itin
        seqrps(jj,ii) = seqtmp(ii)
   45   continue
   50   continue
c
c 4.2.1.2 Print an error message if read errors occured
      if (krderr .gt. 0) then
        if    (krderr .eq. 1) then
           call abortjob
     &        ('rdqsvmp ', 23,   'Error in reading radial mesh values '
     &        ,'jperr   ', jperr,    'kerrp   ', kerrp,    -1)
        elseif(krderr .gt. 1) then
           call abortjob
     &        ('rdqsvmp ', 24,   'Multiple errors reading radial mesh '
     &        ,'krderr  ', krderr,   'kerrp   ', kerrp,    -1)
        endif
      endif
c
c 4.2.2 Read the inverse equilibrium z grid
c       The equilibrium is stored with theta in the first dimension
c       and must be read in accordingly
c
c 4.2.2.1 Read the array one flux surface at a time
      kzderr      = 0
      jperr       = 0
      do 60 jpin  = 1,npsidm
        jj          = jpin
        call readabs(krdtp,kueql,naddrs,nthtdm,seqtmp,kerzp)
        if(kerzp .ne. 0) then
          kzderr  = kzderr + 1
          jperr   = jj
        endif
        do 55 itin    = 1,nthtdm
        ii            = itin
        seqzps(jj,ii) = seqtmp(ii)
   55   continue 
   60   continue
c
c 4.2.2.2 Print an error message if read errors occured
      if (kzderr .gt. 0) then
        if    (kzderr .eq. 1) then
           call abortjob
     &        ('rdqsvmp ', 25,   'Error in reading axial  mesh values '
     &        ,'jperr   ', jperr,    'kerzp   ', kerzp,    -1)
        elseif(kzderr .gt. 1) then
           call abortjob
     &        ('rdqsvmp ', 26,   'Multiple errors reading axial  mesh '
     &        ,'kzderr  ', kzderr,   'kerzp   ', kerzp,    -1)
        endif
      endif
c
c 4.2.2 Read  the Jacobian
c
      if(keqtype .ne. 0) then
c
c 4.2.2.1 Read the array one flux surface at a time
        kjderr      = 0
        jperr       = 0
        do 70 jpin  = 1,npsidm
          jj          = jpin
          call readabs(krdtp,kueql,naddrs,nthtdm,seqtmp,kerj3)
          if(kerj3 .ne. 0) then
            kjderr  = kjderr + 1
            jperr   = jj
          endif
          do 65 itin    = 1,nthtdm
          ii            = itin
          seqaj3(jj,ii) = seqtmp(ii)
   65     continue
   70     continue
c
c 4.2.2.2 Print an error message if read errors occured
        if (kjderr .gt. 0) then
          if    (kjderr .eq. 1) then
             call abortjob
     &        ('rdqsvmp ', 27,   'Error in reading Jacobian values    '
     &        ,'jperr   ', jperr,    'kerj3   ', kerj3,    -1)
          elseif(kjderr .gt. 1) then
             call abortjob
     &        ('rdqsvmp ', 28,   'Multiple errors reading Jacobian    '
     &        ,'kjderr  ', kjderr,   'kerj3   ', kerj3,    -1)
          endif
        endif
c
c 4.2.2.1 Read the array one flux surface at a time
        kaderr      = 0
        jperr       = 0
        do 80 jpin  = 1,npsidm
          jj          = jpin
          call readabs(krdtp,kueql,naddrs,nthtdm,seqtmp,kerj0)
          if(kerj0 .ne. 0) then
            kaderr  = kaderr + 1
            jperr   = jj
          endif
          do 75 itin    = 1,nthtdm
          ii            = itin
          seqaj0(jj,ii) = seqtmp(ii)
   75     continue
   80     continue
c
c 4.2.2.2 Print an error message if read errors occured
        if (kaderr .gt. 0) then
          if    (kaderr .eq. 1) then
             call abortjob
     &        ('rdqsvmp ', 29,   'Error in reading Jacobian values    '
     &        ,'jperr   ', jperr,    'kerj0   ', kerj0,    -1)
          elseif(kaderr .gt. 1) then
             call abortjob
     &        ('rdqsvmp ', 30,   'Multiple errors reading Jacobian    '
     &        ,'kaderr  ', kaderr,   'kerj0   ', kerj0,    -1)
          endif
        endif
      endif
c
c
c
c 5.0 Set auxiliary quantities and modify the units
c
c 5.1 Set the quantities that were not explicitly read in
c
c 5.1.1 Set the basic integer parameters
c
      nprofl      = npsi
      nthet       = nth2
      nthp1       = ntht + 1
c
c 5.1.2 Set the density profile
c
      dnnorm      = 1.0
      do 90 jj    = 1,nprofl
      sdns(jj)    = dnnorm
   90 continue
c
c
c 5.2 Set roundoff parameters
c
      radfact     = rdefolt
c
      rndofps     = rndoff*psifact
      rndofpr     = rndoff*prsfact
      rndofr      = rndoff*radfact
c
c
c 5.3 Conversion factors
c
      btffact     = radfact*bfield0
      prnorm      = sp(1)
c
c
c 5.4 Reset the poloidal flux to Wb/m**2
c
c 5.4.2 Reset the flux array
c
      do 100 jj   = 1,nprofl
      psimsh(jj)  = psifact*psimsh(jj)
  100 continue
c
c 5.4.3 Set psimax and psilim
c
      psimax      = psimsh(1)
      psilim      = psimsh(nprofl)
c
c
c 5.5 Reset the pressure and toroidal field units and shift the pressure
c     and toroidal field to the grid points
c
c 5.5.1 Reset the pressure and pprime units
c
      prnorm      = prsfact*prnorm
c
      do 120 jj   = 1,nprofl
      sp   (jj)   =  prsfact         *sp   (jj)
      spp  (jj)   = (prsfact/psifact)*spp  (jj)
  120 continue
c
c 5.5.2 Reset the toroidal field function and units
c
      fbnorm      = 1.0*btffact
c
      do 130 jj   = 1,nprofl
      sf   (jj)   =  fbnorm         *sf   (jj)
      sffp (jj)   = (fbnorm/psifact)*sffp (jj)
  130 continue
c
c 5.5.3 Reset the remaining input profile units
c
      do 140 jj   = 1,nprofl
      sqvlp(jj)   = (1.0/psifact)              *sqvlp(jj)
      sg1  (jj)   = (btffact/radfact)          *sg1  (jj)
      sg2  (jj)   = (btffact/(psifact*radfact))*sg2  (jj)
      sg3  (jj)   =  psifact                   *sg3  (jj)
      sg4  (jj)   =  1.0                       *sg4  (jj)
  140 continue
c
c 5.5.4 Shift the pressure, toroidal field function, and sg3 
c       half a grid call
c
c 5.5.4.1 Shift interior points
      do 150 jj   = 2,nprofl
      jjp         = nprofl - jj + 2
      spj1        = sp (jjp-1)
      spj2        = sp ( jjp )
      sfj1        = sf (jjp-1)
      sfj2        = sf ( jjp )
      sgj1        = sg3(jjp-1)
      sgj2        = sg3( jjp )
      sp (jjp)    = 0.5*(spj1 + spj2)
      sf (jjp)    = 0.5*(sfj1 + sfj2)
      sg3(jjp)    = 0.5*(sgj1 + sgj2)
  150 continue
c
c 5.5.4.2 Set the axis values
      sp(1)       = prnorm
      sf(1)       = sg1(1)*sqvl(1)
c
c 5.5.4.3 Enforce p = 0.0 at the edge
      pedge       = sp(nprofl)
      if(abs(pedge) .gt. rndoff*prnorm) then
         call abortjob
     &        ('rdqsvmp ', 31,   'Adjusted edge pressure not zero     '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
         sp(nprofl)  = 0.0
      endif
c
c 5.5.5 Reset the sffp to f*fprime
c
      do 160 jj   = 1,nprofl
      sffp (jj)   = sf   (jj)*sffp (jj)
  160 continue
c
c
c 5.6 Readjust the storage of the 2D mapping quantities
c
c 5.6.1 Readjust the storage of the mapping quantities seqrps and seqzps
c       For neqsym = 1 only the top half plus two points on each end are read in
c
      do 170 jj     = 1,nprofl
c
c 5.6.1.1 Store the excess points
      rrps1         = seqrps(jj,1)
      rrps2         = seqrps(jj,2)
      rrps3         = seqrps(jj,ntlast)
      rrps4         = seqrps(jj,ntlast-1)
      zzps1         = seqzps(jj,1)
      zzps2         = seqzps(jj,2)
      zzps3         = seqzps(jj,ntlast)
      zzps4         = seqzps(jj,ntlast-1)
c
c 5.6.1.2 Shift the index
      do 165 ii     = 1,ntht
      iip           = ii + ntadjst
      seqrps(jj,ii) = seqrps(jj,iip)
      seqzps(jj,ii) = seqzps(jj,iip)
  165 continue
  170 continue
c
c 5.6.2 Readjust the storage of the Jacobian quantities
c
      if(keqtype .ne. 0) then
         do 180 jj     = 1,nprofl
c
c 5.6.2.1 Store the excess points
         a3ps1         = seqaj3(jj,1)
         a3ps2         = seqaj3(jj,2)
         a3ps3         = seqaj3(jj,ntlast)
         a3ps4         = seqaj3(jj,ntlast-1)
         a0ps1         = seqaj0(jj,1)
         a0ps2         = seqaj0(jj,2)
         a0ps3         = seqaj0(jj,ntlast)
         a0ps4         = seqaj0(jj,ntlast-1)
c
c 5.6.2.2 Shift the index
         do 175 ii     = 1,ntht
         iip           = ii + ntadjst
         seqaj3(jj,ii) = seqaj3(jj,iip)
         seqaj0(jj,ii) = seqaj0(jj,iip)
  175    continue
  180    continue
      endif
c
c
c 5.7 Check for consistency of seqrps and seqzps on axis
c
c 5.7.1 Compute the average of seqrps and seqzps on axis
c
      seqraxs     = 0.0
      seqzaxs     = 0.0
      do 200 ii   = 1,ntht
      seqraxs     = seqraxs + seqrps(1,ii)
      seqzaxs     = seqzaxs + seqzps(1,ii)
  200 continue
c
      seqraxs     = seqraxs/float(ntht)
      seqzaxs     = seqzaxs/float(ntht)
c
c 5.7.2 Check for discrepancies
c
      ircnt       = 0
      izcnt       = 0
      do 250 ii   = 1,ntht
      seqrdif     = abs(seqrps(1,ii) - seqraxs)
      seqzdif     = abs(seqzps(1,ii) - seqzaxs)
      if(seqrdif .ge. rndofr) ircnt  = ircnt + 1
      if(seqzdif .ge. rndofr) izcnt  = izcnt + 1
  250 continue
c
      if(ircnt .gt. 0) then
         call abortjob
     &        ('rdqsvmp ', 32,   'Input r mesh is not constant on axis'
     &        ,'ntht    ', ntht ,    'ircnt   ', ircnt,    -1)
         write(kuout,1000) ntht
         write(kuout,1010) (seqrps(1,ii),ii=1,ntht)
      endif
c
      if(izcnt .gt. 0) then
         call abortjob
     &        ('rdqsvmp ', 33,   'Input z mesh is not constant on axis'
     &        ,'ntht    ', ntht ,    'izcnt   ', izcnt,    -1)
         write(kuout,1100) ntht
         write(kuout,1110) (seqzps(1,ii),ii=1,ntht)
      endif
c
c
c 5.8 Set the scalar data
c
c 5.8.1 Set the axis and limiter positions
c
c 5.8.1.1 Set the values
      xma         = seqraxs
      zma         = seqzaxs
      xlim        = seqrps(npsi,1)
      zlim        = seqzps(npsi,1)
c
c 5.8.1.2 Set the nominal plasma major radius value at the axis position
      rcnt        = radfact
c
c 5.8.2 Set the toroidal field and current
c
c 5.8.2.1 Set the total current
c         This needs to be set properly
      totcur      = bfield0
      call abortjob
     &        ('rdqsvmp ', 34,   'Total current is not set for this   '
     &        ,'nmap    ', nmap,     'npsi    ', npsi,     -1)
c
c 5.8.2.2 Set sfedge and btor
      sfedge      = sf(nprofl)
      btor        = sfedge/xma
c
c 5.8.2.3 Set the input axis elongation temporarily
      axddxz      = 0.0
c
c
c
c 6.0 Reset the conventions if nonstandard
c
c 6.1 Reverse signs of psimsh and psi derivatives if input has
c     the alternate psi convention
c
      if(psimsh(1) .gt. psimsh(nprofl)) then
c
c 6.1.1 Print a warning
c
         call abortjob
     &        ('rdqsvmp ', 35,   'Reversing sign convention of psi    '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
c
c 6.1.2 Reverse the signs
c
         do 300 jj  = 1,nprofl
         psimsh(jj) = -psimsh(jj)
         sffp  (jj) = -sffp  (jj)
         spp   (jj) = -spp   (jj)
  300    continue
      endif
c
c
c 6.2 Check the sign convention of btor
c
c 6.2.1 Check the signs of btor and totcur
c
        if(btor   .lt. 0.0) ibsign  = -1
        if(btor   .eq. 0.0) ibsign  =  0
        if(btor   .gt. 0.0) ibsign  = +1
c
c 6.2.2 Print a warning if btor is zero
c
        if(ibsign .eq. 0) call abortjob
     &        ('rdqsvmp ', 36,   'Sign of btor from sf(npsi) zero     '
     &        ,'ibsign  ', ibsign,   'nprofl  ', nprofl,   -1)
c
        if(totcur .lt. 0.0) itsign  = -1
        if(totcur .eq. 0.0) itsign  =  0
        if(totcur .gt. 0.0) itsign  = +1
c
c 6.2.3 Switch the sign of totcur if the convention is reversed
c
        if(ibsign .lt. 0  .and.  itsign .lt. 0) then
          call abortjob
     &        ('rdqsvmp ', 37,   'Switched btor and current signs     '
     &        ,'ibsign  ', ibsign,   'itsign  ', itsign,   -1)
          totcur     = -totcur
        endif
c
c
c 6.3 Set sfqi equal to sf*sqvl
c
        do 350 jj     = 1,npsi
        sfqi(jj)      = sf(jj)*sqvl(jj)
  350   continue
c     
c
c
c 7.0 Set up the auxiliary quantities
c
c 7.1 Set scalar quantities
c
c 7.1.1 Set the profile switch npst
c
      npst        = 0
c
c 7.1.2 Set the magnetic axis values
c
      psisep      = psimax
      xsep        = 0.0
      zsep        = 0.0
c
      xax(1)      = xma
      xax(2)      = 0.0
      zax(1)      = zma
      zax(2)      = 0.0
      psimx(1)    = psimax
      psimx(2)    = 0.0
c
c
c 7.2 Check for consistent input
c
      if(neqsym .eq. 0  .and.  isym .ne. 0) call abortjob
     &        ('rdqsvmp ', 38,   'Asymmetric equilibrium with isym = 1'
     &        ,'neqsym  ', neqsym,   'isym    ', isym,     -1)
      if(neqsym .ne. 0  .and.  isym .eq. 0) call abortjob
     &        ('rdqsvmp ', 39,   'neqsym and isym are inconsistent    '
     &        ,'neqsym  ', neqsym,   'isym    ', isym,      0)
c
c
c
c 8.0 Set the number of poloidal angles and complete arrays
c     for up-down symmetry
c
      if    (neqsym .eq. 1) then
c
c 8.1 Ensure the magnetic axis is on the midplane
c
c 8.1.1 Check for discrepancy
c
        if(abs(zma) .gt. 0.0) then
          if(abs(zma) .le. rndofr) call abortjob
     &        ('rdqsvmp ', 40,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,     0)
          if(abs(zma) .gt. rndofr) call abortjob
     &        ('rdqsvmp ', 41,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,    -1)
          write(kuout,2000) xma,zma
        endif
c
c 8.1.2 Reset the axis on the midplane
c
        zma             = 0.0
c
c
c 8.2 Ensure the first flux surface is at the magnetic axis
c
c 8.2.1 Check for discrepancies
c
        ikr0            = 0
        ikr1            = 0
        ikz0            = 0
        ikz1            = 0
        suminr          = 0.0
        suminz          = 0.0
        do 400 ii       = 1,ntht
c
c 8.2.1.1 Check the r value is the axis value
        dscinr          = seqrps(1,ii) - xma
        suminr          = suminr + abs(dscinr)
        if(abs(dscinr) .ne. 0.0) then
          if(abs(dscinr) .le. rndofr) ikr0   = ikr0 + 1
          if(abs(dscinr) .gt. rndofr) ikr1   = ikr1 + 1
        endif
c
c 8.2.1.2 Check the z value is the axis value
        dscinz          = seqzps(1,ii) - zma
        suminz          = suminz + abs(dscinz)
        if(abs(dscinz) .ne. 0.0) then
          if(abs(dscinz) .le. rndofr) ikz0   = ikz0 + 1
          if(abs(dscinz) .gt. rndofr) ikz1   = ikz1 + 1
        endif
c
  400   continue
c
c 8.2.1.3 Find the mean discrepancy
        suminr          = suminr / float(ntht)
        suminz          = suminz / float(ntht)
c
c 8.2.2 Print error message if any discrepancy
c
        if(ikr0 .gt. 0  .or.  ikr1 .gt. 0  .or.  ikz0 .gt. 0  .or.
     &                                           ikz1 .gt. 0) then
          if(ikr0 .gt. 0) call abortjob
     &        ('rdqsvmp ', 42,   'Small Discrepancy in seqrps(1)      '
     &        ,'ikr0    ', ikr0,     'neqsym  ', neqsym,    0)
          if(ikz0 .gt. 0) call abortjob
     &        ('rdqsvmp ', 43,   'Small Discrepancy in seqzps(1)      '
     &        ,'ikz0    ', ikz0,     'neqsym  ', neqsym,    0)
          if(ikr1 .gt. 0) call abortjob
     &        ('rdqsvmp ', 44,   'Large Discrepancy in seqrps(1)      '
     &        ,'ikr1    ', ikr1,     'neqsym  ', neqsym,   -1)
          if(ikz1 .gt. 0) call abortjob
     &        ('rdqsvmp ', 45,   'Large Discrepancy in seqzps(1)      '
     &        ,'ikz1    ', ikz1,     'neqsym  ', neqsym,   -1)
c
          write(kuout,2100) npsi,ntht,suminr,suminz
          if(ikr1 .gt. 0  .or.  ikz1 .gt. 0) then
            write(kuout,2110)
            write(kuout,2120) (iii, seqrps(1,iii), seqzps(1,iii),
     &                              iii=1,ntht)
          endif
        endif
c
c 8.2.3 Reset the first flux surface identically to the axis values
c
        do 410 ii       = 1,ntht
        seqrps(1,ii)    = xma
        seqzps(1,ii)    = zma
  410   continue
c
c
c 8.3 Ensure that the first and last ray lay along the midplane
c
c 8.3.1 Check for discrepancy
c
        jkm0            = 0
        jkm1            = 0
        jkp0            = 0
        jkp1            = 0
        sumray1         = 0.0
        sumrayn         = 0.0
        do 420 jj       = 1,npsi
c
c 8.3.1.1 Check the first ray is on the midplane
        dscray1         = seqzps(jj,  1 ) - zma
        sumray1         = sumray1 + abs(dscray1) 
        if(abs(dscray1) .ne.   0.0 ) then
          if(abs(dscray1) .le. rndofr) jkm0   = jkm0 + 1
          if(abs(dscray1) .gt. rndofr) jkm1   = jkm1 + 1
        endif
c
c 8.3.1.2 Check the last  ray is on the midplane
        dscrayn         = seqzps(jj,ntht) - zma
        sumrayn         = sumrayn  +  abs(dscrayn)
        if(abs(dscrayn) .ne.   0.0 ) then
          if(abs(dscrayn) .le. rndofr) jkp0   = jkp0 + 1
          if(abs(dscrayn) .gt. rndofr) jkp1   = jkp1 + 1
        endif
  420   continue
c
c 8.3.1.3 Find the mean discrepancy
        sumray1         = sumray1 / float(npsi)
        sumrayn         = sumrayn / float(npsi)
c
c 8.3.2 Print error message if any discrepancy
c
        if(jkm0 .gt. 0  .or.  jkp0 .gt. 0  .or.  jkm1 .gt. 0  .or.
     &                                           jkp1 .gt. 0) then
          if(jkm0 .gt. 0) call abortjob
     &        ('rdqsvmp ', 46,   'First ray slightly off midplane     '
     &        ,'jkm0    ', jkm0,     'neqsym  ', neqsym,    0)
          if(jkp0 .gt. 0) call abortjob
     &        ('rdqsvmp ', 47,   'Last  ray slightly off midplane     '
     &        ,'jkp0    ', jkp0,     'neqsym  ', neqsym,    0)
          if(jkm1 .gt. 0) call abortjob
     &        ('rdqsvmp ', 48,   'First ray is not on the midplane    '
     &        ,'jkm1    ', jkm1,     'neqsym  ', neqsym,   -1)
          if(jkp1 .gt. 0) call abortjob
     &        ('rdqsvmp ', 49,   'Last  ray is not on the midplane    '
     &        ,'jkp1    ', jkp1,     'neqsym  ', neqsym,   -1)
c
          write(kuout,2200) npsi,ntht,sumray1,sumrayn
          if(jkm1 .gt. 0  .or.  jkp1 .gt. 0) then
            write(kuout,2210)
            write(kuout,2220) (jjj, seqrps(jjj,  1 ), seqzps(jjj,  1 ),
     &                              seqrps(jjj,ntht), seqzps(jjj,ntht),
     &                                                jjj=1,npsi)
          endif
        endif
c
c 8.3.3 Reset the rays along the midplane
c
        do 430 jj       = 1,npsi
        seqzps(jj,  1 ) = 0.0
        seqzps(jj,ntht) = 0.0
  430   continue
c
c
c 8.4 Fill the complete r and z arrays for up-down symmetry
c
        do 450 ii       = nthp1,nthet
        i1              = ii
        i0              = nthet + 1 - i1
c
        do 440 jj       = 1,npsi
        seqrps(jj,i1)   = +seqrps(jj,i0)
        seqzps(jj,i1)   = -seqzps(jj,i0)
  440   continue
  450   continue

c
c
c 8.5 Fill the complete Jacobian arrays
c
        if(keqtype .ne. 0) then
          do 470 ii     = nthp1,nthet
          i1            = ii
          i0            = nthet + 1 - i1
c
          do 460 jj     = 1,npsi
          seqaj0(jj,i1) = +seqaj0(jj,i0)
          seqaj3(jj,i1) = +seqaj3(jj,i0)
  460     continue
  470     continue
        endif
      endif
c
c
c
c 9.0 Return and end
c
      return
 1000 format(/,5x,'seqrps(1,ii),ii=1,',i5)
 1010 format(5(1x,e16.9))
 1100 format(/,5x,'seqzps(1,ii),ii=1,',i5)
 1110 format(5(1x,e16.9))
 2000 format(/,10x,'xma     = ',e16.9, 4x,'zma     = ',e16.9)
 2100 format(/,10x,'npsi    = ',i5,   15x,'ntht    = ',i5,/
     &        ,10x,'suminr  = ',e16.9, 4x,'suminz  = ',e16.9)
 2110 format(/, 4x,'ii',6x,'seqrps(1,ii)',5x,'seqzps(1,ii)')
 2120 format((1x,i5,2x,2(1x,e16.9)))
 2200 format(/,10x,'npsi    = ',i5,   15x,'ntht    = ',i5,/
     &        ,10x,'sumray1 = ',e16.9, 4x,'sumrayn = ',e16.9)
 2210 format(/, 4x,'jj',6x,'seqrps(jj,  1 )',2x,'seqzps(jj,  1 )'
     &                ,2x,'seqrps(jj,ntht)',2x,'seqzps(jj,ntht)')
 2220 format((1x,i5,2x,4(1x,e16.9)))
      end
      subroutine rdiflmp
c
c >>>> Set totcur
c
c -------------------------------------------------------------
c  Read inverse equilibrium file from CORSICA binary I-file
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
c
      character*8   etitl,date
      character*40  string
c
      integer*8     ndimensn,ishift
      integer*8     npseq,ntheq
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension seqtmp(npp*ntt)
      equivalence (seqtmp(1) , seqf28(1,1))
c
c
c
c
c 1.0 Initialization
c
c 1.1 Set the dimensions
c
      nppd      = npp
      nttd      = ntt
c
c
c 1.2 Initialize error flags and roundoff parameters
c
      kerps     = 0
      kerf      = 0
      kerp      = 0
      kerq      = 0
      kerrp     = 0
      kerzp     = 0
c
      ierfp     = 0
      ierpp     = 0
      kerfp     = 0
      kerpp     = 0
c
      rndoff    = roundff
c
c
c 1.3 Set the equilibrium type
c
c 1.3.1 Check the equilibrium type
c 
      kmap    = nmap
      ktype   = nmtype
      if(kmap .ne.  -4) then
         call abortjob
     &        ('rdiflmp ',  1,   'Incorrect equilibrium file type     '
     &        ,'kmap    ', kmap,     'ktype   ', ktype,    -1)
         return
      endif
c
      if(ktype .ne.  +1) then
         call abortjob
     &        ('rdiflmp ',  2,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
      endif
c
c 1.3.2 Set the up-down symmetry for asymmetric
c
      neqsym    = 0
c
c
c 1.4 Check the equilibrium type is appropriate
c
      if    (krdeqlb .eq. +1) then
         krdtp  = 0
      elseif(krdeqlb .ne. +1) then
         call abortjob
     &        ('rdiflmp ',  3,   'rdiflmp called for invalid krdeqlb  '
     &        ,'krdeqlb ', krdeqlb,  'nmap    ', nmap,     -1)
c
         krdtp   = 0
      endif
c
c
c 1.5 Set the conversion factors
c
      if(bfieldf .ne. 0.0) bfield0   = bfieldf
      if(bfieldf .eq. 0.0) bfield0   = 1.0
      psifact   =  bfield0
      prsfact   =  bfield0*bfield0
c
c
c
c 2.0 Read and set the initial data
c
c 2.1 Set the default heading and date
c
c 2.1.1 Initialize the title and date
c
      date      = 'unknown'
      do 10 it  = 1,nft
      etitl(it) = ' '
   10 continue
c
c 2.1.2 Reset the default heading
c
      write (string,1000)
      read  (string,1010) (etitl(kk),kk=1,nft)
c
c
c 2.2 Read the mesh sizes
c
c 2.2.1 Read the full 64 bits containing the two 32 bit integers
c
      rewind(kueql)
      read  (kueql) ndimensn
c
c 2.2.2 Set the endian type
c       The ordering assumes the file is little endian
      ndian    = 0
c
c
c 2.2.3 Extract the two integers
c
c 2.2.3.1 For little endian files
      if    (ndian .eq. 0) then
c
c 2.2.3.1.1 Extract the left side of ndimensn as npsi
         npseq    = and(ndimensn,Z'00000000FFFFFFFF')
         npsi     = npseq
c
c 2.2.3.2.2 Extract the right side of ndimensn as ntht and perform a 32 bit shift
         ntheq    = and(ndimensn,Z'FFFFFFFF00000000')
         ishift   = 32
         ntht     = rshift(ntheq,ishift)
c
c 2.2.3.2 For big endian files
      elseif(ndian .eq. 1) then
c
c 2.2.3.2.1 Extract the left side of ndimensn as ntht
         ntheq    = and(ndimensn,Z'00000000FFFFFFFF')
         ntht     = ntheq
c
c 2.2.3.2.2 Extract the right side of ndimensn as npsi and perform a 32 bit shift
         npseq    = and(ndimensn,Z'FFFFFFFF00000000')
         ishift   = 32
         npsi     = rshift(npseq,ishift)
      endif
c
c
c 2.3 Set the theta dimension according to up-down symmetry
c
c 2.3.1 Set the full theta array size
c
      if(neqsym .eq. 0) nth2        =    ntht
      if(neqsym .ne. 0) nth2        = 2*(ntht-1) + 1
c
c 2.3.2 Print a warning if the input array sizes are too large for the
c        dimensions
c
      if (npsi   .le. 0) call abortjob
     &        ('rdiflmp ',  4,   'npsi is outside allowed dimensions  '
     &        ,'npsi    ', npsi,     'nppd    ', nppd,     +1)
c
      if (nth2   .le. 0) call abortjob
     &        ('rdiflmp ',  5,   'nth2 is outside allowed dimensions  '
     &        ,'nth2    ', nth2,     'nttd    ', nttd,     +1)
c
      if (npsi  .gt. nppd) call abortjob
     &        ('rdiflmp ',  6,   'npsi larger than allowed dimension  '
     &        ,'npsi    ', npsi,     'nppd    ', nppd,     +1)
c
      if (nth2  .gt. nttd) call abortjob
     &        ('rdiflmp ',  7,   'nth2 larger than allowed dimension  '
     &        ,'nth2    ', nth2,     'nttd    ', nttd,     +1)
c
c
c 2.4 Set the address position for counting the data elements
c     nstart is set at one to include the integer data already read
c
      nshift    = 0
      nstart    = 1 + nshift
      naddrs    = nstart + 1
c
c
c
c 3.0 Read the equilibrium quantities
c
c 3.1 Read the profiles
c
c 3.1.1 Read the poloidal flux
c
c 3.1.1.1 Read the profile
      call readabs(krdtp,kueql,naddrs,npsi,psimsh, kerps)
      if (kerps .ne. 0) call abortjob
     &        ('rdiflmp ',  8,   'Error in reading poloidal flux mesh '
     &        ,'krdtp   ', krdtp,    'kerps   ', kerps,    -1)
c
c 3.1.1.2 Reverse the sign for the poloidal flux
      do 20  jp   =  1,npsi
      jpp         =  jp
      psimsh(jpp) = -psimsh(jpp)
   20 continue
c
c
c 3.1.2 Read the toroidal field profile
c
      call readabs(krdtp,kueql,naddrs,npsi,sf,     kerf)
      if (kerf  .ne. 0) call abortjob
     &        ('rdiflmp ',  9,   'Error reading toroidal field profile'
     &        ,'krdtp   ', krdtp,    'kerf    ', kerf,     -1)
c
c 3.1.3 Read the pressure profile
c
      call readabs(krdtp,kueql,naddrs,npsi,sp,     kerp)
      if (kerp  .ne. 0) call abortjob
     &        ('rdiflmp ', 10,   'Error in reading pressure profile   '
     &        ,'krdtp   ', krdtp,    'kerp    ', kerp,     -1)
c
c 3.1.4 Read the safety factor profile
c
      call readabs(krdtp,kueql,naddrs,npsi,sqvl,   kerq)
      if (kerq  .ne. 0) call abortjob
     &        ('rdiflmp ', 11,   'Error reading safety factor profile '
     &        ,'krdtp   ', krdtp,    'kerq    ', kerq,     -1)
c
c
c 3.2 Read the inverse mapping r(psii,theta), and z(psi,theta)
c
c 3.2.1 Read the inverse equilibrium r grid
c       The equilibrium is stored with theta in the first dimension
c
c 3.2.1.1 Read the array
c
      npstt   = npsi*ntht
      call readabs(krdtp,kueql,naddrs,npstt,seqtmp,kerrp)
      if (kerrp .ne. 0) then
        call abortjob
     &        ('rdiflmp ', 12,   'Error in reading radial mesh values '
     &        ,'kerrp   ', kerrp,    'npstt   ', npstt,    -1)
      endif
c
c 3.2.1.2 Reorder the array and store in seqrps
      do 50 jpin  = 1,npsi
        jj            = jpin
c
        do 40 itin    = 1,ntht
        ii            = itin
        iijj          = ii + (jj-1)*ntht
        seqrps(jj,ii) = seqtmp(iijj)
   40   continue
   50   continue
c
c 3.2.2 Read the inverse equilibrium z grid
c       The equilibrium is stored with theta in the first dimension
c
c 3.2.2.1 Read the array
c
      npstt   = npsi*ntht
      call readabs(krdtp,kueql,naddrs,npstt,seqtmp,kerzp)
      if (kerzp .ne. 0) then
        call abortjob
     &        ('rdiflmp ', 13,   'Error in reading  axial mesh values '
     &        ,'kerzp   ', kerzp,    'npstt   ', npstt,    -1)
      endif
c
c 3.2.2.2 Reorder the array and store in seqrps
      do 70 jpin  = 1,npsi
        jj            = jpin
c
        do 60 itin    = 1,ntht
        ii            = itin
        iijj          = ii + (jj-1)*ntht
        seqzps(jj,ii) = seqtmp(iijj)
   60   continue
   70   continue
c
c
c 
c 4.0 Set the quantities that were not explicitly read in
c
c 4.1 Set the basic integer parameters
c
      nprofl      = npsi
      nthet       = nth2
      nthp1       = ntht + 1
c
c
c 4.2 Calculate the profile derivatives
c
c 4.2.1 Set up the cubic spline interpolation coefficients for the
c       profiles sf and sp 
c
c 4.2.1.1 Set up the extrapolation coefficients
      nbcond     = nspbc0
      nprofl1    = nprofl - 1
      nprofl2    = nprofl - 2
      delx21     = psimsh(   2   ) - psimsh(   1   )
      delx32     = psimsh(   3   ) - psimsh(   2   )
      delx31     = psimsh(   3   ) - psimsh(   1   )
      delxn1     = psimsh(nprofl)  - psimsh(nprofl1)
      delxnx     = psimsh(nprofl1) - psimsh(nprofl2)
      delxn2     = psimsh(nprofl)  - psimsh(nprofl2)
      dr3132     = delx31/delx32
      dr2132     = delx21/delx32
      drn2nx     = delxn2/delxnx
      drn1nx     = delxn1/delxnx
      if    (nbcond .le. 0) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      elseif(nbcond .eq. 1) then
        xtrap1     = 1.0
        xtrap1p    = 0.0
        xtrapn     = 1.0
        xtrapnp    = 0.0
      elseif(nbcond .eq. 2) then
        xtrap1     = +dr3132
        xtrap1p    = -dr2132
        xtrapn     = +drn2nx
        xtrapnp    = -drn1nx
      elseif(nbcond .gt. 2) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      endif
c
c 4.2.1.2.1 Spline boundary conditions for the toroidal field function sf
c
c 4.2.1.2.1.1 Set the second derivatives at the endpoints 
      sf2pp      = f2sx(   2   ,sf,  psimsh,nprofl)
      sf3pp      = f2sx(   3   ,sf,  psimsh,nprofl)
      sfn1pp     = f2sx(nprofl1,sf,  psimsh,nprofl)
      sfn2pp     = f2sx(nprofl2,sf,  psimsh,nprofl)
c
      sfbc11     = xtrap1*sf2pp   + xtrap1p*sf3pp
      sfbcnn     = xtrapn*sfn1pp  + xtrapnp*sfn2pp
c
c 4.2.1.2.1.2 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nbcond .ge.  0  .and.  nbcond .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfbcnn
c
c 4.2.1.2.1.3 Use natural boundary conditions at the plasma surface but force
c             a near floating condition at the axis
      elseif(nbcond .gt. +2) then
        bigval     = abs(float(nbcond))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfn1pp
c
c 4.2.1.2.1.4 Use a floating condition at both ends
      elseif(nbcond .lt.  0) then
        bigval     = abs(float(nbcond))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 4.2.1.2.2 Compute the spline coefficients for sf
      call icsici(psimsh,sf,  nprofl,bcb,csf,  nppd,ierf)
      if(ierf  .ne. 0) call abortjob
     &        ('rdiflmp ', 14,   'Interpolation error for sf  (psimsh)'
     &        ,'ierf    ', ierf,     'nprofl  ', nprofl,   +1)
c
c 4.2.1.2.3 Spline boundary conditions for the pressure sp
c
c 4.2.1.2.3.1 Set the second derivatives at the endpoints 
      sp2pp      = f2sx(   2   ,sp,  psimsh,nprofl)
      sp3pp      = f2sx(   3   ,sp,  psimsh,nprofl)
      spn1pp     = f2sx(nprofl1,sp,  psimsh,nprofl)
      spn2pp     = f2sx(nprofl2,sp,  psimsh,nprofl)
c
      spbc11     = xtrap1*sp2pp   + xtrap1p*sp3pp
      spbcnn     = xtrapn*spn1pp  + xtrapnp*spn2pp
c
c 4.2.1.2.3.2 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nbcond .ge.  0  .and.  nbcond .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*spbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*spbcnn
c
c 4.2.1.2.3.3 Use natural boundary conditions at the plasma surface but force
c             a near floating condition at the axis
      elseif(nbcond .gt. +2) then
        bigval     = abs(float(nbcond))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spn1pp
c
c 4.2.1.2.3.4 Use a floating condition at both ends
      elseif(nbcond .lt.  0) then
        bigval     = abs(float(nbcond))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 4.2.1.2.4 Compute the spline coefficients for sp
      call icsici(psimsh,sp,  nprofl,bcb,csp,  nppd,ierp)
      if(ierp  .ne. 0) call abortjob
     &        ('rdiflmp ', 15,   'Interpolation error for sp  (psimsh)'
     &        ,'ierp    ', ierp,     'nprofl  ', nprofl,   +1)
c
c 4.2.2 Interpolation to the new mesh
c       sffp here is just sfp
c
      do 120 j      = 1,nprofl
      jv            = j
      ps            = psimsh(jv)
c
      sffp(jv)      = sterpp(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                          rndoff,kerfp)
c
      if(kerfp .ne. 0) call abortjob
     &        ('rdiflmp ', 16,   'Differentiation error for sf(jv)    '
     &        ,'kerfp   ', kerfp,    'jv      ', jv,       -1)
c
      spp (jv)      = sterpp(ps,psimsh,sp,  csp,  nprofl,npp,0,
     &                          rndoff,kerpp)
c
      if(kerpp .ne. 0) call abortjob
     &        ('rdiflmp ', 17,   'Differentiation error for sp(jv)    '
     &        ,'kerpp   ', kerpp,    'jv      ', jv,       -1)
  120 continue
c
c
c 4.3 Set the density profile
c
      dnnorm      = 1.0
      do 150 jj   = 1,nprofl
      sdns(jj)    = dnnorm
  150 continue
c
c
c
c 5.0 Modify the units
c
c 5.1 Set roundoff parameters
c
      radfact     = 1.0
c
      rndofps     = rndoff*psifact
      rndofpr     = rndoff*prsfact
      rndofr      = rndoff*radfact
c
c
c 5.2 Conversion factors
c
      btffact     = radfact*bfield0
      prnorm      = sp(1)
c
c
c 5.3 Reset the poloidal flux to Wb/m**2
c
c 5.3.2 Reset the flux array
c
      do 200 jj   = 1,nprofl
      psimsh(jj)  = psifact*psimsh(jj)
  200 continue
c
c 5.3.3 Set psimax and psilim
c
      psimax      = psimsh(1)
      psilim      = psimsh(nprofl)
c
c
c 5.4 Reset the pressure and toroidal field units and shift the pressure
c     and toroidal field to the grid points
c
c 5.4.1 Reset the pressure and pprime units
c
      prnorm      = prsfact*prnorm
c
      do 220 jj   = 1,nprofl
      sp   (jj)   =  prsfact         *sp   (jj)
      spp  (jj)   = (prsfact/psifact)*spp  (jj)
  220 continue
c
c 5.4.2 Reset the toroidal field function and units
c
      fbnorm      = 1.0*btffact
c
      do 230 jj   = 1,nprofl
      sf   (jj)   =  fbnorm         *sf   (jj)
      sffp (jj)   = (fbnorm/psifact)*sffp (jj)
  230 continue
c
c 5.4.3 Reset the remaining input profile units
c
c
c 5.4.4.2 Set the axis values
      sp(1)       = prnorm
c
c 5.4.4.3 Enforce p = 0.0 at the edge
      pedge       = sp(nprofl)
      if(abs(pedge) .gt. rndoff*prnorm) then
         call abortjob
     &        ('rdiflmp ', 18,   'Adjusted edge pressure not zero     '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
         sp(nprofl)  = 0.0
      endif
c
c 5.4.5 Reset the sffp to f*fprime
c
      do 250 jj   = 1,nprofl
      sffp (jj)   = sf   (jj)*sffp (jj)
  250 continue
c
c
c 5.5 Check for consistency of seqrps and seqzps on axis
c
c 5.5.1 Compute the average of seqrps and seqzps on axis
      seqraxs     = 0.0
      seqzaxs     = 0.0
      do 300 ii   = 1,ntht
      seqraxs     = seqraxs + seqrps(1,ii)
      seqzaxs     = seqzaxs + seqzps(1,ii)
  300 continue
c
      seqraxs     = seqraxs/float(ntht)
      seqzaxs     = seqzaxs/float(ntht)
c
c 5.5.2 Check for discrepancies
      ircnt       = 0
      izcnt       = 0
      do 350 ii   = 1,ntht
      seqrdif     = abs(seqrps(1,ii) - seqraxs)
      seqzdif     = abs(seqzps(1,ii) - seqzaxs)
      if(seqrdif .ge. rndofr) ircnt  = ircnt + 1
      if(seqzdif .ge. rndofr) izcnt  = izcnt + 1
  350 continue
c
      if(ircnt .gt. 0) then
         call abortjob
     &        ('rdiflmp ', 19,   'Input r mesh is not constant on axis'
     &        ,'ntht    ', ntht ,    'ircnt   ', ircnt,    -1)
         write(kuout,2000) ntht
         write(kuout,2010) (seqrps(1,ii),ii=1,ntht)
      endif
c
      if(izcnt .gt. 0) then
         call abortjob
     &        ('rdiflmp ', 20,   'Input z mesh is not constant on axis'
     &        ,'ntht    ', ntht ,    'izcnt   ', izcnt,    -1)
         write(kuout,2100) ntht
         write(kuout,2110) (seqzps(1,ii),ii=1,ntht)
      endif
c
c
c 5.6 Set the scalar data
c
c 5.6.1 Set the axis and limiter positions
c
c 5.6.1.1 Set the values
      xma         = seqraxs
      zma         = seqzaxs
      xlim        = seqrps(npsi,1)
      zlim        = seqzps(npsi,1)
c
c 5.6.1.2 Set the nominal plasma major radius value at the axis position
c>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      rcnt        = radfact
c<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      rcnt        = xma
c
c 5.6.2 Set the toroidal field and current
c
c 5.6.2.1 Set the total current
c         This needs to be set properly
      totcur      = bfield0
      call abortjob
     &        ('rdiflmp ', 21,   'Total current is not set for this   '
     &        ,'nmap    ', nmap,     'npsi    ', npsi,     -1)
c
c 5.6.2.2 Set sfedge and btor
      sfedge      = sf(nprofl)
      btor        = sfedge/xma
c
c 5.6.2.3 Set the input axis elongation temporarily
      axddxz      = 0.0
c
c
c
c 6.0 Reset the conventions if nonstandard
c
c 6.1 Reverse signs of psimsh and psi derivatives if input has
c     the alternate psi convention
c
      if(psimsh(1) .gt. psimsh(nprofl)) then
c
c 6.1.1 Print a warning
c
         call abortjob
     &        ('rdiflmp ', 22,   'Reversing sign convention of psi    '
     &        ,'nprofl  ', nprofl,   'npsi    ', npsi,     -1)
c
c 5.1.2 Reverse the signs
c
         do 400 jj  = 1,nprofl
         psimsh(jj) = -psimsh(jj)
         sffp  (jj) = -sffp  (jj)
         spp   (jj) = -spp   (jj)
  400    continue
      endif
c
c
c 6.2 Check the sign convention of btor
c
c 6.2.1 Check the signs of btor and totcur
c
        if(btor   .lt. 0.0) ibsign  = -1
        if(btor   .eq. 0.0) ibsign  =  0
        if(btor   .gt. 0.0) ibsign  = +1
c
c 6.2.2 Print a warning if btor is zero
c
        if(ibsign .eq. 0) call abortjob
     &        ('rdiflmp ', 23,   'Sign of btor from sf(npsi) zero     '
     &        ,'ibsign  ', ibsign,   'nprofl  ', nprofl,   -1)
c
        if(totcur .lt. 0.0) itsign  = -1
        if(totcur .eq. 0.0) itsign  =  0
        if(totcur .gt. 0.0) itsign  = +1
c
c 6.2.3 Switch the sign of totcur if the convention is reversed
c
        if(ibsign .lt. 0  .and.  itsign .lt. 0) then
          call abortjob
     &        ('rdiflmp ', 24,   'Switched btor and current signs     '
     &        ,'ibsign  ', ibsign,   'itsign  ', itsign,   -1)
          totcur     = -totcur
        endif
c
c
c 6.3 Set sfqi equal to sf*sqvl
c
        do 450 jj     = 1,npsi
        sfqi(jj)      = sf(jj)*sqvl(jj)
  450   continue
c     
c
c
c 7.0 Set up the auxiliary quantities
c
c 7.1 Set scalar quantities
c
c 7.1.1 Set the profile switch npst
c
      npst        = 0
c
c 7.1.2 Set the magnetic axis values
c
      psisep      = psimax
      xsep        = 0.0
      zsep        = 0.0
c
      xax(1)      = xma
      xax(2)      = 0.0
      zax(1)      = zma
      zax(2)      = 0.0
      psimx(1)    = psimax
      psimx(2)    = 0.0
c
c
c 7.2 Check for consistent input
c
      if(neqsym .eq. 0  .and.  isym .ne. 0) call abortjob
     &        ('rdiflmp ', 25,   'Asymmetric equilibrium with isym = 1'
     &        ,'neqsym  ', neqsym,   'isym    ', isym,     -1)
      if(neqsym .ne. 0  .and.  isym .eq. 0) call abortjob
     &        ('rdiflmp ', 26,   'neqsym and isym are inconsistent    '
     &        ,'neqsym  ', neqsym,   'isym    ', isym,      0)
c
c
c
c 8.0 Set the number of poloidal angles and complete arrays
c     for up-down symmetry
c
      if    (neqsym .eq. 1) then
c
c
c 8.1 Ensure the magnetic axis is on the midplane
c
        if(abs(zma) .gt. 0.0) then
          if(abs(zma) .le. rndofr) call abortjob
     &        ('rdiflmp ', 27,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,     0)
          if(abs(zma) .gt. rndofr) call abortjob
     &        ('rdiflmp ', 28,   'zma is not zero for neqsym = 1      '
     &        ,'neqsym  ', neqsym,   'nthet   ', nthet,    -1)
          write(kuout,3000) xma,zma
        endif
c
c
c 8.2 Ensure the first flux surface is at the magnetic axis
c
c 8.2.1 Check for discrepancies
c
        ikr0            = 0
        ikr1            = 0
        ikz0            = 0
        ikz1            = 0
        suminr          = 0.0
        suminz          = 0.0
        do 500 ii       = 1,ntht
c
c 8.2.1.1 Check the r value is the axis value
        dscinr          = seqrps(1,ii) - xma
        suminr          = suminr + abs(dscinr)
        if(abs(dscinr) .ne. 0.0) then
          if(abs(dscinr) .le. rndofr) ikr0   = ikr0 + 1
          if(abs(dscinr) .gt. rndofr) ikr1   = ikr1 + 1
        endif
c
c 8.2.1.2 Check the z value is the axis value
        dscinz          = seqzps(1,ii) - zma
        suminz          = suminz + abs(dscinz)
        if(abs(dscinz) .ne. 0.0) then
          if(abs(dscinz) .le. rndofr) ikz0   = ikz0 + 1
          if(abs(dscinz) .gt. rndofr) ikz1   = ikz1 + 1
        endif
c
  500   continue
c
c 8.2.1.3 Find the mean discrepancy
        suminr          = suminr / float(ntht)
        suminz          = suminz / float(ntht)
c
c 8.2.2 Print error message if any discrepancy
c
        if(ikr0 .gt. 0  .or.  ikr1 .gt. 0  .or.  ikz0 .gt. 0  .or.
     &                                           ikz1 .gt. 0) then
          if(ikr0 .gt. 0) call abortjob
     &        ('rdiflmp ', 29,   'Small Discrepancy in seqrps(1)      '
     &        ,'ikr0    ', ikr0,     'neqsym  ', neqsym,    0)
          if(ikz0 .gt. 0) call abortjob
     &        ('rdiflmp ', 30,   'Small Discrepancy in seqzps(1)      '
     &        ,'ikz0    ', ikz0,     'neqsym  ', neqsym,    0)
          if(ikr1 .gt. 0) call abortjob
     &        ('rdiflmp ', 31,   'Large Discrepancy in seqrps(1)      '
     &        ,'ikr1    ', ikr1,     'neqsym  ', neqsym,   -1)
          if(ikz1 .gt. 0) call abortjob
     &        ('rdiflmp ', 32,   'Large Discrepancy in seqzps(1)      '
     &        ,'ikz1    ', ikz1,     'neqsym  ', neqsym,   -1)
c
          write(kuout,3100) npsi,ntht,suminr,suminz
          if(ikr1 .gt. 0  .or.  ikz1 .gt. 0) then
            write(kuout,3110)
            write(kuout,3120) (iii, seqrps(1,iii), seqzps(1,iii),
     &                              iii=1,ntht)
          endif
        endif
c
c 8.2.3 Reset the first flux surface identically to the axis values
c
        do 510 ii       = 1,ntht
        seqrps(1,ii)    = xma
        seqzps(1,ii)    = zma
  510   continue
c
c
c 8.3 Ensure that the first and last ray lay along the midplane
c
c 8.3.1 Check for discrepancy
c
        jkm0            = 0
        jkm1            = 0
        jkp0            = 0
        jkp1            = 0
        sumray1         = 0.0
        sumrayn         = 0.0
        do 520 jj       = 1,npsi
c
c 8.3.1.1 Check the first ray is on the midplane
        dscray1         = seqzps(jj,  1 ) - zma
        sumray1         = sumray1 + abs(dscray1) 
        if(abs(dscray1) .ne.   0.0 ) then
          if(abs(dscray1) .le. rndofr) jkm0   = jkm0 + 1
          if(abs(dscray1) .gt. rndofr) jkm1   = jkm1 + 1
        endif
c
c 8.3.1.2 Check the last  ray is on the midplane
        dscrayn         = seqzps(jj,ntht) - zma
        sumrayn         = sumrayn  +  abs(dscrayn)
        if(abs(dscrayn) .ne.   0.0 ) then
          if(abs(dscrayn) .le. rndofr) jkp0   = jkp0 + 1
          if(abs(dscrayn) .gt. rndofr) jkp1   = jkp1 + 1
        endif
  520   continue
c
c 8.3.1.3 Find the mean discrepancy
        sumray1         = sumray1 / float(npsi)
        sumrayn         = sumrayn / float(npsi)
c
c 8.3.2 Print error message if any discrepancy
c
        if(jkm0 .gt. 0  .or.  jkp0 .gt. 0  .or.  jkm1 .gt. 0  .or.
     &                                           jkp1 .gt. 0) then
          if(jkm0 .gt. 0) call abortjob
     &        ('rdiflmp ', 33,   'First ray slightly off midplane     '
     &        ,'jkm0    ', jkm0,     'neqsym  ', neqsym,    0)
          if(jkp0 .gt. 0) call abortjob
     &        ('rdiflmp ', 34,   'Last  ray slightly off midplane     '
     &        ,'jkp0    ', jkp0,     'neqsym  ', neqsym,    0)
          if(jkm1 .gt. 0) call abortjob
     &        ('rdiflmp ', 35,   'First ray is not on the midplane    '
     &        ,'jkm1    ', jkm1,     'neqsym  ', neqsym,   -1)
          if(jkp1 .gt. 0) call abortjob
     &        ('rdiflmp ', 36,   'Last  ray is not on the midplane    '
     &        ,'jkp1    ', jkp1,     'neqsym  ', neqsym,   -1)
c
          write(kuout,3200) npsi,ntht,sumray1,sumrayn
          if(jkm1 .gt. 0  .or.  jkp1 .gt. 0) then
            write(kuout,3210)
            write(kuout,3220) (jjj, seqrps(jjj,  1 ), seqzps(jjj,  1 ),
     &                              seqrps(jjj,ntht), seqzps(jjj,ntht),
     &                                                jjj=1,npsi)
          endif
        endif
c
c 8.3.3 Reset the rays along the midplane
c
        do 530 jj       = 1,npsi
        seqzps(jj,  1 ) = 0.0
        seqzps(jj,ntht) = 0.0
  530   continue
c
c
c 8.1 Fill the complete r and z arrays for up-down symmetry
c
        do 550 ii       = nthp1,nthet
        i1              = ii
        i0              = nthet + 1 - i1
c
        do 540 jj       = 1,npsi
        seqrps(jj,i1)   = +seqrps(jj,i0)
        seqzps(jj,i1)   = -seqzps(jj,i0)
  540   continue
  550   continue
      endif
c
c
c
c 9.0 Return and end
c
      return
 1000 format('Inverse equilibrium from CORSICA I-file')
 1010 format(5a8)
 2000 format(/,5x,'seqrps(1,ii),ii=1,',i5)
 2010 format(5(1x,e16.9))
 2100 format(/,5x,'seqzps(1,ii),ii=1,',i5)
 2110 format(5(1x,e16.9))
 3000 format(/,10x,'xma     = ',e16.9, 4x,'zma     = ',e16.9)
 3100 format(/,10x,'npsi    = ',i5,   15x,'ntht    = ',i5,/
     &        ,10x,'suminr  = ',e16.9, 4x,'suminz  = ',e16.9)
 3110 format(/, 4x,'ii',6x,'seqrps(1,ii)',5x,'seqzps(1,ii)')
 3120 format((1x,i5,2x,2(1x,e16.9)))
 3200 format(/,10x,'npsi    = ',i5,   15x,'ntht    = ',i5,/
     &        ,10x,'sumray1 = ',e16.9, 4x,'sumrayn = ',e16.9)
 3210 format(/, 4x,'jj',6x,'seqrps(jj,  1 )',2x,'seqzps(jj,  1 )'
     &                ,2x,'seqrps(jj,ntht)',2x,'seqzps(jj,ntht)')
 3220 format((1x,i5,2x,4(1x,e16.9)))
      end
      subroutine readabs(krtype,kueql,nstart,nlength,array,kerr)
c
c  Read binary file either in sequential or direct access
c
      dimension array(nlength)
c
c
c
c 1.0 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c
c 2.0 Read the file data
c
c     Sequential access: read the array
c     For sequential access files naddrs and naddrf are irrelevant but keep track
c     of the number of items read
c
      if    (krtype .eq. 0) then
        naddrs    = nstart
        naddrf    = naddrs + nlength - 1
        read(kueql,err = 200) (array(iarray),iarray=1,nlength)
        ierr     = nlength
c
c
c     Direct access: Read one item at a time from nstart
c
      elseif(krtype .eq. 1) then
        naddrs    = nstart
        naddrf    = naddrs + nlength - 1
c
        do 100 ir = 1,nlength
        ird       = ir
        iaddrs    = naddrs + ird -1
        iarray    = ird
        read(kueql, rec = iaddrs, err = 200) array(iarray)
        ierr      = ird
  100   continue
      endif
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. nlength) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine setarcl(kmap)
c
c -------------------------------------------------------------
c  Reset input inverse equilibrium to equal arclength
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Set the dimensions
c
c 1.1.1 Storage dimensions
c
      nppd      = npp
      nttd      = ntt
      ntdim     = nlx
c
      npval     = npsi
      ntval     = nthet
c
c 1.1.2 Initialize error flags and roundoff parameters
c
      kera      = 0
      kerr      = 0
      kerz      = 0
      small     = roundff
      tolsp0    = tolspln
      tolsp1    = tolaugm*tolspln
c
c 1.1.3 Initialize error message counters
c
      kercnta   = 0
      kercntr   = 0
      kercntz   = 0
      kercntap  = 0
      kercntrp  = 0
      kercntzp  = 0
c
c
c 1.2 Check the equilibrium type and dimensions
c
c 1.2.1 Check the equilibrium type
c
      if(kmap .eq.  0) then
         call abortjob
     &        ('setarcl ',  1,   'Incorrect equilibrium file type     '
     &        ,'kmap    ', kmap,     'nmap    ', nmap,     -1)
         return
      endif
c
c 1.2.2 Check the dimensions
c
      if(npval .gt.  nppd) then
         call abortjob
     &        ('setarcl ',  2,   'Dimension for flux is too small     '
     &        ,'npval   ', npval,    'nppd    ', nppd,     +1)
      endif
c
      if(npval .lt.   2  ) then
         call abortjob
     &        ('setarcl ',  3,   'Number of flux surfaces less than 2 '
     &        ,'npval   ', npval,    'nppd    ', nppd,     -1)
      endif
c
      if(ntval .gt.  nttd) then
         call abortjob
     &        ('setarcl ',  4,   'Dimension for angle less than nttd  '
     &        ,'ntval   ', ntval,    'nttd    ', nttd,     +1)
      endif
c
      if(ntval .gt.  ntdim) then
         call abortjob
     &        ('setarcl ',  5,   'Dimension for angle less than nlx   '
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    +1)
      endif
c
      if(ntval .le.    0  ) then
         call abortjob
     &        ('setarcl ',  6,   'Number of angles less or equal to 0 '
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    +1)
      endif
c
c
c 1.3 Set control parameters
c
      if    (kmap .eq. -4) then
         mapreset   = 0
      elseif(kmap .ne. -4) then
         mapreset   = mpreset
      endif
c
c
c
c 2.0 Calculate the points for an equal arclength mesh for each surface except
c     the first
c
c 2.1 Loop over flux surfaces
c
      do 500 np = 2,npval
      jp        = np
      jsurf     = jp
c
c
c 2.2 Calculate the equal arc points in the counterclockwise direction
c
c 2.2.1 Store the mesh points in forward order
c
         do 100 nt = 1,ntval
         it        = nt
         itp       = it
         xp(it)    = seqrps(jp,itp)
         zp(it)    = seqzps(jp,itp)
  100    continue
c
c 2.2.2 Check the periodic point is present
c
c 2.2.2.1 Find the closure gap
         diffxp    =     xp(ntval) - xp(  1  )
         diffzp    =     zp(ntval) - zp(  1  )
         scalxp    = abs(xp(  2  ) - xp(  1  ))
         scalzp    = abs(zp(  2  ) - zp(  1  ))
         close2    = diffxp*diffxp + diffzp*diffzp
         closep    = sqrt(close2)
         scale2    = scalxp*scalxp + scalzp*scalzp
         scalep    = sqrt(scale2)
c
c 2.2.2.2 Set ntvalp if the gap is closed
         if    (closep .le. roundff*scalep) then
            ntvalp     = ntval
c
c 2.2.2.3 Set ntvalp if the gap is not closed 
         elseif(closep .gt. roundff*scalep) then
c
c 2.2.2.3.1 If not quite closed
            if    (closep .le. dlclose*scalep) then
               ntvalp     = ntval
               call abortjob
     &        ('setarcl ',  7,   'Input mesh is not exactly closed    '
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    -1)
c
c 2.2.2.3.2 If not closed at all
            elseif(closep .gt. dlclose*scalep) then
               call abortjob
     &        ('setarcl ',  8,   'Input mesh is missing periodic point'
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    -1)
c
               if    (ntval .lt.  nttd  .and.  ntval .lt. ntdim) then
                  ntvalp     = ntval + 1
               elseif(ntval .ge.  nttd  .or.   ntval .ge. ntdim) then
                  if(ntval .ge.  nttd) call abortjob
     &        ('setarcl ',  9,   'New angle dimension less than nttd  '
     &        ,'ntval   ', ntval,    'nttd    ', nttd,     -1)
                  if(ntval .ge. ntdim) call abortjob
     &        ('setarcl ', 10,   'New angle dimension less than ntdim '
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    -1)
                  ntvalp     = ntval
               endif
            endif
c
c 2.2.2.4 Reset the last points
            xp(ntvalp) = xp(1)
            zp(ntvalp) = zp(1)
         endif
c
c 2.2.3 Compute the arclength and spline coefficients
c
         call arclng(xp,zp,ntvalp,ntdim,1.0,tp, arc, csx,csz,kera)
c
         if(kera .ne. 0) then
            call abortjob
     &        ('setarcl ', 11,   'Error in arclength calculation      '
     &        ,'kera    ', kera,     'jsurf   ', jsurf,    -1)
            return
         endif
c
c 2.2.4 Reset the mesh positions to the equal arc values in (st1,st2)
c
         arc0          =  arc (  1  )
         arcmn         =  arc0
         arcmx         =  arc (ntvalp)
         darc          = (arcmx -arcmn )/ (ntvalp-1.0)
         do 150 nt     = 1,ntvalp
         it            = nt
         arcval        = arc0  + (it-1.0)*darc
c
         rnewv         = sterpl(arcval, arc, xp, csx,ntvalp,ntdim,1,
     &                          small,  kerr)
         if(kerr .ne. 0) then
            call abortjob
     &        ('setarcl ', 12,   'Forward r(arc) interpolation error  '
     &        ,'jsurf   ', jsurf,    'kerr    ', kerr,     -1)
            return
         endif
c
         znewv         = sterpl(arcval, arc, zp, csz,ntvalp,ntdim,1,
     &                          small,  kerz)
         if(kerz .ne. 0) then
            call abortjob
     &        ('setarcl ', 13,   'Forward z(arc) interpolation error  '
     &        ,'jsurf   ', jsurf,    'kerr    ', kerr,     -1)
            return
         endif
c
         tp (it)       = arcval
         sv1(it)       = rnewv
         sv2(it)       = znewv
  150    continue
c
c
c 2.3 Repeat the calculation in the opposite direction to ensure symmetry
c
c 2.3.1 Store the mesh points in reverse order
c
         do 200 nt = 1,ntval
         it        = nt
         itp       = ntval - it + 1
         xp(it)    = seqrps(jp,itp)
         zp(it)    = seqzps(jp,itp)
  200    continue

c
c 2.3.2 Check the periodic point is present
c
c 2.3.2.1 Find the closure gap
         diffxp    =     xp(  1  ) - xp(ntval)
         diffzp    =     zp(  1  ) - zp(ntval)
         scalxp    = abs(xp(ntval) - xp(ntval-1))
         scalzp    = abs(zp(ntval) - zp(ntval-1))
         close2    = diffxp*diffxp + diffzp*diffzp
         closep    = sqrt(close2)
         scale2    = scalxp*scalxp + scalzp*scalzp
         scalep    = sqrt(scale2)
c
c 2.3.2.2 Set ntvalp if the gap is closed
         if    (closep .le. roundff*scalep) then
            ntvalq     = ntval
c
c 2.3.2.3 Set ntvalp if the gap is not closed 
         elseif(closep .gt. roundff*scalep) then
c
c 2.3.2.3.1 If not quite closed
            if    (closep .le. dlclose*scalep) then
               ntvalq     = ntval
               call abortjob
     &        ('setarcl ', 14,   'Input mesh is not exactly closed    '
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    -1)
c
c 2.3.2.3.2 If not closed at all
            elseif(closep .gt. dlclose*scalep) then
               call abortjob
     &        ('setarcl ', 15,   'Input mesh is missing periodic point'
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    -1)
c
               if    (ntval .lt.  nttd  .and.  ntval .lt. ntdim) then
                  ntvalq     = ntval + 1
               elseif(ntval .ge.  nttd  .or.   ntval .ge. ntdim) then
                  if(ntval .ge.  nttd) call abortjob
     &        ('setarcl ', 16,   'New angle dimension less than nttd  '
     &        ,'ntval   ', ntval,    'nttd    ', nttd,     -1)
                  if(ntval .ge. ntdim) call abortjob
     &        ('setarcl ', 17,   'New angle dimension less than ntdim '
     &        ,'ntval   ', ntval,    'ntdim   ', ntdim,    -1)
                  ntvalq     = ntval
               endif
            endif
c
c 2.3.2.4 Reset the last points
            xp(ntvalq) = xp(1)
            zp(ntvalq) = zp(1)
         endif
c
c 2.3.3 Compute the arclength and spline coefficients
c
         call arclng(xp,zp,ntvalq,ntdim,1.0,tpp,arcc,csx,csz,kera)
c
         if(kera .ne. 0) then
            call abortjob
     &        ('setarcl ', 18,   'Error in arclength calculation      '
     &        ,'kera    ', kera,     'jsurf   ', jsurf,    -1)
            return
         endif
c
c 2.3.4 Reset the mesh positions to the equal arc values in (st3,st4)
c
         arcc0         =  arcc(  1  )
         arccmn        =  arcc0
         arccmx        =  arcc(ntvalq)
         darcc         = (arccmx-arccmn)/ (ntvalq-1.0)
         do 250 nt     = 1,ntvalq
         it            = nt
         arccval       = arcc0 + (it-1.0)*darcc
c
         rnewv         = sterpl(arccval,arcc,xp, csx,ntvalq,ntdim,1,
     &                          small,  kerr)
         if(kerr .ne. 0) then
            call abortjob
     &        ('setarcl ', 19,   'Reverse r(arc) interpolation error  '
     &        ,'jsurf   ', jsurf,    'kerr    ', kerr,     -1)
            return
         endif
c
         znewv         = sterpl(arccval,arcc,zp, csz,ntvalq,ntdim,1,
     &                          small,  kerz)
         if(kerz .ne. 0) then
            call abortjob
     &        ('setarcl ', 20,   'Reverse z(arc) interpolation error  '
     &        ,'jsurf   ', jsurf,    'kerr    ', kerr,     -1)
            return
         endif
c
         tpp(it)       = arccval
         sv3(it)       = rnewv
         sv4(it)       = znewv
  250    continue
c
c
c 2.4 Average the results
c
c 2.4.1 Check ntvalp and ntvalq are the same
c
         if    (ntvalp .eq. ntvalq) then
            ntval0    = ntval
            ntval     = ntvalp
         elseif(ntvalp .ne. ntvalq) then
            call abortjob
     &        ('setarcl ', 21,   'Reverse direction closing different '
     &        ,'ntvalp  ', ntvalp,   'ntvalq  ', ntvalq,   -1)
            ntval0    = ntval
            ntval     = ntval0
         endif
c
c 2.4.2 Initialize error counters and differences
c
         arclast    = arc (ntvalp)
         tplast     = tp  (ntvalp)
         arcclast   = arcc(ntvalq)
         tpplast    = tpp (ntvalq)
         karcflg    = 0
         ktpflg     = 0
         kxpflg     = 0
         kzpflg     = 0
         itarcmx    = 0
         ittpmx     = 0
         itxpmx     = 0
         itzpmx     = 0
         arcdfmx    = 0.0
         tpdfmx     = 0.0
         xpdfmx     = 0.0
         zpdfmx     = 0.0
c
c 2.4.3 Calculate the averages and the maximum differences
c         
         do 300 nt  = 1,ntval
         it         = nt
         itp        = ntval - it + 1
         arcv       = arc (it)
         tpv        = tp  (it)
         arccv      = arcclast - arcc(itp)
         tppv       = tpplast  - tpp (itp)
         sv1v       = sv1 (it)
         sv3v       = sv3 (itp)
         sv2v       = sv2 (it)
         sv4v       = sv4 (itp)
         arcdf      = arccv    - arcv
         tpdf       = tppv     - tpv
         xpdf       = sv1v     - sv3v
         zpdf       = sv2v     - sv4v
c
         if(abs(arcdf) .ge. abs(arcdfmx)) then
            itarcmx = it
            arcdfmx = arcdf
         endif
         if(abs(tpdf)  .ge. abs(tpdfmx) ) then
            ittpmx  = it
            tpdfmx  = tpdf
         endif
         if(abs(xpdf)  .ge. abs(xpdfmx)) then
            itxpmx  = it
            xpdfmx  = xpdf
         endif
         if(abs(zpdf)  .ge. abs(zpdfmx)) then
            itzpmx  = it
            zpdfmx  = zpdf
         endif
c
         sv0(it)    = 0.5*(arcv  +  arccv)
         sv5(it)    = 0.5*(tpv   +  tppv)
         xp (it)    = 0.5*(sv1v  +  sv3v)
         zp (it)    = 0.5*(sv2v  +  sv4v)
  300    continue
c
c 2.4.4 Print warnings if the differences exceed tolerances
c
c 2.4.4.1 Check the arclength, tp, xp, and zp independently
         if(abs(arcdfmx) .ge. small) then
            if    (abs(arcdfmx) .lt. tolsp0) then
               karcflg   = -1 
               call abortjob
     &        ('setarcl ', 22,   'Small asymmetry in arc integration '
     &        ,'jsurf   ', jsurf,    'itarcmx ', itarcmx,   0)
            elseif(abs(arcdfmx) .ge. tolsp0) then
               karcflg   = +1
               call abortjob
     &        ('setarcl ', 23,   'Large asymmetry in arc integration '
     &        ,'jsurf   ', jsurf,    'itarcmx ', itarcmx,  -1)
               write(kuout,1000) arclast,arcclast,tplast, tpplast,
     &                                            arcdfmx,tolsp0
            endif
         endif
c
         if(abs(tpdfmx)  .ge. small) then
            if    (abs(tpdfmx)  .lt. tolsp0) then
               ktpflg    = -1 
               call abortjob
     &        ('setarcl ', 24,   'Small asymmetry in tp construction '
     &        ,'jsurf   ', jsurf,    'ittpmx  ', ittpmx,    0)
            elseif(abs(tpdfmx)  .ge. tolsp0) then
               ktpflg    = +1
               call abortjob
     &        ('setarcl ', 25,   'Large asymmetry in tp construction '
     &        ,'jsurf   ', jsurf,    'ittpmx  ', ittpmx,   -1)
               write(kuout,1100) arclast,arcclast,tplast, tpplast,
     &                                            tpdfmx, tolsp0
            endif
         endif
c
         if(abs(xpdfmx)  .ge. small) then
            if    (abs(xpdfmx)  .lt. tolsp0) then
               kxpflg    = -1 
               call abortjob
     &        ('setarcl ', 26,   'Small asymmetry in xp construction '
     &        ,'jsurf   ', jsurf,    'itxpmx  ', itxpmx,    0)
            elseif(abs(xpdfmx)  .ge. tolsp0) then
               kxpflg    = +1
               call abortjob
     &        ('setarcl ', 27,   'Large asymmetry in xp construction '
     &        ,'jsurf   ', jsurf,    'itxpmx  ', itxpmx,   -1)
               write(kuout,1200) arclast,arcclast,tplast, tpplast,
     &                                            xpdfmx, tolsp0
            endif
         endif
c
         if(abs(zpdfmx)  .ge. small) then
            if    (abs(zpdfmx)  .lt. tolsp0) then
               kzpflg    = -1 
               call abortjob
     &        ('setarcl ', 28,   'Small asymmetry in zp construction '
     &        ,'jsurf   ', jsurf,    'itzpmx  ', itzpmx,    0)
            elseif(abs(zpdfmx)  .ge. tolsp0) then
               kzpflg    = +1
               call abortjob
     &        ('setarcl ', 29,   'Large asymmetry in zp construction '
     &        ,'jsurf   ', jsurf,    'itzpmx  ', itzpmx,   -1)
               write(kuout,1300) arclast,arcclast,tplast, tpplast,
     &                                            zpdfmx, tolsp0
            endif
         endif
c
c 2.4.4.2 Set the global flag if there is any discrepancy
         kflag    = 0
         kflagp   = 0
         if    (karcflg .eq. -1  .or.  ktpflg  .eq. -1  .or.
     &          kxpflg  .eq. -1  .or.  kzpflg  .eq. -1) then
            kflag   = +1
         elseif(karcflg .eq. +1  .or.  ktpflg  .eq. +1  .or.
     &          kxpflg  .eq. +1  .or.  kzpflg  .eq. +1) then
            kflagp  = +1
         endif
c
c
c
c 2.5 Check the new mesh against the original mesh
c
c 2.5.1 Initialize counters
c
         kounta      = 0
         kountr      = 0
         kountz      = 0
         kountap     = 0
         kountrp     = 0
         kountzp     = 0
         itdifa      = 0
         itdifr      = 0
         itdifz      = 0
         itdifap     = 0
         itdifrp     = 0
         itdifzp     = 0
         difamax     = 0.0
         difrmax     = 0.0
         difzmax     = 0.0
         difamaxp    = 0.0
         difrmaxp    = 0.0
         difzmaxp    = 0.0
         ascale      = arcmx
         rscale      = rdefolt
         zscale      = rdefolt
c
c 2.5.2 Check the differences for kmap not 4
c
         if(kmap .ne. -4) then
c
c 2.5.2.1 Calculate the maximum difference
            do 350 nt   = 1,ntval
            it          = nt
            diffa       = sv0      (it) - sv5 (it) 
            diffr       = seqrps(jp,it) - xp  (it)
            diffz       = seqzps(jp,it) - zp  (it)
c
c 2.5.2.1.1 For arclength
            if(abs(diffa) .ge. tolsp0*ascale) then
               kounta      = kounta  + 1
               if(abs(diffa) .ge. abs(difamax))  then
                  itdifa      = it
                  difamax     = diffa
               endif
               if(abs(diffa) .ge. tolsp1*ascale) then
                  kountap     = kountap + 1
                  if(abs(diffa) .ge. abs(difamaxp)) then
                     itdifap     = it
                     difamaxp    = diffa
                  endif
               endif
            endif
c
c 2.5.2.1.2 For seqrps
            if(abs(diffr) .ge. tolsp0*rscale) then
               kountr      = kountr + 1
               if(abs(diffr) .ge. abs(difrmax))  then
                  itdifr      = it
                  difrmax     = diffr
               endif
               if(abs(diffr) .ge. tolsp1*rscale) then
                  kountrp     = kountrp + 1
                  if(abs(diffr) .ge. abs(difrmaxp)) then
                     itdifrp     = it
                     difrmaxp    = diffr
                  endif
               endif
            endif
c
c 2.5.2.1.3 For seqzps
            if(abs(diffz) .ge. tolsp0*zscale) then
               kountz      = kountz + 1
               if(abs(diffz) .ge. abs(difzmax))  then
                  itdifz      = it
                  difzmax     = diffz
               endif
               if(abs(diffz) .ge. tolsp1*zscale) then
                  kountzp     = kountzp + 1
                  if(abs(diffz) .ge. abs(difzmaxp)) then
                     itdifzp     = it
                     difzmaxp    = diffz
                  endif
               endif
            endif
  350       continue
c
c 2.5.2.2 Print warnings if the differences are excessive
c
            kwritea    = 0
            kwriter    = 0
            kwritez    = 0
c
c 2.5.2.2.1 For arclength
            if(kounta .ne. 0) then
               kercnta      = kercnta + 1
               if    (kercnta .lt. nerstop) then
                  if    (kountap .eq. 0) then
                     call abortjob
     &        ('setarcl ', 30,   'Small equalarc discrepancy for arc '
     &        ,'jsurf   ', jsurf,    'kounta  ', kounta,    0)
                     write(kuout,2000) itdifa, difamax, tolsp0, ascale
                  elseif(kountap .ne. 0) then
                     kercntap   = kercntap + 1
                     call abortjob
     &        ('setarcl ', 31,   'Large equalarc discrepancy for arc '
     &        ,'jsurf   ', jsurf,    'kountap ', kountap,  -1)
                     write(kuout,2010) kounta,
     &                                 itdifa, difamax, tolsp0,
     &                                 itdifap,difamaxp,tolsp1, ascale
                  endif
               endif
            endif
c
            if(kountap .ne. 0) then
               if    (kercntap .lt. nerstop) then
                  kwritea  = +1
               elseif(kercntap .eq. nerstop) then
                  kwritea  = -1
               elseif(kercntap .gt. nerstop) then
                  kwritea  =  kwritea - 1
               endif
            endif

c
c 2.5.2.2.2 For seqrps
            if(kountr .ne. 0) then
               kercntr      = kercntr + 1
               if    (kercntr .lt. nerstop) then
                  if    (kountrp .eq. 0) then
                     call abortjob
     &        ('setarcl ', 32,   'Small discrepancy in seqrps for arc'
     &        ,'jsurf   ', jsurf,    'kountr  ', kountr,    0)
                     write(kuout,2100) itdifr, difrmax, tolsp0, rscale
                  elseif(kountrp .ne. 0) then
                     kercntrp   = kercntrp + 1
                     call abortjob
     &        ('setarcl ', 33,   'Large discrepancy in seqrps for arc'
     &        ,'jsurf   ', jsurf,    'kountrp ', kountrp,  -1)
                     write(kuout,2110) kountr,
     &                                 itdifr, difrmax, tolsp0,
     &                                 itdifrp,difrmaxp,tolsp1, rscale
                  endif
               endif
            endif
c
            if(kountrp .ne. 0) then
               if    (kercntrp .lt. nerstop) then
                  kwriter  = +1
               elseif(kercntrp .eq. nerstop) then
                  kwriter  = -1
               elseif(kercntrp .gt. nerstop) then
                  kwriter  =  kwriter - 1
               endif
            endif
c
c 2.5.2.2.3 For seqzps
            if(kountz .ne. 0) then
               kercntz      = kercntz + 1
               if    (kercntz .lt. nerstop) then
                  if    (kountzp .eq. 0) then
                     call abortjob
     &        ('setarcl ', 34,   'Small discrepancy in seqzps for arc'
     &        ,'jsurf   ', jsurf,    'kountz  ', kountz,    0)
                     write(kuout,2200) itdifz, difzmax, tolsp0, zscale
                  elseif(kountzp .ne. 0) then
                     kercntzp   = kercntzp + 1
                     call abortjob
     &        ('setarcl ', 35,   'Large discrepancy in seqzps for arc'
     &        ,'jsurf   ', jsurf,    'kountzp ', kountzp,  -1)
                     write(kuout,2210) kountz,
     &                                 itdifz, difzmax, tolsp0,
     &                                 itdifzp,difzmaxp,tolsp1, zscale
                  endif
               endif
            endif
c
            if(kountzp .ne. 0) then
               if    (kercntzp .lt. nerstop) then
                  kwritez  = +1
               elseif(kercntzp .eq. nerstop) then
                  kwritez  = -1
               elseif(kercntzp .gt. nerstop) then
                  kwritez  =  kwritez - 1
               endif
            endif
c
c 2.5.2.3 Print a warning if the maximum number of warnings was reached
            if(kwritea .eq. -1) then
               call abortjob
     &        ('setarcl ', 36,   'No. of arc discrepancies = nerstop '
     &        ,'jsurf   ', jsurf,    'kounta  ', kounta,   -1)
            endif
            if(kwriter .eq. -1) then
               call abortjob
     &        ('setarcl ', 37,   'No. seqrps discrepancies = nerstop '
     &        ,'jsurf   ', jsurf,    'kountr  ', kountr,   -1)
            endif
            if(kwritez .eq. -1) then
               call abortjob
     &        ('setarcl ', 38,   'No. seqzps discrepancies = nerstop '
     &        ,'jsurf   ', jsurf,    'kountz  ', kountz,   -1)
            endif
c
c 2.5.2.4 Write out the contour diagnostics
            if(kwritea .ne. 0  .or.  kwriter .ne. 0  .or.
     &                               kwritez .ne. 0)  then
               if    (kwritea .eq. +1) then
c
c 2.5.2.4.1 For arclength errors only
                  if     (kwriter .eq.  0 .and.  kwritez .eq.  0) then
                     write(kuout,3000) ntval0, ntval,   ntvalp, ntvalq,
     &                                 arclast,arcclast,tplast, tpplast
                     write(kuout,3005)
                     ntvalmin   = min0(ntvalp,ntvalq)
                     do 360 itv = 1,ntvalmin
                     itt        = itv
                     its        = ntvalq - itt + 1
                     sv0v       = sv0 (itt)
                     sv5v       = sv5 (itt)
                     arcv       = arc (itt)
                     tpv        = tp  (itt)
                     arccv      = arcclast - arcc(its)
                     tppv       = tpplast  - tpp (its)
                     arcdf      = arccv    - arcv
                     tpdf       = tppv     - tpv
                     write(kuout,3010) itt,sv0v,arcv,arccv,arcdf,
     &                                     sv5v,tpv, tppv, tpdf
  360                continue
                     if    (ntvalp .gt. ntvalq)  then
                        write(kuout,3020) ntvalp,
     &                                    arc (ntvalp),tp  (ntvalp)
                     elseif(ntvalq .gt. ntvalp) then
                        arccv     = arcclast - arcc(   1  )
                        tppv      = tpplast  - tpp (   1  )
                        write(kuout,3030) arccv,       tppv
                     endif
c
c 2.5.2.4.2 For arclength errors as well as errors in r and z
                  else
                     if((kwriter .eq. +1 .or.   kwritez .eq. +1) .or.
     &                  (kwriter .le. -1 .or.   kwritez .le. -1)) then
                        write(kuout,3100) ntval0, ntval,   ntvalp,
     &                                                     ntvalq,
     &                                    arclast,arcclast,tplast,
     &                                                     tpplast
                        write(kuout,3105)
                        do 370 itv = 1,ntval0
                        itt        = itv
                        sv0v       = sv0 (itt)
                        sv5v       = sv5 (itt)
                        xpv        = xp  (itt)
                        zpv        = zp  (itt)
                        xsv        = seqrps(jsurf,itt)
                        zsv        = seqzps(jsurf,itt)
                        svdf       = sv5v    - sv0v
                        xpdf       = xsv     - xpv
                        zpdf       = zsv     - zpv           
                        write(kuout,3110) itt,sv0v,sv5v,svdf,
     &                                        xsv, xpv, xpdf,
     &                                        zsv, zpv, zpdf

  370                   continue
                        if(ntval .gt. ntval0) write(kuout,3115) ntval,
     &                                        sv0(ntval),sv5(ntval),
     &                                        xp (ntval),zp (ntval)
c
                        write(kuout,3120)
                        do 375 itv = 1,ntval
                        itt        = itv
                        its        = ntvalq - itt + 1
                        arcv       = arc (itt)
                        tpv        = tp  (itt)
                        arccv      = arcclast - arcc(its)
                        tppv       = tpplast  - tpp (its)
                        arcdf      = arccv    - arcv
                        tpdf       = tppv     - tpv
                        write(kuout,3130) itt,arcv,arccv,arcdf,
     &                                        tpv, tppv, tpdf
  375                   continue
                        if    (ntvalp .gt. ntval) then
                           arcv       = arc (ntvalp)
                           tpv        = tp  (ntvalp)
                           write(kuout,3135) ntvalp,arcv, tpv
                        elseif(ntvalq .gt. ntval) then
                           arccv      = arcclast - arcc(   1  )
                           tppv       = tpplast  - tpp (   1  )
                           write(kuout,3140)        arccv,tppv
                        endif
c
                        if(kflag .ne. 0  .or.  kflagp .ne. 0) then
                           write(kuout,3150) kflag,  kflagp,
     &                                       karcflg,ktpflg,
     &                                       kxpflg, kzpflg,
     &                                       arcdfmx,tpdfmx,
     &                                       xpdfmx, zpdfmx
                           write(kuout,3155)
                           do 380 itv = 1,ntval
                           itt        = itv
                           its        = ntvalq - itt + 1
                           sv1v       = sv1 (itt)
                           sv2v       = sv2 (itt)
                           sv3v       = sv3 (its)
                           sv4v       = sv4 (its)
                           rpdf       = sv3v     - sv1v
                           zpdf       = sv4v     - sv2v
                           write(kuout,3160) itt,sv1v,sv3v, rpdf,
     &                                           sv2v,sv4v, zpdf
  380                      continue
                           if    (ntvalp .gt. ntval) then
                              sv1v       =            sv3 (ntvalp)
                              sv2v       =            sv4 (ntvalp)
                              write(kuout,3165) ntvalp,sv1v, sv2v
                           elseif(ntvalq .gt. ntval) then
                              sv3v       =            sv3 (   1  )
                              sv4v       =            sv4 (   1  )
                              write(kuout,3170)        sv3v, sv4v
                           endif
                        endif
                     else
                        call abortjob
     &        ('setarcl ', 39,   'Logic error: kwriter kwritez zero  '
     &        ,'kwriter ', kwriter,  'kwritez ', kwritez,  -1)
                     endif
                  endif
c
c 2.5.2.4.3 For cases where the arclength errors are small or the warning
c           maximum is exceeded
               elseif(kwritea .ne. +1) then
                  if     (kwriter .eq. +1  .or.   kwritez .eq. +1) then
                     write(kuout,3200) ntval0, ntval,   ntvalp, ntvalq,
     &                                 arclast,arcclast,tplast, tpplast
                     write(kuout,3205)
                     do 385 itv = 1,ntval0
                     itt        = itv
                     sv0v       = sv0 (itt)
                     sv5v       = sv5 (itt)
                     xpv        = xp  (itt)
                     zpv        = zp  (itt)
                     xsv        = seqrps(jsurf,itt)
                     zsv        = seqzps(jsurf,itt)
                     svdf       = sv5v    - sv0v
                     xpdf       = xsv     - xpv
                     zpdf       = zsv     - zpv           
                     write(kuout,3210) itt,sv0v,sv5v,svdf,xpv,xsv,xpdf,
     &                                                    zpv,zsv,zpdf
  385                continue
                     if(ntval .gt. ntval0) then
                        write(kuout,3215) ntval,
     &                                    sv0(ntval),sv5(ntval),
     &                                    xp (ntval),zp (ntval)
                     endif
c
                     write(kuout,3220)
                     do 390 itv = 1,ntval
                     itt        = itv
                     its        = ntvalq - itt + 1
                     arcv       = arc (itt)
                     tpv        = tp  (itt)
                     arccv      = arcclast - arcc(its)
                     tppv       = tpplast  - tpp (its)
                     arcdf      = arccv    - arcv
                     tpdf       = tppv     - tpv
                     write(kuout,3230) itt,arcv,arccv,arcdf,
     &                                     tpv, tppv, tpdf
  390                continue
                     if    (ntvalp .gt. ntval) then
                        arcv       = arc (ntvalp)
                        tpv        = tp  (ntvalp)
                        write(kuout,3235) ntvalp,arcv, tpv
                     elseif(ntvalq .gt. ntval) then
                        arccv      = arcclast - arcc(   1  )
                        tppv       = tpplast  - tpp (   1  )
                        write(kuout,3240)        arccv,tppv
                     endif
c
                     if(kflag .ne. 0  .or.  kflagp .ne. 0) then
                        write(kuout,3250) kflag,  kflagp,
     &                                    karcflg,ktpflg,
     &                                    kxpflg, kzpflg,
     &                                    arcdfmx,tpdfmx,
     &                                    xpdfmx, zpdfmx
                        write(kuout,3255)
                        do 395 itv = 1,ntval
                        itt        = itv
                        its        = ntvalq - itt + 1
                        sv1v       = sv1 (itt)
                        sv2v       = sv2 (itt)
                        sv3v       = sv3 (its)
                        sv4v       = sv4 (its)
                        rpdf       = sv3v     - sv1v
                        zpdf       = sv4v     - sv2v
                        write(kuout,3260) itt,sv1v,sv3v, rpdf,
     &                                        sv2v,sv4v, zpdf
  395                   continue
                        if    (ntvalp .gt. ntval) then
                           sv1v       =            sv3 (ntvalp)
                           sv2v       =            sv4 (ntvalp)
                           write(kuout,3265) ntvalp,sv1v, sv2v
                        elseif(ntvalq .gt. ntval) then
                           sv3v       =            sv3 (   1  )
                           sv4v       =            sv4 (   1  )
                           write(kuout,3270)        sv3v, sv4v
                        endif
                     endif
c
                  elseif (kwriter .ne. +1  .and.  kwritez .ne. +1) then
                     if    (kwritea .eq. 0  .and.  kwriter .lt. 0
     &                                      .and.  kwritez .lt. 0) then
                        call abortjob
     &        ('setarcl ', 40,   'Diagnostic max. exceeded: kwritea=0'
     &        ,'kwriter ', kwriter,  'kwritez ', kwritez,  -1)
                     elseif(kwritea .lt. 0  .and.  kwriter .lt. 0
     &                                      .and.  kwritez .lt. 0) then
                        call abortjob
     &        ('setarcl ', 41,   'Diagnostic max. exceeded: kwritea<0'
     &        ,'kwriter ', kwriter,  'kwritez ', kwritez,  -1)
                     else
                        call abortjob
     &        ('setarcl ', 42,   'Logic error:kwriter kwritez nonzero'
     &        ,'kwriter ', kwriter,  'kwritez ', kwritez,  -1)
                     endif
                  endif
               endif
            endif
         endif

c
c
c 2.6 Reset the grid points for the case where the differences are large
c     or either mapreset = 1 or kmap = -4
c
c 2.6.1 Decide which differences are too large
c
         if(kountap .eq. 0  .and.  kountrp .eq. 0  .and.
     &                             kountzp .eq. 0) kreset =  0
         if(kountap .eq. 0  .and.  kountrp .ne. 0  .and.
     &                             kountzp .eq. 0) kreset = -1
         if(kountap .eq. 0  .and.  kountrp .eq. 0  .and.
     &                             kountzp .ne. 0) kreset = -2
         if(kountap .ne. 0  .and.  kountrp .eq. 0  .and.
     &                             kountzp .eq. 0) kreset = +1
         if(kountap .ne. 0  .and.  kountrp .eq. 0  .and.
     &                             kountzp .ne. 0) kreset = +2
         if(kountap .ne. 0  .and.  kountrp .ne. 0  .and.
     &                             kountzp .eq. 0) kreset = +3
         if(kountap .ne. 0  .and.  kountrp .ne. 0  .and.
     &                             kountzp .ne. 0) kreset = +4
c
c 2.6.2 Print a warning if the differences are too large
c
         if(kmap .eq. -4  .or.  mapreset .eq. 1  .or.
     &                          kountap  .ne. 0 ) then
            if(kmap .ne. -4) then
               if(mapreset .eq. 0  .and.  kreset .ne. 0) call abortjob
     &        ('setarcl ', 43,   'Resetting poloidal mesh to equalarc'
     &        ,'jsurf   ', jsurf,    'kreset  ', kreset,   -1)
               if(mapreset .ne. 0  .and.  kreset .ne. 0) call abortjob
     &        ('setarcl ', 44,   'Resetting poloidal mesh to equalarc'
     &        ,'jsurf   ', jsurf,    'kreset  ', kreset,   -1)
            endif
c
c 2.6.3 Reset the points
c
            do 400 nt = 1,ntval
            it        = nt
            seqrps(jp,it) = xp(it)
            seqzps(jp,it) = zp(it)
  400       continue
         endif
  500 continue
c
c
c
c 3.0 Print appropriate warnings
c
c 3.1 Print a warning if the grid points were reset by request
c
      if(mapreset .ne. 0) call abortjob
     &        ('setarcl ', 45,   'Requested reset mesh to equalarc   '
     &        ,'jsurf   ', jsurf,    'mapreset', mapreset, -1)
c
c
c 3.2 Reset the dimension if needed
c
      if(ntval .ne. nthet) then
         call abortjob
     &        ('setarcl ', 46,   'Resetting poloidal mesh dimension  '
     &        ,'ntval   ', ntval,    'nthet   ', nthet,    -1)
         nthet   = ntval
      endif
c
c
c
c 4.0 Return and end
c
      return
 1000 format(10x,'arclast  = ',e12.5,4x,'arcclast = ',e12.5
     &       ,4x,'tplast   = ',e12.5,4x,'tpplast  = ',e12.5
     &       ,4x,'arcdfmx  = ',e12.5,4x,'tolsp0   = ',e12.5)
 1100 format(10x,'arclast  = ',e12.5,4x,'arcclast = ',e12.5
     &       ,4x,'tplast   = ',e12.5,4x,'tpplast  = ',e12.5
     &       ,4x,'tpdfmx   = ',e12.5,4x,'tolsp0   = ',e12.5)
 1200 format(10x,'arclast  = ',e12.5,4x,'arcclast = ',e12.5
     &       ,4x,'tplast   = ',e12.5,4x,'tpplast  = ',e12.5
     &       ,4x,'xpdfmx   = ',e12.5,4x,'tolsp0   = ',e12.5)
 1300 format(10x,'arclast  = ',e12.5,4x,'arcclast = ',e12.5
     &       ,4x,'tplast   = ',e12.5,4x,'tpplast  = ',e12.5
     &       ,4x,'zpdfmx   = ',e12.5,4x,'tolsp0   = ',e12.5)
 2000 format(10x,'itdifa   = ',i5,4x,   'difamax  = ',e12.5
     &       ,4x,'tolsp0   = ',e12.5,4x,'ascale   = ',e12.5)
 2010 format(10x,'kounta   = ',i5
     &    ,/,10x,'itdifa   = ',i5,4x,   'difamax  = ',e12.5
     &       ,4x,'tolsp0   = ',e12.5
     &    ,/,10x,'itdifap  = ',i5,4x,   'difamaxp = ',e12.5
     &       ,4x,'tolsp1   = ',e12.5,4x,'ascale   = ',e12.5)
 2100 format(10x,'itdifr   = ',i5,4x,   'difrmax  = ',e12.5
     &       ,4x,'tolsp0   = ',e12.5,4x,'rscale   = ',e12.5)
 2110 format(10x,'kountr   = ',i5
     &    ,/,10x,'itdifr   = ',i5,4x,   'difrmax  = ',e12.5
     &       ,4x,'tolsp0   = ',e12.5
     &    ,/,10x,'itdifrp  = ',i5,4x,   'difrmaxp = ',e12.5
     &       ,4x,'tolsp1   = ',e12.5,4x,'rscale   = ',e12.5)
 2200 format(10x,'itdifz   = ',i5,4x,   'difzmax  = ',e12.5
     &       ,4x,'tolsp0   = ',e12.5,4x,'zscale   = ',e12.5)
 2210 format(10x,'kountz   = ',i5
     &    ,/,10x,'itdifz   = ',i5,4x,   'difzmax  = ',e12.5
     &       ,4x,'tolsp0   = ',e12.5
     &    ,/,10x,'itdifzp  = ',i5,4x,   'difzmaxp = ',e12.5
     &       ,4x,'tolsp1   = ',e12.5,4x,'zscale   = ',e12.5)
 3000 format(   6x,'ntval0   = ',i5,  11x,'ntval    = ',i5
     &        ,11x,'ntvalp   = ',i5,  11x,'ntvalq   = ',i5
     &      ,/, 6x,'arclast  = ',e14.7,2x,'arcclast = ',e14.7
     &        , 2x,'tplast   = ',e14.7,2x,'tpplast  = ',e14.7)
 3005 format(/, 15x,'Original arclengths',45x,'New arclengths'  
     &       ,/, 4x,'itt', 6x,'sv0',12x,'arc',12x,'arcc',10x,'arcdf'
     &         ,16x,'sv5',13x,'tp',12x,'tpp',11x,'tpdf'
     &       ,/,6x,'(Ave (arc,arcc))',1x,'(Forward arc)'
     &         ,2x,'(Reverse arc)',   4x,'(arcc-arc)'
     &         ,7x,'(Ave (tp, tpp))', 2x,'(Forward tp)'
     &         ,1x,'(Reverse  tp)',   3x,'(tpp - tp)')
 3010 format(1x,i5,4(1x,e14.7),5x,4(1x,e14.7))
 3020 format(1x,i5,15x,(1x,e14.7),50x,(1x,e14.7))
 3030 format(5x,'1',30x,(1x,e14.7),50x,(1x,e14.7))
 3100 format(   6x,'ntval0   = ',i5,  11x,'ntval    = ',i5
     &        ,11x,'ntvalp   = ',i5,  11x,'ntvalq   = ',i5
     &      ,/, 6x,'arclast  = ',e14.7,2x,'arcclast = ',e14.7
     &        , 2x,'tplast   = ',e14.7,2x,'tpplast  = ',e14.7)
 3105 format(/,  4x,'itt', 6x,'sv0',   12x,'sv5',11x,'svdf'
     &                    ,8x,'seqrps',11x,'xp', 11x,'xpdf'
     &                    ,9x,'seqzps',11x,'zp', 11x,'zpdf'
     &       ,/,6x,'(Ave (arc,arcc)',1x,'(Ave (tp, tpp)'
     &         ,3x,'(sv5-sv0)'
     &         ,3x,'(Original xp)',4x,'(New xp)',5x,'(seqrps-xp)'
     &         ,2x,'(Original zp)',4x,'(New zp)',5x,'(seqzps-zp)')
 3110 format(1x,i5,2(1x,e14.7),(1x,e12.5),2(1x,e14.7),(1x,e12.5)
     &            ,2(1x,e14.7),(1x,e12.5))
 3115 format(1x,i5,2(1x,e14.7),28x,(1x,e14.7),28x,(1x,e14.7))
 3120 format(/,  4x,'itt', 6x,'arc',11x,'arcc',10x,'arcdf'
     &                   ,10x,'tp',13x,'tpp',10x,'tpdf'
     &       ,/,8x,'(Forward arc)',2x,'(Reverse arc)'
     &         ,2x,'(arcc-arc)'
     &         ,4x,'(Forward tp)', 3x,'(Reverse tp)'
     &         ,3x,'(tpp - tp)')
 3130 format(1x,i5,2(1x,e14.7),(1x,e12.5),2(1x,e14.7),(1x,e12.5))
 3135 format(1x,i5, (1x,e14.7),28x,(1x,e14.7))
 3140 format(5x,'1',15x,(1x,e14.7),28x,(1x,e15.7))
 3150 format(   6x,'kflag    = ',i5,  11x,'kflagp   = ',i5
     &        ,11x,'karcflg  = ',i5,  11x,'ktpflg   = ',i5
     &        ,11x,'kxpflg   = ',i5,  11x,'kzpflg   = ',i5
     &      ,/, 6x,'arcdfmx  = ',e14.7,2x,'tpdfmx   = ',e14.7
     &        , 2x,'xpdfmx   = ',e14.7,2x,'zpdfmx   = ',e14.7)
 3155 format(/,  4x,'itt', 6x,'sv1',12x,'sv3',11x,'rpdf'
     &                    ,9x,'sv2',12x,'sv4',11x,'zpdf'
     &       ,/,9x,'(Forward xp)', 3x,'(Reverse xp)'
     &         ,2x,'(sv3 - sv1)'
     &         ,3x,'(Forward zp)', 3x,'(Reverse zp)'
     &         ,2x,'(sv4 - sv2)')
 3160 format(1x,i5,2(1x,e14.7),(1x,e12.5),2(1x,e14.7),(1x,e12.5))
 3165 format(1x,i5, (1x,e14.7),28x,(1x,e14.7))
 3170 format(5x,'1',15x,(1x,e14.7),28x,(1x,e15.7))
 3200 format(   6x,'ntval0   = ',i5,  11x,'ntval    = ',i5
     &        ,11x,'ntvalp   = ',i5,  11x,'ntvalq   = ',i5
     &      ,/, 6x,'arclast  = ',e14.7,2x,'arcclast = ',e14.7
     &        , 2x,'tplast   = ',e14.7,2x,'tpplast  = ',e14.7)

 3205 format(/,  4x,'itt', 6x,'sv0',   12x,'sv5'11x,'svdf'
     &                    ,8x,'seqrps',11x,'xp',11x,'xpdf'
     &                    ,9x,'seqzps',11x,'zp',11x,'zpdf'
     &       ,/,6x,'(Ave (arc,arcc)',1x,'(Ave (tp, tpp)'
     &         ,3x,'(sv5-sv0)'
     &         ,3x,'(Original xp)',4x,'(New xp)',5x,'(seqrps-xp)'
     &         ,2x,'(Original zp)',4x,'(New zp)',5x,'(seqzps-zp)')
 3210 format(1x,i5,2(1x,e14.7),(1x,e12.5),2(1x,e14.7),(1x,e12.5)
     &            ,2(1x,e14.7),(1x,e12.5))
 3215 format(1x,i5,2(1x,e14.7),28x,(1x,e14.7),28x,(1x,e14.7))
 3220 format(/,  4x,'itt', 6x,'arc',11x,'arcc',10x,'arcdf'
     &                   ,10x,'tp',13x,'tpp',10x,'tpdf'
     &       ,/,8x,'(Forward arc)',2x,'(Reverse arc)'
     &         ,2x,'(arcc-arc)'
     &         ,4x,'(Forward tp)', 3x,'(Reverse tp)'
     &         ,3x,'(tpp - tp)')
 3230 format(1x,i5,2(1x,e14.7),(1x,e12.5),2(1x,e14.7),(1x,e12.5))
 3235 format(1x,i5, (1x,e14.7),28x,(1x,e14.7))
 3240 format(5x,'1',15x,(1x,e14.7),28x,(1x,e15.7))
 3250 format(   6x,'kflag    = ',i5,  11x,'kflagp   = ',i5
     &        ,11x,'karcflg  = ',i5,  11x,'ktpflg   = ',i5
     &        ,11x,'kxpflg   = ',i5,  11x,'kzpflg   = ',i5
     &      ,/, 6x,'arcdfmx  = ',e14.7,2x,'tpdfmx   = ',e14.7
     &        , 2x,'xpdfmx   = ',e14.7,2x,'zpdfmx   = ',e14.7)
 3255 format(/,  4x,'itt', 6x,'sv1',12x,'sv3',11x,'rpdf'
     &                    ,9x,'sv2',12x,'sv4',11x,'zpdf'
     &       ,/,9x,'(Forward xp)', 3x,'(Reverse xp)'
     &         ,2x,'(sv3 - sv1)'
     &         ,3x,'(Forward zp)', 3x,'(Reverse zp)'
     &         ,2x,'(sv4 - sv2)')
 3260 format(1x,i5,2(1x,e14.7),(1x,e12.5),2(1x,e14.7),(1x,e12.5))
 3265 format(1x,i5, (1x,e14.7),28x,(1x,e14.7))
 3270 format(5x,'1',15x,(1x,e14.7),28x,(1x,e15.7))
      end
      subroutine rdfastp
c
c -------------------------------------------------------------
c  Read fast particle file
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nft=5)
      parameter (nbd=1600,nbl=1200)
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c
c
c 2.0 Set the fast particle pressure zero if no profile is available
c
      if(ifastp .le. 0) then
        nfast1    = nprofl
        do 100 kk = 1,nfast1
        spsif(kk) = psimsh(kk)
        sfast(kk) = 0.0
  100   continue
c
        nfast     = nfast1
      endif
c
c
c
c 3.0 Read the fast particle pressure
c
      if(ifastp .gt. 0) then
c
c
c 3.1 Read the number of points
c
        read(kufst,1000) nfast1
c
c
c 3.2 Set the profile to default if the number of points is not positive
c
        nfast     = nfast1
        if    (nfast .le. 0) then
          call abortjob
     &        ('rdfastp ',  1,   'Input nfast is not well defined     '
     &        ,'ifastp  ', ifastp,   'nfast   ', nfast,    -1)
c
          nfast1    = nprofl
          do 200 kk = 1,nfast1
          spsif(kk) = psimsh(kk)
          sfast(kk) = 0.0
  200     continue
c
c
c 3.3 Set the profile if the number of points is too large
c
        elseif(nfast .gt. npb) then
          call abortjob
     &        ('rdfastp ',  2,   'Input nfast is too large            '
     &        ,'ifastp  ', ifastp,   'nfast   ', nfast,    -1)
          nfast1    = npb
          if    (ifastp .ge.  +1  .and.  ifastp .le.  +8) then
            read(kufst,1010) (spsif(kk),kk=1,nfast1)
            read(kufst,1010) (sfast(kk),kk=1,nfast1)
          elseif(ifastp .ge.  +9  .and.  ifastp .le. +16) then
            do 220 kk = 1,nfast1
            read(kufst,1020) spsif(kk),sfast(kk)
  220       continue
          endif
c
c
c 3.4 Read the profile if the number of points is just right
c
        elseif(nfast .gt. 0  .and.  nfast .le. npb) then
          if    (ifastp .ge.  +1  .and.  ifastp .le.  +8) then
            read(kufst,1010) (spsif(kk),kk=1,nfast1)
            read(kufst,1010) (sfast(kk),kk=1,nfast1)
          elseif(ifastp .ge.  +9  .and.  ifastp .le. +16) then
            do 240 kk = 1,nfast1
            read(kufst,1020) spsif(kk),sfast(kk)
  240       continue
          endif
        endif
c
c
c 3.5 Reset nfast
c
        nfast   = nfast1
      endif
c
c
c
c 4.0 Rescale the flux mesh to psi
c
      if(ifastp .eq.  +5  .or.  ifastp .eq.  +6 .or.
     &   ifastp .eq.  +7  .or.  ifastp .eq.  +8 .or.
     &   ifastp .eq. +13  .or.  ifastp .eq. +14 .or.
     &   ifastp .eq. +15  .or.  ifastp .eq. +16) then
        delpsiv   = psilim - psimax
        do 300 kk = 1,nfast
        psiv      = psimax + delpsiv*spsif(kk)
        spsif(kk) = psiv
  300   continue
      endif
c
c
c
c 5.0 Check the fast profile mesh is well defined
c
c 5.1 Define the extreme values
c
      spsimn   = spsif(  1  )
      spsimx   = spsif(nfast)
      psaxis   = psimax
      psedge   = psilim
c
      dpfmin   = spsimn - psaxis
      dpfmax   = psedge - spsimx
      tolpsi   = tolspln*abs(psedge - psaxis)
c
c
c 5.2 Check spsif(1) is close to psaxis
c
      if(abs(dpfmin) .ge. tolpsi) then
        if(dpfmin .lt. 0.0) call abortjob
     &        ('rdfastp ',  3,   'spsif(1) is less than psaxis        '
     &        ,'ifastp  ', ifastp,   'nfast   ', nfast,    -1)
        if(dpfmin .gt. 0.0) call abortjob
     &        ('rdfastp ',  4,   'spsif(1) greater than psaxis        '
     &        ,'ifastp  ', ifastp,   'nfast   ', nfast,    -1)
        write(kuout,2000) spsimn,psaxis,dpfmin,tolpsi
      endif
c
c
c 5.3 Check spsif(nfast) is close to psedge
c
      if(abs(dpfmax) .ge. tolpsi) then
        if(dpfmax .lt. 0.0) call abortjob
     &        ('rdfastp ',  5,   'spsif(nfast) greater than psedge    '
     &        ,'ifastp  ', ifastp,   'nfast   ', nfast,    -1)
        if(dpfmax .gt. 0.0) call abortjob
     &        ('rdfastp ',  6,   'spsif(nfast) less  than psedge      '
     &        ,'ifastp  ', ifastp,   'nfast   ', nfast,    -1)
        write(kuout,2010) spsimx,psedge,dpfmax,tolpsi
      endif
c
c
c 5.4 Reset spsif(  1  ) and spsif(nfast)
c
      if(dpfmin .gt. 0.0) spsif(  1  ) = psaxis
      if(dpfmax .gt. 0.0) spsif(nfast) = psedge
c
c
c
c 6.0 Return and end
c
      return
 1000 format(2x,i6)
 1010 format(5(1x,e15.4))
 1020 format(1x,f9.4,1x,1pe14.8)
 2000 format(4x,'spsif(  1  ) = ',e14.7,2x,'psaxis       = ',e14.7
     &      ,2x,'dpfmin       = ',e14.7,2x,'tolpsi       = ',e14.7)
 2010 format(4x,'spsif(nfast) = ',e14.7,2x,'psedge       = ',e14.7
     &      ,2x,'dpfmax       = ',e14.7,2x,'tolpsi       = ',e14.7)
      end
      subroutine setauxp
c
c -------------------------------------------------------------
c  Set the auxiliary equilibrium parameters
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Dimensions
c
      nvnd       = nvn
      npd1       = np1
      npd2       = np2
      ncd1       = nc1
      npqd       = npq
c
c
c 1.2 Define jpsi1, jpsi2, and ithtp
c
      jpsi1      = jpsi+1
      jpsi2      = jpsi+2
      ithtp      = itht+1
c
c
c 1.3 Set the arclength mesh size
c
      ntmax      = min0(narcmx,nlx)
c
c
c
c 2.0 Initialize psi range
c
c 2.1 Reset psisep = psimax to force non Doublet
c
      if(ndoublt .eq. 0) psisep    = psimax
c
c
c 2.2 Save psimax and psilim from setting the mesh and initialize delpsir
c
      psimax0    = psimax
      psilim0    = psilim
      delpsir0   = psilim0 - psimax0
      if(delpsir0 .eq. 0.0) call abortjob
     &        ('setauxp ',  1,   'delpsir is zero: psilim = psimax    '
     &        ,'jpsi    ', jpsi,     'itht    ', itht,     +1)
c
      if(delpsir0 .lt. 0.0) call abortjob
     &        ('setauxp ',  2,   'delpsir is negative: psilim < psimax'
     &        ,'jpsi    ', jpsi,     'itht    ', itht,     -2)
c
c
c 2.3 Initialize delpsir = delpsir0
c
      delpsir    = delpsir0
c
c
c
c 3.0 Initialize arrays
c
c 3.1 Surface integrals
c
      do 100 kj       = 1,nvnd
      svint(kj)       =  0.0
  100 continue
c
c
c 3.2 Profile arrays
c
      do 120 jv       = 1,npd1
      psival (jv)     =  0.0
      psinitl(jv)     =  0.0
      psivl0 (jv)     =  0.0
      qp     (jv)     =  0.0
c
      qpinitl(jv)     =  0.0
      fqpi   (jv)     =  0.0
      fqim   (jv)     =  0.0
      qdel   (jv)     =  0.0
      qprime (jv)     =  0.0
      qpint  (jv)     =  0.0
      fqint  (jv)     =  0.0
c
      rst    (jv)     =  0.0
      zst    (jv)     =  0.0
      rstp   (jv)     =  0.0
      zstp   (jv)     =  0.0
      rsinitl(jv)     =  0.0
      zsinitl(jv)     =  0.0
c
      sint0  (jv)     =  0.0
      sint1  (jv)     =  0.0
      sint2  (jv)     =  0.0
      sint3  (jv)     =  0.0
      sint4  (jv)     =  0.0
      savge  (jv)     =  0.0
      tavge  (jv)     =  0.0
c
      psivl1 (jv)     =  0.0
      qp1    (jv)     =  0.0
      fqpi1  (jv)     =  0.0
      qprim1 (jv)     =  0.0
      sintp0 (jv)     =  0.0
      psivmsh(jv)     =  0.0
c
      psivalu(jv)     =  0.0
      psinorm(jv)     =  0.0
      psisqrt(jv)     =  0.0
      psirho2(jv)     =  0.0
      psirhov(jv)     =  0.0
      psinrho(jv)     =  0.0
      psitorf(jv)     =  0.0
      psintor(jv)     =  0.0
      psisqtf(jv)     =  0.0
      psivolm(jv)     =  0.0
      psinvol(jv)     =  0.0
      psisqvl(jv)     =  0.0
      dpsirh2(jv)     =  0.0
      dpsirho(jv)     =  0.0
      dpsinrh(jv)     =  0.0
      dpsitor(jv)     =  0.0
      dpsintf(jv)     =  0.0
      dpsisqt(jv)     =  0.0
      dpsivol(jv)     =  0.0
      dpsinvl(jv)     =  0.0
      dpsisqv(jv)     =  0.0
  120 continue
c
      psivl0 (npd2)   =  0.0
      rst    (npd2)   =  0.0
      zst    (npd2)   =  0.0
      rstp   (npd2)   =  0.0
      zstp   (npd2)   =  0.0
      rsinitl(npd2)   =  0.0
      zsinitl(npd2)   =  0.0
c
      psivl1 (npd2)   =  0.0
      qp1    (npd2)   =  0.0
      fqpi1  (npd2)   =  0.0
      qprim1 (npd2)   =  0.0
      sintp0 (npd2)   =  0.0
      psivmsh(npd2)   =  0.0
c
      psivalu(npd2)   =  0.0
      psinorm(npd2)   =  0.0
      psisqrt(npd2)   =  0.0
      psirho2(npd2)   =  0.0
      psirhov(npd2)   =  0.0
      psinrho(npd2)   =  0.0
      psitorf(npd2)   =  0.0
      psintor(npd2)   =  0.0
      psisqtf(npd2)   =  0.0
      psivolm(npd2)   =  0.0
      psinvol(npd2)   =  0.0
      psisqvl(npd2)   =  0.0
      dpsirh2(npd2)   =  0.0
      dpsirho(npd2)   =  0.0
      dpsinrh(npd2)   =  0.0
      dpsitor(npd2)   =  0.0
      dpsintf(npd2)   =  0.0
      dpsisqt(npd2)   =  0.0
      dpsivol(npd2)   =  0.0
      dpsinvl(npd2)   =  0.0
      dpsisqv(npd2)   =  0.0
c
c
c 3.3 Angle quantities
c
      do 150 iv       = 1,ncd1
      arcsurf(iv)     =  0.0
      pestchi(iv)     =  0.0
      hamlchi(iv)     =  0.0
      alfarc (iv)     =  0.0
      alfpst (iv)     =  0.0
      alfham (iv)     =  0.0
      chic   (iv)     =  0.0
      chie   (iv)     =  0.0
      rsrf   (iv)     =  0.0
      zsrf   (iv)     =  0.0
      dydx   (iv)     =  0.0
      xjsc   (iv)     =  0.0
  150 continue
c
c
c 3.4 Surface coordinate positions
c
      do 220 iv       = 1,ncd1
      do 200 jv       = 1,npd1
      rs     (iv,jv)  =  0.0
      zs     (iv,jv)  =  0.0
  200 continue
  220 continue
c
c
c 3.5 Surface coordinate quantities
c
      do 260 jv       = 1,npd1
      arcnorm(jv)     =  0.0
      pstnorm(jv)     =  0.0
      hamnorm(jv)     =  0.0
      dlnlval(jv)     =  0.0
      dpnlval(jv)     =  0.0
      dhnlval(jv)     =  0.0
      do 250 iv       = 1,ncd1
      rcell  (jv,iv)  =  0.0
      zcell  (jv,iv)  =  0.0
      dpsdr  (jv,iv)  =  0.0
      dpsdz  (jv,iv)  =  0.0
      chiarcl(jv,iv)  =  0.0
      chipest(jv,iv)  =  0.0
      chihaml(jv,iv)  =  0.0
      xjcarcl(jv,iv)  =  0.0
      xjcpest(jv,iv)  =  0.0
      xjchaml(jv,iv)  =  0.0
      alfarcl(jv,iv)  =  0.0
      alfpest(jv,iv)  =  0.0
      alfhaml(jv,iv)  =  0.0
  250 continue
  260 continue
c
c
c 3.6 Equilibrium quantities
c
      do 320 jv       = 1,npd1
      do 300 iv       = 1,ncd1
      f3 (jv,iv)      =  0.0
      f4 (jv,iv)      =  0.0
      f5 (jv,iv)      =  0.0
      f7 (jv,iv)      =  0.0
      f8 (jv,iv)      =  0.0
      f9 (jv,iv)      =  0.0
      f10(jv,iv)      =  0.0
      f11(jv,iv)      =  0.0
      f12(jv,iv)      =  0.0
      f13(jv,iv)      =  0.0
      f14(jv,iv)      =  0.0
      f15(jv,iv)      =  0.0
      f16(jv,iv)      =  0.0
      f17(jv,iv)      =  0.0
      f18(jv,iv)      =  0.0
      f19(jv,iv)      =  0.0
      f20(jv,iv)      =  0.0
      f21(jv,iv)      =  0.0
      f22(jv,iv)      =  0.0
      f23(jv,iv)      =  0.0
      f24(jv,iv)      =  0.0
      f25(jv,iv)      =  0.0
      f26(jv,iv)      =  0.0
      f27(jv,iv)      =  0.0
      f28(jv,iv)      =  0.0
  300 continue
  320 continue
c
c
c 3.7 Rational surface quantites
c
      do 400 lq       = 1,npqd
      lpsiq   (lq)    =  0
c
      psivlq  (lq)    =  0.0
      qprimq  (lq)    =  0.0
      qvalue  (lq)    =  0.0
      psimshq (lq)    =  0.0
c
      psivalq (lq)    =  0.0
      psinrmq (lq)    =  0.0
      psisqrq (lq)    =  0.0
      psirh2q (lq)    =  0.0
      psirhoq (lq)    =  0.0
      psinrhq (lq)    =  0.0
      psitorq (lq)    =  0.0
      psintfq (lq)    =  0.0
      psisqtq (lq)    =  0.0
      psivolq (lq)    =  0.0
      psinvlq (lq)    =  0.0
      psisqvq (lq)    =  0.0
c
      dpsir2q (lq)    =  0.0
      dpsirhq (lq)    =  0.0
      dpsinrq (lq)    =  0.0
      dpsitfq (lq)    =  0.0
      dpsintq (lq)    =  0.0
      dpsistq (lq)    =  0.0
      dpsivlq (lq)    =  0.0
      dpsinvq (lq)    =  0.0
      dpsisvq (lq)    =  0.0
c
      shearps (lq)    =  0.0
      shearrh (lq)    =  0.0
      sheartf (lq)    =  0.0
      shearvl (lq)    =  0.0
c
      epslrh1 (lq)    =  0.0
      shearrh1(lq)    =  0.0
      shearfrh(lq)    =  0.0
      epslvl1 (lq)    =  0.0
      shearvl1(lq)    =  0.0
      shearfvl(lq)    =  0.0
  400 continue
c
c
c 4.0 Return and end
c
      return
      end
      subroutine chkprof
c
c -------------------------------------------------------------
c  Check the input profiles are consistent
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)

c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
      kmap       = nmap
      smallno    = abs(roundff)
      roundf     = tolspln
c
      if(npst .ne. 0) then
         call abortjob
     &        ('chkprof ',  1,   'No input profile check: npst .ne. 0 '
     &        ,'npst    ', npst,     'kmap    ', kmap,      0)
         return
      endif
c
c
c
c 2.0 Compute the spline arrays
c
      nxtrap     = nspbc0
c
c 2.1 Set up the extrapolation coefficients
c
      nprofl1    = nprofl - 1
      nprofl2    = nprofl - 2
      delx21     = psimsh(   2   ) - psimsh(   1   )
      delx32     = psimsh(   3   ) - psimsh(   2   )
      delx31     = psimsh(   3   ) - psimsh(   1   )
      delxn1     = psimsh(nprofl)  - psimsh(nprofl1)
      delxnx     = psimsh(nprofl1) - psimsh(nprofl2)
      delxn2     = psimsh(nprofl)  - psimsh(nprofl2)
      dr3132     = delx31/delx32
      dr2132     = delx21/delx32
      drn2nx     = delxn2/delxnx
      drn1nx     = delxn1/delxnx
      if    (nxtrap .le. 0) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      elseif(nxtrap .eq. 1) then
        xtrap1     = 1.0
        xtrap1p    = 0.0
        xtrapn     = 1.0
        xtrapnp    = 0.0
      elseif(nxtrap .eq. 2) then
        xtrap1     = +dr3132
        xtrap1p    = -dr2132
        xtrapn     = +drn2nx
        xtrapnp    = -drn1nx
      elseif(nxtrap .gt. 2) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      endif
c
c
c 2.2 Set up the spline coefficients for the spline boundary conditions
c
c 2.2.1 Toroidal field function sf
c
c 2.2.1.1 Set the second derivatives at the endpoints
      sf2pp      = f2sx(   2   ,sf,  psimsh,nprofl)
      sf3pp      = f2sx(   3   ,sf,  psimsh,nprofl)
      sfn1pp     = f2sx(nprofl1,sf,  psimsh,nprofl)
      sfn2pp     = f2sx(nprofl2,sf,  psimsh,nprofl)
c
      sfbc11     = xtrap1*sf2pp  + xtrap1p*sf3pp
      sfbcnn     = xtrapn*sfn1pp + xtrapnp*sfn2pp
c
c 2.2.1.2 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nxtrap .ge.  0  .and.  nxtrap .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfbcnn
c
c 2.2.1.3 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
      elseif(nxtrap .gt. +2) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfn1pp
c
c 2.2.1.4 Use a floating condition at both ends
      elseif(nxtrap .lt.  0) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 2.2.1.5 Compute the spline coefficients
      call icsici(psimsh,sf,   nprofl,bcb,csf,  npp,ierf)
      if(ierf .ne. 0) call abortjob
     &        ('chkprof ',  2,   'Interpolation error: sf(psimsh)     '
     &        ,'ierf    ', ierf,     'nprofl  ', nprofl,   +1)
c
c 2.2.2 Pressure sp
c
c 2.2.2.1 Set the second derivatives at the endpoints
      sp2pp      = f2sx(   2   ,sp,  psimsh,nprofl)
      sp3pp      = f2sx(   3   ,sp,  psimsh,nprofl)
      spn1pp     = f2sx(nprofl1,sp,  psimsh,nprofl)
      spn2pp     = f2sx(nprofl2,sp,  psimsh,nprofl)
c
      spbc11     = xtrap1*sp2pp  + xtrap1p*sp3pp
      spbcnn     = xtrapn*spn1pp + xtrapnp*spn2pp
c
c 2.2.2.2 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nxtrap .ge.  0  .and.  nxtrap .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*spbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*spbcnn
c
c 2.2.2.3 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
      elseif(nxtrap .gt. +2) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spn1pp
c
c 2.2.2.4 Use a floating condition at both ends
      elseif(nxtrap .lt.  0) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 2.2.2.5 Compute the spline coefficients
      call icsici(psimsh,sp,   nprofl,bcb,csp,  npp,ierp)
      if(ierp  .ne. 0) call abortjob
     &        ('chkprof ',  3,   'Interpolation error: sp(psimsh)     '
     &        ,'ierp    ', ierp,     'nprofl  ', nprofl,   +1)
c
c 2.2.3 Derivative of toroidal field function sffp
c
c 2.2.3.1 Set the second derivatives at the endpoints
      sfp2pp     = f2sx(   2   ,sffp,psimsh,nprofl)
      sfp3pp     = f2sx(   3   ,sffp,psimsh,nprofl)
      sfpn1pp    = f2sx(nprofl1,sffp,psimsh,nprofl)
      sfpn2pp    = f2sx(nprofl2,sffp,psimsh,nprofl)
c
      sfpbc11    = xtrap1*sfp2pp  + xtrap1p*sfp3pp
      sfpbcnn    = xtrapn*sfpn1pp + xtrapnp*sfpn2pp
c
c 2.2.3.2 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nxtrap .ge.  0  .and.  nxtrap .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfpbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfpbcnn
c
c 2.2.3.3 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
      elseif(nxtrap .gt. +2) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*sfp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfpn1pp
c
c 2.2.3.4 Use a floating condition at both ends
      elseif(nxtrap .lt.  0) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*sfp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 2.2.3.5 Compute the spline coefficients
      call icsici(psimsh,sffp,nprofl,bcb,csffp,npp,ierfp)
      if(ierfp .ne. 0) call abortjob
     &        ('chkprof ',  4,   'Interpolation error:sffp(psimsh)    '
     &        ,'ierfp   ', ierfp,    'nprofl  ', nprofl,   +1)
c
c 2.2.4 Derivative of pressure spp
c
c 2.2.4.1 Set the second derivatives at the endpoints
      spp2pp     = f2sx(   2   ,spp, psimsh,nprofl)
      spp3pp     = f2sx(   3   ,spp, psimsh,nprofl)
      sppn1pp    = f2sx(nprofl1,spp, psimsh,nprofl)
      sppn2pp    = f2sx(nprofl2,spp, psimsh,nprofl)
c
      sppbc11    = xtrap1*spp2pp  + xtrap1p*spp3pp
      sppbcnn    = xtrapn*sppn1pp + xtrapnp*sppn2pp
c
c 2.2.4.2 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nxtrap .ge.  0  .and.  nxtrap .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sppbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sppbcnn
c
c 2.2.4.3 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
      elseif(nxtrap .gt. +2) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*spp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sppn1pp
c
c 2.2.4.4 Use a floating condition at both ends
      elseif(nxtrap .lt.  0) then
        bigval     = abs(float(nxtrap))
        bcb(1)     = bigval
        bcb(2)     = bigval*spp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 2.2.4.5 Compute the spline coefficients
      call icsici(psimsh,spp,  nprofl,bcb,cspp, npp,ierpp)
      if(ierpp .ne. 0) call abortjob
     &        ('chkprof ',  5,   'Interpolation error: spp(psimsh)    '
     &        ,'ierpp   ', ierpp,    'nprofl  ', nprofl,   +1)
c
c
c
c 3.0 Check consistency of the input profiles
c
c 3.1 Find the maxima of sffp and spp for normalization
c
      ffmaxv     = 0.0
      ppmaxv     = 0.0
      do 50 j    = 1,nprofl
      jvl        = j
      ffvl       = sffp(jvl)
      ppvl       = spp (jvl)
      if(abs(ffvl) .gt. abs(ffmaxv)) ffmaxv  = ffvl
      if(abs(ppvl) .gt. abs(ppmaxv)) ppmaxv  = ppvl
 50   continue
c
c
c 3.2 Initialize the difference parameters
c
      kfdiff     = 0
      jfdiff     = 0
      ffdmax     = 0.0
      ff0max     = 0.0
      ff1max     = 0.0
      kpdiff     = 0
      jpdiff     = 0
      ppdmax     = 0.0
      pp0max     = 0.0
      pp1max     = 0.0
c
c
c 3.3 Calculate the largest differences normalized to the largest value
c
      do 100 j   = 1,nprofl
      jvl        = j
      ps         = psimsh(jvl)
c
      ffvl0      = sffp(jvl)
      ffvla      = sterpl(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                            smallno,ierfa)
      ffvlb      = sterpp(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                            smallno,ierfb)
      ffvl1      = ffvla*ffvlb
c
      if(ierfa .ne. 0) call abortjob
     &        ('chkprof ',  6,   'Spline interpolation error for sf   '
     &        ,'ierfa   ', ierfa,    'jvl     ', jvl,      -1)
      if(ierfb .ne. 0) call abortjob
     &        ('chkprof ',  7,   'Spline differentiation error for sf '
     &        ,'ierfb   ', ierfb,    'jvl     ', jvl,      -1)
      ffdiff     =          ffvl1  -     ffvl0
c
      ppvl0      = spp(jvl)
      ppvl1      = sterpp(ps,psimsh,sp,  csp,  nprofl,npp,0,
     &                            smallno,ierp1)
c
      if(ierp1 .ne. 0) call abortjob
     &        ('chkprof ',  8,   'Spline differentiation error for sp '
     &        ,'ierp1   ', ierp1,    'jvl     ', jvl,      -1)
      ppdiff     =         ppvl1      - ppvl0
c
      if(abs(ffdiff) .ge. roundf*abs(ffmaxv)) then
         kfdiff     = kfdiff + 1
         if(abs(ffdiff) .ge. abs(ffdmax)) then
            jfdiff     = jvl
            ffdmax     = ffdiff
            ff0max     = ffvl0
            ff1max     = ffvl1
         endif
      endif
c
      if(abs(ppdiff) .ge. roundf*abs(ppmaxv)) then
         kpdiff     = kpdiff + 1
         if(abs(ppdiff) .ge. abs(ppdmax)) then
            jpdiff     = jvl
            ppdmax     = ppdiff
            pp0max     = ppvl0
            pp1max     = ppvl1
         endif
      endif
  100 continue
c
c
c
c 4.0 Print warnings as needed
c
c 4.1 Print a warning
c
      if(kfdiff .ne. 0) then
         if    (kfdiff .eq. 1) then
            call abortjob
     &        ('chkprof ',  9,   'Inconsistency between sffp and sf   '
     &        ,'kfdiff  ', kfdiff,   'jfdiff  ', jfdiff,   -1)
            write(kuout,1000) roundf, jfdiff,sffp(jfdiff)
     &                       ,ff0max, ff1max,ffdmax,ffmaxv
         elseif(kfdiff .gt. 1) then
            call abortjob
     &        ('chkprof ', 10,   'Multiple inconsistencies:sffp and sf'
     &        ,'kfdiff  ', kfdiff,   'jfdiff  ', jfdiff,   -1)
            write(kuout,1010) roundf, jfdiff,sffp(jfdiff)
     &                       ,ff0max, ff1max,ffdmax,ffmaxv
         endif
      endif
c
      if(kpdiff .ne. 0) then
        if    (kpdiff .eq. 1) then
          call abortjob
     &        ('chkprof ', 11,   'Inconsistency between sp p and sp   '
     &        ,'kfdiff  ', kfdiff,   'jfdiff  ', jfdiff,   -1)
          write(kuout,1100) roundf, jpdiff,spp (jpdiff)
     &                     ,pp0max, pp1max,ppdmax,ppmaxv
        elseif(kpdiff .gt. 1) then
          call abortjob
     &        ('chkprof ', 12,   'Multiple inconsistencies: spp and sp'
     &        ,'kpdiff  ', kpdiff,   'jpdiff  ', jpdiff,   -1)
          write(kuout,1110) roundf, jpdiff,spp (jpdiff)
     &                     ,pp0max, pp1max,ppdmax,ppmaxv
        endif
      endif
c
c
c 4.2 Print the differences if there are multiple discrepancies
c
      if(kfdiff .gt. 1  .or.  kpdiff .gt. 1) then
c
c 4.2.1 Print the spline boundary condition data
c
        write(kuout,2000) nxtrap,xtrap1,xtrap1p,xtrapn,xtrapnp
        write(kuout,2010) delx21,delx32,delx31,delxn1,delxnx,delxn2
        write(kuout,2020) dr3132,dr2132,drn2nx,drn1nx
        write(kuout,2030) sf2pp, sf3pp, sfn1pp, sfn2pp, sfbc11, sfbcnn
        write(kuout,2040) sp2pp, sp3pp, spn1pp, spn2pp, spbc11, spbcnn
        write(kuout,2050) sfp2pp,sfp3pp,sfpn1pp,sfpn2pp,sfpbc11,sfpbcnn
        write(kuout,2060) spp2pp,spp3pp,sppn1pp,sppn2pp,sppbc11,sppbcnn
c
c 4.2.2 Print the heading for the table of differences
c
        write(kuout,2100)
        write(kuout,2110)
c
c 4.2.3 Repeat the calculation and print the differences
c       Differences are normalized to the local values
c
        ierf1s     = 0
        ierfas     = 0
        ierfbs     = 0
        ierp1s     = 0
        ierp2s     = 0
        do 200 j   = 1,nprofl
        jvl        = j
        ps         = psimsh(jvl)
c
        ffvl0      = sffp(jvl)
        ffvl1      = sterpl(ps,psimsh,sffp,csffp,nprofl,npp,0,
     &                                smallno,ierf1)
        ffvla      = sterpl(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                                smallno,ierfa)
        ffvlb      = sterpp(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                                smallno,ierfb)
        ffvl2      = ffvla*ffvlb
        if(ierf1 .ne. 0) ierf1s  = ierf1
        if(ierfa .ne. 0) ierfas  = ierfa
        if(ierfb .ne. 0) ierfbs  = ierfb
        ffdiff     =          ffvl2  -     ffvl0
        ffsumm     = 0.5*(abs(ffvl2) + abs(ffvl0))
c
        ppvl0      = spp(jvl)
        ppvl1      = sterpl(ps,psimsh,spp, cspp, nprofl,npp,0,
     &                                smallno,ierp1)
        ppvl2      = sterpp(ps,psimsh,sp,  csp,  nprofl,npp,0,
     &                                smallno,ierp2)
        if(ierp1 .ne. 0) ierp1s  = ierp1
        if(ierp2 .ne. 0) ierp2s  = ierp2
        ppdiff     =          ppvl2  -     ppvl0
        ppsumm     = 0.5*(abs(ppvl2) + abs(ppvl0))
c
        ffdiffx    = ffdiff/(0.5*(abs(ffvl2) + abs(ffvl0)))
        ppdiffx    = ppdiff/(0.5*(abs(ppvl2) + abs(ppvl0)))
        write(kuout,2120) jvl,ffvl0,ffvl1,ffvl2,ffvla,ffvlb,ffdiffx
     &                       ,ppvl0,ppvl1,ppvl2,ppdiffx
  200   continue
        if(ierf1s .ne. 0) call abortjob
     &        ('chkprof ', 13,   'Spline interpolation error for sffp '
     &        ,'ierf1s  ', ierf1s,   'nxtrap  ', nxtrap,    0)
        if(ierfas .ne. 0) call abortjob
     &        ('chkprof ', 14,   'Spline interpolation error for sf   '
     &        ,'ierfas  ', ierfas,   'nxtrap  ', nxtrap,    0)
        if(ierfbs .ne. 0) call abortjob
     &        ('chkprof ', 15,   'Spline differentiation error for sf '
     &        ,'ierfbs  ', ierfbs,   'nxtrap  ', nxtrap,    0)
        if(ierp1s .ne. 0) call abortjob
     &        ('chkprof ', 16,   'Spline interpolation error for spp  '
     &        ,'ierp1s  ', ierp1s,   'nxtrap  ', nxtrap,    0)
        if(ierp2s .ne. 0) call abortjob
     &        ('chkprof ', 17,   'Spline differentiation error for sp '
     &        ,'ierp2s  ', ierp2s,   'nxtrap  ', nxtrap,    0)
      endif 
c
c
c
c 5.0 Return and end
c
      return
 1000 format(6x,'Discrepancy: roundf  = ',e12.5
     &    ,/,6x,'sffp(',i5,') = ',e16.9,2x,'ff0max  = ',e16.9
     &      ,2x,'ff1max  = ',e16.9,2x,'ffdmax  = ',e12.5
     &      ,2x,'ffmaxv  = ',e12.5)
 1010 format(6x,'Maximum discrepancy: roundf  = ',e12.5
     &    ,/,6x,'sffp(',i5,') = ',e16.9,2x,'ff0max  = ',e16.9
     &      ,2x,'ff1max  = ',e16.9,2x,'ffdmax  = ',e12.5
     &      ,2x,'ffmaxv  = ',e12.5)
 1100 format(6x,'Discrepancy: roundf  = ',e12.5
     &    ,/,6x,'spp (',i5,') = ',e16.9,2x,'pp0max  = ',e16.9
     &      ,2x,'pp1max  = ',e16.9,2x,'ppdmax  = ',e12.5
     &      ,2x,'ppmaxv  = ',e12.5)
 1110 format(6x,'Maximum discrepancy: roundf  = ',e12.5
     &    ,/,6x,'spp (',i5,') = ',e16.9,2x,'pp0max  = ',e16.9
     &      ,2x,'pp1max  = ',e16.9,2x,'ppdmax  = ',e12.5
     &      ,2x,'ppmaxv  = ',e12.5)
 2000 format(  3x,'nxtrap   = ',i5
     &      ,/,3x,'xtrap1   = ',e12.5, 4x,'xtrap1p  = ',e12.5
     &      ,/,3x,'xtrapn   = ',e12.5, 4x,'xtrapnp  = ',e12.5)
 2010 format(/,3x,'delx21   = ',e12.5, 4x,'delx32   = ',e12.5
     &        ,4x,'delx31   = ',e12.5
     &      ,/,3x,'delxn1   = ',e12.5, 4x,'delxnx   = ',e12.5
     &        ,4x,'delxn2   = ',e12.5)
 2020 format(/,3x,'dr3132   = ',e12.5, 4x,'dr2132   = ',e12.5
     &        ,4x,'drn2nx   = ',e12.5, 4x,'drn1nx   = ',e12.5)
 2030 format(/,3x,'Coefficients for sf:'
     &      ,/,3x,'sf2pp    = ',e12.5, 4x,'sf3pp    = ',e12.5
     &        ,4x,'sfn1pp   = ',e12.5, 4x,'sfn2pp   = ',e12.5
     &      ,/,3x,'sfbc11   = ',e12.5,31x,'sfbcnn   = ',e12.5)
 2040 format(/,3x,'Coefficients for sp:'
     &      ,/,3x,'sp2pp    = ',e12.5, 4x,'sp3pp    = ',e12.5
     &        ,4x,'spn1pp   = ',e12.5, 4x,'spn2pp   = ',e12.5
     &      ,/,3x,'spbc11   = ',e12.5,31x,'spbcnn   = ',e12.5)
 2050 format(/,3x,'Coefficients for sffp:'
     &      ,/,3x,'sfp2pp   = ',e12.5, 4x,'sfp3pp   = ',e12.5
     &        ,4x,'sfpn1pp  = ',e12.5, 4x,'sfpn2pp  = ',e12.5
     &      ,/,3x,'sfpbc11  = ',e12.5,31x,'sfpbcnn  = ',e12.5)
 2060 format(/,3x,'Coefficients for spp:'
     &      ,/,3x,'spp2pp   = ',e12.5, 4x,'spp3pp   = ',e12.5
     &        ,4x,'sppn1pp  = ',e12.5, 4x,'sppn2pp  = ',e12.5
     &      ,/,3x,'sppbc11  = ',e12.5,31x,'sppbcnn  = ',e12.5)
 2100 format(/,5x,'Discrepancies from plasma boundary to axis:')
 2110 format(3x,'j',7x,'ffv0',8x,'ffv1',8x,'ffv2',10x,'sf'
     &             ,9x,'sfp', 7x,'ffdiff',11x,'ppv0',8x,'ppv1'
     &             ,8x,'ppv2',7x,'ppdiff')
 2120 format(1x,i5,6(1x,e11.4),4x,4(1x,e11.4))
      end
      subroutine setgdrz
c
c -------------------------------------------------------------
c  Construct (r,z) grid mesh
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
      parameter (nvn=7)
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c     Switch dimensioning of cspl1 for internal use in  subroutine ibcccu
      dimension cspl1p(nw2,2,nxz)
c     compare   cspl1 (2,nxx,nh2)
      equivalence (cspl1(1,1,1),cspl1p(1,1,1))
c
c
c
c 1.0 Initialization
c
c 1.1 Grid dimension and spacing
c
c 1.1.1 Dimensions
c 
      nzd2       = nh2
      nkd        = nxd + nzd
c
c 1.1.2 Grid sizing
c
      ndim1      = nx
      ndim2      = nz
      dmx        = xdim/(nx-1.0)
      dmz        = zdim/(nz-1.0)
      zlowr      = -0.5*zdim
c
c
c 1.2 Poloidal coordinate normalization
c
      charcmx    = twopi
      chpstmx    = twopi
      chhammx    = twopi
c
c
c
c 2.0 Set up equilibrium grid
c
      do 10 i    = 1,nx
      x(i)       = redge   + (i-1.0)*dmx
   10 continue
c
      do 20 j    = 1,nz
      z(j)       = zlowr   + (j-1.0)*dmz
   20 continue
c
c
c
c 3.0 Set up spline fit to equilibrium flux solution
c     The spline coefficients are passed back as cspl1p(2*nxx,2,nxz) dimensioned
c     the same way as in ibcccu but are used as cspl1(2,nxx,2*nxz)
c     As a   4 dimensional array cspln  this is
c         csplin(1,i,1,j)  = psi
c         csplin(2,i,1,j)  = dpsi/dx
c         csplin(1,i,2,j)  = dpsi/dy
c         csplin(2,i,2,j)  = d(dpsi/dx)/dy
c     As the 3 dimensional array cspl1  this is
c         cspl1 (1,i,2j-1) = psi
c         cspl1 (2,i,2j-1) = dpsi/dx
c         cspl1 (1,i, 2j ) = dpsi/dy
c         cspl1 (2,i, 2j ) = d(dpsi/dx)/dy
c     As the 3 dimensional array cspl1p this is
c         cspl1p(2*k-1,1,j) = psi
c         cspl1p( 2*k ,1,j) = dpsi/dx
c         cspl1p(2*k-1,2,j) = dpsi/dy
c         cspl1p( 2*k ,2,j) = d(dpsi/dx)/dy
c
c 3.1 Initialize the spline array
c
      finitl           = 0.0
      do 120 kk        = 1,nxd
      kk1              = kk
      do 100 jj        = 1,nh2
      jj1              = jj
      cspl1(1,kk1,jj1) = +finitl
      cspl1(2,kk1,jj1) = +finitl
  100 continue
  120 continue
c
c
c 3.2 Construct the spline coefficients
c
      call ibcccu(psarray,x,nx,z,nz,cspl1p,nxd,nzd,work0,vork0
     &           ,nkd,ier)
      if(ier .ne. 0) call abortjob
     &        ('setgdrz ',  1,   'Bicubic spline error in psi(r,z)    '
     &        ,'ier     ', ier,      'nx      ', nx,       +1)
c
c
c
c 4.0 Reset magnetic axis from spline fit
c
c 4.1 Reset single magnetic axis
c
c 4.1.1 First recalculate the magnetic axis
c
      newtit     = nwtmag
      erconv     = cnvmag
      xaxs       = xma
      zaxs       = zma
      psiaxs     = psimax
      if(psimax .eq. psisep) nreset  = 1
      if(psimax .ne. psisep) nreset  = 0
c
      call magax(x,nx,z,nz,cspl1,nxd,nzd,xaxs,zaxs,psiaxs,newtit
     &                                                   ,erconv)
c
c 4.1.2 Reset the first axis point
c
c 4.1.2.1 Check for large discrepancies
      iaxerr     = 0
      epsaxr     = epsaxs*xdim
      epsaxz     = epsaxs*zdim
      epsaxp     = epsaxs*abs(delpsir0)
      delxma     =   xma    -   xaxs
      delzma     =   zma    -   zaxs
      delpax     = psimax0  -  psiaxs
      if(abs(delxma) .ge. epsaxr) then
        iaxerr     = 1
        call abortjob
     &        ('setgdrz ',  2,   'Recomputed axis xma .ne. input      '
     &        ,'iaxerr  ', iaxerr,   'newtit  ', newtit,    0)
      endif
      if(abs(delzma) .ge. epsaxz) then
        iaxerr     = 2
        call abortjob
     &        ('setgdrz ',  3,   'Recomputed axis zma .ne. input      '
     &        ,'iaxerr  ', iaxerr,   'newtit  ', newtit,    0)
      endif
      if(abs(delpax) .ge. epsaxp) then
        iaxerr     = 3
        call abortjob
     &        ('setgdrz ',  4,   'Recomputed axis psi .ne. input      '
     &        ,'iaxerr  ', iaxerr,   'newtit  ', newtit,    0)
      endif
c
      if(     iaxerr        .ne.    0  ) then
        write(kuout,1000) iaxerr,epsaxs,xma,    xaxs,  delxma,epsaxr
     &                                 ,zma,    zaxs,  delzma,epsaxz
     &                                 ,psimax0,psiaxs,delpax,epsaxp
      endif
c
c 4.1.2.2 Reset the axis
      xma        = xaxs
      zma        = zaxs
      psimax     = psiaxs
c
c 4.1.2.3 Reset psimsh and psisep:
c         Future interpolations will use this value instead of the value read in (psimax0)
c         Reset spsif(1) as well
      psimsh(1)  = psiaxs
      spsif (1)  = psiaxs
c
c 4.1.2.4 Reset the arrays
      xax  (1)   = xaxs
      zax  (1)   = zaxs
      psimx(1)   = psiaxs
c
c 4.1.2.5 Reset psisep equal to the new psimax if they were equal before
      if(nreset .eq. 1) psisep = psimax
c
c 4.1.3 Redefine the flux difference using the new psimax
c
      delpsir    = psilim - psimax
      if(delpsir .eq. 0.0) call abortjob
     &        ('setgdrz ',  5,   'Recomputed delpsir is zero          '
     &        ,'nx      ', nx,       'nz      ', nz,       +1)
c
c 4.1.4 Set the psi differences for the last two intervals
c
      dpedg1     = psilim - psimsh(nprofl-1)
      dpedg2     = psilim - psimsh(nprofl-2)
c
c
c 4.2 Set up multiple magnetic axis definitions
c
c 4.2.1 Dee shape
c
      if    ((ndoublt .eq.   0   )   .or.
     &      ((psisep  .eq. psimax)   .or.  (psisep .gt. psilim))) then
        numax    = 1
        smap(1)  = psimax
        smax(1)  = xma
        smaz(1)  = zma
c
        smap(2)  = psimax
        smax(2)  = xma
        smaz(2)  = zma
        xsep     = xma
        zsep     = zma
        xax(1)   = xma
        xax(2)   = 0.0
        zax(1)   = zma
        zax(2)   = 0.0

c
c 4.2.2 Doublet shape
c
      elseif((ndoublt .ne.    0  )  .and.
     &      ((psisep  .ne. psimax)  .and.  (psisep .le. psilim))) then
        numax    = 2
        do 200 i = 1,numax
        smap(i)  = psimx(i)
        smax(i)  = xax(i)
        smaz(i)  = zax(i)
 200    continue
      endif
c
c
c
c 5.0 Set up dpsi/dx, dpsi/dy arrays
c
      call getgsqm(psarray,grsq,nx,nz,dmx,dmz,nxd,nzd,gpx,gpy)
c
      return
c
 1000 format(1x,'Warning: input magnetic axis is inaccurate:'
     &      ,1x,'iaxerr  = ',i5,   2x,'epsaxs  = ',e16.6,/
     &      ,1x,'xma     = ',e16.6,2x,'xaxs    = ',e16.6
     &      ,2x,'delxma  = ',e16.6,2x,'epsaxr  = ',e16.6,/
     &      ,1x,'zma     = ',e16.6,2x,'zaxs    = ',e16.6
     &      ,2x,'delzma  = ',e16.6,2x,'epsaxz  = ',e16.6,/
     &      ,1x,'psimax0 = ',e16.6,2x,'psiaxs  = ',e16.6
     &      ,2x,'delpax  = ',e16.6,2x,'epsaxp  = ',e16.6)
      end
      subroutine setgdpc
c
c -------------------------------------------------------------
c  Construct (psi,chi) grid mesh
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
      parameter (nvn=7)
c
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialize
c
c 1.1 Define the tolerance
c
      rndoff   = roundff
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(kmap .eq.  0) then
         call abortjob
     &        ('setgdpc ',  1,   'Called for a direct equilibrium     '
     &        ,'kmap    ', kmap,     'ktype   ', ktype,    -1)
         return
      endif
c
      if(ktype .eq.  0) then
         call abortjob
     &        ('setgdpc ',  2,   'Equilibrium type: direct equilibrium' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('setgdpc ',  3,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Initialize the bicubic spline parameters
c
      nvt      = max0(npsi,nthet)
      ibdnk    =  0
      ibdpd    = -1
c
c
c 1.4 Poloidal coordinate normalization
c
      charcmx  = twopi
      chpstmx  = twopi
      chhammx  = twopi
c
c
c 1.5 Check delpsir is valid
c
      if(delpsir .eq. 0.0) call abortjob
     &        ('setgdpc ',  4,   'delpsir = 0: Inverse equilibrium    '
     &        ,'ktype   ', ktype,    'npsi    ', npsi,     +1)
c
c
c
c 2.0 Set the flux and poloidal equilibrium meshes
c
c 2.1 Set up the flux meshes for interpolation
c
      do 50 jj      = 1,npsi
      jvl           = jj
      psimv         = psimsh(jvl)
      ppvmsh0       = defmesh(psimv,psimax,delpsir,peqpk0,rndoff
     &                       ,dpsds0,dpsdss0,ier)
      if(ier .ne. 0) call abortjob
     &        ('setgdpc ',  5,   'Interpolation error for peqpk0      '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      ppvmsh1       = defmesh(psimv,psimax,delpsir,peqpk1,rndoff
     &                       ,dpsds1,dpsdss1,ier)
      if(ier .ne. 0) call abortjob
     &        ('setgdpc ',  6,   'Interpolation error for peqpk1      '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      ppvmsh2       = defmesh(psimv,psimax,delpsir,peqpk2,rndoff
     &                       ,dpsds2,dpsdss2,ier)
      if(ier .ne. 0) call abortjob
     &        ('setgdpc ',  7,   'Interpolation error for peqpk2      '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      peqmsh0(jvl)  = ppvmsh0
      peqdsd0(jvl)  = dpsds0
      peqdss0(jvl)  = dpsdss0
c
      peqmsh1(jvl)  = ppvmsh1
      peqmsh2(jvl)  = ppvmsh2
   50 continue
c
c
c 2.2 Set up the poloidal  grid
c
      dthchi        = charcmx/float(nthet-1)
      ntht1         = nthet - 1
      do 100 ii     = 1,ntht1
      thchi(ii)     = (ii-1.0)*dthchi
  100 continue
      thchi(nthet)  = charcmx
c
c
c
c 3.0 Compute the bicubic spline interpolation coefficients
c
c 3.1 Set the node values in the spline array
c
      do 250 jj      = 1,npsi
      do 200 ii      = 1,nthet
      csrvl(jj,ii,1) = seqrps(jj,ii)
      cszvl(jj,ii,1) = seqzps(jj,ii)
c
      if(ktype .eq. +2) then
        csarc(jj,ii,1) = seqarc(jj,ii)
        cspst(jj,ii,1) = seqpst(jj,ii)
        csham(jj,ii,1) = seqham(jj,ii)
      endif
  200 continue
  250 continue
c
c
c 3.2 Compute the interpolation coefficients
c
c 3.2.1 Spline for r and z
c
      call bispline(peqmsh0,thchi,npsi,nthet,npp,ntt,csrvl
     &                           ,work1,vork1,nvt,ibdpd)
      call bispline(peqmsh0,thchi,npsi,nthet,npp,ntt,cszvl
     &                           ,work1,vork1,nvt,ibdpd)
c
c 3.2.2 Spline for arclength coordinates as well if ktype = +2
c
      if(ktype .eq. +2) then
        call bispline(peqmsh0,thchi,npsi,nthet,npp,ntt,csarc
     &                             ,work1,vork1,nvt,ibdnk)
        call bispline(peqmsh0,thchi,npsi,nthet,npp,ntt,cspst
     &                             ,work1,vork1,nvt,ibdnk)
        call bispline(peqmsh0,thchi,npsi,nthet,npp,ntt,csham
     &                             ,work1,vork1,nvt,ibdnk)
      endif
c
c
c
c 4.0 Compute the interpolation coefficients for derivatives
c     of psi on the boundary
c
      if(ktype .eq. +2) then
c
c 4.1 Interpolation coefficients for dpsi/dr
c
c 4.1.1 Set up the periodic boundary conditions
c
        nthet1     = nthet-1
        bcc(1)     = 0.0
        bcc(2)     = 2.*f2s(nthet1,seqdpdr,thchi,ntt)
        bcc(3)     = 0.0
        bcc(4)     = bcc(2)
c
c 4.1.2 Compute the interpolation coefficients
c
        call icsici(thchi, seqdpdr,nthet,bcc,csdpdr,ntt,ier)
        if(ier .ne. 0) call abortjob
     &        ('setgdpc ',  8,   'Interpolation error dpdr(thchi)     '
     &        ,'ier     ', ier,      'nthet   ', nthet,    +1)
c
c
c 4.2 Interpolation coefficients for dpsi/dz
c
c 4.2.1 Set up the periodic boundary conditions
c
        bcc(2)     = 2.*f2s(nthet1,seqdpdz,thchi,ntt)
        bcc(4)     = bcc(2)
c
c 4.2.2 Compute the interpolation coefficients
c
        call icsici(thchi, seqdpdz,nthet,bcc,csdpdz,ntt,ier)
        if(ier .ne. 0) call abortjob
     &        ('setgdpc ',  9,   'Interpolation error dpdz(thchi)     '
     &        ,'ier     ', ier,      'nthet   ', nthet,    +1)
c
c
c
c 5.0 Set up the splines for the arclength endpoints if needed
c
c 5.1 Define the vector of full arclength values
c
        do 300 jj  = 1,npsi
        arcmax(jj) = seqarc(jj,nthet)
        pstmax(jj) = seqpst(jj,nthet)
        hammax(jj) = seqham(jj,nthet)
  300   continue
c
c
c 5.2 Set the extrapolation coefficients for the spline boundary conditions
c
        npsim1    = npsi - 1
        npsim2    = npsi - 2
        delx21     = peqmsh0(   2  ) - peqmsh0(   1  )
        delx32     = peqmsh0(   3  ) - peqmsh0(   2  )
        delx31     = peqmsh0(   3  ) - peqmsh0(   1  )
        delxn1     = peqmsh0(npsi)   - peqmsh0(npsim1)
        delxnx     = peqmsh0(npsim1) - peqmsh0(npsim2)
        delxn2     = peqmsh0(npsi)   - peqmsh0(npsim2)
        dr3132     = delx31/delx32
        dr2132     = delx21/delx32
        drn2nx     = delxn2/delxnx
        drn1nx     = delxn1/delxnx
        if    (nspbc1 .eq. 0) then
          xtrap1     = 0.0
          xtrap1p    = 0.0
          xtrapn     = 0.0
          xtrapnp    = 0.0
        elseif(nspbc1 .eq. 1) then
          xtrap1     = 1.0
          xtrap1p    = 0.0
          xtrapn     = 1.0
          xtrapnp    = 0.0
        elseif(nspbc1 .eq. 2) then
          xtrap1     = +dr3132
          xtrap1p    = -dr2132
          xtrapn     = +drn2nx
          xtrapnp    = -drn1nx
        elseif(nspbc1 .gt. 2) then
          xtrap1     = 0.0
          xtrap1p    = 0.0
          xtrapn     = 0.0
          xtrapnp    = 0.0
        endif
c
c
c 5.3 Spline the total arclengths
c
c 5.3.1 Set up the boundary conditions
c
        am2pp      = f2sx(   2  ,arcmax,peqmsh0,npsi)
        am3pp      = f2sx(   3  ,arcmax,peqmsh0,npsi)
        amn1pp     = f2sx(npsim1,arcmax,peqmsh0,npsi)
        amn2pp     = f2sx(npsim2,arcmax,peqmsh0,npsi)
c
        ambc11     = xtrap1*am2pp   + xtrap1p*am3pp
        ambcnn     = xtrapn*amn1pp  + xtrapnp*amn2pp
c
c 5.3.1.1 Set the second derivative at the endpoint
        if    (nspbc1 .ge.  0  .and.  nspbc1 .le.  2) then
          bcb(1)     = 0.0
          bcb(2)     = 2.0*ambc11
          bcb(3)     = 0.0
          bcb(4)     = 2.0*ambcnn
c
c 5.3.1.2 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
        elseif(nspbc1 .gt. +2) then
          bigval     = abs(float(nspbc1))
          bcb(1)     = bigval
          bcb(2)     = bigval*am2pp
          bcb(3)     = bigval
          bcb(4)     = bigval*amn1pp
c
c 5.3.1.3 Use a floating condition at both ends
        elseif(nspbc1 .lt.  0) then
          bigval     = abs(float(nspbc1))
          bcb(1)     = bigval
          bcb(2)     = bigval*am2pp
          bcb(3)     = 0.0
          bcb(4)     = 0.0
        endif
c
c 5.3.2 Compute the spline coefficients
c
        call icsici(peqmsh0,arcmax,npsi,bcb,csarcm,npp,iera)
        if(iera .ne. 0) call abortjob
     &        ('setgdpc ', 10,   'Interpolation error arcmax(peqmsh0) '
     &        ,'iera    ', iera,     'npsi    ', npsi,     +1)
c
c
c 5.4 Spline the total Pest angle 
c
c 5.4.1 Set up the boundary conditions
c
        pm2pp      = f2sx(   2  ,pstmax,peqmsh0,npsi)
        pm3pp      = f2sx(   3  ,pstmax,peqmsh0,npsi)
        pmn1pp     = f2sx(npsim1,pstmax,peqmsh0,npsi)
        pmn2pp     = f2sx(npsim2,pstmax,peqmsh0,npsi)
c
        pmbc11     = xtrap1*pm2pp   + xtrap1p*pm3pp
        pmbcnn     = xtrapn*pmn1pp  + xtrapnp*pmn2pp
c
c 5.4.1.1 Set the second derivative at the endpoint
        if    (nspbc1 .ge.  0  .and.  nspbc1 .le.  2) then
          bcb(1)     = 0.0
          bcb(2)     = 2.0*pmbc11
          bcb(3)     = 0.0
          bcb(4)     = 2.0*pmbcnn
c
c 5.4.1.2 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
        elseif(nspbc1 .gt. +2) then
          bigval     = abs(float(nspbc1))
          bcb(1)     = bigval
          bcb(2)     = bigval*pm2pp
          bcb(3)     = bigval
          bcb(4)     = bigval*pmn1pp
c
c 5.4.1.3 Use a floating condition at both ends
        elseif(nspbc1 .lt.  0) then
          bigval     = abs(float(nspbc1))
          bcb(1)     = bigval
          bcb(2)     = bigval*pm2pp
          bcb(3)     = 0.0
          bcb(4)     = 0.0
        endif
c
c 5.4.2 Compute the spline coefficients
c
        call icsici(peqmsh0,pstmax,npsi,bcb,cspstm,npp,ierp)
        if(ierp .ne. 0) call abortjob
     &        ('setgdpc ', 11,   'Interpolation error pstmax(peqmsh0) '
     &        ,'ierp    ', ierp,     'npsi    ', npsi,     +1)
c
c
c 5.5 Spline the total Hamiltonian angle
c
c 5.5.1 Set up the boundary conditions
c
        hm2pp      = f2sx(   2  ,pammax,peqmsh0,npsi)
        hm3pp      = f2sx(   3  ,pammax,peqmsh0,npsi)
        hmn1pp     = f2sx(npsim1,pammax,peqmsh0,npsi)
        hmn2pp     = f2sx(npsim2,pammax,peqmsh0,npsi)
c
        hmbc11     = xtrap1*hm2pp   + xtrap1p*hm3pp
        hmbcnn     = xtrapn*hmn1pp  + xtrapnp*hmn2pp
c
c 5.5.1.1 Set the second derivative at the endpoint
        if    (nspbc1 .ge.  0  .and.  nspbc1 .le.  2) then
          bcb(1)     = 0.0
          bcb(2)     = 2.0*hmbc11
          bcb(3)     = 0.0
          bcb(4)     = 2.0*hmbcnn
c
c 5.5.1.2 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
        elseif(nspbc1 .gt. +2) then
          bigval     = abs(float(nspbc1))
          bcb(1)     = bigval
          bcb(2)     = bigval*hm2pp
          bcb(3)     = bigval
          bcb(4)     = bigval*hmn1pp
c
c 5.5.1.3 Use a floating condition at both ends
        elseif(nspbc1 .lt.  0) then
          bigval     = abs(float(nspbc1))
          bcb(1)     = bigval
          bcb(2)     = bigval*hm2pp
          bcb(3)     = 0.0
          bcb(4)     = 0.0
        endif
c
c 5.5.2 Compute the spline coefficients
c
        call icsici(peqmsh0,hammax,npsi,bcb,cshamm,npp,ierh)
        if(ierh .ne. 0) call abortjob
     &        ('setgdpc ', 12,   'Interpolation error hammax(peqmsh0) '
     &        ,'ierh    ', ierh,     'npsi    ', npsi,     +1)
      endif
c
c
c
c 6.0 Set up the magnetic axis definitions
c
c 6.1 Reset the flux difference in case psimax or psilim has been modified
c
c 6.1.1 Reset delpsir
c
      delpsir      = psilim - psimax
      if(delpsir .eq. 0.0) call abortjob
     &        ('setgdpc ', 13,   'delpsir has been reset to zero      '
     &        ,'ktype   ', ktype,    'npsi    ', npsi,     +1)
c
c 6.1.2 Set the psi differences for the last two intervals
c
      dpedg1     = psilim - psimsh(npsi-1)
      dpedg2     = psilim - psimsh(npsi-2)
c
c
c 6.2 Set the equilibrium data for a non-doublet
c
      numax        = 1
      smap(1)      = psimax
      smax(1)      = xma
      smaz(1)      = zma
c
      smap(2)      = psimax
      smax(2)      = xma
      smaz(2)      = zma
      xsep         = xma
      zsep         = zma
      xax(1)       = xma
      xax(2)       = 0.0
      zax(1)       = zma
      zax(2)       = 0.0
c
c
c
c 7.0 Define the box containing the mesh
c
c 7.1 Find the mesh extrema
c
      xmin         = seqrps(npsi,1)
      xmax         = seqrps(npsi,1)
      ymin         = seqzps(npsi,1)
      ymax         = seqzps(npsi,1)
c
      do 400 ii = 1,nthet
      if(xmin .gt. seqrps(npsi,ii)) xmin   = seqrps(npsi,ii)
      if(xmax .lt. seqrps(npsi,ii)) xmax   = seqrps(npsi,ii)
      if(ymin .gt. seqzps(npsi,ii)) ymin   = seqzps(npsi,ii)
      if(ymax .lt. seqzps(npsi,ii)) ymax   = seqzps(npsi,ii)
  400 continue
c
c
c 7.2 Set the box extrema slightly outside the mesh
c
c 7.2.1 Set the box edges
c
      boxwid       = 0.10*(xmax - xmin)
      boxhgt       = 0.10*(ymax - ymin)
c
      rmmin        = xmin - 0.5*boxwid
      rmmax        = xmax + 0.5*boxwid
      zmmin        = ymin - 0.5*boxhgt
      zmmax        = ymax + 0.5*boxhgt
c
      redge        = rmmin
      zlowr        = zmmin
c
c 7.2.2 Check the inboard edge is positive
c
      if(redge .le. 0.0) then
        rsign        = sign(1.5,redge)
        nrsign       = ifix(rsign)
        call abortjob
     &        ('setgdpc ', 14,   'inboard redge is non positive       '
     &        ,'ktype   ', ktype,    'nrsign  ', nrsign,   -1)
        redge        = abs(boxwid*roundff)
      endif
c
c
c 7.3 Set the final box range and other data
c
c 7.3.1 Grid sizing
c
      ndim1        = npsi
      ndim2        = nthet
      npgrid       = sqrt(float(ndim1)*float(ndim2))
      xdim         = rmmax - redge
      zdim         = zmmax - zmmin
c
      dmx          = xdim/(npgrid-1.0)
      dmz          = zdim/(npgrid-1.0)
      zlowr        = -0.5*zdim
c
c
c 7.3.3 Other data
c
      ipestg       = 0
c
c
c
c 8.0 Return and end
c
      return
      end
      function defmesh(psiv,psi0,dpsi,alpha,rndff,dpsds,dpsdss,ier)
c
c -------------------------------------------------------------
c  Define the parameterized flux mesh
c -------------------------------------------------------------
c
c Input:
c         psiv    = psi value
c         psi0    = psi on axis
c         dpsi    = psi(edge) - psi(axis)
c         alpha   = exponent for s = [(psi-psi0) / dpsi]**alpha
c         rndff   = roundoff for normalized psi
c Output:
c         defmesh = s(psiv)
c         dpsds   = dpsi/ds
c         dpsdss  = d**2/ds**2(psi)
c         ier     = error flag
c
      ier         = 0
c
      if    (alpha .gt. 0.0) then
        alfa     = alpha
      elseif(alpha .lt. 0.0) then
        ier      = 1
        alfa     = abs(alpha)
      elseif(alpha .eq. 0.0) then
        ier      = 2
        alfa     = 1.0
      endif
c
      alfa1        = 1.0/alfa
      alfa2        = alfa1*alfa1
      alfas        = 1.0 -     alfa
      alfass       = 1.0 - 2.0*alfa
c
      psval        = (psiv-psi0)/dpsi
      if(psval  .lt. 0.0) then
        ier    = 3
        psval  = 0.0
      endif
c
      if    (psval .eq. 0.0) then
        if(alfa   .gt. 0.0) sval   = psval**alfa
        if(alfa   .le. 0.0) sval   = rndff**alfa
        if(alfas  .gt. 0.0) dpds   = alfa1*dpsi*(psval**alfas)
        if(alfas  .le. 0.0) dpds   = alfa1*dpsi*(rndff**alfas)
        if(alfass .gt. 0.0) dpdss  = alfa2*alfas*dpsi*(psval**alfass)
        if(alfass .le. 0.0) dpdss  = alfa2*alfas*dpsi*(rndff**alfass)
      elseif(psval .gt. 0.0) then
        sval   = psval**alfa
        dpds   = alfa1*dpsi*(psval**alfas)
        dpdss  = alfa2*alfas*dpsi*(psval**alfass)
      endif
c
      defmesh     = sval
      dpsds       = dpds
      dpsdss      = dpdss
c
      return
      end
      subroutine writeql
c
c -------------------------------------------------------------
c  Write out the input equilibrium
c -------------------------------------------------------------
c
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nft=5)
c
      character*8   etitl,date
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Write out the equilibrium type and title
c
c 1.1 Equilibrium type
c
c 1.1.1 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('writeql ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c 1.1.2 Write out the equilibrium type
c
      if    (kmap .eq.  0) then
         write(kutty,1000)
         write(kuout,1000)
      elseif(kmap .eq. +1  .or.  kmap .eq. +2) then
         write(kutty,1010)
         write(kuout,1010)
      elseif(kmap .eq. -1) then
         write(kutty,1020)
         write(kuout,1020)
      elseif(kmap .eq. -2  .or.  kmap .eq. -3) then
         write(kutty,1030)
         write(kuout,1030)
      elseif(kmap .eq. -4) then
         write(kutty,1040)
         write(kuout,1040)
      else
         write(kutty,1050)
         write(kuout,1050)
      endif
c
c
c 1.2 Equilibrium heading and date
c
      write(kutty,1100) (etitl(it),it=1,nft),date
      write(kuout,1100) (etitl(it),it=1,nft),date
c
c
c
c 2.0 Write the equilibrium input dimensions
c
c 2.1 For all types
c
      write(kuout,2000)
c
c
c 2.2 For direct equilibria
c
      if    (ktype .eq. 0) then
         write(kuout,2010) nx,  nz,   xdim,zdim,redge
c
c
c 2.3 For inverse equilibria
c
      elseif(ktype .gt. 0) then
         write(kuout,2020) npsi,nthet,xdim,zdim,redge
      endif
c
c
c
c 3.0 Write out the scalar equilibrium data
c
c 3.1 Poloidal flux limits
c
      write(kuout,3000)
      write(kuout,3010) xma, zma, psimax,psilim
      write(kuout,3020) xsep,zsep,psisep
c
c
c 3.2 Toroidal field and current
c
      write(kuout,3100)
      write(kuout,3110) rcnt,totcur,btor
c
c
c
c 4.0 Write out the input equilibrium profiles
c
c 4.1 Write out the basic equilibrium profiles
c
      write(kuout,4000) npst
      write(kuout,4010)
      do 100 jv  = 1,nprofl
      jvl        = jv
      write(kuout,4020) jvl, psimsh(jvl), sf    (jvl), sp    (jvl)
     &                     , sffp  (jvl), spp   (jvl), sdns  (jvl)
  100 continue
c
c
c 4.2 Write out the fast ion pressure if set
c
      if(ifastp .gt. 0) then
        write(kuout,4100) nfast
        if(ifastp .eq.  +1  .or.  ifastp .eq.  +5  .or.
     &     ifastp .eq.  +9  .or.  ifastp .eq. +13) write(kuout,4105)
        if(ifastp .eq.  +2  .or.  ifastp .eq.  +6  .or.
     &     ifastp .eq. +10  .or.  ifastp .eq. +14) write(kuout,4110)
        if(ifastp .eq.  +3  .or.  ifastp .eq.  +7  .or.
     &     ifastp .eq. +11  .or.  ifastp .eq. +15) write(kuout,4115)
        if(ifastp .eq.  +4  .or.  ifastp .eq.  +8  .or.
     &     ifastp .eq. +12  .or.  ifastp .eq. +16) write(kuout,4120)
        do 150 jvf = 1,nfast
        write(kuout,4125) jvf,spsif(jvf),sfast(jvf)
  150   continue
      endif
c
c
c
c 5.0 Write out the input equilibrium mesh
c
      if(ktype .eq. 0) then
        write(kuout,5000) nx
        write(kuout,5010) (x(ivl),ivl = 1,nx)
c
        write(kuout,5100) nz
        write(kuout,5110) (z(ivl),ivl = 1,nz)
      endif
c
c
c
c 4.0 Return and end
c
      return
 1000 format(//,10x,'Direct Equilibrium read from EQDSK file',/
     &         ,10x,'------ ----------- ---- ---- ----- ----')
 1010 format(//,10x,'Inverse Equilibrium read from TOQ file',/
     &         ,10x,'------- ----------- ---- ---- --- ----')
 1020 format(//,10x,'Inverse Equilibrium read from JSOLVER file',/
     &         ,10x,'------- ----------- ---- ---- ------- ----')
 1030 format(//,10x,'Inverse Equilibrium read from QSOLVER file',/
     &         ,10x,'------- ----------- ---- ---- ------- ----')
 1040 format(//,10x,'Inverse Equilibrium read from CORSICA I-file',/
     &         ,10x,'------- ----------- ---- ---- ------- ------')
 1050 format(//,10x,'Unknown Equilibrium type',/
     &         ,10x,'------- ----------- ----')
 1100 format(/, 10x,5a8,2x,'Equilibrium Date:',1x,a8,/)
 2000 format(/, 10x,'Equilibrium Dimensions:')
 2010 format(   5x, 'nx      = ',i5,15x,  'nz      = ',i5,/
     &        , 5x, 'xdim    = ',e16.9,4x,'zdim    = ',e16.9
     &        , 4x, 'redge   = ',e16.9)
 2020 format(   5x, 'npsi    = ',i5,15x,  'nthet   = ',i5,/
     &        , 5x, 'xdim    = ',e16.9,4x,'zdim    = ',e16.9
     &        , 4x, 'redge   = ',e16.9)
 3000 format(/, 10x,'Poloidal Flux:')
 3010 format(   5x, 'xma     = ',e16.9,4x,'zma     = ',e16.9
     &        , 4x, 'psimax  = ',e16.9,4x,'psilim  = ',e16.9)
 3020 format(   5x, 'xsep    = ',e16.9,4x,'zsep    = ',e16.9
     &        , 4x, 'psisep  = ',e16.9)
 3100 format(/, 10x,'Field and Current:')
 3110 format(   5x, 'rcnt    = ',e16.9,4x,'totcur  = ',e16.9
     &        , 4x, 'btor    = ',e16.9)
 4000 format(//,10x,'Input profiles read from equilibrium file:'
     &       ,/,10x,'(From magnetic axis to plasma boundary)'
     &         , 2x,'npst  = ',i2)
 4010 format(/ ,6x, 'j',8x, 'psimsh',13x,'sf',15x,'sp',14x,'sffp'
     &                 ,13x,'spp',14x,'sdns',/)
 4020 format(1x,i6,2x,6(1x,e16.9))
 4100 format(//,10x,'Fast ion pressure profile read from input:'
     &         , 2x,'nfast  = ',i6)
 4105 format(/ ,6x, 'j',8x, 'spsif',10x,'sfast (Pa)',/)
 4110 format(/ ,6x, 'j',8x, 'spsif',10x,'sfast (kPa)',/)
 4115 format(/ ,6x, 'j',8x, 'spsif',10x,'sfast (MPa)',/)
 4120 format(/ ,6x, 'j',8x, 'spsif',8x, 'sfast (2mu0/B**2)',/)
 4125 format(1x,i6,2x,2(1x,e16.9))
 5000 format(//,10x,'Direct equilibrium  radial  mesh: x(i),i = 1,'
     &         ,i5/)
 5010 format(8(1x,e13.6))
 5100 format(//,10x,'Direct equilibrium vertical mesh: z(j),j = 1,'
     &         ,i5/)
 5110 format(8(1x,e13.6))
      end
      subroutine setdpsi
c
c -------------------------------------------------------------
c  Reset the boundary flux value
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Save psimax and psilim from setting the grids.
c     These may have been changed slightly from the original input values
c     psimax0, psilim0, and delpsir0
c
      psimax1   = psimax
      psilim1   = psilim
      delpsir1  = psilim1 - psimax1
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('setdpsi ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Set mapmax to iterate only if mapmaxd > 0 and an increment is requested
c
      if    (mapmaxd .ge. 0) then
        if    (dpsisl .ne. 0.0  .and.  dpsisd .ne. 0.0) then
          mapmax   = mapmaxd
        elseif(dpsisl .eq. 0.0  .and.  dpsisd .ne. 0.0) then
          mapmax   = mapmaxd
        elseif(dpsisl .ne. 0.0  .and.  dpsisd .eq. 0.0) then
          mapmax   = 1
        elseif(dpsisl .eq. 0.0  .and.  dpsisd .eq. 0.0) then
          mapmax   = 0
        endif
      elseif(mapmaxd .lt. 0) then
        mapmax   = 0
      endif
c
c
c
c 2.0 Set dpsisv and dpsidec if no increment and return
c
      if    (mapmax .eq. 0) then
        dpsidec   = 0.0
        dpsisv    = dpsisl
        write(kuout,1000) mapmax,dpsisl, dpsisd, dpsidec,dpsisv
     &                          ,psimax0,psilim0,psimax1,psilim1
     &                          ,psimax, psilim
        return
      endif
c
c
c
c 3.0 Iterate to search for the last closed flux surface
c
      if    (mapmax .gt. 0) then
c
c 3.1 Initialize loop 
c
c 3.1.1 Initialize data
c
        mapsuccs     = 0
        dpsidec      = 0.0
        dpsidec0     = dpsidec
        dpsidec1     = dpsidec
        dpsuccs      = dpsidec
        dpfaild      = dpsidec
c
c 3.1.2 Write out a header
c
        write(kutty,2000) mapmax,dpsisl, dpsisd
        write(kuout,2000) mapmax,dpsisl, dpsisd
c
c
c 3.2 Loop over increments
c
c
c 3.2.1 Initialize the loop counter variables and loop
c
        mapcntr      = 0
  100   mapcntr      = mapcntr + 1
c
c 3.2.2 Set the boundary increment
c
          dpsist       = dpsisl - dpsidec
c
c
c 3.3 Set the increment from the boundary for mapping the last closed flux surface
c
c 3.3.1 Set dpsisw for direct equilibria
c
          if    (ktype .eq. 0) then
            dpsisw      = dpsist
c
c 3.3.2 Set dpsisw and print a warning if dpsist .ne. 0 for the
c       inverse equilibrium
c
          elseif(ktype .gt. 0) then
c
c 3.3.2.1 Set dpsisw = 0 if dpsist = 0
            if    (dpsist .eq. 0.0) then
              dpsisw      = 0.0
c
c 3.3.2.2 Set dpsisw inside the boundary if dpsist is inside and print a warning
            elseif(dpsist .lt. 0.0) then
              dpsisw    = dpsist
              call abortjob
     &        ('setdpsi ',  2,   'Inverse equilibrium: dpsist < 0     '
     &        ,'ktype   ', ktype,    'npsi    ', npsi,      0)
c
c 3.3.2.3 Set dpsisw = 0 if dpsist is outside the inverse equilibrium boundary
c         and print a warning
            elseif(dpsist .gt. 0.0) then
              dpsisw    = 0.0
              call abortjob
     &        ('setdpsi ',  3,   'Inverse equilibrium: dpsist > 0     '
     &        ,'ktype   ', ktype,    'npsi    ', npsi,     -1)
            endif
          endif
c
c
c 3.4 Reset the temporary flux grid for mapping the boundary
c
c 3.4.1 Reset psi extrema
c
          psimaxw    = psimax1
          psilimw    = psilim1 + delpsir1*dpsisw
          psisepw    = psisep
c
c 3.4.2 Set temporary delpsir
c
          delpsirw   = psilimw - psimaxw
c
          if(delpsirw .eq. 0.0) call abortjob
     &        ('setdpsi ',  4,   'Temporary delpsirw is zero          '
     &        ,'ktype   ', ktype,    'mapcntr ', mapcntr,  +1)
c
c 3.4.3 Set the temporary mesh psival, psivl0, and psilim
c
c 3.4.3.1 Set psilim
          psilim     = psilimw
          delpsir    = delpsirw
c
c 3.4.3.2 Set the mesh psival and psivl0
          call compmsh(jpsi1,ndoublt,numax,psipak,psincr,psimaxw
     &                ,psilimw,psisepw,delpsirw,jsep,psival,psivl0)
c
c
c 3.5 Map the surface using this value of psilim
c
c 3.5.1 Initialize parameters
c
          jsurf      = 0
          maperr     = 0
          maponly    = 0
          nvnt       = nvn
          ithtm      = itht
          psivl      = psilim
c
c 3.5.2 For direct equilibria
c
          if    (ktype .eq. 0) then
c
c 3.5.1.1 Construct the starting position for the contour by integrating
c         along an orthogonal ray from the axis to the outboard midplane
          call ortogray(0)
c
c 3.5.2.2 Initialize parameters for call to eqdmap
            rst0     = rst(1)
            zst0     = zst(1)
c
c 3.5.2.3 Map the plasma boundary
            call eqdmap(jsurf,psivl,ithtm,rst0,zst0,rst1,zst1
     &                 ,arprv,svint,nvnt,maponly,mapid,maperr)
c
c 3.5.3 For inverse equilibria
c
          elseif(ktype .gt. 0) then
c
c 3.5.3.1 Set the equilibrium psi mesh for inverse equilibria
            call setpsim
c
c 3.5.3.2 Map the plasma boundary
            rst1     = rst(1)
            zst1     = zst(1)
            call toqmap(ktype,jsurf,maperr,psivl,ithtm,svint,nvnt)
          endif
c
c
c 3.6 Reset dpsidec0 and dpsidec1
c
          dpsidec0   = dpsidec1
          dpsidec1   = dpsisl - dpsisw
c
c
c 3.7 Print out the surface just tried
c
      if    (maperr .eq. 0  .and.  mapsuccs .eq. 0) then
        write(kutty,2100) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
        write(kuout,2100) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
c
      elseif(maperr .ne. 0  .and.  mapsuccs .eq. 0) then
        write(kutty,2110) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
        write(kuout,2110) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
c
      elseif(maperr .eq. 0  .and.  mapsuccs .gt. 0) then
        write(kutty,2120) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
        write(kuout,2120) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
c
      elseif(maperr .ne. 0  .and.  mapsuccs .gt. 0) then
        write(kutty,2130) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
        write(kuout,2130) maperr,  mapcntr, mapmax,  mapsuccs
     &                   ,dpsidec, dpsisw,  psilim0, psilim
      endif
c
      write(kuout,2150) dpsisl,  dpsisd,  dpsist,  dpsisw
     &                 ,dpsidec0,dpsidec1
     &                 ,psimax0, psilim0, psimax1, psilim1
     &                 ,psimax,  psilim
c
c
c
c 4.0 Decision point:
c     Continue iterating  to search for a closed surface or
c     Iterate with a bisection search for the last closed surface or
c     Return with solution
c
          if    (mapsuccs .eq. 0) then
c
c 4.1 Return or set up bisection iteration if the first time mapping was successful
c
            if    (maperr .eq. 0) then
c
c 4.1.1 Return if dpsuccs on the first iteration with no cutoff
c
              if    (mapcntr .eq. 1  .or.  mapcntr .eq. mapmax) then
c
c 4.1.1.1 Set parameters specifying successful mapping
                mapsuccs  = 1
                dpsisv    = dpsisw
c
c 4.1.1.2 Save the new surface start position
                rstp(1)   = rst1
                zstp(1)   = zst1
c
c 4.1.1.3 Print the successful mapping data, print a warning if this is the last
c         allowed iteration, and return
                if    (mapcntr .eq. 1) then
                  write(kutty,2200) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  write(kuout,2200) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpsidec, dpsisv,  psilim0, psilim
c
                elseif(mapcntr .ne. 1) then
                  write(kutty,2210) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  write(kuout,2210) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  call abortjob
     &        ('setdpsi ',  5,   'No bisection iteration performed    '
     &        ,'mapcntr ', mapcntr,  'mapsuccs', mapsuccs,  0)
                endif
c
                write(kuout,2220) dpsisl,  dpsisd,  dpsist,  dpsisv
     &                           ,dpsidec0,dpsidec1,dpsidec
     &                           ,psimax0, psilim0, psimax1, psilim1
     &                           ,psimax,  psilim
c
                write(kutty,2250) mapcntr,mapsuccs,dpsisv,psilim
                write(kuout,2250) mapcntr,mapsuccs,dpsisv,psilim
                return
c
c 4.1.2 Set up for bisection if several iterations were done before the first successful one
c
              elseif(mapcntr .gt. 1  .and.  mapcntr .lt. mapmax) then
                mapsuccs  = 1
                dpfaild   = dpsidec0
                dpsuccs   = dpsidec1
                dpsidec   = 0.5*(dpsuccs + dpfaild)
c
                write(kutty,2300) dpsidec,dpfaild,dpsuccs
                write(kuout,2300) dpsidec,dpfaild,dpsuccs
c
                go to 100
              endif
c
c
c 4.2 Try again if mapping still unsuccessful with dpsidec adjusted further
c
            elseif(maperr .ne. 0  .and.  mapcntr .lt. mapmax) then
c
c 4.2.1 Reset the increment and iterate again
c
              if(mapcntr .eq. 1) dpsidec  =   dpsisd
              if(mapcntr .gt. 1) dpsidec  = 2*dpsidec
c
c 4.2.2 Print a warning and iterate again
c 
              call abortjob
     &        ('setdpsi ',  6,   'Trying with dpsidec incremented     '
     &        ,'mapcntr ', mapcntr,  'maperr  ', maperr,    0)
c
              write(kutty,2310) dpsidec,dpsidec0,dpsidec1
              write(kuout,2310) dpsidec,dpsidec0,dpsidec1
c
              go to 100
c
c
c 4.3 Quit if the last closed flux surface could not be found
c
            elseif(maperr .ne. 0  .and.  mapcntr .ge. mapmax) then
              call abortjob
     &        ('setdpsi ',  7,   'Unable to find a closed surface     '
     &        ,'ktype   ', ktype,    'mapmax  ', mapmax,   +1)
            endif
          endif
c
c
c 4.4 Return or iterate with bisection if a successful value was already found
c
          if(mapsuccs .eq. +1) then
c
c 4.4.1 Reset the bisection bounds as needed
              if(maperr .eq. 0) dpsuccs    = dpsidec1
              if(maperr .ne. 0) dpfaild    = dpsidec1
c
c 4.4.2 Iterate again if bisection not converged and maximum iterations not exceeded
c
            dpsidif    = abs(dpsuccs - dpfaild)
            dpsicon    = abs(dpsisd)
            if(mapcntr .lt. mapmax  .and.  dpsidif .gt. dpsicon) then
c
c 4.4.2.1 Reset the decrement
              dpsidec   = 0.5*(dpsuccs + dpfaild)
c
c 4.4.2.2 Print out the data from this attempt and iterate again
              write(kutty,2400) dpsidec,dpfaild,dpsuccs
              write(kuout,2400) dpsidec,dpfaild,dpsuccs
              go to 100
            endif
c
c 4.4.3 Return if bisection converged or if maximum iterations is reached and the mapping
c       was successful
c
            if(mapcntr .eq. mapmax  .or.   dpsidif .le. dpsicon) then 
              if    (maperr  .eq.   0   ) then
c
c 4.4.3.1 Set parameters specifying successful converged mapping
                mapsuccs  = 2

c 4.4.3.2 Save the new surface start position
                dpsisv    = dpsisl - dpsuccs
                rstp(1)   = rst1
                zstp(1)   = zst1
c
c 4.4.3.3 Print the successful mapping and a warning if the last
c         iteration was reached and return
                if    (mapcntr .lt. mapmax) then
                  write(kutty,2500) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpfaild, dpsuccs, dpsidif, dpsicon
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  write(kuout,2500) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpfaild, dpsuccs, dpsidif, dpsicon
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  write(kuout,2510) dpsisl,  dpsisd,  dpsist,  dpsisv
     &                             ,dpsidec0,dpsidec1,dpsidec
     &                             ,psimax0, psilim0, psimax1, psilim1
     &                             ,psimax,  psilim
                elseif(mapcntr .eq. mapmax) then
                  write(kutty,2520) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpfaild, dpsuccs, dpsidif, dpsicon
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  write(kuout,2520) maperr,  mapcntr, mapmax,  mapsuccs
     &                             ,dpfaild, dpsuccs, dpsidif, dpsicon
     &                             ,dpsidec, dpsisv,  psilim0, psilim
                  call abortjob
     &        ('setdpsi ',  8,   'Bisection did not fully converge    '
     &        ,'mapcntr ', mapcntr,  'mapsuccs', mapsuccs,  0)
                  write(kuout,2530) dpsisl,  dpsisd,  dpsist,  dpsisv
     &                             ,dpsidec0,dpsidec1,dpsidec
     &                             ,psimax0, psilim0, psimax1, psilim1
     &                             ,psimax,  psilim
                endif
c
                write(kutty,2550) mapcntr,mapsuccs,dpsisv,psilim
                write(kuout,2550) mapcntr,mapsuccs,dpsisv,psilim
                return
c
c 4.4.5 Redo previous successful iteration if bisection converged or
c       if maximum iterations
c       is reached but the last iteration failed
c
              elseif(maperr  .ne.   0   ) then
                mapcntr   = mapcntr - 1
                dpsidec   = dpsuccs
                write(kutty,2600) dpsidec, dpfaild, dpsuccs
                write(kuout,2600) dpsidec, dpfaild, dpsuccs
                go to 100
              endif
            endif
c
c
c 4.5 Set the data and return for the last iteration redone
c
          elseif(mapsuccs .eq. +2) then
c
c 4.5.1 Check the mapping was successful as it should be
c
            if(maperr .ne. 0) then
              write(kutty,2610) maperr,  mapcntr, mapmax,  mapsuccs
     &                         ,dpfaild, dpsuccs, dpsidec, dpsisw
     &                         ,psilim0, psilim
              write(kuout,2610) maperr,  mapcntr, mapmax,  mapsuccs
     &                         ,dpfaild, dpsuccs, dpsidec, dpsisw
     &                         ,psilim0, psilim
              write(kuout,2620) dpsisl,  dpsisd,  dpsist,  dpsisw
     &                         ,dpsidec0,dpsidec1,dpsidec
     &                         ,psimax0, psilim0, psimax1, psilim1
     &                         ,psimax,  psilim
              if(dpsidec .eq. dpsuccs) call abortjob
     &        ('setdpsi ',  9,   'Failed to find Last Closed Flux     '
     &        ,'maperr  ', maperr,   'mapsuccs', mapsuccs, +1)
              if(dpsidec .ne. dpsuccs) call abortjob
     &        ('setdpsi ', 10,   'Failed to find Last Closed Flux     '
     &        ,'maperr  ', maperr,   'mapsuccs', mapsuccs, +1)
            endif
c
c 4.5.2 Save the new surface start position
c
            dpsisv    = dpsisl - dpsidec
            rstp(1)   = rst1
            zstp(1)   = zst1
c
c 4.5.3 Print the successful mapping and a warning if the last iteration was reached and return
c
              write(kutty,2700) maperr,  mapcntr, mapmax,  mapsuccs
     &                         ,dpfaild, dpsuccs, dpsidec, dpsisv
     &                         ,psilim0, psilim
              write(kuout,2700) maperr,  mapcntr, mapmax,  mapsuccs
     &                         ,dpfaild, dpsuccs, dpsidec, dpsisv
     &                         ,psilim0, psilim
c
            if(mapcntr .eq. mapmax) then
              call abortjob
     &        ('setdpsi ', 11,   'Bisection did not fully converge    '
     &        ,'mapcntr ', mapcntr,  'mapsuccs', mapsuccs,  0)
            endif
            write(kuout,2710) dpsisl,  dpsisd,  dpsist,  dpsisv
     &                       ,dpsidec0,dpsidec1,dpsidec
     &                       ,psimax0, psilim0, psimax1, psilim1
     &                       ,psimax,  psilim
c
            write(kutty,2750) mapcntr,mapsuccs,dpsisv,psilim
            write(kuout,2750) mapcntr,mapsuccs,dpsisv,psilim
            return
          endif
c
c
c 4.6 End of loop over iterations
c
      endif
c
c
c
c 5.0 Return and end
c
      return
 1000     format(//,1x, 'No iteration done for Last Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'mapmax   = ',i5,/
     &             ,1x, '-- --------- --- --- ----- ------ ----'
     &                 ,' -------',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9,/)
 2000     format(//,1x, 'Beginning iteration to find Last Closed'
     &                 ,' Flux Surface:'
     &             ,4x, 'mapmax   = ',i5,/
     &             ,1x, '--------- --------- -- ---- ----  -----'
     &                 ,' ---- -------',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9)
 2100     format(/, 5x,'First Successful mapping of Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2110     format(/, 5x, 'Unsuccessful mapping of Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2120     format(/ ,5x, 'Successful mapping of Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2130     format(/, 5x, 'Unsuccessful mapping of Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2150     format(/, 5x, 'Data From Attempted Mapping of Closed Flux'
     &                 ,' Surface:',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9
     &             ,4x, 'dpsist   = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 2200     format(//,1x, 'Returning After Successful Mapping of Last'
     &                 ,' Closed Flux Surface on First Iteration',/
     &             ,1x, '--------- ----- ---------- ------- -- ----'
     &                 ,' ------ ---- ------- -- ----- ---------',/
     &             ,24x,'No Additional Decrement:'
     &             ,4x, 'maperr   = ',i5,/     
     &             ,24x,'-- ---------- ---------',/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2210     format(//,1x, 'Returning After Successful Mapping of Last'
     &                 ,' Closed Flux Surface on Last Iteration:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,1x, '--------- ----- ---------- ------- -- ----'
     &                 ,' ------ ---- ------- -- ---- ---------',/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2220     format(/, 5x, 'Data Returned From Final Successful Mapping'
     &                 ,' of Last Closed Flux Surface:',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9
     &             ,4x, 'dpsist   = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9
     &             ,4x, 'dpsidec  = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 2250     format(/, 1x, 'Completed Mapping of Last Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'mapcntr  = ',i5,2x,   'mapsuccs = ',i5,/
     &             ,1x, '--------- ------- -- ---- ------ ----'
     &                 ,' -------',/
     &             ,5x, 'dpsisv   = ',e16.9,4x,'psilim   = ',e16.9,/)
 2300     format(/, 5x, 'Beginning  Bisection Search for Last Closed'
     &                 ,' Flux Surface:',/
     &             ,5x, 'New increment dpsidec  = ',e16.9,/
     &             ,5x, 'dpfaild  = ',e16.9,4x,'dpsuccs  = ',e16.9)
 2310     format(/, 5x, 'Continue Search for Last Closed Flux'
     &                 ,' Surface:',/
     &             ,5x, 'New increment dpsidec  = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9)
 2400     format(/, 5x, 'Continuing Bisection Search for Last Closed'
     &                 ,' Flux Surface:',/
     &             ,5x, 'New increment dpsidec  = ',e16.9,/
     &             ,5x, 'dpfaild  = ',e16.9,4x,'dpsuccs  = ',e16.9)
 2500     format(//,1x, 'Successful Convergence of Bisection'
     &                 ,' Iteration for Last Closed Flux Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,1x, '---------- ----------- -- ---------'
     &                 ,' --------- --- ---- ------ ---- -------',/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpfaild  = ',e16.9,4x,'dpsuccs  = ',e16.9,/
     &             ,5x, 'dpsidif  = ',e16.9,4x,'dpsicon  = ',e16.9,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2510     format(/, 5x, 'Data Returned From Final Successful Converged'
     &                 ,'  Mapping of Last Closed Flux Surface:',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9
     &             ,4x, 'dpsist   = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9
     &             ,4x, 'dpsidec  = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 2520     format(//,5x, 'Bisection Iteration Not Yet Converged'
     &                 ,' for Last Closed Flux Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpfaild  = ',e16.9,4x,'dpsuccs  = ',e16.9,/
     &             ,5x, 'dpsidif  = ',e16.9,4x,'dpsicon  = ',e16.9,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2530     format(/, 5x, 'Data Returned From Final Mapping'
     &                 ,'  of Last Closed Flux Surface:',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9
     &             ,4x, 'dpsist   = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9
     &             ,4x, 'dpsidec  = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 2550     format(/, 1x, 'Completed Mapping of Last Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'mapcntr  = ',i5,2x,   'mapsuccs = ',i5,/
     &             ,1x, '--------- ------- -- ---- ------ ----'
     &                 ,' -------',/
     &             ,5x, 'dpsisv   = ',e16.9,4x,'psilim   = ',e16.9,/)
 2600     format(/, 5x, 'Last Bisection iteration failed: Recompute'
     &                 ,' Previous Successful Mapping: dpsidec = '
     &                 ,e16.9,/
     &             ,5x, 'dpfaild  = ',e16.9,4x,'dpsuccs  = ',e16.9)
 2610     format(//,5x, 'Re-mapping of Last Closed Flux Surface'
     &                 ,' Failed:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2620     format(/, 5x, 'Data From Re-mapping of Last Closed Flux'
     &                 ,' Surface:',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9
     &             ,4x, 'dpsist   = ',e16.9,4x,'dpsisw   = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9
     &             ,4x, 'dpsidec  = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 2700     format(//,1x, 'Successful Re-mapping of Final Last Closed'
     &                 ,' Flux Surface:'
     &             ,4x, 'maperr   = ',i5,/
     &             ,1x, '---------- ---------- -- -----  ---- -----'
     &                 ,' ---- -------',/
     &             ,5x, 'mapcntr  = ',i5,15x,  'mapmax   = ',i5
     &             ,15x,'mapsuccs = ',i5,/
     &             ,5x, 'dpfaild  = ',e16.9,4x,'dpsuccs  = ',e16.9,/
     &             ,5x, 'dpsidec  = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'psilim0  = ',e16.9,4x,'psilim   = ',e16.9)
 2710     format(/, 5x, 'Data Returned From Final Successful'
     &                 ,' Re-mapping of Last Closed Flux Surface:',/
     &             ,5x, 'dpsisl   = ',e16.9,4x,'dpsisd   = ',e16.9
     &             ,4x, 'dpsist   = ',e16.9,4x,'dpsisv   = ',e16.9,/
     &             ,5x, 'dpsidec0 = ',e16.9,4x,'dpsidec1 = ',e16.9
     &             ,4x, 'dpsidec  = ',e16.9,/
     &             ,5x, 'psimax0  = ',e16.9,4x,'psilim0  = ',e16.9,/
     &             ,5x, 'psimax1  = ',e16.9,4x,'psilim1  = ',e16.9
     &             ,4x, 'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 2750     format(/, 1x, 'Completed Mapping of Last Closed Flux'
     &                 ,' Surface:'
     &             ,4x, 'mapcntr  = ',i5,2x,   'mapsuccs = ',i5,/
     &             ,1x, '--------- ------- -- ---- ------ ----'
     &                 ,' -------',/
     &             ,5x, 'dpsisv   = ',e16.9,4x,'psilim   = ',e16.9,/)
      end
      subroutine compmsh(npsi1,ndblt,nmax,pspak,psinc,psimaxw,psilimw
     &                  ,psisepw,delpsirw,nsep,psiv,psiv1)
c
c -------------------------------------------------------------
c  Construct default flux mesh
c  Input:   npsi1,ndblt,nmax,pspak,psinc,psimaxw,psilimw,psisepw,delpsirw
c  Output:  nsep,psiv(npsi1),psiv1(npsi1+1)
c -------------------------------------------------------------
c
      dimension psiv(npsi1),psiv1(npsi1+1)
c
c
c
c 1.0 Set the mesh in psiv
c
c 1.1 Initialize parameters
c
      npsi        = npsi1 - 1
c
c
c 1.2 Set the mesh for an asymmetric dee
c     The mesh is equally spaced over npsi points with an additional
c     point added close to the magnetic axis
c
      if    (nmax .eq. 1) then
        nsep           = npsi1
        nsrf0          = npsi1
        if    (psinc .le. 0.0  .or.   psinc .ge. 1.0) then
          nsrf1     = npsi1
          psincv    = 0.0
        elseif(psinc .gt. 0.0  .and.  psinc .lt. 1.0) then
          nsrf1     = npsi
          psincv    = psinc
        endif
        nsrf2          = nsrf1 - 1
        dpsi           = delpsirw/(nsrf2**pspak)
        if(psincv .ge. 0.5) psincp1    = 0.4
        if(psincv .lt. 0.5) psincp1    = psincv 
        psiv  (  1  )  = psilimw
        psiv  (nsrf0)  = psimaxw
        psiv  (nsrf1)  = psimaxw + 2.0*dpsi*psincp1
        do 100 jv      = 2,nsrf2
        psiv  (jv)     = psimaxw + ((nsrf1-jv)**pspak)*dpsi
  100   continue
c
c
c 1.3 Set the mesh for a Doublet
c
      elseif(nmax .eq. 2) then
        dincr        = 1.0 - psinc
        npsim        = npsi-1
        dpsi         = psisepw - psilimw
        dpsi2        = psimaxw - psisepw
        nsep0        = npsim*dpsi/(dpsi + dpsi2)  +  dincr
        dpsi         = dpsi/(nsep0**pspak)
        do 110 jv    = 1,nsep0
        psiv  (jv)   = psilimw + ((jv-1.0)**pspak)*dpsi
  110   continue
c
        nsep         = nsep0+1
        psiv  (nsep) = psisepw
        do 120 jv    = nsep+1,npsim
        psiv  (jv)   = psisepw + (jv-nsep)*dpsi
  120   continue
        psiv  (npsi) = 0.5*(psimaxw + psiv  (npsi-1))
c
c
c 1.4 Other cases: Print error if nmax is not one or two
c
      elseif(nmax .lt. 1) then
        call abortjob
     &        ('compmsh ',  1,   'nmax is  less   than one            '
     &        ,'ndblt   ', ndblt,    'nmax    ', nmax,     +1)
c
      elseif(nmax .gt. 2) then
        call abortjob
     &        ('compmsh ',  2,   'nmax is greater than two            '
     &        ,'ndblt   ', ndblt,    'nmax    ', nmax,     +1)
      endif
c
c
c 1.4 Reset psi to midpoint of intervals
c
      psiv  (npsi1)  = psimaxw
      do 200 jv      = 1,npsi
      psiv  (jv)     = 0.5*(psiv(jv) + psiv(jv+1))
  200 continue
c
c
c
c 2.0 Set psiv1 array to cover the range from psilimw to psimaxw
c     for use in runkut
c
      do 500 jv      = 1,npsi
      jv1            = jv+1
      psiv1 (jv1)    = psiv  (jv)
  500 continue
c
      psiv1 (   1  ) = psilimw
      psiv1 (npsi+2) = psimaxw
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine reseteq
c
c -------------------------------------------------------------
c  Reset the equilibrium data
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension zpsin(npp)
      dimension zpr(npp),zpp(npp),zf(npp),zffp(npp),zdns(npp),zfst(npp)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize smallno and reset flag
c
      mreset     = 0
      smallno    = abs(roundff)
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('reseteq ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Check consistency of btor with sf
c
c 1.3.1 Compare btor and sf/r
c
      btorsf     = sf(nprofl)/rcnt
      btscale    = abs(btorsf) + abs(btor)
c
c 1.3.2 Print a warning if different
c
      if(abs(btorsf-btor)   .gt. tolbtor*btscale) then
        call abortjob
     &        ('reseteq ',  2,   'btor and sf(nprofl) inconsistent    '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
        write(kuout,1000) btor,btorsf,sf(nprofl),rcnt
c
c 1.3.3 Check if btor and sf are simply opposite sign and reset btor
c
        if(abs(btorsf+btor)   .le. tolbtor*btscale) then
          call abortjob
     &        ('reseteq ',  3,   'btor has the wrong sign cf sf(1)    '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
          mreset   = -1
          btor     = -btor
        endif
      endif
c
c
c
c 2.0 Reverse the sign of the toroidal field if btor is negative.
c     otherwise, the safety factor q is negative.
c
      if( ktype .lt. 2 ) then
        if(btor .lt. 0.0  .and.  sf(1) .lt. 0.0) then
          if(mreset .eq. 0) mreset   = +1
          if(mreset .ne. 0) mreset   = -1
c
c
c 2.1 Reverse btor and the toroidal field function
c
c 2.1.1 Check the sign of sf(nprofl) as well
c
          if(sf(nprofl) .lt. 0) ksgnsf  = -1
          if(sf(nprofl) .eq. 0) ksgnsf  =  0
          if(sf(nprofl) .gt. 0) ksgnsf  = +1
c
c 2.1.2 Print a warning
c
          call abortjob
     &        ('reseteq ',  4,   'Switching sign of btor and sf       '
     &        ,'ktype   ', ktype,    'ksgnsf  ', ksgnsf,    0)
c
c 2.1.3 Switch the sign of btor and the sf profile
c
          btor       = -btor
          do 100 i   = 1,nprofl
          sf  (i)    = -sf  (i)
 100      continue
c
c
c 2.2 Reverse the input q profile if needed
c
          if(ktype .eq. 1) then
            if(mreset .eq. 0) mreset   = +2
            if(mreset .ne. 0) mreset   = -2
c
c 2.2.1 Check if psimsh(1) .gt. psimsh(nprofl)
c
            if(psimsh(1) .gt. psimsh(nprofl))
     &         call abortjob
     &        ('reseteq ',  5,   'Switch bt: psimsh(1)>psimsh(np)     '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
            if(psimsh(1) .lt. psimsh(nprofl))
     &         call abortjob
     &        ('reseteq ',  6,   'Switch bt: psimsh(1)<psimsh(np)     '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
c
c 2.2.2 Reverse the profiles
c
            do 110 i   = 1,nprofl
            sqvl(i)    = -sqvl(i)
            sfqi(i)    = -sfqi(i)
 110        continue
          endif
        endif
      endif
c
c
c 2.3 Write out the input equilibrium profiles with reset signs
c
      if(mreset .ne. 0) then
        write(kuout,2000) mreset,npst
        write(kuout,2010)
        write(kuout,2020)
        do 150 jv  = 1,nprofl
        jvl        = jv
        write(kuout,2030) jvl, psimsh(jvl), sf    (jvl), sp    (jvl)
     &                       , sffp  (jvl), spp   (jvl), sdns  (jvl)
  150   continue
      endif
c
c
c
c 3.0 Reset the density and fast pressure profiles as needed
c
c 3.1 Reset the density profile
c
c 3.1.1 Normalize the density profile and save the normalization
c
      if    (idnsty .lt. 0) then
         dnnorm  = 1.0
      elseif(idnsty .eq. 0) then
         dnnorm  = 1.0
      elseif(idnsty .gt. 0) then
         if(sdns(1) .le. 0.0) dnnorm  = 1.0
         if(sdns(1) .gt. 0.0) dnnorm  = sdns(1)
      endif
c
c 3.1.2 Renormalize or set the density profile if not read in
c
      dpfact     = delpsir1
      do 200 jd  = 1,nprofl
      sfactor    = sqrt(abs((psimsh(jd) - psimax1)/dpfact))
c
      if(idnsty .lt. 0) then
         if    (idnsty .eq. -1) then
            sfact0  =  1.0
            sfact1  = (1.0 - sfactor**iabs(ndnxp1))**iabs(ndnxp2)
         elseif(idnsty .eq. -2) then
            sfact0  = sfactor**iabs(ndnxp0)
            sfact1  =  1.0
         elseif(idnsty .eq. -3) then
            sfact0  = sfactor**iabs(ndnxp0)
            sfact1  = (1.0 - sfactor**iabs(ndnxp1))**iabs(ndnxp2)
         endif
         sdns(jd) = sfact0*sfact1/dnnorm
c
      elseif(idnsty .eq. 0) then
         sdns(jd) = 1.0    /dnnorm
c
      elseif(idnsty .gt. 0) then
         if(ndnxp0 .eq. 0) sdns(jd) =  sdns(jd)/dnnorm
         if(ndnxp0 .ne. 0) sdns(jd) = (sdns(jd)*sfactor**iabs(ndnxp0))
     &                                         /dnnorm
      endif
  200 continue
c
c
c 3.2 Reset the fast ion pressure profile
c
c 3.2.1 Reset the fast ion profile on the psimsh mesh if read in
c
      if    (ifastp .gt. 0) then
c
c 3.2.1.1 Set up the cubic spline interpolation coefficients for the profile
c
c 3.2.1.1.1 Set up the extrapolation coefficients
      nfbcnd     = nspbc0
      nfast1     = nfast - 1
      nfast2     = nfast - 2
      delx21     = spsif(   2  ) - spsif(   1   )
      delx32     = spsif(   3  ) - spsif(   2   )
      delx31     = spsif(   3  ) - spsif(   1   )
      delxn1     = spsif(nfast)  - spsif(nfast1)
      delxnx     = spsif(nfast1) - spsif(nfast2)
      delxn2     = spsif(nfast)  - spsif(nfast2)
      dr3132     = delx31/delx32
      dr2132     = delx21/delx32
      drn2nx     = delxn2/delxnx
      drn1nx     = delxn1/delxnx
      if    (nfbcnd .le. 0) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      elseif(nfbcnd .eq. 1) then
        xtrap1     = 1.0
        xtrap1p    = 0.0
        xtrapn     = 1.0
        xtrapnp    = 0.0
      elseif(nfbcnd .eq. 2) then
        xtrap1     = +dr3132
        xtrap1p    = -dr2132
        xtrapn     = +drn2nx
        xtrapnp    = -drn1nx
      elseif(nfbcnd .gt. 2) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      endif
c
c 3.2.1.1.2 Set up the spline coefficients for the spline boundary conditions
      sf2pp      = f2sx(   2  ,sfast,spsif,nfast)
      sf3pp      = f2sx(   3  ,sfast,spsif,nfast)
      sfn1pp     = f2sx(nfast1,sfast,spsif,nfast)
      sfn2pp     = f2sx(nfast2,sfast,spsif,nfast)
c
      sfbc11     = xtrap1*sf2pp   + xtrap1p*sf3pp
      sfbcnn     = xtrapn*sfn1pp  + xtrapnp*sfn2pp
c
c 3.2.1.1.2.1 Set the boundary conditions at the endpoint from the second
c             derivatives
      if    (nfbcnd .ge.  0  .and.  nfbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfbcnn
c
c 3.2.1.1.2.2 Use natural boundary conditions at the plasma surface but force
c             a near floating condition at the axis
      elseif(nfbcnd .gt. +2) then
        bigval     = abs(float(nfbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spn1pp
c
c 3.2.1.1.2.3 Use a floating condition at both ends
      elseif(nfbcnd .lt.  0) then
        bigval     = abs(float(nfbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 3.2.1.2 Compute the spline coefficients
c
c 3.2.1.2.1 Compute the spline coefficients 
        call icsici(spsif,sfast,nfast,bcb,csfst,npb,ier)
c
c 3.2.1.2.2 Set the profile on the psimsh mesh to zero if there is an
c         interpolation error
        if(ier .ne. 0) then
          call abortjob
     &        ('reseteq ',  7,   'Interpolation error: sfast(psif)    '
     &        ,'ier     ', ier,      'nfast   ', nfast,    -1)
          do 210 jv  = 1,nprofl
          spfst(jv)  = 0.0
  210     continue
c
c 3.2.1.3 Interpolate the profile from spsif mesh to the psimsh mesh
        elseif(ier .eq. 0) then
          kferr      = 0
          do 215 jv  = 1,nprofl
          ps         = psimsh(jv)
          zfast      = sterpl(ps,spsif,sfast,csfst, nfast,npb,0,
     &                                 smallno,ierf)
          if(ierf .ne. 0) then
            call abortjob
     &        ('reseteq ',  8,   'Interpolation error for sfast(j)    '
     &        ,'ierf    ', ierf,     'jv      ', jv,       -1)
            kferr    = kferr + 1
          endif
          spfst(jv)  =  zfast
  215     continue
c
          if(kferr .ne. 0) then
            write(kuout,2100) nfast,nprofl,kferr
            write(kuout,2110)
            write(kuout,2120) (spsif(kf),kf = 1,nfast)
            write(kuout,2130)
            write(kuout,2140) (psimsh(jvv),jvv = 1,nprofl)
          endif
        endif
c
c 3.2.2 Construct the fast particle pressure from the thermal pressure
c
      elseif(ifastp .le. 0) then
c
c 3.2.2.1 Check nfast equals nprofl if no profile is read in
        if(nfast .ne. nprofl) then
          call abortjob
     &        ('reseteq ',  9,   'nfast is not set correctly          '
     &        ,'nfast   ', nfast,    'nprofl  ', nprofl,   -1)
          nfast      = nprofl
        endif
c
c 3.2.2.2 Set the fast particle pressure zero for ifastp = 0
        if    (ifastp .eq. 0) then
          do 220 jv  = 1,nprofl
          spfst(jv)  = 0.0
  220     continue
c
c
c 3.2.2.3 Set the fast particle pressure from the thermal pressure for ifastp < 0
        elseif(ifastp .lt. 0) then
          do 230 jv  = 1,nprofl
          pfactor    = (sp(1)  - sp(nprofl))
          pressr     = (sp(jv) - sp(nprofl))
          fpress     = (pressr/pfactor)**iabs(ifastp)
          spfst(jv)  =  fpress
  230     continue
        endif
      endif
c
c
c 3.3 Renormalize the fast particle pressure and save the normalization
c
c 3.3.1 Save the normalization
c
c 3.3.1.1 Set the normalization at 1.0 if there is no fast ion profile
      if    (ifastp .eq. 0) then
        pfnorm      = 1.0
c
c 3.3.1.2 Set the normalization if the fast ion profile is defined 
      elseif(ifastp .ne. 0) then
        pfnorm      = abs(spfst(1))
        if(abs(pfnorm) .le. smallno) then
          call abortjob
     &        ('reseteq ', 10,   'Normalization spfst(1) is zero      '
     &        ,'nfast   ', nfast,    'nprofl  ', nprofl,   -1)
          pfmax      = 0.0
          do 240 jv  = 1,nprofl
          if(abs(spfst(jv)) .ge. pfmax) pfmax  = abs(spfst(jv))
  240     continue
c
          pfnorm     = pfmax
        endif
c
        if(pfnorm .le. 0.0) then
          call abortjob
     &        ('reseteq ', 11,   'Normalization spfst not defined     '
     &        ,'nfast   ', nfast,    'nprofl  ', nprofl,   -1)
          pfnorm    = 1.0
        endif
      endif
c
c 3.3.2 Renormalize the profile
c
c 3.3.2.1 Renormalize the input profile to unity on axis
      pfnorm0     = pfnorm
c
      do 250 jv   = 1,nprofl
      spfst(jv)   = spfst(jv) / pfnorm0
  250 continue
c
c 3.3.2.2 Reset the units if the fast particle profile is read in
c
c         This is achieved by modifying the pfnorm factor
c         For ifastp =  +1 read in row form: profile in  Pa versus psi
c         For ifastp =  +2 read in row form: profile in kPa versus psi
c         For ifastp =  +3 read in row form: profile in MPa versus psi
c         For ifastp =  +4 read in row form: profile in 2mu0/B**2 versus psi
c         For ifastp =  +5 read in row form: profile in  Pa versus psinorm
c         For ifastp =  +6 read in row form: profile in kPa versus psinorm
c         For ifastp =  +7 read in row form: profile in MPa versus psinorm
c         For ifastp =  +8 read in row form: profile in 2mu0/B**2 versus psinorm
c         For ifastp =  +9 read in column form: profile in  Pa versus psi
c         For ifastp = +10 read in column form: profile in kPa versus psi
c         For ifastp = +11 read in column form: profile in MPa versus psi
c         For ifastp = +12 read in column form: profile in 2mu0/B**2 versus psi
c         For ifastp = +13 read in column form: profile in  Pa versus psinorm
c         For ifastp = +14 read in column form: profile in kPa versus psinorm
c         For ifastp = +15 read in column form: profile in MPa versus psinorm
c         For ifastp = +16 read in column form: profile in 2mu0/B**2 versus psinorm
c         For ifastp <  0 the profile is constructed from the thermal pressure in Pa
      if(ifastp .gt. 0) then
        if(ifastp .eq.  +1  .or.  ifastp .eq.  +5  .or.
     &     ifastp .eq.  +9  .or.  ifastp .eq. +13) prfactr = 1.0
        if(ifastp .eq.  +2  .or.  ifastp .eq.  +6  .or.
     &     ifastp .eq. +10  .or.  ifastp .eq. +14) prfactr = 1.0e+03
        if(ifastp .eq.  +3  .or.  ifastp .eq.  +7  .or.
     &     ifastp .eq. +11  .or.  ifastp .eq. +15) prfactr = 1.0e+06
        if(ifastp .eq.  +4  .or.  ifastp .eq.  +8  .or.
     &     ifastp .eq. +12  .or.  ifastp .eq. +16) prfactr = 
     &                                                btor**2/(2.0*amu)
        pfnorm    = pfnorm * prfactr
      endif
c
c
c
c 4.0 Check that the input pressure and density are non-negative
c
c 4.1 Check for any negative values
c
      kpzer      = 0
      kdzer      = 0
      kfzer      = 0
      kpneg      = 0
      kdneg      = 0
      kfneg      = 0
      jpnegmx0   = 0
      jdnegmx0   = 0
      jfnegmx0   = 0
      spnegmx0   = 0.0
      sdnegmx0   = 0.0
      sfnegmx0   = 0.0
      do 300 j   = 1,nprofl
      if(sp   (j) .eq. 0.0) kpzer  = kpzer  + 1
      if(sp   (j) .lt. 0.0) then
        if(sp  (j) .le. spnegmx0) then
          jpnegmx0   = j
          spnegmx0   = sp  (j)
        endif
        kpneg      = kpneg  + 1
        sp   (j)   = 0.0
      endif
c
      if(sdns (j) .eq. 0.0) kdzer  = kdzer  + 1
      if(sdns (j) .lt. 0.0) then
        if(sdns (j) .le. sdnegmx0) then
          jdnegmx0   = j
          sdnegmx0   = sdns(j)
        endif
        kdneg      = kdneg  + 1
        sdns (j)   = 0.0
      endif
c
      if(spfst(j) .eq. 0.0) kfzer  = kfzer  + 1
      if(spfst(j) .lt. 0.0) then
        if(spfst(j) .le. sfnegmx0) then
          jfnegmx0   = j
          sfnegmx0   = spfst(j)
        endif
        kfneg      = kfneg  + 1
        spfst(j)   = 0.0
      endif
  300 continue
c
      if(kpneg  .gt. 0) then
        call abortjob
     &        ('reseteq ', 12,   'Input pressure is negative          '
     &        ,'kpneg   ', kpneg,    'nprofl  ', nprofl,   -1)
        write(kuout,3000) jpnegmx0,spnegmx0
      endif
c
      if(kdneg  .gt. 0) then
        call abortjob
     &        ('reseteq ', 13,   'Input density  is negative          '
     &        ,'kdneg   ', kdneg,    'nprofl  ', nprofl,   -1)
        write(kuout,3010) jdnegmx0,sdnegmx0
      endif
c
      if(kfneg  .gt. 0) then
        call abortjob
     &        ('reseteq ', 14,   'Input fast ion pressure negative    '
     &        ,'kfneg   ', kfneg,    'nprofl  ', nprofl,   -1)
        write(kuout,3020) jfnegmx0,sfnegmx0
      endif
c
c
c 4.2 Check specifically the on-axis pressure and density
c
c 4.2.1 Check for negative value on axis
c
      if(sp   (1) .lt. 0.0) call abortjob
     &        ('reseteq ', 15,   'Input axis pressure is negative     '
     &        ,'kpneg   ', kpneg,    'kpzer   ', kpzer,    -1)
      if(sdns (1) .lt. 0.0) call abortjob
     &        ('reseteq ', 16,   'Input axis density  is negative     '
     &        ,'kdneg   ', kdneg,    'kdzer   ', kdzer,    -1)
      if(spfst(1) .lt. 0.0) call abortjob
     &        ('reseteq ', 17,   'Input axis fast ion p negative      '
     &        ,'kfneg   ', kfneg,    'kfzer   ', kfzer,    -1)
c
c 4.2.2 Check for zero value on axis
c
      if(sp  (1) .eq. 0.0) call abortjob
     &        ('reseteq ', 18,   'Input axis pressure is zero         '
     &        ,'kpzer   ', kpzer,    'kpneg   ', kpneg,    -1)
      if(sdns(1) .eq. 0.0) call abortjob
     &        ('reseteq ', 19,   'Input axis density  is zero         '
     &        ,'kdzer   ', kdzer,    'kdneg   ', kdneg,    -1)
      if(ifastp .ne. 0  .and.  spfst(1) .eq. 0.0) call abortjob
     &        ('reseteq ', 20,   'Input axis fastion pressure zero    '
     &        ,'kfzer   ', kfzer,    'kfneg   ', kfneg,    -1)
c
c
c 4.3 Write out the new tables
c
      if(kpneg .gt. 0  .or.  kdneg .gt. 0  .or.  kfneg .gt. 0  .or.
     &   sp   (1) .le. 0.0  .or.  sdns (1) .le. 0.0  .or.
     &     (ifastp .ne. 0  .and.  spfst(1) .le. 0.0)) then
        write(kuout,3050) kpneg,kdneg,kfneg,kpzer,kdzer,kfzer
        write(kuout,3060)
        do 350 jv  = 1,nprofl
        jvl        = jv
        write(kuout,3070) jvl,psimsh(jvl),sp   (jvl),sdns (jvl)
     &                                              ,spfst(jvl)
  350   continue
      endif
c
c
c
c 5.0 Reset psilim, f, p, ffp, pp, dnsty, and pfast to the new plasma boundary
c
c 5.1 Set dpslv
c
      dpslv      = dpsisv
c
c
c 5.2 Interpolate the input profiles to the rescaled mesh
c
c 5.2.1 Set up the extrapolation coefficients
c
      nsbcnd     = nspbc0
      nprofl1    = nprofl - 1
      nprofl2    = nprofl - 2
      delx21     = psimsh(   2   ) - psimsh(   1   )
      delx32     = psimsh(   3   ) - psimsh(   2   )
      delx31     = psimsh(   3   ) - psimsh(   1   )
      delxn1     = psimsh(nprofl)  - psimsh(nprofl1)
      delxnx     = psimsh(nprofl1) - psimsh(nprofl2)
      delxn2     = psimsh(nprofl)  - psimsh(nprofl2)
      dr3132     = delx31/delx32
      dr2132     = delx21/delx32
      drn2nx     = delxn2/delxnx
      drn1nx     = delxn1/delxnx
      if    (nsbcnd .le. 0) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      elseif(nsbcnd .eq. 1) then
        xtrap1     = 1.0
        xtrap1p    = 0.0
        xtrapn     = 1.0
        xtrapnp    = 0.0
      elseif(nsbcnd .eq. 2) then
        xtrap1     = +dr3132
        xtrap1p    = -dr2132
        xtrapn     = +drn2nx
        xtrapnp    = -drn1nx
      elseif(nsbcnd .gt. 2) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      endif
c
c 5.2.2 Set up the cubic spline interpolation coefficients for the
c       profiles sf, sp, sffp, spp, sdns, and spfst
c       Note that for npst = 1 sp and sffp are interpolated but not used
c
c 5.2.2.1 Set up the spline coefficients for the spline boundary conditions
c         for the toroidal field function sf
c
c 5.2.2.1.1 Set the second derivatives at the endpoints
      sf2pp      = f2sx(   2   ,sf,  psimsh,nprofl)
      sf3pp      = f2sx(   3   ,sf,  psimsh,nprofl)
      sfn1pp     = f2sx(nprofl1,sf,  psimsh,nprofl)
      sfn2pp     = f2sx(nprofl2,sf,  psimsh,nprofl)
c
      sfbc11     = xtrap1*sf2pp  + xtrap1p*sf3pp
      sfbcnn     = xtrapn*sfn1pp + xtrapnp*sfn2pp
c
c 5.2.2.1.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfbcnn
c
c 5.2.2.1.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfn1pp
c
c 5.2.2.1.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 5.2.2.2 Compute the spline coefficients for sf
      call icsici(psimsh,sf,   nprofl,bcb,csf,  npp,ierf)
      if(ierf  .ne. 0) call abortjob
     &        ('reseteq ', 21,   'Interpolation error: sf  (psimsh)   '
     &        ,'ierf    ', ierf,     'nprofl  ', nprofl,   +1)
c
c 5.2.2.3 Set up the spline coefficients for the spline boundary conditions
c         for the pressure sp
c
c 5.2.2.3.1 Set the second derivatives at the endpoints
      sp2pp      = f2sx(   2   ,sp,  psimsh,nprofl)
      sp3pp      = f2sx(   3   ,sp,  psimsh,nprofl)
      spn1pp     = f2sx(nprofl1,sp,  psimsh,nprofl)
      spn2pp     = f2sx(nprofl2,sp,  psimsh,nprofl)
c
      spbc11     = xtrap1*sp2pp  + xtrap1p*sp3pp
      spbcnn     = xtrapn*spn1pp + xtrapnp*spn2pp
c
c 5.2.2.3.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*spbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*spbcnn
c
c 5.2.2.3.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spn1pp
c
c 5.2.2.3.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 5.2.2.4 Compute the spline coefficients for sp
      call icsici(psimsh,sp,   nprofl,bcb,csp,  npp,ierp)
      if(ierp  .ne. 0) call abortjob
     &        ('reseteq ', 22,   'Interpolation error: sp(psimsh)     '
     &        ,'ierp    ', ierp,     'nprofl  ', nprofl,   +1)
c
c 5.2.2.5 Set up the spline coefficients for the spline boundary conditions
c         for the derivative of toroidal field function sffp
c
c 5.2.2.5.1 Set the second derivatives at the endpoints
      sfp2pp     = f2sx(   2   ,sffp,psimsh,nprofl)
      sfp3pp     = f2sx(   3   ,sffp,psimsh,nprofl)
      sfpn1pp    = f2sx(nprofl1,sffp,psimsh,nprofl)
      sfpn2pp    = f2sx(nprofl2,sffp,psimsh,nprofl)
c
      sfpbc11    = xtrap1*sfp2pp  + xtrap1p*sfp3pp
      sfpbcnn    = xtrapn*sfpn1pp + xtrapnp*sfpn2pp
c
c 5.2.2.5.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfpbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfpbcnn
c
c 5.2.2.5.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sfp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfpn1pp
c
c 5.2.2.5.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sfp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 5.2.2.6 Compute the spline coefficients for sffp
      call icsici(psimsh,sffp,nprofl,bcb,csffp,npp,ierfp)
      if(ierfp .ne. 0) call abortjob
     &        ('reseteq ', 23,   'Interpolation error:sffp(psimsh)    '
     &        ,'ierfp   ', ierfp,    'nprofl  ', nprofl,   +1)
c
c 5.2.2.7 Set up the spline coefficients for the spline boundary conditions
c         for the derivative of pressure spp
c
c 5.2.2.7.1 Set the second derivatives at the endpoints
      spp2pp     = f2sx(   2   ,spp, psimsh,nprofl)
      spp3pp     = f2sx(   3   ,spp, psimsh,nprofl)
      sppn1pp    = f2sx(nprofl1,spp, psimsh,nprofl)
      sppn2pp    = f2sx(nprofl2,spp, psimsh,nprofl)
c
      sppbc11    = xtrap1*spp2pp  + xtrap1p*spp3pp
      sppbcnn    = xtrapn*sppn1pp + xtrapnp*sppn2pp
c
c 5.2.2.7.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sppbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sppbcnn
c
c 5.2.2.7.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sppn1pp

c
c 5.2.2.7.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 5.2.2.8 Compute the spline coefficients for spp
      call icsici(psimsh,spp,  nprofl,bcb,cspp, npp,ierpp)
      if(ierpp .ne. 0) call abortjob
     &        ('reseteq ', 24,   'Interpolation error: spp(psimsh)    '
     &        ,'ierpp   ', ierpp,    'nprofl  ', nprofl,   +1)
c
c 5.2.2.9 Set up the spline coefficients for the spline boundary conditions
c         for the density sdns
c
c 5.2.2.9.1 Set the second derivatives at the endpoints
      sdn2pp     = f2sx(   2   ,sdns,psimsh,nprofl)
      sdn3pp     = f2sx(   3   ,sdns,psimsh,nprofl)
      sdnn1pp    = f2sx(nprofl1,sdns,psimsh,nprofl)
      sdnn2pp    = f2sx(nprofl2,sdns,psimsh,nprofl)
c
      sdnbc11    = xtrap1*sdn2pp  + xtrap1p*sdn3pp
      sdnbcnn    = xtrapn*sdnn1pp + xtrapnp*sdnn2pp
c
c 5.2.2.9.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sdnbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sdnbcnn
c
c 5.2.2.9.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sdn2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sdnn1pp
c
c 5.2.2.9.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sdn2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 5.2.2.10 Compute the spline coefficients for sdns
      call icsici(psimsh,sdns, nprofl,bcb,csdn, npp,ierdn)
      if(ierdn .ne. 0) call abortjob
     &        ('reseteq ', 25,   'Interpolation error: sdns(psimsh)   '
     &        ,'ierdn   ', ierdn,    'nprofl  ', nprofl,   +1)
c
c 5.2.2.11 Set up the spline coefficients for the spline boundary conditions
c          for the fast ion pressure spfst
c
c 5.2.2.11.1 Set the second derivatives at the endpoints
      spf2pp     = f2sx(   2   ,spfst,psimsh,nprofl)
      spf3pp     = f2sx(   3   ,spfst,psimsh,nprofl)
      spfn1pp    = f2sx(nprofl1,spfst,psimsh,nprofl)
      spfn2pp    = f2sx(nprofl2,spfst,psimsh,nprofl)
c
      spfbc11    = xtrap1*spf2pp  + xtrap1p*spf3pp
      spfbcnn    = xtrapn*spfn1pp + xtrapnp*spfn2pp
c
c 5.2.2.11.2 Set the boundary conditions at the endpoint from the second
c            derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*spfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*spfbcnn
c
c 5.2.2.11.3 Use natural boundary conditions at the plasma surface but force
c            a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spfn1pp
c
c 5.2.2.11.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spf2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 5.2.2.12 Compute the spline coefficients for spfst
      call icsici(psimsh,spfst,nprofl,bcb,csfst, npp,ierpf)
      if(ierpf .ne. 0) call abortjob
     &        ('reseteq ', 26,   'Interpolation error: spfst(psimsh)  '
     &        ,'ierpf   ', ierpf,    'nprofl  ', nprofl,   +1)
c
c 5.2.3 Set up the new psi array
c
      zpsmax        = psimax1
      zpslim        = psilim1 + delpsir1*dpslv
      zdpsin        = (zpslim - psimax1)/float(nprofl-1)
c
      do 400 jv     = 1,nprofl-1
      zpsin(jv)     = psimsh(jv) + (psimsh(jv)-psimax1)*dpslv
  400 continue
      zpsin(nprofl) = zpslim
c
c 5.2.4 Interpolation to the new mesh
c
      do 420 j      = 1,nprofl
      jv            = j
      ps            = zpsin(jv)
      if(ps .le. psilim1) then
c
c 5.2.4.1 Interpolate sf, sp, sdns and spfst
        zf(jv)       = sterpl(ps,psimsh,sf,   csf,    nprofl,npp,0,
     &                           smallno,ierf)
        zpr(jv)      = sterpl(ps,psimsh,sp,   csp,    nprofl,npp,0,
     &                           smallno,ierp)
        zdns(jv)     = sterpl(ps,psimsh,sdns, csdn,   nprofl,npp,0,
     &                           smallno,ierd)
        zfst(jv)     = sterpl(ps,psimsh,spfst,csfst,  nprofl,npp,0,
     &                           smallno,ierb)
c
        if(ierf .ne. 0) call abortjob
     &        ('reseteq ', 27,   'Interpolation error for sf  (jv)    '
     &        ,'ierf    ', ierf,     'jv      ', jv,       -1)
        if(ierp .ne. 0) call abortjob
     &        ('reseteq ', 28,   'Interpolation error for sp  (jv)    '
     &        ,'ierp    ', ierp,     'jv      ', jv,       -1)
        if(ierd .ne. 0) call abortjob
     &        ('reseteq ', 29,   'Interpolation error for sdns(jv)    '
     &        ,'ierd    ', ierd,     'jv      ', jv,       -1)
        if(ierb .ne. 0) call abortjob
     &        ('reseteq ', 30,   'Interpolation error for spfst(j)    '
     &        ,'ierb    ', ierb,     'jv      ', jv,       -1)
c
c 5.2.4.2 For standard input profiles use spp and sffp directly (npst = 0) 
        if    (npst .eq. 0) then
          zffp(jv)    = sterpl(ps,psimsh,sffp,csffp,nprofl,npp,0,
     &                            smallno,ierff)
          if(ierff .ne. 0) call abortjob
     &        ('reseteq ', 31,   'Interpolation error for sffp(jv)    '
     &        ,'ierff   ', ierff,    'jv      ', jv,       -1)
c
          zpp(jv)     = sterpl(ps,psimsh,spp, cspp, nprofl,npp,0,
     &                            smallno,ierpp)
          if(ierpp .ne. 0) call abortjob
     &        ('reseteq ', 32,   'Interpolation error for spp (jv)    '
     &        ,'ierpp   ', ierpp,    'jv      ', jv,       -1)
c
c 5.2.4.3 For alternative profiles differentiate sp and sf (npst = 1)
        elseif(npst .eq. 1) then
          fp1         = sterpp(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                            smallno,ierfp)
          zffp(jv)    = zf(jv)*fp1
          zpp (jv)    = sterpp(ps,psimsh,sp,  csp,  nprofl,npp,0,
     &                            smallno,ierpp)
c
          if(ierfp .ne. 0) call abortjob
     &        ('reseteq ', 33,   'Differentiation error for sf(jv)    '
     &        ,'ierfp   ', ierfp,    'jv      ', jv,       -1)
          if(ierpp .ne. 0) call abortjob
     &        ('reseteq ', 34,   'Differentiation error for sp(jv)    '
     &        ,'ierpp   ', ierpp,    'jv      ', jv,       -1)
        endif
c
      elseif(ps .gt. psilim1) then
        call abortjob
     &        ('reseteq ', 35,   'Attempted interpolate psi>psilim    '
     &        ,'jv      ', jv,       'nprofl  ', nprofl,   -1)
        zf  (jv)    = sf   (nprofl)
        zpr (jv)    = sp   (nprofl)
        zdns(jv)    = sdns (nprofl)
        zfst(jv)    = spfst(nprofl)
        if    (npst .eq. 0) then
          zffp(jv)  = sffp (nprofl)
          zpp (jv)  = spp  (nprofl)
        elseif(npst .eq. 1) then
          fp1       = sterpp(psilim,psimsh,sf, csf, nprofl,npp,0,
     &                              smallno,ierfp)
          zffp(jv)  = zf(jv)*fp1
          zpp (jv)  = sterpp(psilim,psimsh,sp, csp, nprofl,npp,0,
     &                              smallno,ierpp)
c
          if(ierfp .ne. 0) call abortjob
     &        ('reseteq ', 36,   'Differentiation error for sf(jv)    '
     &        ,'ierfp   ', ierfp,    'jv      ', jv,       -1)
          if(ierpp .ne. 0) call abortjob
     &        ('reseteq ', 37,   'Differentiation error for sp(jv)    '
     &        ,'ierpp   ', ierpp,    'jv      ', jv,       -1)
        endif
      endif
  420 continue
c
c 5.2.5 Reset psilim, psimsh, sffp, spp, sf, sp, sdns, and spfst to the
c       new interpolated values
c
c 5.2.5.1 Reset psimax and psilim
      psimax         = zpsmax
      psilim         = zpslim
c
c 5.2.5.2 Reset the functions:
c         All functions including spp and sffp are defined at this point
c         Nevertheless, ffprime and pprime are continued to be calculated directly
c         from sf snd sp
      do 430 j       = 1,nprofl
      psimsh(j)      = zpsin(j)
      sffp  (j)      = zffp (j)
      spp   (j)      = zpp  (j)
      sf    (j)      = zf   (j)
      sp    (j)      = zpr  (j)
      sdns  (j)      = zdns (j)
      spfst (j)      = zfst (j)
  430 continue
      psimsh(   1  ) = psimax
      psimsh(nprofl) = psilim
c
c
c 5.3 Check the new profiles
c
c 5.3.1 Check that the new pressure and density are non-negative.
c       If not, force them to be positive
c
      kpneg          = 0
      kdneg          = 0
      kfneg          = 0
      jpnegmx1       = 0
      jdnegmx1       = 0
      jfnegmx1       = 0
      spnegmx1       = 0.0
      sdnegmx1       = 0.0
      sfnegmx1       = 0.0
      do 440 j       = 1,nprofl
c
c 5.3.1.1 Check the pressure
c         The pressure is forced to be non zero
      if(sp  (j) .lt. smallno) then
        if(sp  (j) .lt. 0.0) then
          if(sp  (j) .le. spnegmx1) then
            jpnegmx1  = j
            spnegmx1  = sp  (j)
          endif
          kpneg     = kpneg  + 1
        endif
        sp  (j)   = smallno
      endif
c
c 5.3.1.2 Check the density
c         The density is forced to be non zero
      if(sdns(j) .lt. smallno) then
        if(sdns(j) .lt. 0.0) then
          if(sdns(j) .le. sdnegmx1) then
            jdnegmx1  = j
            sdnegmx1  = sdns(j)
          endif
          kdneg     = kdneg  + 1
        endif
        sdns(j)   = smallno
      endif
c
c 5.3.1.3 Check the fast ion pressure
c         The fast ion pressure can be zero
      if(spfst(j) .lt. 0.0) then
        if(spfst(j) .le. sfnegmx1) then
          jfnegmx1  = j
          sfnegmx1  = spfst(j)
        endif
        kfneg     = kfneg  + 1
        spfst(j)  = 0.0
      endif
  440 continue
c
      if(kpneg  .gt. 0) then
        call abortjob
     &        ('reseteq ', 38,   'Negative reset pressure set zero    '
     &        ,'kpneg   ', kpneg,    'nprofl  ', nprofl,   -1)
        write(kuout,3100) jpnegmx1,spnegmx1
      endif
c
      if(kdneg  .gt. 0) then
        call abortjob
     &        ('reseteq ', 39,   'Negative reset density set small    '
     &        ,'kdneg   ', kdneg,    'nprofl  ', nprofl,   -1)
        write(kuout,3110) jdnegmx1,sdnegmx1
      endif
c
      if(kfneg  .gt. 0) then
        call abortjob
     &        ('reseteq ', 40,   'Negative fast ion p set to zero     '
     &        ,'kfneg   ', kfneg,    'nprofl  ', nprofl,   -1)
        write(kuout,3120) jfnegmx1,sfnegmx1
      endif
c
c 5.3.2 Check that the pressure and density are not identically zero
c
      kpzero         = 0
      kdzero         = 0
      do 460 j       = 1,nprofl
c
c 5.3.2.1 Check the pressure
      if(abs(sp  (j)) .le. smallno*(1.0+smallno)) then
        kpzero        = kpzero + 1
        sp  (j)       = smallno
      endif
c
c 5.3.2.2 Check the density
      if(abs(sdns(j)) .le. smallno*(1.0+smallno)) then
        kdzero        = kdzero + 1
        sdns(j)       = smallno
      endif
  460 continue
c
      if(kpzero .eq. nprofl) call abortjob
     &        ('reseteq ', 41,   'Final pressure identically zero     '
     &        ,'kpzero  ', kpzero,   'nprofl  ', nprofl,   -1)
c
      if(kdzero .eq. nprofl) call abortjob
     &        ('reseteq ', 42,   'Final density  identically zero     '
     &        ,'kdzero  ', kdzero,   'nprofl  ', nprofl,   -1)
c
c
c 5.3.3 Check for smallness of the new sf
c
c 5.3.3.1 Find the maximum of sf
      sfmax          = 0.0
      do 500 jj      = 1,nprofl
      if(abs(sf(jj)) .gt. sfmax) sfmax  = abs(sf(jj))
  500 continue
c
c 5.3.3.2 Reset sf  if small everywhere
      if    (sfmax .le. smallno) then
c
c 5.3.3.2.1 Reset sf to be finite if identically zero
        if    (sfmax .eq. 0.0) then
          call abortjob
     &        ('reseteq ', 43,   'sf identically zero: resetting      '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
c
          do 510 jj  = 1,nprofl
          sf(jj)     = +smallno
  510     continue
c
c 5.3.3.2.2 Reset sf above smallno everywhere if everywhere small
        elseif(sfmax .gt. 0.0) then
          call abortjob
     &        ('reseteq ', 44,   'sf too small:  reset to smallno     '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
c
          do 520 jj  = 1,nprofl
          if(sf(jj) .lt. 0.0) sf(jj)  = -smallno
          if(sf(jj) .eq. 0.0) sf(jj)  =  0.0
          if(sf(jj) .gt. 0.0) sf(jj)  = +smallno
  520     continue
        endif
c
c 5.3.3.3 Check the boundary value if sf is significant over the range
      elseif(sfmax .gt. smallno) then
c
c 5.3.3.3.1 Compare sf(nprofl) with the maximum
        sfratio  = abs(sf(nprofl))/sfmax
c
c 5.3.3.3.2 Reset the edge value if too small
c           btor is reset from this below
        if(sfratio .le. smallno) then
          if(sf(nprofl) .lt. 0.0) sf(nprofl)= -smallno*sfmax
          if(sf(nprofl) .eq. 0.0) sf(nprofl)= +smallno*sfmax
          if(sf(nprofl) .gt. 0.0) sf(nprofl)= +smallno*sfmax
          call abortjob
     &        ('reseteq ', 45,   'sf(nprofl) << max(sf): resetting    '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
        endif
      endif
c
c
c 5.4 Write out the new input equilibrium profiles
c
      write(kuout,3200) npst
      write(kuout,3210) dnnorm,pfnorm
      write(kuout,3220)
      do 550 jv       = 1,nprofl
      jvl             = jv
      write(kuout,3230) jvl, psimsh(jvl), sf    (jvl), sp    (jvl)
     &                     , sffp  (jvl), spp   (jvl), sdns  (jvl)
     &                                               , spfst (jvl)
  550 continue
c
c
c
c 6.0 Reset the other equilibrium quantities for consistency
c
c 6.1 From changes to psilim
c
c 6.1.1 Reset delpsir using the new psilim
c
      delpsir         = psilim - psimax
      if(delpsir .eq. 0.0) call abortjob
     &        ('reseteq ', 46,   'New psilim invalid: delpsir = 0     '
     &        ,'ktype   ', ktype,    'jpsi    ', jpsi,     +1)
c
c 6.1.2 Reset btor to be consistent with the new sf(nprofl)
c
c 6.1.2.1 Check consitency of the new sf with the original value of btor
      btoreq          = btor
      btorsf          = sf(nprofl)/rcnt
      btscale         = abs(btoreq) + abs(btorsf)
c
      if(abs(btorsf-btoreq) .gt. tolbtor*btscale) then
        call abortjob
     &        ('reseteq ', 47,   'New sf(nprofl) .ne. rcnt*btor       '
     &        ,'nprofl  ', nprofl,   'ktype   ', ktype,    -1)
        write(kuout,3300) btoreq,btorsf,sf(nprofl),rcnt
      endif
c
c 6.1.2.2 Reset btor to sf(nprofl)/rcnt
      btor            = btorsf
c
c
c 6.2 Reset the magnetic axis and separatrix to xma,zma,psimax
c     if psisep > psilim
c     It should never get here since it implies psimax > psilim 
c
      if(psisep .eq. psimax  .and.  psisep .gt. psilim) then
        xax  (1)    = xma
        zax  (1)    = zma
        xsep        = xma
        zsep        = zma
        psimx(1)    = psimax
        call abortjob
     &        ('reseteq ', 48,   'psimax>psilim and psisep=psimax     '
     &        ,'ndoublt ', ndoublt,  'numax   ', numax,    -1)
      endif
c
c
c
c 7.0 Return and end
c
      return
c
 1000 format(/, 6x, 'btor        = ',e14.7,4x,'sf(edge)/rc = ',e14.7,
     &       /, 6x, 'sf(edge)    = ',e14.7,4x,'rcnt        = ',e14.7,/)
 2000 format(/, 10x,'Profiles reset from equilibrium input: mreset  = '
     &             ,i2,2x,'npst  = ',i2)
 2010 format(/, 10x,'Original profiles (magnetic axis to boundary):')
 2020 format(/, 6x, 'j',8x, 'psimsh',13x,'sf',15x,'sp',14x,'sffp'
     &                 ,13x,'spp',14x,'sdns',/)
 2030 format(1x,i6,2x,6(1x,e16.9))
 2100 format(/,  5x,'Equilibrium and fast particle meshes:'
     &       ,/, 10x,'nfast   = ',i6,4x,'nprofl   = ',i6
     &           ,4x,'kerrf   = ',i6)
 2110 format(/,10x,'spsif:')
 2120 format(5(1x,e18.11))
 2130 format(/,10x,'psimsh:')
 2140 format(5(1x,e18.11))
 3000 format(/,  5x,'Negative input pressure value is:'
     &          ,4x,'sp   (',i5,') = ',e14.7)
 3010 format(/,  5x,'Negative input density  value is:'
     &          ,4x,'sdns (',i5,') = ',e14.7)
 3020 format(/,  5x,'Negative input fast ion pressure value is:'
     &          ,4x,'spfst(',i5,') = ',e14.7)
 3050 format(/, 10x,'Reset profiles with corrected zeros:'
     &       ,/,5x,'kpneg   = ',i5,4x,'kdneg   = ',i5
     &         ,4x,'kfneg   = ',i5
     &       ,/,5x,'kpzer   = ',i5,4x,'kdzer   = ',i5
     &         ,4x,'kfzer   = ',i5)
 3060 format(/, 6x, 'j',8x, 'psimsh',13x,'sp',14x,'sdns',13x,'spfst',/)
 3070 format(1x,i6,2x,4(1x,e16.9))
 3100 format(/,  5x,'Negative adjusted pressure value is:'
     &          ,4x,'sp   (',i5,') = ',e14.7)
 3110 format(/,  5x,'Negative adjusted density  value is:'
     &          ,4x,'sdns (',i5,') = ',e14.7)
 3120 format(/,  5x,'Negative adjusted fast ion p value is:'
     &          ,4x,'spfst(',i5,') = ',e14.7)
 3200 format(/, 10x,'Final profiles interpolated to new psi mesh:'
     &        ,  2x,'npst  = ',i2
     &      ,/, 10x,'(magnetic axis to boundary):')
 3210 format(/, 10x,'Normalizations: dnnorm  = ',e14.7
     &                          ,4x,'pfnorm  = ',e14.7)
 3220 format(/, 6x, 'j',8x, 'psimsh',13x,'sf',15x,'sp',14x,'sffp'
     &                 ,13x,'spp',14x,'sdns',13x,'spfst',/)
 3230 format(1x,i6,2x,7(1x,e16.9))
 3300 format(/, 6x, 'btor(orig) = ',e14.7,4x,'btor(new)  = ',e14.7,
     &       /, 6x, 'sf(edge)   = ',e14.7,4x,'rcnt       = ',e14.7,/)

      end
      subroutine setmesh
c
c -------------------------------------------------------------
c  Construct initial flux mesh
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
      parameter (nlx=1441)
c
      character*8   vermgta
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
      nreset   = 0
      npdm     = npx
c
      psmmgta  = bigno
      pslmgta  = bigno
c
c
c
c 2.0 Set up initial stability flux mesh if mmesh .ge. 0
c
      if    (mmesh .ge. 0) then
        call compmsh(jpsi1,ndoublt,numax,psipak,psincr,psimax,psilim
     &              ,psisep,delpsir,jsep,psival,psivl0)
      endif
c
c
c
c 3.0 Read in the mesh from a file if mmesh is negative
c
      if    (mmesh .lt. 0) then
c
c 3.1 Read from a previous egta file
c
        if    (mmesh .eq. -1) then
          write(kutty,1000) nmesh,mmesh,kurdm
          write(kuout,1000) nmesh,mmesh,kurdm
c
c 3.1.1 Read the initial scalar data
c
          read(kurdm) vermgta
          read(kurdm) nrmgta,nzmgta,xdmgta,zdmgta,rcmgta,remgta
          read(kurdm) jpmgta,itmgta,jsmgta,numgta
c
c 3.1.2 Check the dimensions are consistent
c
          if(jpmgta .ne. jpsi) then
            if    (jpmgta .le. npdm) then
              call abortjob
     &        ('setmesh ',  1,   'jpsi from egta different from input '
     &        ,'jpmgta  ', jpmgta,   'jpsi    ', jpsi,     -2)
              nreset  = 1
              jpsi    = jpmgta
            elseif(jpmgta .gt. npdm) then
              call abortjob
     &        ('setmesh ',  2,   'jpsi from egta exceeds dimension    '
     &        ,'jpmgta  ', jpmgta,   'jpsi    ', jpsi,     +1)
            endif
          endif
c
c 3.1.3 Read the equilibrium scalar data
c
          read(kurdm) smgta1 ,smgta2, smgta3, smgta4, smgat5, smgta6
          read(kurdm) psmmgta,xmmgta, zmmgta, pslmgta,xlmgta, zlmgta
     &               ,qlmgta, flmgta
          read(kurdm) pssmgta,xsmgta, zsmgta
          read(kurdm) btmgta, tcmgta, qamgta, fqmgta, pamgta, ppmgta
     &               ,famgta, ffmgta, dnmgta
          read(kurdm) bpmgta, bamgta, bbmgta
c
c 3.1.4 Read the profile and store psival
c         psival was written from 1 to jpsi backwards in this file, followed
c         by psilim
c
          read(kurdm) (psival(jv), pvmgta, fvmgta, ppvmgta, ffvmgta
     &                ,qvmgta,     fqvmgta,dvmgta, jv = jpsi,1,-1)
     &                ,pslmgta,    plmgta, flmgta, pplmgta,fflmgta
     &                ,qlmgta,     fqmgta, dlmgta
c
c
c 3.2 Read from a previous tgta file
c
        elseif(mmesh .eq. -2) then
          write(kutty,1100) nmesh,mmesh,kurdm
          write(kuout,1100) nmesh,mmesh,kurdm
c
c 3.2.1 Read the initial scalar data
c
          read(kurdm) vermgta
          read(kurdm) nrmgta,nzmgta,xdmgta,zdmgta,rcmgta,remgta
          read(kurdm) jpmgta,itmgta,jsmgta,numgta
          read(kurdm) ntmgta,ivmgta,iwmgta,irmgta,rxmgta
c
c 3.2.2 Check the dimensions are consistent
c
          if(jpmgta .ne. jpsi) then
            if    (jpmgta .le. npdm) then
              call abortjob
     &        ('setmesh ',  3,   'jpsi from tgta different from input '
     &        ,'jpmgta  ', jpmgta,   'jpsi    ', jpsi,     -1)
              nreset  = 2
              jpsi    = jpmgta
            elseif(jpmgta .gt. npdm) then
              call abortjob
     &        ('setmesh ',  4,   'jpsi from tgta exceeds dimension    '
     &        ,'jpmgta  ', jpmgta,   'jpsi    ', jpsi,     +1)
            endif
          endif
c
c 3.2.3 Read the equilibrium scalar data
c
          read(kurdm) smgta1 ,smgta2, smgta3, smgta4, smgat5, smgta6
          read(kurdm) psmmgta,xmmgta, zmmgta, pslmgta,xlmgta, zlmgta
     &               ,psmgta, xsmgta, zsmgta
          read(kurdm) btmgta, tcmgta, qamgta, fqmgta, pamgta, famgta
     &               ,ppmgta, ffmgta, dnmgta
          read(kurdm) qlmgta ,flmgta, fcmgta, ommgta
          read(kurdm) bpmgta, bamgta, bbmgta
c
c 3.2.4 Read the profile and store psival
c
c         psival was written from 1 to jpsi1 backwards from the definition here
c         and was wriiten to include psilim but not psimax
          read(kurdm) (psival(jv), dpvmgta, pvmgta, fvmgta, ppvmgta
     &                ,ffvmgta,    qvmgta,  fqvmgta,dvmgta
     &                                             ,jv = jpsi,1,-1)
     &                ,pslmgta,    dplmgta, plmgta, flmgta, pplmgta
     &                ,fflmgta,    qvmgta,  fqlmgta,dlmgta
c
c
c
c 4.0 Read from the formatted ngta file
c
        elseif(mmesh .lt. -2) then
c
c 4.1 Read the profile in backward direction from psimax to psilim
c
          if    (mmesh .eq. -3) then
            write(kutty,1200) nmesh,mmesh,kurdn
            write(kuout,1200) nmesh,mmesh,kurdn
c
c 4.1.1 Read the data dimension
c
            read (kurdn,1210,end=600) jpngta
c
c 4.1.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ',  5,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 3
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ',  6,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.1.3 Read the data from psimax to psilim
c
            read (kurdn,1220,end=650) psmmgta,(psival(jp),jp=jpsi,1,-1)
     &                       ,pslmgta
c
c
c 4.2 Read the profile in forward  direction from psilim to psimax
c
          elseif(mmesh .eq. -4) then
            write(kutty,1300) nmesh,mmesh,kurdn
            write(kuout,1300) nmesh,mmesh,kurdn
c
c 4.2.1 Read the data dimension
c
            read (kurdn,1310,end=600) jpngta
c
c 4.2.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ',  7,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 3
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ',  8,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.2.3 Read the data from psilim to psimax
c
            read (kurdn,1320,end=650) pslmgta,(psival(jp),jp=1,jpsi)
     &                       ,psmmgta
c
c
c 4.3 Read the profile in backward direction from psimax to psilim, one
c     line at a time
c
          elseif(mmesh .eq. -5) then
            write(kutty,1400) nmesh,mmesh,kurdn
            write(kuout,1400) nmesh,mmesh,kurdn
c
c 4.3.1 Read the data dimension
c
            read (kurdn,1410,end=600) jpngta
c
c 4.3.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ',  9,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 4
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ', 10,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.3.3 Read the data from psimax to psilim
c
            read (kurdn,1420,end=650) psmmgta,(psival(jp),jp=jpsi,1,-1)
     &                       ,pslmgta
c
c
c 4.4 Read the profile in forward  direction from psilim to psimax, one
c     line at a time
c
          elseif(mmesh .eq. -6) then
            write(kutty,1500) nmesh,mmesh,kurdn
            write(kuout,1500) nmesh,mmesh,kurdn
c
c 4.4.1 Read the data dimension
c
            read (kurdn,1510,end=600) jpngta
c
c 4.4.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ', 11,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 5
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ', 12,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.4.3 Read the data from psilim to psimax
c
            read (kurdn,1520,end=650) pslmgta,(psival(jp),jp=1,jpsi)
     &                       ,psmmgta
c
c
c 4.5 Read the profile in backward direction from psimax to psilim, in free format
c
          elseif(mmesh .eq. -7) then
            write(kutty,1600) nmesh,mmesh,kurdn
            write(kuout,1600) nmesh,mmesh,kurdn
c
c 4.5.1 Read the data dimension
c
            read (kurdn,*,end=600) jpngta
c
c 4.5.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ', 13,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 6
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ', 14,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.5.3 Read the data from psimax to psilim
c
            read (kurdn,*,end=650) psmmgta,(psival(jp),jp=jpsi,1,-1)
     &                    ,pslmgta
c
c
c 4.6 Read the profile in forward  direction from psilim to psimax, in free format
c
          elseif(mmesh .eq. -8) then
            write(kutty,1700) nmesh,mmesh,kurdn
            write(kuout,1700) nmesh,mmesh,kurdn
c
c 4.6.1 Read the data dimension
c
            read (kurdn,*,end=600) jpngta
c
c 4.6.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ', 15,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 6
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ', 16,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.6.3 Read the data from psilim to psimax
c
            read (kurdn,*,end=650) pslmgta,(psival(jp),jp=1,jpsi)
     &                    ,psmmgta
c
c
c 4.7 Print a warning if mmesh is out of normal range but read the
c     profile in backward direction in free format
c
          else
            call abortjob
     &        ('setmesh ', 17,   'mmesh is out of the allowed range   '
     &        ,'mmesh   ', mmesh,    'krdngta ', krdngta,  -1)
            write(kutty,1800) nmesh,mmesh,kurdn
            write(kuout,1800) nmesh,mmesh,kurdn
c
c 4.7.1 Read the data dimension
c
            read (kurdn,*,end=600) jpngta
c
c 4.7.2 Check the dimensions are consistent
c
            if(jpngta .ne. jpsi) then
              if    (jpngta .le. npdm) then
                call abortjob
     &        ('setmesh ', 18,   'jpsi from ngta different from input '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     -1)
                nreset  = 7
                jpsi    = jpngta
              elseif(jpngta .gt. npdm) then
                call abortjob
     &        ('setmesh ', 19,   'jpsi from ngta exceeds dimension    '
     &        ,'jpngta  ', jpngta,   'jpsi    ', jpsi,     +1)
              endif
            endif
c
c 4.7.3 Read the data from psimax to psilim
c
            read (kurdn,*,end=650) psmmgta,(psival(jp),jp=jpsi,1,-1)
     &                            ,pslmgta
          endif
        endif
c
c
c
c 5.0 Readjust the mesh if necessary
c
c 5.1 Reset jpsi1 if the mesh size changed
c
        if(nreset .ne. 0) then
          jpsi1         = jpsi + 1
          jpsi2         = jpsi + 2
        endif
c
c
c 5.2 Set the last value
c
        psival(jpsi1) = psmmgta
c
c
c 5.3 Renormalize psival if necessary
c
c 5.3 Set the beginning and end of psival read in and set jsep
c
c 5.3.1 Set the variables
c
        jsep        = jpsi1
        kperror     = 0
c
        psibeg      = pslmgta
        psiend      = psmmgta
        psdifm      = (pslmgta - psmmgta)
        pserror     = roundff*abs(delpsir)
        pscheck     = psichek*abs(delpsir)

c
c 5.3.2 Print a warning if the psi ranges are inconsistent
c
        if(abs(psdifm) .eq. 0.0) then
          if    (mmesh .eq. -1  .or.  mmesh .lt. -2) then
            call abortjob
     &        ('setmesh ', 20,   'psilim equals psimax from mgta file '
     &        ,'mmesh   ', mmesh,    'krdmgta ', krdmgta,  +1)
c
          elseif(mmesh .lt. -2) then
            call abortjob
     &        ('setmesh ', 21,   'psilim equals psimax from ngta file '
     &        ,'mmesh   ', mmesh,    'krdngta ', krdngta,  +1)
          endif
        endif
c
c 5.3.3 Check the range of the psi from the previous map is the same as the
c       new equilibrium
c
c 5.3.3.1 Check new psilim and psimax are close
        if(       abs(psibeg-psilim)       .ge. pserror) then
          kperror   = +1
          if(       abs(psibeg-psilim)       .lt. pscheck) then
            call abortjob
     &        ('setmesh ', 22,   'psilim not quite equals equilibrium '
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,     0)
          else
            call abortjob
     &        ('setmesh ', 23,   'psilim is different from equilibrium'
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,    -1)
          endif
        endif
c
        if(       abs(psiend-psimax)       .ge. pserror) then
          kperror   = -1
          if(       abs(psiend-psimax)       .lt. pscheck) then
            call abortjob
     &        ('setmesh ', 24,   'psimax not quite equals equilibrium '
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,     0)
          else
            call abortjob
     &        ('setmesh ', 25,   'psimax is different from equilibrium'
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,    -1)
          endif
        endif
c
c 5.3.3.2 Check the array is not simply reversed if the new psi range
c         is different from the equilibrium
        if(iabs(kperror) .eq. +1) then
          if(abs(psiend-psilim) .le. pscheck  .and.
     &       abs(psibeg-psimax) .le. pscheck)   then
            call abortjob
     &        ('setmesh ', 26,   'Reversing psival array from read in '
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,    -1)
            psibg         =  psibeg
            psind         =  psiend
            psibeg        =  psind
            psiend        =  psibg
            psdifm        = -psdifm
            jphalf        =  jpsi/2
            do 300 jv     =  1,jphalf
            jvp           =  jpsi1 - jv
            pvjv          =  psival(jv)
            pvjvp         =  psival(jvp)
            psival(jv)    =  pvjvp
            psival(jvp)   =  pvjv
  300       continue
            psival(jpsi1) = psiend
          endif
        endif
c
c 5.3.3.3 Check new psilim and psimax are within the range
        if((psibeg-psilim)*(psibeg-psimax) .gt.   0.0  ) then
          kperror   = +2
          call abortjob
     &        ('setmesh ', 27,   'psilim from mesh file out of range  '
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,    -1)
        endif
c
        if((psiend-psilim)*(psiend-psimax) .gt.   0.0  ) then
          kperror   = -2
          call abortjob
     &        ('setmesh ', 28,   'psimax from mesh file out of range  '
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,    -1)
        endif
c
c 5.3.3.4 Check the psival array ends correctly at psiend
        psilast  = psival(jpsi1)
        if(       abs(psiend-psilast)      .ge. pserror) then
          call abortjob
     &        ('setmesh ', 29,   'Last psi not equal to psival(jpsi1) '
     &        ,'jpsi1   ', jpsi1,    'mmesh   ', mmesh,    -1)
c
          psival(jpsi1) = psiend
        endif        
c
c 5.3.4 Renormalize the array
c
        if(kperror .ne. 0) then
          call abortjob
     &        ('setmesh ', 30,   'Renormalized psi mesh read from file'
     &        ,'kperror ', kperror,  'mmesh   ', mmesh,    -1)
c
          write(kuout,2000) jpsi1
          write(kuout,2010) psdifm,delpsir,psibeg,psilim,psiend,psimax
          write(kuout,2020)
          write(kuout,2050) (psival(jvl),jvl=1,jpsi1)
c          
          do 400 jv     = 1,jpsi
          psvold        = (psival(jv) - psibeg) / psdifm 
          psvnew        = psilim + psvold*delpsir
          psival(jv)    = psvnew
  400     continue
          psival(jpsi1) = psimax
        endif
c
c 5.3.5 Write out the array
c
        write(kuout,2030)
        write(kuout,2050) (psival(jvl),jvl=1,jpsi1)
c
c
c
c 6.0 Set psivl0 array to cover the range from psilim to psimax
c
        do 500 jv       = 1,jpsi
        jv1             = jv+1
        psivl0(jv1)     = psival(jv)
  500   continue
c
        psivl0(   1  )  = psilim
        psivl0(jpsi+2)  = psimax
      endif
c
c
c
c 7.0 Return and end
c
c 7.1 Return normally
c
      return
c
c
c 7.2 Error in reading psi mesh
c
 600  continue
      call abortjob
     &        ('setmesh ', 31,   'Mesh file contains no mesh size data'
     &        ,'mmesh   ', mmesh,    'jpsi    ', jpsi,     +1)
      stop 'Mesh reading Error'
 650  continue
      call abortjob
     &        ('setmesh ', 32,   'Mesh file has Insufficient mesh data'
     &        ,'mmesh   ', mmesh,    'jpngta  ', jpngta,   -2)
      write(kuout,3000) psimax,psilim
      write(kuout,3010) jpngta
      write(kuout,3020) (psival(jv),jv = jpngta,1,-1)
      if    (abs(psmmgta-bigno) .le. roundff  .and.
     &       abs(pslmgta-bigno) .le. roundff) then
        write(kuout,3030) psmmgta,pslmgta
      elseif(abs(psmmgta-bigno) .le. roundff  .and.
     &       abs(pslmgta-bigno) .gt. roundff) then
        write(kuout,3040) psmmgta
      elseif(abs(psmmgta-bigno) .gt. roundff  .and.
     &       abs(pslmgta-bigno) .le. roundff) then
        write(kuout,3050) pslmgta
      elseif(abs(psmmgta-bigno) .gt. roundff  .and.
     &       abs(pslmgta-bigno) .gt. roundff) then
        write(kuout,3060)
      endif
      stop 'Mesh reading Error'
c  
 1000 format(/,10x,'Reading Mesh from previous binary egta file:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdm   = ',i5)
 1100 format(/,10x,'Reading Mesh from previous binary tgta file:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdm   = ',i5)
 1200 format(/,10x,'Reading Mesh as array from formatted file'
     &         ,1x,'from psimax to psilim:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 1210 format(1x,i5)
 1220 format(5(1x,f14.7))
 1300 format(/,10x,'Reading Mesh as array from formatted file'
     &         ,1x,'from psilim to psimax:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 1310 format(1x,i5)
 1320 format(5(1x,f14.7))
 1400 format(/,10x,'Reading Mesh as table from formatted file'
     &         ,1x,'from psimax to psilim:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 1410 format(1x,i5)
 1420 format(1x,e16.9)
 1500 format(/,10x,'Reading Mesh as table from formatted file'
     &         ,1x,'from psilim to psimax:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 1510 format(1x,i5)
 1520 format(1x,e16.9)
 1600 format(/,10x,'Reading Mesh in free format from formatted'
     &         ,1x,'file from psimax to psilim:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 1700 format(/,10x,'Reading Mesh in free format from formatted'
     &         ,1x,'file from psilim to psimax:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 1800 format(/,10x,'Attempting to Read Mesh in free format from'
     &         ,1x,'formatted file from psimax to psilim:'
     &      ,/,10x,'nmesh   = ',i5,17x,'mmesh   = ',i5
     &        ,17x,'kurdn   = ',i5)
 2000 format(/,10x,'Renormalization for psi mesh: jpsi1 =',i5,/)
 2010 format(  5x, 'psdifm  = ',e16.9,4x,'delpsir = ',e16.9,/
     &        ,5x, 'psibeg  = ',e16.9,4x,'psilim  = ',e16.9
     &        ,4x, 'psiend  = ',e16.9,4x,'psimax  = ',e16.9)
 2020 format(/,5x, 'Initial psi mesh from prior run:')
 2030 format(/,5x, 'Final   psi mesh from prior run:')
 2050 format(5(1x,e16.9))
 3000 format(  5x,'psimax   = ',e16.9,4x,'psilim   = ',e16.9)
 3010 format(/,5x,'psi mesh read in: (psival(jv),jv = ',i6,',1,-1):')
 3020 format(5(1x,e16.9))
 3030 format(/,5x,'psmmgta  = ',e16.9,4x,'pslmgta  = ',e16.9)
 3040 format(/,5x,'psmmgta  = ',e16.9,4x,'pslmgta not defined')
 3050 format(/,5x,'pslmgta  = ',e16.9,4x,'psmmgta not defined')
 3060 format(/,5x,'Neither psmmgta or pslmgta is defined')
      end
      subroutine setprof
c
c ------------------------------------------------------------
c  Calculate pprime, ffprime, f arrays and fit coefficients
c ------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Set up f, p, ffprime, pprime, dnsty, and pfast arrays
c
c 1.1 Initialization
c
      smallno    = abs(roundff)
c
c
c 1.2 Compute the spline arrays
c
c 1.2.1 Set up the extrapolation coefficients
c
      nsbcnd     = nspbc0
      nprofl1    = nprofl - 1
      nprofl2    = nprofl - 2
      delx21     = psimsh(   2   ) - psimsh(   1   )
      delx32     = psimsh(   3   ) - psimsh(   2   )
      delx31     = psimsh(   3   ) - psimsh(   1   )
      delxn1     = psimsh(nprofl)  - psimsh(nprofl1)
      delxnx     = psimsh(nprofl1) - psimsh(nprofl2)
      delxn2     = psimsh(nprofl)  - psimsh(nprofl2)
      dr3132     = delx31/delx32
      dr2132     = delx21/delx32
      drn2nx     = delxn2/delxnx
      drn1nx     = delxn1/delxnx
      if    (nsbcnd .le. 0) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      elseif(nsbcnd .eq. 1) then
        xtrap1     = 1.0
        xtrap1p    = 0.0
        xtrapn     = 1.0
        xtrapnp    = 0.0
      elseif(nsbcnd .eq. 2) then
        xtrap1     = +dr3132
        xtrap1p    = -dr2132
        xtrapn     = +drn2nx
        xtrapnp    = -drn1nx
      elseif(nsbcnd .gt. 2) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      endif
c
c 1.2.2 Set up the cubic spline interpolation coefficients for the
c       profiles sf, sp, sffp, spp, sdns, and spfst
c       Note that for npst = 1 sp and sffp are interpolated but not used
c
c 1.2.2.1 Set up the spline coefficients for the spline boundary conditions
c         for the toroidal field function sf
c
c 1.2.2.1.1 Set the second derivatives at the endpoints
      sf2pp      = f2sx(   2   ,sf,  psimsh,nprofl)
      sf3pp      = f2sx(   3   ,sf,  psimsh,nprofl)
      sfn1pp     = f2sx(nprofl1,sf,  psimsh,nprofl)
      sfn2pp     = f2sx(nprofl2,sf,  psimsh,nprofl)
c
      sfbc11     = xtrap1*sf2pp  + xtrap1p*sf3pp
      sfbcnn     = xtrapn*sfn1pp + xtrapnp*sfn2pp
c
c 1.2.2.1.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfbcnn
c
c 1.2.2.1.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfn1pp
c
c 1.2.2.1.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sf2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 1.2.2.1.5 Compute the spline coefficients for sf
      call icsici(psimsh,sf,   nprofl,bcb,csf,  npp,ierf)
      if(ierf  .ne. 0) call abortjob
     &        ('setprof ',  1,   'Interpolation error: sf(psimsh)     '
     &        ,'ierf    ', ierf,     'nprofl  ', nprofl,   +1)
c
c 1.2.2.2 Set up the spline coefficients for the spline boundary conditions
c         for the pressure sp
c
c 1.2.2.2.1 Set the second derivatives at the endpoints
      sp2pp      = f2sx(   2   ,sp,  psimsh,nprofl)
      sp3pp      = f2sx(   3   ,sp,  psimsh,nprofl)
      spn1pp     = f2sx(nprofl1,sp,  psimsh,nprofl)
      spn2pp     = f2sx(nprofl2,sp,  psimsh,nprofl)
c
      spbc11     = xtrap1*sp2pp  + xtrap1p*sp3pp
      spbcnn     = xtrapn*spn1pp + xtrapnp*spn2pp
c
c 1.2.2.2.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*spbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*spbcnn
c
c 1.2.2.2.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spn1pp
c
c 1.2.2.2.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 1.2.2.2.5 Compute the spline coefficients for sp
      call icsici(psimsh,sp,   nprofl,bcb,csp,  npp,ierp)
      if(ierp  .ne. 0) call abortjob
     &        ('setprof ',  2,   'Interpolation error: sp(psimsh)     '
     &        ,'ierp    ', ierp,     'nprofl  ', nprofl,   +1)
c
c 1.2.2.3 Set up the spline coefficients for the spline boundary conditions
c         for the derivative of toroidal field function sffp
c
c 1.2.2.3.1 Set the second derivatives at the endpoints
      sfp2pp     = f2sx(   2   ,sffp,psimsh,nprofl)
      sfp3pp     = f2sx(   3   ,sffp,psimsh,nprofl)
      sfpn1pp    = f2sx(nprofl1,sffp,psimsh,nprofl)
      sfpn2pp    = f2sx(nprofl2,sffp,psimsh,nprofl)
c
      sfpbc11    = xtrap1*sfp2pp  + xtrap1p*sfp3pp
      sfpbcnn    = xtrapn*sfpn1pp + xtrapnp*sfpn2pp
c
c 1.2.2.3.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sfpbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sfpbcnn
c
c 1.2.2.3.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sfp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sfpn1pp
c
c 1.2.2.3.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sfp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 1.2.2.3.5 Compute the spline coefficients for sffp
      call icsici(psimsh,sffp,nprofl,bcb,csffp,npp,ierfp)
      if(ierfp .ne. 0) call abortjob
     &        ('setprof ',  3,   'Interpolation error: sffp(psimsh)   '
     &        ,'ierfp   ', ierfp,    'nprofl  ', nprofl,   +1)
c
c 1.2.2.4 Set up the spline coefficients for the spline boundary conditions
c         for the derivative of pressure spp
c
c 1.2.2.4.1 Set the second derivatives at the endpoints
      spp2pp     = f2sx(   2   ,spp, psimsh,nprofl)
      spp3pp     = f2sx(   3   ,spp, psimsh,nprofl)
      sppn1pp    = f2sx(nprofl1,spp, psimsh,nprofl)
      sppn2pp    = f2sx(nprofl2,spp, psimsh,nprofl)
c
      sppbc11    = xtrap1*spp2pp  + xtrap1p*spp3pp
      sppbcnn    = xtrapn*sppn1pp + xtrapnp*sppn2pp
c
c 1.2.2.4.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sppbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sppbcnn
c
c 1.2.2.4.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spp2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sppn1pp
c
c 1.2.2.4.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spp2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 1.2.2.4.5 Compute the spline coefficients for spp
      call icsici(psimsh,spp,  nprofl,bcb,cspp, npp,ierpp)
      if(ierpp .ne. 0) call abortjob
     &        ('setprof ',  4,   'Interpolation error: spp(psimsh)    '
     &        ,'ierpp   ', ierpp,    'nprofl  ', nprofl,   +1)
c
c 1.2.2.5 Set up the spline coefficients for the spline boundary conditions
c         for the density sdns
c
c 1.2.2.5.1 Set the second derivatives at the endpoints
      sdn2pp     = f2sx(   2   ,sdns,psimsh,nprofl)
      sdn3pp     = f2sx(   3   ,sdns,psimsh,nprofl)
      sdnn1pp    = f2sx(nprofl1,sdns,psimsh,nprofl)
      sdnn2pp    = f2sx(nprofl2,sdns,psimsh,nprofl)
c
      sdnbc11    = xtrap1*sdn2pp  + xtrap1p*sdn3pp
      sdnbcnn    = xtrapn*sdnn1pp + xtrapnp*sdnn2pp
c
c 1.2.2.5.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*sdnbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*sdnbcnn
c
c 1.2.2.5.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sdn2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*sdnn1pp
c
c 1.2.2.5.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*sdn2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 1.2.2.5.5 Compute the spline coefficients for sdns
      call icsici(psimsh,sdns, nprofl,bcb,csdn, npp,ierdn)
      if(ierdn .ne. 0) call abortjob
     &        ('setprof ',  5,   'Interpolation error: sdns(psimsh)   '
     &        ,'ierdn   ', ierdn,    'nprofl  ', nprofl,   +1)
c
c 1.2.2.6 Set up the spline coefficients for the spline boundary conditions
c         for the fast ion pressure spfst
c
c 1.2.2.6.1 Set the second derivatives at the endpoints
      spf2pp     = f2sx(   2   ,spfst,psimsh,nprofl)
      spf3pp     = f2sx(   3   ,spfst,psimsh,nprofl)
      spfn1pp    = f2sx(nprofl1,spfst,psimsh,nprofl)
      spfn2pp    = f2sx(nprofl2,spfst,psimsh,nprofl)
c
      spfbc11    = xtrap1*spf2pp  + xtrap1p*spf3pp
      spfbcnn    = xtrapn*spfn1pp + xtrapnp*spfn2pp
c
c 1.2.2.6.2 Set the boundary conditions at the endpoint from the second
c           derivatives
      if    (nsbcnd .ge.  0  .and.  nsbcnd .le.  2) then
        bcb(1)     = 0.0
        bcb(2)     = 2.0*spfbc11
        bcb(3)     = 0.0
        bcb(4)     = 2.0*spfbcnn
c
c 1.2.2.6.3 Use natural boundary conditions at the plasma surface but force
c           a near floating condition at the axis
      elseif(nsbcnd .gt. +2) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spf2pp
        bcb(3)     = bigval
        bcb(4)     = bigval*spfn1pp
c
c 1.2.2.6.4 Use a floating condition at both ends
      elseif(nsbcnd .lt.  0) then
        bigval     = abs(float(nsbcnd))
        bcb(1)     = bigval
        bcb(2)     = bigval*spf2pp
        bcb(3)     = 0.0
        bcb(4)     = 0.0
      endif
c
c 1.2.2.6.5 Compute the spline coefficients for spfst
      call icsici(psimsh,spfst,nprofl,bcb,csfst, npp,ierpf)
      if(ierpf .ne. 0) call abortjob
     &        ('setprof ',  6,   'Interpolation error: spfst(psimsh)  '
     &        ,'ierpf   ', ierpf,    'nprofl  ', nprofl,   +1)
c
c
c 1.3 Check the pressure spline and reset csp spline coefficients for
c     linear interpolation if points are too close
c
      pfact    = prfrac
      call cuschk(nprofl,npp,csp,sp,psimsh,pfact,kerc)
      if(kerc .ne. 0) then
         if(kerc .gt. 0) call abortjob
     &        ('setprof ',  7,   'Pressure spline reset to linear     '
     &        ,'kerc    ', kerc,     'nprofl  ', nprofl,    0)
         if(kerc .lt. 0) call abortjob
     &        ('setprof ',  8,   'Multiple Pressure spline resets     '
     &        ,'kerc    ', kerc,     'nprofl  ', nprofl,    0)
      endif
c
c
c
c 2.0 Interpolate the profiles to the flux mesh
c
c 2.1 Set up the profile arrays
c
      do 100 j   = 1,jpsi1
      jvl        = j
      ps         = psival(jvl)
c
c 2.1.1 Interpolate f, p, dnsty, and pfast
c
      f(jvl)     = sterpl(ps,psimsh,sf,   csf,  nprofl,npp,0,
     &                       smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('setprof ',  9,   'Interpolation error for f(psival)   '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      p(jvl)     = sterpl(ps,psimsh,sp,   csp,  nprofl,npp,0,
     &                       smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('setprof ', 10,   'Interpolation error for p(psival)   '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      dnsty(jvl) = sterpl(ps,psimsh,sdns, csdn, nprofl,npp,0,
     &                       smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('setprof ', 11,   'Interpolation error for dnsty(psi)  '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      pfast(jvl) = sterpl(ps,psimsh,spfst,csfst,nprofl,npp,0,
     &                       smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('setprof ', 12,   'Interpolation error for pfast(psi)  '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
c 2.1.2 For standard equilibrium profiles interpolate spp and sffp (npst = 0)
c
      if    (npst .eq. 0) then
        ffp(jvl)   = sterpl(ps,psimsh,sffp,csffp,nprofl,npp,0,
     &                         smallno,ierf)
        pp (jvl)   = sterpl(ps,psimsh,spp, cspp, nprofl,npp,0,
     &                         smallno,ierp)
c
        if(ierf .ne. 0) call abortjob
     &        ('setprof ', 11,   'Interpolation error for ffp(psival) '
     &        ,'ierf    ', ierf,     'jvl     ', jvl,      -1)
        if(ierp .ne. 0) call abortjob
     &        ('setprof ', 12,   'Interpolation error for pp(psival)  '
     &        ,'ierp    ', ierp,     'jvl     ', jvl,      -1)
c
c 2.1.3 For alternative equilibrium profiles differentiate sp and sf (npst = 1)
c
      elseif(npst .eq. 1) then
        fp1        = sterpp(ps,psimsh,sf,  csf,  nprofl,npp,0,
     &                         smallno,ierf)
        ffp(jvl)   = f(jvl)*fp1
        pp (jvl)   = sterpp(ps,psimsh,sp,  csp,  nprofl,npp,0,
     &                         smallno,ierp)
c
        if(ierf .ne. 0) call abortjob
     &        ('setprof ', 13,   'Differentiation error for f(psival) '
     &        ,'ierf    ', ierf,     'jvl     ', jvl,      -1)
        if(ierp .ne. 0) call abortjob
     &        ('setprof ', 14,   'Differentiation error for p(psival) '
     &        ,'ierp    ', ierp,     'jvl     ', jvl,      -1)
      endif
  100 continue
c
c
c 2.2 Set the axis values
c
c 2.2.1 Set the axis f, p, dnsty, and pfast
c
      faxe       = sf(1)
      paxe       = sp(1)
      dnaxe      = sdns(1)
      pfaxe      = spfst(1)
c
c 2.2.2 For standard equilibrium profiles (npst = 0)
c
      if    (npst .eq. 0) then
        ffpaxe     = sffp(1)
        ppaxe      = spp (1)
c
c 2.2.3 For alternative equilibrium profiles (npst = 1)
c
      elseif(npst .eq. 1) then
        fp1        = sterpp(psimax,psimsh,sf,csf,nprofl,npp,0,
     &                             smallno,ierf)
        ffpaxe     = fp1*sf(1)
        ppaxe      = sterpp(psimax,psimsh,sp,csp,nprofl,npp,0,
     &                             smallno,ierp)
c
        if(ierf .ne. 0) call abortjob
     &        ('setprof ', 15,   'Differentiation error for f(axis)   '
     &        ,'ierf    ', ierf,     'nprofl  ', nprofl,   -1)
        if(ierp .ne. 0) call abortjob
     &        ('setprof ', 16,   'Differentiation error for p(axis)   '
     &        ,'ierp    ', ierp,     'nprofl  ', nprofl,   -1)
      endif
c
c
c
c 3.0 Check the pressure, density, and fast particle pressure are nonnegative
c
c 3.1 Initialize counters
c
      kpnegv     = 0
      kdnegv     = 0
      kfnegv     = 0
      jvprmx     = 0
      jvdnmx     = 0
      jvpfmx     = 0
      prnegmx    = 0.0
      dnnegmx    = 0.0
      pfnegmx    = 0.0
c
c
c 3.2 Check through the values
c
      do 200 j   = 1,jpsi1
      jvl        = j
c
c 3.2.1 Check the pressure
c
      prval      = p    (jvl)
      if(prval .lt. 0.0   .or.  abs(prval) .lt. smallno) then
        if(prval .lt. 0.0) then
          kpnegv     = kpnegv + 1
          if(abs(prval) .ge. abs(prnegmx)) then
            jvprmx     = jvl
            prnegmx    = prval
          endif
        endif
        p    (jvl)  = smallno
      endif
c
c 3.2.2 Check the density
c
      dnval      = dnsty(jvl)
      if(dnval .lt. 0.0   .or.  abs(dnval) .lt. smallno) then
        if(dnval .lt. 0.0) then
          kdnegv     = kdnegv + 1
          if(abs(dnval) .ge. abs(dnnegmx)) then
            jvdnmx     = jvl
            dnnegmx    = dnval
          endif
        endif
        dnsty(jvl) = smallno
      endif
c
c 3.2.2 Check the fast particle pressure
c
      pfval      = pfast(jvl)
      if(pfval .lt. 0.0) then
        kfnegv     = kfnegv + 1
          if(abs(pfval) .ge. abs(pfnegmx)) then
            jvpfmx     = jvl
            pfnegmx    = pfval
          endif
        pfast(jvl) = 0.0
      endif
  200 continue
c
c
c 3.3 Print a warning if profile was modified
c
c 3.3.1 Pressure profile
c
      if(kpnegv .gt. 0) then
        call abortjob
     &        ('setprof ', 17,   'Final negative pressure reset >0    '
     &        ,'kpnegv  ', kpnegv,   'jpsi1   ', jpsi1,    -1)
        write(kuout,1000) jvprmx,prnegmx
      endif
c
c 3.3.2 Density profile
c
      if(kdnegv .gt. 0) then
        call abortjob
     &        ('setprof ', 18,   'Final negative density reset > 0    '
     &        ,'kdnegv  ', kdnegv,   'jpsi1   ', jpsi1,    -1)
        write(kuout,1010) jvdnmx,dnnegmx
      endif
c
c 3.3.1 Fast particle pressure profile
c
      if(kfnegv .gt. 0) then
        call abortjob
     &        ('setprof ', 19,   'Final fast ion pressure reset >0    '
     &        ,'kfnegv  ', kfnegv,   'jpsi1   ', jpsi1,    -1)
        write(kuout,1020) jvpfmx,pfnegmx
      endif
c
c
c
c 4.0 Return and end
c
      return
 1000 format(10x,'Largest negative pressure: p    (',i5,') = ',e12.5)
 1010 format(10x,'Largest negative density:  dnsty(',i5,') = ',e12.5)
 1020 format(10x,'Largest negative fast ion pressure: pfast(',i5,') = '
     &          ,e12.5)
      end
      subroutine setaxs0
c
c ------------------------------------------------------------
c  Calculate axis fit parameters for (r,z) equilibrium
c ------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/psft/  rpsi,zpsi,rj0,rjp,rj3,rj5,rj7,sa0,sa2,sa3,sa4,
     &              sb2,sb3,sb4
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension pds(6)
      dimension ftpar(14)
c
      equivalence (ftpar(1), rpsi) , (ftpar(2), zpsi) ,
     &            (ftpar(3),  rj0) , (ftpar(4),  rjp) ,
     &            (ftpar(5),  rj3) , (ftpar(6),  rj5) ,
     &            (ftpar(7),  rj7) , (ftpar(8),  sa0) ,
     &            (ftpar(9),  sa2) , (ftpar(10), sa3) ,
     &            (ftpar(11), sa4) , (ftpar(12), sb2) ,
     &            (ftpar(13), sb3) , (ftpar(14), sb4)
c
c
c
c 1.0 Initialization
c
c 1.1 Define the tolerance
c
      rndoff   = roundff
c
c
c 1.2 Set kqaxe to decide if axis fit is valid
c
      kqaxe   = -1
      if(nx .eq. nz ) kqaxe =  0
      if(nx .ne. nz ) kqaxe =  1
      if(nx .ne. nxx) kqaxe =  2
c
c
c
c 2.0 Calculate the fit coefficients for all magnetic axes
c
c 2.1 Loop over magnetic axes
c
      do 100 lx = 1,numax
      lax       = lx
c
c
c 2.2 Search for the psi, r, and z array index values near the axis
c
c 2.2,1 Search for psi
c
      do 10 j  = 1,jpsi
      jpls     =  j
      if(smap(lax) .ge. psival(jpls)) go to 15
   10 continue
      jpls     = jpsi1
c
   15 jp       = jpls
c
c 2.2.2 Search for r
c
      do 20 i  = 1,nx
      ils      =  i
      if(smax(lax) .le. x(ils)) go to 25
   20 continue
c
   25 iax      = ils
c
c 2.2.3 Search for z
c
      do 30 j  = 1,nz
      jls      =  j
      if(smaz(lax) .le. z(jls)) go to 35
   30 continue
c
   35 jax      = jls
c
c
c 2.3 Calculate the fit coefficients for this axis
c     This is bypassed if kqaxe < 0
c     This should never occur under normal conditions
c
      if(kqaxe .ge. 0) then
c
c 2.3.1 Compute the coefficients
c
        call psifit(jp,iax,jax,smax(lax),smaz(lax),smap(lax),ker0)
        if    (ker0 .eq. 0) then
          kqcal00   = +1
        elseif(ker0 .ne. 0) then
          kqcal00   =  0
          call abortjob
     &        ('setaxs0 ',  1,   'Error detected fitting near axis    '
     &        ,'ker0    ', ker0,     'jp      ', jp,       -1)
        endif
c
c 2.3.2 Store the coefficients
c
        do 50 ipl       = 1,14
        fitax(ipl,lax)  = ftpar(ipl)
   50   continue
      endif
c
c
c 2.4 End loop over axes
c
  100 continue
c
c
c
c 3.0 Calculate the fit coefficients for a Doublet x-point if present
c
      if(ndoublt .ne. 0  .and.  psisep .ne. psimax) then
c
c 3.1 Search for the r, and z array index values near the x-point
c
c 3.1.1 Search for r
c
        do 120 i = 1,nx
        ils      = i
        if(xsep .le. x(ils)) go to 125
  120   continue
c
  125   ixp      = ils
c
c 3.1.2 Search for z
c
        do 130 j = 1,nz
        jls      = j
        if(zsep .le. z(jls)) go to 135
  130   continue
c
  135   jxp      = jls
c
c
c 3.2 Calculate the fit coefficients for the x-point
c     This is bypassed if kqaxe < 0
c
        if(kqaxe .ge. 0) then
c
c 3.2.1 Compute the coefficients
c
          call psifit(jsep,ixp,jxp,xsep,zsep,psisep,ker1)
          if(ker1 .ne. 0) then
            call abortjob
     &        ('setaxs0 ',  2,   'Error in fitting near separatrix    '
     &        ,'ker1    ', ker1,     'jsep    ', jsep,     -1)
          endif
c
c 3.2.2 Store the coefficients
c
          do 150 ipl   = 1,14
          fitsep(ipl)  = ftpar(ipl)
  150     continue
        endif
      endif
c
c
c
c 4.0 Calculate on axis values of q, elongation, triangularity
c     from the fit to the first magnetic axis
c
c 4.1 Calculate values from the fit if kqaxe .ge. 0
c
      if(kqaxe .ge. 0) then
        kqcal01    = +1
        fitax11    = fitax(1, 1)
        fitax31    = fitax(3, 1)
        fitax61    = fitax(6, 1)
        fitax91    = fitax(9, 1)
        fitax101   = fitax(10,1)
        fitax121   = fitax(12,1)
        if(abs(fitax31) .le. rndoff) then
          call abortjob
     &        ('setaxs0 ',  3,   'Vanishing (3,1) axis component      '
     &        ,'iax     ', iax,      'jax     ', jax,      -1)
          kqcal01  = -1
          fitax31  = rndoff
        endif
c
        ws    = 1.0 - 16.0*(fitax91**2 + fitax121**2) / fitax31**2
        if(ws .le. 0.0) then
          call abortjob
     &        ('setaxs0 ',  4,   'Fit parameter ws is non positive    '
     &        ,'iax     ', iax,      'jax     ', jax,      -1)
          kqcal01 = -2
          ws      = rndoff
        endif
c
        qax0   = 2.0*f(jpsi1) / (smax(1)*fitax31*sqrt(ws))
        eax0   = sqrt(ws) / (1.0 - 4.0*sqrt(fitax91**2 + fitax121**2)
     &                    / fitax31)
        tax0   = ( (0.25*fitax61 - fitax91) / (2.*fitax11)
     &                                      * (1.0 - 1.0/eax0**2) 
     &         +    6.0*fitax101 * (1.0 + 1.0/(3.0*eax0**2)))
     &                                      / (fitax31 - 4.0*fitax91)
c
c
c 4.2 Set the calculation parameter to zero if kqaxe < 0
c     qax0, eax0, and tax0 are then set to zero if either calculation parameter
c     is zero
c
      elseif(kqaxe .lt. 0) then
        kqcal01    =  0
      endif
c
c
c 4.3 Set the final parameter kqcal0 to decide whether the fitting calculation
c     for qaxis is valid
c
c 4.3.1 Set the parameter if there is no fatal error
c
      if(kqcal00 .gt. 0  .and.  kqcal01 .gt. 0) kqcal0   = +1
      if(kqcal00 .gt. 0  .and.  kqcal01 .lt. 0) kqcal0  = kqcal01
      if(kqcal00 .lt. 0  .and.  kqcal01 .lt. 0) kqcal0  = kqcal01
      if(kqcal00 .lt. 0  .and.  kqcal01 .gt. 0) kqcal0  = kqcal00
c
c 4.3.2 Bypass this if  there is an error in the fitting of psi near the axis
c       from either psifit or the construction of qax0 and eax0
c       Set qax0, eax0, and taxe0 to zero
c
      if(kqcal00 .eq. 0  .or.  kqcal01 .eq. 0) then
        kqcal0   = 0
        qax0     = 0.0
        eax0     = 0.0
        tax0     = 0.0
      endif
c
c
c
c 5.0 Recompute the axis values using the spline fit
c
c 5.1 Compute the derivatives from the spline fit
c
c 5.1.1 Set the default switch on
c
      kqcal1    = +1
c
c 5.1.2 Use the spline fit to psi at (xma,zma)
c
      call dbcevl(x,nx,z,nz,cspl1,nxd,nzd,xma,zma,pds,ier)
      if(ier .ne. 0) then
        call abortjob
     &        ('setaxs0 ',  5,   'psi spline interpolation error      '
     &        ,'ier     ', ier,      'nx      ', nx,       -1)
        kqcal1    =  0
      endif
c
c 5.1.3 Set the coefficients from the fit
c
      if(kqcal1 .eq. +1) then
        a0     = 1.0*pds(1)
        b0     = 1.0*pds(2)
        c0     = 1.0*pds(3)
        a1     = 0.5*pds(5)
        b1     = 0.5*pds(4)
        c1     = 0.5*pds(6)
c
c
c 5.2 Compute the safety factor, elongation, and orientation on axis
c
c 5.2.1 Compute the elongation and orientation
c
        thet   = 0.5*atan2(2.0*b1,a1-c1)
c
        ap1    = a1*cos(thet)**2 + 2.0*b1*sin(thet)*cos(thet)
     &         + c1*sin(thet)**2
        cp1    = a1*sin(thet)**2 - 2.0*b1*sin(thet)*cos(thet)
     &         + c1*cos(thet)**2
c
        if(abs(cp1) .le. rndoff*abs(ap1)) then
          call abortjob
     &        ('setaxs0 ',  6,   'Radial width of ellipse vanishes    '
     &        ,'nx      ', nx,       'nz      ', nz,       -1)
          cp1     = rndoff*abs(ap1)
          kqcal1  = -1
        endif
c
        eax1   = sqrt(ap1/cp1)
c
c 5.2.2 Compute q on axis
c
c 5.2.2.1 Set the axis profile values from sffp and spp
        if    (npst .eq. 0) then
          ffonax  = sffp(1)
          pponax  = spp (1)
c
c 5.2.2.2 Set the axis profile values from sf and sp
        elseif(npst .eq. 1) then
          pvonax  = smap(1)
          ffonax  = sterpp(pvonax,psimsh,sf,  csf,  nprofl,npp,0,
     &                            rndoff,ierf)
          ffonax  = ffonax*sf(1)
          pponax  = sterpp(pvonax,psimsh,sp,  csp,  nprofl,npp,0,
     &                            rndoff,ierp)
c
          if(ierf .ne. 0) then
            call abortjob
     &        ('setaxs0 ',  7,   'Differentiation error in f(axis)    '
     &        ,'ierf    ', ierf,     'npst    ', npst,     -1)
            kqcal1  = -2
          endif
          if(ierp .ne. 0) then
            call abortjob
     &        ('setaxs0 ',  8,   'Differentiation error in p(axis)    '
     &        ,'ierp    ', ierp,     'npst    ', npst,     -1)
            kqcal1  = -3
          endif
        endif
c
c 5.2.2.3 Set the axis current density and elongation
        aj1     = -(amu*xma*xma*pponax + ffonax)
        aj2     = +2.0*(a1+c1)
c
c 5.2.2.4 Set q on axis
        qax1    = sf(1)/xma * (1.0+eax1*eax1)/(eax1*aj1)
        tax1    = 0.0
c
c
c 5.3 Set q on axis zero if there is an error
c
      else
        eax1    = 0.0
        qax1    = 0.0
        tax1    = 0.0
      endif
c
c
c
c 6.0 Choose the value of q on axis
c
c 6.1 Print the coefficients and both qaxe estimates and reset qaxe if both
c     calculations are valid
c
      if    (kqcal0 .ne. 0  .and.  kqcal1 .ne. 0) then
c
c 6.1.1 Calculate the differences in the estimates
c
        qaxtol     = qptol*(abs(qax0) + abs(qax1))
        eaxtol     = qptol*(abs(eax0) + abs(eax1))
        qaxerr     = qax0 - qax1
        eaxerr     = eax0 - eax1
c
c 6.1.2 Print a warning if the two estimates for qaxe and eaxe
c       disagree
c
        if(abs(qaxerr) .ge. qaxtol  .and.  abs(eaxerr) .ge. eaxtol) then
          call abortjob
     &        ('setaxs0 ',  9,   'Estimates for qaxe disagree         '
     &        ,'kqcal0  ', kqcal0,   'kqcal1  ', kqcal1,    0)
        endif
c
        if(abs(qaxerr) .ge. qaxtol  .and.  abs(eaxerr) .lt. eaxtol) then
          call abortjob
     &        ('setaxs0 ', 10,   'Estimates for eaxe disagree         '
     &        ,'kqcal0  ', kqcal0,   'kqcal1  ', kqcal1,    0)
        endif
c
        if(abs(qaxerr) .lt. qaxtol  .and.  abs(eaxerr) .ge. eaxtol) then
          call abortjob
     &        ('setaxs0 ', 11,   'Estimates axis q and e disagree     '
     &        ,'kqcal0  ', kqcal0,   'kqcal1  ', kqcal1,    0)
        endif
c
c 6.1.3 Write out the two estimates and coefficients
c
        write(kuout,1000) iax,jax,fitax31,ws,
     &                            fitax91,fitax121,
     &                            fitax61,fitax11,fitax101
        write(kuout,1010) a0,b0,c0,a1,b1,c1,aj1,aj2
        write(kuout,1020) qax0,eax0,tax0,qax1,eax1,tax1,qaxerr,eaxerr
c
c
c 6.2 Print the second estimate and coefficients only if the first is invalid  
c
      elseif(kqcal0 .eq. 0  .and.  kqcal1 .ne. 0) then
        call abortjob
     &        ('setaxs0 ', 12,   'Error in axis fit estimate to q0    '
     &        ,'kqcal0  ', kqcal0,   'kqcal1  ', kqcal1,   -1)
        write(kuout,1010) a0,b0,c0,a1,b1,c1,aj1,aj2
        write(kuout,1030) qax1,eax1,tax1
c
c
c 6.3 Print the first estimate and coefficients only if the second is invalid  
c
      elseif(kqcal0 .ne. 0  .and.  kqcal1 .eq. 0) then
        call abortjob
     &        ('setaxs0 ', 13,   'Error in spline estimate to q0      '
     &        ,'kqcal0  ', kqcal0,   'nx      ', nx,       -1)
        write(kuout,1000) iax,jax,fitax31,ws,
     &                            fitax91,fitax121,
     &                            fitax61,fitax11,fitax101
        write(kuout,1040) qax0,eax0,tax0
c
c
c 6.4 Quit if neither estimate is valid
c
      elseif(kqcal0 .eq. 0  .and.  kqcal1 .eq. 0) then
        call abortjob
     &        ('setaxs0 ', 14,   'No valid estimate for q on axis     '
     &        ,'kqaxe   ', kqaxe,    'nx      ', nx,       +1)
      endif
c
c
c 6.5 Set qaxe eaxe and taxe
c     if nqaxis =  0 use the default choice
c     if nqaxis = -1 force use of the equilibrium fit from fitaxe (kqcal0)
c     if nqaxis = +1 force use of the axis fit from local axis derivatives and
c                    jphi (kqcal1)
c     if nqaxis < -1 use weight 1/iabs(nqaxis) on equilibrium fit from fitaxe
c                    (kqcal0)
c     if nqaxis > +1 use weight 1/iabs(nqaxis) on axis fit from local axis
c                    derivatives and jphi (kqcal1)
c
c 6.5.1 Set options
c
c 6.5.1.1 Set option when one option does not exist
        nqchois    = nqaxis
        kqchuse    =  0
c
        if    (kqcal1 .ne. 0  .and.  kqcal0 .eq. 0) then
          fact0     = 1.0
          kqchuse   =  +1
        elseif(kqcal1 .eq. 0  .and.  kqcal0 .ne. 0) then
          fact0     = 0.0
          kqchuse   =  +2
c
c 6.5.1.2 Set options according to override choice if both options exist
        elseif(kqcal1 .ne. 0  .and.  kqcal0 .ne. 0) then
          if    (nqchois .gt. 0) then
            fact0     =       1.0/float(iabs(nqchois))
            kqchuse   =  +3
          elseif(nqchois .lt. 0) then
            fact0     = 1.0 - 1.0/float(iabs(nqchois))
            kqchuse   =  +4
c
c 6.5.1.3 Set options according to default choice if no override and both options exist
          elseif(nqchois .eq. 0) then
            if    (kqcal1 .gt. 0) then
              fact0     = 1.0
              kqchuse   =  +5 
            elseif(kqcal1 .lt. 0  .and.  kqcal0 .gt. 0) then
              fact0     = 0.0
              kqchuse   =  +6
            elseif(kqcal1 .lt. 0  .and.  kqcal0 .lt. 0) then
              fact0     = 1.0
              kqchuse   =  +7
            endif
          endif
c
c 6.5.1.4 Error condition if no option is selected
        else
          call abortjob
     &        ('setaxs0 ', 15,   'Logic error choosing qaxe value     '
     &        ,'kqcal0  ', kqcal0,   'kqcal1  ', kqcal1,   -1)
          fact0     = 0.5
          kqchuse   =  +8
        endif
c
c 6.5.2 Set the values
c
      factq0    = 1.0 - fact0
      factq1    = 1.0 - factq0
      qaxe      = factq0*qax0 + factq1*qax1
      eaxe      = factq0*eax0 + factq1*eax1
      taxe      = factq0*tax0 + factq1*tax1
c
c
c
c 7.0 Compute the value of fqpi and fqim on axis
c
c 7.1 Compute fqiaxe
c
      raxen       = xma**nham1
      bpaxe       = 0.0
      if(nham2 .lt. 0) bpiaxen  = 0.0
      if(nham2 .eq. 0) bpiaxen  = 1.0
      if(nham2 .gt. 0) bpiaxen  = bigno
      btaxe       = faxe/xma
      if(abs(btaxe) .le. rndoff) btaxe = rndoff
      if(nham3 .ne. 0) btaxen  = (abs(btaxe))**nham3
      if(nham3 .eq. 0) btaxen  = 1.0
      fqidq       = qaxe*xma*xma/faxe
      fqiaxep     = faxe*fqidq/(raxen*btaxen)
      fqiaxe      = fqiaxep*bpiaxen
c
c
c 7.2 Compute fqmaxe
c
      r0adjst     =  raxen
      bpadjst     = (faxe/qaxe)**nham2
      btadjst     =  btaxe*btaxe*btaxen
      fqmaxe      = (r0adjst*bpadjst*btadjst*fqiaxe  -
     &               qaxe*faxe*faxe) / faxe
c
c
c
c 8.0 Define qp(jpsi1) and fqpi(jpsi1) from qaxe and fqiaxe and return
c
c 8.1 Print out the final results
c
      write(kuout,2000) kqcal0,kqcal1,kqchuse
      if    (kqchuse .le. 0) then
        call abortjob
     &        ('setaxs0 ', 16,   'Choice for qaxis was not defined    '
     &        ,'nqchois ', nqchois,  'kqchuse ', kqchuse,  -1)
      elseif(kqchuse .gt. 0  .and.  kqchuse .le. 8) then
        if(kqchuse .eq. +1) write(kuout,2020) 
        if(kqchuse .eq. +2) write(kuout,2025) 
        if(kqchuse .eq. +3) write(kuout,2030)
        if(kqchuse .eq. +4) write(kuout,2035)
        if(kqchuse .eq. +5) write(kuout,2040) 
        if(kqchuse .eq. +6) write(kuout,2045)
        if(kqchuse .eq. +7) write(kuout,2050)
        if(kqchuse .eq. +8) write(kuout,2055)
      elseif(kqchuse .gt. +8) then
        call abortjob
     &        ('setaxs0 ', 17,   'Choice for qaxis was not defined    '
     &        ,'nqchois ', nqchois,  'kqchuse ', kqchuse,  -1)
      endif
c
      write(kuout,2100) factq0, factq1, qaxe,   eaxe,  taxe
      write(kuout,2200) nham1,  nham2,  nham3
      write(kuout,2210) fqidq,  fqiaxep,fqiaxe, fqmaxe,
     &                  raxen,  bpiaxen,btaxen
      write(kuout,2220) r0adjst,bpadjst,btadjst
c
c
c 8.2 Store the final values
c
      qp  (jpsi1) = qaxe
      fqpi(jpsi1) = fqiaxe
      fqim(jpsi1) = fqmaxe
c
c
c 8.3 Return and end
c
      return
c
 1000 format(/,1x,'Axis coefficients from axial  fit:  ',/
     &        ,5x,'iax      = ',i5,11x,  'jax      = ',i5,/
     &        ,5x,'fitax31  = ',e14.6,2x,'ws       = ',e14.6,/
     &        ,5x,'fitax91  = ',e14.6,2x,'fitax121 = ',e14.6,/
     &        ,5x,'fitax61  = ',e14.6,2x,'fitax11  = ',e14.6
     &        ,2x,'fitax101 = ',e14.6,/)
 1010 format(/,1x,'Axis coefficients from spline fit:  ',/
     &        ,5x,'a0       = ',e14.6,2x,'b0       = ',e14.6
     &        ,2x,'c0       = ',e14.6,/
     &        ,5x,'a1       = ',e14.6,2x,'b1       = ',e14.6
     &        ,2x,'c1       = ',e14.6,/
     &        ,5x,'aj1      = ',e14.6,2x,'aj2      = ',e14.6,/)
 1020 format(/,1x,'Fit to q0 and elongation:',/
     &        ,5x,'from axial  fit:   q    = ',1pe14.6
     &        ,4x,                 '  e    = ',e14.6
     &        ,4x,             'and   t    = ',e14.6,/
     &        ,5x,'from spline fit:   q    = ',  e14.6
     &        ,4x,                 '  e    = ',e14.6
     &        ,4x,             'and   t    = ',e14.6,/
     &        ,5x,'Differences:     qaxerr = ',  e14.6
     &        ,4x,                 'eaxerr = ',e14.6,/)
 1030 format(/,1x,'Fit to q0 and elongation:',/
     &        ,5x,'from spline fit: q = ',  e14.6,4x,'e = ',e14.6
     &        ,4x,'and t = ',e14.6,/
     &        ,5x,'(Axial fit bypassed )',/)
 1040 format(/,1x,'Fit to q0 and elongation:',/
     &        ,5x,'from axial fit:  q = ',  e14.6,4x,'e = ',e14.6
     &        ,4x,'and t = ',e14.6,/
     &        ,5x,'(Spline fit bypassed)',/)
 2000 format(/,1x,'Final axis values:',/
     &        ,5x,'kqcal0   = ',  i5   ,11x,'kqcal1   = ',i5
     &       ,11x,'kqchuse  = ',  i5,/)
 2020 format(  1x,'Selected axis q from analytic formula with fit to:'
     &        ,1x,'eaxe (qax1):')
 2025 format(  1x,'Selected axis q from fitting psi around magnetic'
     &        ,1x,'axis (qax0):')
 2030 format(  1x,'Selected axis q from  fitting psi around axis'
     &        ,1x,'weighted by nqaxis (qax0):')
 2035 format(  1x,'Selected axis q from analytic formula with fit to'
     &        ,1x,'eaxe weighted by nqaxis (qax1):')
 2040 format(  1x,'Selected axis q from analytic formula with fit to'
     &        ,1x,'eaxe (qax1):')
 2045 format(  1x,'Selected axis q from fitting psi around magnetic'
     &        ,1x,'axis (qax0):')
 2050 format(  1x,'Selected axis q from analytic formula with fit to'
     &        ,1x,'eaxe (qax1):')
 2055 format(  1x,'Selected axis q from equal weight from analytic'
     &        ,1x,'formula with fit to eaxe and fitting psi around'
     &        ,1x,'axis (qax0):')
 2100 format(  5x,'factq0   = ',1pe14.6, 2x,'factq1   = ',e14.6,/
     &        ,5x,'qaxe     = ',  e14.6, 2x,'eaxe     = ',e14.6
     &        ,2x,'taxe     = ',  e14.6,/)
 2200 format(/,  1x,'Final fqpi and fqim axis values:'
     &      ,/,  5x,'nham1    = ',i5,11x,     'nham2    = ',i5
     &         ,11x,'nham3    = ',i5)
 2210 format(    5x,'fqidq    = ',  e14.6, 2x,'fqiaxep  = ',e14.6
     &        ,  2x,'fqiaxe   = ',  e14.6, 2x,'fqmaxe   = ',e14.6,/
     &        ,  5x,'raxen    = ',  e14.6, 2x,'bpiaxen  = ',e14.6
     &        ,  2x,'btaxen   = ',  e14.6)
 2220 format(    5x,'r0adjst  = ',  e14.6, 2x,'bpadjst  = ',e14.6
     &        ,  2x,'btadjst  = ',  e14.6)
      end
      subroutine setaxs1
c
c ------------------------------------------------------------
c  Calculate axis fit parameters for inverse equilibrium
c ------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Set the dimensions
c
      nppd        = npp
      nttd        = ntt
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('setaxs1 ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Initialize error flags
c
      kaxer0      = 0
      kaxer1      = 0
      kaxdif      = 0
      rndoff      = roundff
      eaxtol      = qptol
      rndofbf     = rndoff*bfieldf
c
c
c
c 2.0 Set axis q, fq, elongation and triangularity
c
c 2.1 Set axis profile values
c
c 2.1.1 Set the scalar values
c
      fonax       = sf  (1)
      qonax       = sqvl(1)
      pponax      = spp (1)
      ffonax      = sffp(1)
c
c 2.1.2 Check the field on axis is finite
c
      if    (abs(fonax) .le. rndofbf) then
         kaxer0   = +1
         call abortjob
     &        ('setaxs1 ',  2,   'Toroidal field f is zero on axis    '
     &        ,'nprofl  ', nprofl,   'kaxer0  ', kaxer0,   -1)
         fonax    = rndofbf
      endif
c
c
c 2.2 Compute axis elongation from q, f, and the current density on axis 
c
c 2.2.1 Compute current density on axis
c
      aj0         = -(amu*xma*xma*pponax + ffonax)
      ajc         = +0.5*(xma*aj0*qonax) / fonax
      dsc         =  ajc*ajc - 1.0
c
c 2.2.2 Compute the two roots for the axis elongation
c
      if    (dsc .le. 0.0) then
         kaxer0      = -1
         call abortjob
     &        ('setaxs1 ',  3,   'Invalid calculated elongation       '
     &        ,'nprofl  ', nprofl,   'kaxer0  ', kaxer0,   -1)
         elongax1    = +0.0
         elongax2    = +0.0
c
      elseif(dsc .gt. 0.0) then
         elongax1    = (ajc + sqrt(dsc))
         elongax2    = (ajc - sqrt(dsc))
      endif
c
c
c 2.3 Compute axis elongation from extrapolation from neighbouring surfaces
c
c 2.3.1 Compute elongation of neighbouring surfaces
c
c 2.3.1.1 Initialize
      elongtn(1)  = 0.0
      jpfmax      = max0(nfitmax,4)
      jpfmax      = min0(nppd,jpfmax)
c
c 2.3.1.2 Loop over neighbouring surfaces
      do 200 jp   = 2,jpfmax
      jpp         =  jp
      srmaxv      = -bigno
      srminv      = +bigno
      if    (neqsym .eq. 0) then
         szmaxv      = -bigno
         szminv      = +bigno
      elseif(neqsym .ne. 0) then
         szmaxv      =  0.0
         szminv      = +bigno
      endif
c
c 2.3.1.3 Find the maximum (r,z) from looping over poloidal angles
      do 100 ip   = 1,nthet
      ipp         = ip
      rsvl        = seqrps(jpp,ipp)
      zsvl        = seqzps(jpp,ipp)
      if(rsvl .ge. srmaxv) srmaxv  = rsvl
      if(rsvl .le. srminv) srminv  = rsvl
      if(zsvl .ge. szmaxv) szmaxv  = zsvl
      if(zsvl .le. szminv) szminv  = zsvl
  100 continue
c
c 2.3.1.4 Set the elongation for this surface
      rlong       =  srmaxv - srminv
      zlong       =  szmaxv - szminv
      if    (rlong .le. 0.0) then
         kaxer1 = kaxer1 + 1
         call abortjob
     &        ('setaxs0 ',  4,   'Flux surface has no radial width    '
     &        ,'kaxer1  ', kaxer1,   'jpp     ', jpp,      -1)
         elongtn(jpp) = -1.0
c
      elseif(rlong .gt. 0.0) then
         elongtn(jpp) = zlong/rlong
      endif
  200 continue
c
c 2.3.2 Extrapolate the elongation in to the axis
c
c 2.3.2.1 Set the interpolation values
      pvalj0      = psimsh(1)
      pvalj1      = psimsh(2)
      elongj1     = elongtn(2)
      pvalj2      = psimsh(3)
      elongj2     = elongtn(3)
      pvalj3      = psimsh(4)
      elongj3     = elongtn(4)
c
      dpsi01      = pvalj0 - pvalj1
      dpsi02      = pvalj0 - pvalj2
      dpsi03      = pvalj0 - pvalj3
      dpsi12      = pvalj1 - pvalj2
      dpsi13      = pvalj1 - pvalj3
      dpsi23      = pvalj2 - pvalj3
c
      dpsprd0     = dpsi01*dpsi02*dpsi03
      dpsprd1     = dpsi12*dpsi13*dpsi23
c
c 2.3.2.2 Check the interpolation data is consistent
      if(dpsprd0 .eq. 0.0) then
         kaxer1    = -1
         call abortjob
     &        ('setaxs0 ',  5,   'Input psi points are coincident     '
     &        ,'jpfmax  ', jpfmax,   'kaxer1  ', kaxer1,   -1)
         write(kuout,1000) dpsi01,dpsi02,dpsi03,
     &                     dpsi12,dpsi13,dpsi23
      endif
c
      if(dpsprd1 .eq. 0.0) then
         kaxer1    = -2
         call abortjob
     &        ('setaxs0 ',  6,   'Input psi points are coincident     '
     &        ,'jpfmax  ', jpfmax,   'kaxer1  ', kaxer1,   -1)
         write(kuout,1000) dpsi01,dpsi02,dpsi03,
     &                     dpsi12,dpsi13,dpsi23
      endif
c
c 2.3.3 Set the extrapolated axis elongation
c
c 2.3.3.1 Set the elongation from the interpolation coefficients if no error
      if    (kaxer1 .ge. 0) then
         coef1      = +(dpsi02*dpsi03)/(dpsi12*dpsi13)
         coef2      = -(dpsi01*dpsi03)/(dpsi12*dpsi23)
         coef3      = +(dpsi01*dpsi02)/(dpsi13*dpsi23)
c
         elongaxp   = coef1*elongj1 + coef2*elongj2 + coef3*elongj3
c
c 2.3.3.2 Set the elongation estimate zero if there is an error
      elseif(kaxer1 .lt. 0) then
         elongaxp   = 0.0
      endif
c
c 2.3.4 Save the value as elongtn(1)
c
      elongtn(1)  = elongaxp
c
c
c 2.4 Determine the final best estimate
c
c 2.4.1 Compare the estimates
c
c 2.4.1.1 Find the difference between the extrapolated estimate and the two
c         roots
      elongd1     = abs(elongax1 - elongaxp)
      elongd2     = abs(elongax2 - elongaxp)
      if    (elongd1 .le. elongd2) then
         elongaxs    = elongax1
         elongdf0    = elongd1
      elseif(elongd1 .gt. elongd2) then
         elongaxs    = elongax2
         elongdf0    = elongd2
      endif
c
c 2.4.1.2 Choose the best estimate
c         For abs(nqaxis)  = 0 use the calculated value (default)
c         For abs(nqaxis)  = 1 use the extrapolated value
c         For abs(nqaxis)  > 1 use the calculated value
      nechois  = iabs(nqaxis)
      if    ((kaxer0   .eq.  0)  .and.
     &       (elongax1 .gt. 0.0  .and.  elongax2 .gt. 0.0)) then
         kaxchos     = 0
         if(nechois .lt. 0) factq  = 1.0
         if(nechois .eq. 0) factq  = 1.0
         if(nechois .gt. 0) factq  = 0.0
         axelong     = (1.0 - factq)*elongaxp + factq*elongaxs
      elseif( kaxer0   .ne.  0   .and.  kaxer1   .eq.  0 )  then
         kaxchos     = +1
         axelong     = elongaxp
      elseif( kaxer0   .ne.  0   .and.  kaxer1   .ne.  0 )  then
         kaxchos     = -1
         axelong     = -1.0
      elseif( kaxer0   .eq.  0   .and.  elongax1 .le. 0.0)  then
         kaxchos     = +2
         axelong     = elongaxp
      elseif( kaxer0   .eq.  0   .and.  elongax2 .le. 0.0)  then
         kaxchos     = +3
         axelong     = elongaxp
      else
         kaxchos     = -2
         axelong     =  0.0
      endif
c
c 2.4.1.3 Set the input value for comparisons
c
      if(kmap .gt. 0) axinput  = axddxz
      if(kmap .lt. 0) axinput  = axelong
c
c 2.4.2 Check the estimates
c
c 2.4.2.1 Check the calculated estimates
      if(kaxchos .lt. 0) then
         call abortjob
     &        ('setaxs1 ',  7,   'Axis elongation is not defined      '
     &        ,'kaxer0  ', kaxer0,   'kaxchos ', kaxchos,  -2)
         kaxdif      = -1
      endif
c
      if(elongdf0 .ge. eaxtol) then
         call abortjob
     &        ('setaxs1 ',  8,   'Axis elongation inconsistency       '
     &        ,'kaxer0  ', kaxer0,   'kaxer1  ', kaxer1,   -2)
         kaxdif      = -1
      endif
c
c 2.4.2.2 Check the estimate against the input value
c
c 2.4.2.2.1 Check the estimate if a valid input exists
      if(axinput .ne. 0.0) then
         elongdf1    = abs(axelong  - axinput)
         elongdfs    = abs(elongaxs - axinput)
         elongdfp    = abs(elongaxp - axinput)
         if(elongdf1 .ge. eaxtol) then
            call abortjob
     &        ('setaxs1 ',  9,   'Input axis elongation different     '
     &        ,'kaxer0  ', kaxer0,   'kaxer1  ', kaxer1,   -1)
c
c 2.4.2.2.2 Check the other estimates and rechoose one if it is valid
            if    (elongdfs .lt. eaxtol) then
               kaxdif    = +1
               axelong   = elongaxs
               call abortjob
     &        ('setaxs1 ', 10,   'Revert to calculated elongation     '
     &        ,'kaxchos ', kaxchos,  'kaxdif  ', kaxdif,   -1)
            elseif(elongdfp .lt. eaxtol) then
               kaxdif    = +2
               axelong   = elongaxp
               call abortjob
     &        ('setaxs1 ', 11,   'Revert to extrapolated elongation   '
     &        ,'kaxchos ', kaxchos,  'kaxdif  ', kaxdif,   -1)
            else
               kaxdif   = +3
            endif
      endif
      elseif(axinput .eq. 0.0) then
         kaxdif     = +4
               call abortjob
     &        ('setaxs1 ', 12,   'No input axis elongation available  '
     &        ,'kaxchos ', kaxchos,  'kaxdif  ', kaxdif,   -1)
         elongdf1   = 0.0
         elongdfs   = 0.0
         elongdfp   = 0.0
      endif
c
c 2.4.3 Print the values
c
      write(kuout,1100)
      if    (kaxchos .eq. 0) then
         if(nechois .lt.  0) write(kuout,1105)
         if(nechois .eq.  0) write(kuout,1110)
         if(nechois .gt.  0) write(kuout,1115)
      elseif(kaxchos .ne. 0) then
         if(kaxchos .eq. +1) write(kuout,1120)
         if(kaxchos .eq. +2) write(kuout,1125)
         if(kaxchos .eq. +3) write(kuout,1130)
         if(kaxchos .eq. -1) write(kuout,1135)
         if(kaxchos .eq. -2) write(kuout,1140)
      endif
c
      write(kuout,1150) kaxdif,kaxchos,nechois,axelong
      write(kuout,1200) axinput,elongaxs,elongaxp
      if    (kaxdif .ne. +4) then
         write(kuout,1210) elongdf0,elongdf1,elongdfs,elongdfp,eaxtol
      elseif(kaxdif .eq. +4) then
         write(kuout,1215) elongdf0,eaxtol
      endif
      write(kuout,1220) elongax1,elongax2,elongd1,elongd2
      write(kuout,1230) jpfmax
      write(kuout,1240)  elongtn(1)
      write(kuout,1245) (elongtn(kj),kj=2,jpfmax)
c
c
c 2.5 Set the final elongation triangularity and q on axis estimates
c
c 2.5.1 Set eaxe and taxe
c
      eax0        = axinput
      tax0        = 0.0
      eax1        = axelong
      tax1        = 0.0
c
c 2.5.2 Set qaxe estimates
c
c 2.5.2.1 Set qaxe from the input q profile value and from the elongation and r*jphi
      qax0        = sqvl(1)
      qax1        = fonax/xma * (1.0+eax1*eax1)/(eax1*aj0)
c
c 2.5.2.2 Set alternative combinations
      if    (axinput  .ne. 0.0) then
        qaxinp      = fonax/xma * (1.0+axinput* axinput )/
     &                                         (axinput *aj0)
      elseif(axinput  .eq. 0.0) then
        qaxinp      = 0.0
      endif
c
      if    (elongaxp .ne. 0.0) then
        qaxisp      = fonax/xma * (1.0+elongaxp*elongaxp)/
     &                                         (elongaxp*aj0)
      elseif(elongaxp .eq. 0.0) then
        qaxisp      = 0.0
      endif
c
      if    (elongax1 .ne. 0.0) then
        qaxis1      = fonax/xma * (1.0+elongax1*elongax1)/
     &                                         (elongax1*aj0)
      elseif(elongax1 .eq. 0.0) then
        qaxis1      = 0.0
      endif
c
      if    (elongax2 .ne. 0.0) then
        qaxis2      = fonax/xma * (1.0+elongax2*elongax2)/
     &                                         (elongax2*aj0)
      elseif(elongax2 .eq. 0.0) then
        qaxis2      = 0.0
      endif
c
c 2.5.3 Print a warning if the two estimates for qaxe disagree
c
c 2.5.3.1 Check the differences
      qaxtol      = qptol*(abs(qax0) + abs(qax1))
      qaxerr      = qax0 - qax1
      if(abs(qaxerr) .ge. qaxtol) then
        call abortjob
     &        ('setaxs1 ', 13,   'Estimates for qaxe disagree         '
     &        ,'kaxchos ', kaxchos,  'kaxdif  ', kaxdif,   -1)
      endif
c
c 2.5.3.2 Print the estimates
      write(kuout,1500) qax0,qax1,qaxerr,qaxtol
c
c
c 2.6 Set the final values for qaxe eaxe and taxe
c     if nqaxis =  0 use the default choice (qax1)
c     if nqaxis <  0 force use of the input equilibrium value (qax0)
c     if nqaxis >  0 force use of the axis fit from local axis derivatives and
c                    jphi (qax1)
c 2.6.1 Set options
c
c 2.6.1.1 Set options according to default choice
        nqchois  = isign(1,nqaxis)
c
        if    (nqchois .eq. 0) then
          fact0     = 1.0
c
c 2.6.1.2 Set option as one of the two estimates
        elseif(nqchois .gt. 0) then
          fact0     = 0.0
        elseif(nqchois .lt. 0) then
          fact0     = 1.0
        endif
c
c 2.6.2 Set the values
c
      factq0      = 1.0 - fact0
      factq1      = 1.0 - factq0
      qaxe        = factq0*qax0 + factq1*qax1
      eaxe        = factq0*eax0 + factq1*eax1
      taxe        = factq0*tax0 + factq1*tax1
c
c
c
c 3.0 Set axis fqpi and fqim
c
c 3.1 Compute fqiaxe
c
      raxen       = xma**nham1
      bpaxe       = 0.0
      if(nham2 .lt. 0) bpiaxen  = 0.0
      if(nham2 .eq. 0) bpiaxen  = 1.0
      if(nham2 .gt. 0) bpiaxen  = bigno
      btaxe       = faxe/xma
      if(abs(btaxe) .le. rndoff) btaxe = rndoff
      if(nham3 .ne. 0) btaxen  = (abs(btaxe))**nham3
      if(nham3 .eq. 0) btaxen  = 1.0
      fqidq       = qaxe*xma*xma/faxe
      fqiaxep     = faxe*fqidq/(raxen*btaxen)
      fqiaxe      = fqiaxep*bpiaxen
c
c
c 3.2 Compute fqmaxe
c
      r0adjst     =  raxen
      bpadjst     = (faxe/qaxe)**nham2
      btadjst     =  btaxe*btaxe*btaxen
      fqmaxe      = (r0adjst*bpadjst*btadjst*fqiaxe  -
     &               qaxe*faxe*faxe) / faxe
c
c
c
c 4.0 Define qp(jpsi1) fqpi(jpsi1) and fqim(jpsi1) from qaxe, fqiaxe, and faxe, and return
c
c 4.1 Print out the final results
c
      write(kuout,2000) nqchois
      write(kuout,2010) factq0, qaxe,   eaxe,   taxe
      write(kuout,2020) qaxinp, qaxisp, qaxis1, qaxis2
      write(kuout,2100) nham1,  nham2,  nham3
      write(kuout,2110) fqidq,  fqiaxep,fqiaxe, fqmaxe,
     &                  raxen,  bpiaxen,btaxen
      write(kuout,2120) r0adjst,bpadjst,btadjst
c
c
c 4.2 Store the final values
c
      qp  (jpsi1) = qaxe
      fqpi(jpsi1) = fqiaxe
      fqim(jpsi1) = fqmaxe
c
c
c
c 5.0 Return and end
c
      return
 1000 format(/, 10x,'dpsi01   = ',e16.9,4x, 'dpsi02   = ',e16.9
     &          ,4x,'dpsi03   = ',e16.9,/
     &         ,10x,'dpsi12   = ',e16.9,4x, 'dpsi13   = ',e16.9
     &          ,4x,'dpsi23   = ',e16.9)
 1100 format(//, 1x,'Inverse equilibrium axis fitting:')
 1105 format(    5x,'Axis elongation estimate used value calculated'
     &          ,1x,'from input qaxis:')
 1110 format(    5x,'Axis elongation estimate used value calculated'
     &          ,1x,'from input qaxis (default):')
 1115 format(    5x,'Axis elongation estimate used value extrapolated'
     &          ,1x,'from inner surfaces:')
 1120 format(    5x,'Axis elongation estimate used value extrapolated'
     &          ,1x,'from inner surfaces:')
 1125 format(    5x,'Axis elongation estimate used value extrapolated'
     &          ,1x,'from inner surfaces:')
 1130 format(    5x,'Axis elongation estimate used value extrapolated'
     &          ,1x,'from inner surfaces:')
 1135 format(    5x,'Axis elongation estimate was not defined:'
     &          ,1x,'Neither calculated nor extrapolated calculation'
     &          ,1x,'was valid:')
 1140 format(    5x,'Axis elongation estimate was not defined:'
     &          ,1x,'No valid option could be determined:')
 1150 format(    5x,'kaxdif   = ',i5,   13x,'kaxchos  = ',i5
     &         ,13x,'nechois  = ',i5
     &        ,/,5x,'axelong  (final axis elongation)      = ',e16.9)
 1200 format(  /,5x,'Axis elongation calculations:'
     &        ,/,5x,'axinput  (from       input     )      = ',e16.9
     &        ,/,5x,'elongaxs (from    calculation  )      = ',e16.9
     &        ,/,5x,'elongaxp (from   extrapolation )      = ',e16.9)
 1210 format(  /,5x,'Differences between estimates:'
     &        ,/,5x,'elongdf0 = ',e16.9,3x,'(elongaxs - elongaxp)'
     &        ,/,5x,'elongdf1 = ',e16.9,3x,'(axelong  - axinput)'
     &        ,/,5x,'elongdfs = ',e16.9,3x,'(elongaxs - axinput)'
     &        ,/,5x,'elongdfp = ',e16.9,3x,'(elongaxp - axinput)'
     &          ,5x,'eaxtol   = ',e16.9)
 1215 format(  /,5x,'Differences between estimates:'
     &        ,/,5x,'elongdf0 = ',e16.9,3x,'(elongaxs - elongaxp)'
     &          ,5x,'eaxtol   = ',e16.9)
 1220 format(//, 5x,'Elongation roots from input qaxis:              '
     &          ,2x,e16.9,2x,e16.9
     &       ,/, 5x,'Difference between roots and extrapolated value:'
     &          ,2x,e16.9,2x,e16.9)
 1230 format(/,  5x,'Neighbouring surface elongations: jpfmax = ',i5)
 1240 format(10x,1x,e16.9,4x,'(Extrapolated to axis)')
 1245 format((26x,5(1x,e16.9)))
 1500 format(/,  1x,'Estimates for axis q:'
     &       ,/, 5x,'qax0     = ',1pe16.9, 2x,'qax1     = ',  e16.9
     &          ,2x,'qaxerr   = ',  e14.6, 4x,'qaxtol   = ',  e14.6)
 2000 format(/,  1x,'Final q axis values:'
     &      ,/,  5x,'nqchois  = ',  i5)
 2010 format(    5x,'factq    = ',1pe14.6,/
     &          ,5x,'qaxe     = ',  e14.6,2x,'eaxe     = ',  e14.6
     &          ,2x,'taxe     = ',  e14.6)
 2020 format(/,  1x,'Alternative estimates for axis q:'
     &      ,/, 12x,'Using axinput ',13x,'Using elongaxp'
     &         ,13x,'Using elongax1',13x,'Using elongax2'
     &      ,/,  5x,'qaxinp   = ',1pe14.6,2x,'qaxisp   = ',  e14.6
     &          ,2x,'qaxis1   = ',  e14.6,2x,'qaxis2   = ',  e14.6)
 2100 format(/,  1x,'Final fqpi and fqim axis values:'
     &      ,/,  5x,'nham1    = ',i5,11x,     'nham2    = ',i5
     &         ,11x,'nham3    = ',i5)
 2110 format(    5x,'fqidq    = ',  e14.6, 2x,'fqiaxep  = ',e14.6
     &        ,  2x,'fqiaxe   = ',  e14.6, 2x,'fqmaxe   = ',e14.6,/
     &        ,  5x,'raxen    = ',  e14.6, 2x,'bpiaxen  = ',e14.6
     &        ,  2x,'btaxen   = ',  e14.6)
 2120 format(    5x,'r0adjst  = ',  e14.6, 2x,'bpadjst  = ',e14.6
     &        ,  2x,'btadjst  = ',  e14.6)
      end
      subroutine rescaleq(kset)
c
c -------------------------------------------------------------
c  Rescale the profiles to specified qaxe
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize axis quantities
c
      sfold     = sf(1)
      fqold     = fqiaxe
      ws        = sfold**2
      rndoff    = roundff
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('rescale ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c
c 2.0 Set btdnew if btdes or qxin is specified
c
c 2.1 For both qxin and btdes zero leave as is
c
      if    (qxin  .eq. 0.0  .and.  btdes .eq. 0.0) then
        btdnew  = 0.0
        qaxnew  = 0.0
c
c
c 2.2 For btdes non zero reset btor to btdes
c
      elseif(qxin  .eq. 0.0  .and.  btdes .ne. 0.0) then
        btdnew  = btdes
        qaxnew  = qaxe*sqrt(1.0  +  rcnt*rcnt*(btdnew*btdnew
     &                                       - btor*btor)
     &                                                    / ws)
        write(kuout,1000) btdes,qxin,btor,qaxe,btdnew,qaxnew
c
c
c 2.3 For qxin non zero reset qaxe to qxin
c
      elseif(qxin  .ne. 0.0  .and.  btdes .eq. 0.0) then
        btdnew  = sqrt(btor**2  +  ws*((qxin/qaxe)**2-1.0)
     &                                                / rcnt**2)
        qaxnew  = qxin
        write(kuout,1010) btdes,qxin,btor,qaxe,btdnew,qaxnew
c
c
c 2.4 For both qxin and btdes non zero ignore btdes and reset qaxe to qxin
c
      elseif(qxin  .ne. 0.0  .and.  btdes .ne. 0.0) then
        btdnew  = sqrt(btor**2  +  ws*((qxin/qaxe)**2-1.0) / rcnt**2)
        qaxnew  = qxin
        call abortjob
     &        ('rescaleq',  2,   'Cannot set q with btdes and qxin    '
     &        ,'ktype   ', ktype,    'kset    ', kset,     -1)
        write(kuout,1050) btdes,qxin,btor,qaxe,btdnew,qaxnew
      endif
c
c
c
c 3.0 Rescale to required btdnew
c
c 3.1 Return if no rescale is required
c
      if    (btdnew .eq. 0.0) then
        kset        = 0
        return
c
c
c 3.2 Rescale if required
c
      elseif(btdnew .ne. 0.0) then
c
c 3.2.1 Rescale sf
c
        wsd        = rcnt*rcnt*(btdnew*btdnew - btor*btor)
        do 10 j    = 1,nprofl
        jvl        = j
        sfoldj     = sf  (jvl)
        sqoldj     = sqvl(jvl)
        sfqoldj    = sfqi(jvl)
        sf(jvl)    = sqrt(wsd + sf(jvl)**2)
        if(ktype .gt. 0) then
          if    (sfoldj .ne. 0.0) then
            sqvl(jvl)  = sqoldj*  sf(jvl)/sfoldj
            sfqi(jvl)  = sfqoldj*(sf(jvl)/sfoldj)**nham3
          elseif(sfoldj .eq. 0.0) then
            call abortjob
     &        ('rescaleq',  3,   'Cannot rescale since f(jvl) = 0     '
     &        ,'ktype   ', ktype,    'jvl     ', jvl,      +1)
          endif
        endif
   10   continue
c
c 3.2.2 Reset qaxe and btor
c
        qaxrat      = qaxnew/qaxe
        faxrat      = sf(1)/sfold
        dlimit      = qaxrat/faxrat
        btor        = btdnew
        qaxe        = qaxnew
c
c 3.2.2 Reset the end points of qp fqpi and fqim from recalculating
c       qaxe fqiaxe and fqmaxe
c
c 3.2.2.1 Compute fqiaxe
        faxep       = sf(1)
        raxen       = xma**nham1
        bpaxe       = 0.0
        if(nham2 .lt. 0) bpiaxen  = 0.0
        if(nham2 .eq. 0) bpiaxen  = 1.0
        if(nham2 .gt. 0) bpiaxen  = bigno
        btaxe       = faxep/xma
        if(abs(btaxe) .le. rndoff) btaxe = rndoff
        if(nham3 .ne. 0) btaxen  = (abs(btaxe))**nham3
        if(nham3 .eq. 0) btaxen  = 1.0
        fqidq       = qaxe*xma*xma/faxep
        fqiaxep     = faxep*fqidq/(raxen*btaxen)
        fqiaxe      = fqiaxep*bpiaxen
c
c 3.2.2.2 Compute fqmaxe
        r0adjst     =  raxen/(xma*xma)
        bpadjst     = (faxep/qaxe)**nham2
        btadjst     =  btaxen
        fqmaxe      = (r0adjst*bpadjst*btadjst*fqiaxe  -
     &                 qaxe*faxep*faxep) / faxep
c
c 3.2.2.3 Reset the values
        qp  (jpsi1) = qaxe
        fqpi(jpsi1) = fqiaxe
        fqim(jpsi1) = fqmaxe
c
c 3.2.3 Set flag if equilibrium quantities are rescaled
c
        kset        = 1
      endif
c
c
c
c 4.0 Rescale the input equilibrium quantities if necessary
c
      if(kset .eq. 1  .and.  ktype .eq. 2) then
c
c     Print a warning since this is not yet written
c
        call abortjob
     &        ('rescaleq',  4,   'Equilibrium rescaled but nmap = 2   '
     &        ,'ktype   ', ktype,    'kset    ', kset,     -1)
      endif
c
c
c
c 5.0 Return and end
c
      return
 1000 format(1x,'Resetting the toroidal field and q from btdes:',/
     &      ,1x,'btdes   = ',e16.9,2x,'qxin    = ',e16.9
     &      ,2x,'btor    = ',e16.9,2x,'qaxe    = ',e16.9,/
     &      ,1x,'btdnew  = ',e16.9,2x,'qaxnew  = ',e16.9)
 1010 format(1x,'Resetting the toroidal field and q from qxin:',/
     &      ,1x,'btdes   = ',e16.9,2x,'qxin    = ',e16.9
     &      ,2x,'btor    = ',e16.9,2x,'qaxe    = ',e16.9,/
     &      ,1x,'btdnew  = ',e16.9,2x,'qaxnew  = ',e16.9)
 1050 format(1x,'Resetting the toroidal field and q  using qxin only:',/
     &      ,1x,'btdes   = ',e16.9,2x,'qxin    = ',e16.9
     &      ,2x,'btor    = ',e16.9,2x,'qaxe    = ',e16.9,/
     &      ,1x,'btdnew  = ',e16.9,2x,'qaxnew  = ',e16.9)
      end
      subroutine ortogray(kcall)
c
c -------------------------------------------------------------
c  Construct initial orthogonal ray from axis to separatrix
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nxx=513,nxz=nxx)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize step sizes for runkut
c
      stpfac0   = stepfac
      stpfac1   = stpfac0
      rndoff    = roundff
      tolpsi    = epsaxs
c
c
c 1.2 Initialize function fitting parameters for runkut
c
      newtmxp   = nwtfitp
      newtmxm   = nwtfitm
      tlnewtp   = tolnwtp
      tlnewtm   = tolnwtm
c
c
c 1.3 Initialize search for runkut
c
      is        = 1
      js        = 1
      delxi     = 1.0/dmx
      delzi     = 1.0/dmz
c
c
c 1.4 Set auxiliary variables for runkut
c
      if(kuttaop .eq. 0) kutopt  =  0
      if(kuttaop .lt. 0) kutopt  = -1
      if(kuttaop .gt. 0) kutopt  = +1
c
c
c
c 2.0 Calculate the starting orthogonal poloidal ray for the Dee case
c     Start at the magnetic axis and integrate out with reversed storage
c
      if(numax .eq. 1) then
c
c 2.1 Loop until stpfac1 is large enough that the correct
c     direction is taken
c
        nrunkt    = 0
   10   nrunkt    = nrunkt + 1
c
c
c 2.2 Integrate from the axis out to the edge
c       The first point is moved slightly off axis to ensure nonzero gradient
c
        krerun    = 0
        jstart    = jpsi2
        jfinal    =   1
        jfin1     =   2
        step1     = stpfac1*dmx
        rstart    = smax(1)
        zstart    = smaz(1)
        call runkut(x,z,nx,nz,psarray,gpx,gpy,nxd,nzd,1,jpsi2,jstart,
     &              rstart,zstart,step1,is,js,delxi,delzi,ipestg,
     &              psivl0,rst,zst,jfinal,np2,kutopt,nrkmax1,
     &              numstp,newtmxp,newtmxm,tlnewtp,tlnewtm,rndoff,
     &              tolpsi,kuout,ker0)
c
c
c 2.3 Check for errors
c
c 2.3.1 Check for errors in the integration
c
        if    (ker0 .ne. 0) then
          krerun    = +1
          jfin1     =  min0(jstart,jfinal+1)
          rdray     = 0.0
          if    (ker0 .lt. 0) then
            write(kuout,1000)
            write(kuout,1010) jstart,jfinal
            write(kuout,1015) (psivl0(jj),jj = jstart,1,-1)
            write(kuout,1020) nrunkt,rdray,step1,stpfac0,stpfac1
     &                                    ,jstart,rst(jstart)
     &                                    ,jfinal,rst(jfinal)
            write(kuout,1030) jstart,jfinal
            write(kuout,1040)
            write(kuout,1050) (rst(jj),zst(jj),jj = jstart,jfin1,-1)
            if(jstart .ne. jfin1) 
     &      write(kuout,1060)  rst(jfinal),zst(jfinal)
c
            call abortjob
     &        ('ortogray',  1,   'Fatal Runge Kutta error for Dee     '
     &        ,'nrunkt  ', nrunkt,   'ker0    ', ker0,     +1)
          elseif(ker0 .gt. 0) then
            call abortjob
     &        ('ortogray',  2,   'Error in Runge Kutta for Dee        '
     &        ,'nrunkt  ', nrunkt,   'ker0    ', ker0,     -1)
          endif
c
c 2.3.2 Check the integration is in the right direction
c
        elseif(ker0 .eq. 0) then
          rdray     = rst(  1  ) - rst(jpsi2)
          if(stpfac0 .ge. 0.0  .and.  rdray .le. 0.0) krerun  = +2
        endif
c
c 2.3.3 Repeat with modified step size if there is an error
c
        if(krerun .ne. 0) then
c
c 2.3.3.1 If runkut had an error modify the step size
          if    (krerun .eq. +1) then
            if    (ker0 .eq. 1 .or. ker0 .eq. 2 .or. ker0 .eq. 3 .or.
     &                                               ker0 .eq. 5) then
              call abortjob
     &        ('ortogray',  3,   'Rerun Runge Kutta:  halved step     '
     &        ,'nrunkt  ', nrunkt,   'jfinal  ', jfinal,    0)
              stpfac1  = 0.5*stpfac1
            elseif(ker0 .eq. 4 .or. ker0 .eq. 6 .or. ker0 .eq. 7) then
              call abortjob
     &        ('ortogray',  4,   'Rerun Runge Kutta: doubled step     '
     &        ,'nrunkt  ', nrunkt,   'jfinal  ', jfinal,    0)
              stpfac1  = 2.0*stpfac1
            else
              call abortjob
     &        ('ortogray',  5,   'Unidentified error from runkut      '
     &        ,'nrunkt  ', nrunkt,   'ker0    ', ker0,     -1)
              stpfac1  = 2.0*stpfac1
            endif
c
c 2.3.3.2 If the direction is incorrect modify the step size
          elseif(krerun .eq. +2) then
              call abortjob
     &        ('ortogray',  6,   'Wrong direction: rerun half step    '
     &        ,'nrunkt  ', nrunkt,   'krerun  ', krerun,   -1)
              stpfac1  = 0.5*stpfac1
c
c 2.3.3.3 For unidentified errors make a default modification in the step size
          elseif(krerun .gt. +2) then
            call abortjob
     &        ('ortogray',  7,   'Logic error defining new step       '
     &        ,'nrunkt  ', nrunkt,   'krerun  ', krerun,   -1)
            stpfac1  = 0.5*stpfac1
          endif
c
c 2.3.3.4 Print the diagnostic data
          write(kuout,1100)
          write(kuout,1110) jstart,jfinal
          write(kuout,1115) (psivl0(jj),jj = jstart,1,-1)
c
          if(kcall .ne. 0) then
            write(kuout,1200) nrunkt,rdray,step1,stpfac0,stpfac1
     &                                    ,jstart,rst(jstart)
     &                                    ,jfinal,rst(jfinal)
            write(kuout,1205) jstart,jfinal
            write(kuout,1210)
            write(kuout,1215) (rst(jj),zst(jj),jj = jstart,jfin1,-1)
            if(jstart .ne. jfin1) 
     &      write(kuout,1220)  rst(jfinal),zst(jfinal)
          endif
c
c 2.3.3.5 Stop if the maximum number of tries is exceeded
          if(nrunkt .ge. nrkmax0) then
            if(kcall .eq. 0) then
              write(kuout,2000) nrunkt,rdray,step1
     &                                      ,jpsi2,rst(jpsi2),rst(1)
              write(kuout,2005) jstart,jfinal
              write(kuout,2010) (rst(jj),zst(jj),jj = jstart,jfin1,-1)
              if(jstart .ne. jfin1) 
     &                      write(kuout,2020)  rst(jfinal),zst(jfinal)
            endif
            call abortjob
     &        ('ortogray',  8,   'Number of tries exceeded nrkmax0    '
     &        ,'nrunkt  ', nrunkt,   'krerun  ', krerun,   +1)
          endif
c
c 2.3.3.6 Try again with the new step size
          go to 10
        endif
c
c
c
c 3.0 Calculate the starting orthogonal poloidal ray for the Doublet case
c     Start at the x point
c
      elseif(numax .eq. 2) then
c
c
c 3.1 Integrate to the separatrix from the X-point
c
c 3.1.1 Integrate
c
        jstart    = jsep+1
        step0     = stpfac0*dmx
        rstart    = xsep
        zstart    = zsep
        call runkut(x,z,nx,nz,psarray,gpx,gpy,nxd,nzd,1,jsep+1,jstart,
     &              rstart,zstart,step0,is,js,delxi,delzi,ipestg,
     &              psivl0,rst,zst,jfinal,np2,kutopt,nrkmax1,
     &              numstp,newtmxp,newtmxm,tlnewtp,tlnewtm,rndoff,
     &              tolpsi,kuout,ker1)
c
c 3.1.2 Check for errors
c
        if(ker1 .ne. 0) then
          call abortjob
     &        ('ortogray',  9,   'Error in Runge Kutta for doublet    '
     &        ,'ker1    ', ker1,     'jsep    ', jsep,     +1)
        endif
c
c
c 3.2 Integrate to the edge.  Take a big vertical step
c       for low percentage flux doublets.
c
c 3.2.1 Integrate
c
        ps1a      = flxstp
        ps1b      = 2.00*flxstp
        ps1c      = flxstp
        ps        = (psisep-psimx(1))/(psilim-psimx(1))
        ws        = (stpfac0*(ps-ps1a) - (ps-ps1b))/ps1c
        delz      = (z(2)-z(1)) *amin1(1.0,amax1(ws,stpfac0))
c
        rs1       = rst(jsep)
        zs1       = zst(jsep)
c
        jstart    = jsep
        rstart    = xsep
        zstart    = zsep + delz
        call runkut(x,z,nx,nz,psarray,gpx,gpy,nxd,nzd,jsep,jpsi1,jsep,
     &              rstart,zstart,step0,is,js,delxi,delzi,ipestg,
     &              psivl0,rst,zst,jfinal,np2,kutopt,nrkmax1,
     &              numstp,newtmxp,newtmxm,tlnewtp,tlnewtm,rndoff,
     &              tolpsi,kuout,ker2)
c
c 3.2.2 Check for errors
c
        if(ker2 .ne. 0) then
          call abortjob
     &        ('ortogray', 10,   'Error in Runge Kutta for doublet    '
     &        ,'ker2    ', ker2,     'jsep    ', jsep,     +1)
        endif
c
c
c 3.3 Set the separatrix
c
        rst(jsep) = rs1
        zst(jsep) = zs1
      endif
c
c
c
c 4.0 Return and end
c
      return
c
 1000 format(  5x,'Psi mesh:')
 1010 format(  5x,'(psivl0(j), j = ',i5,',1 [Axis to edge]: jfinal = '
     &        ,i5)
 1015 format(5(1x,e16.9))
 1020 format(/,5x,'nrunkt      = ',i5,   11x,'rdray       = ',e14.7,/
     &        ,5x,'step1       = ',e14.7, 2x,'stpfac0     = ',e14.7
     &        ,2x,'New step fraction:',1x,e14.7,/
     &        ,5x,'rst(',i5,')  = ',e14.7
     &        ,2x,'rst(',i5,')  = ',e14.7,/)
 1030 format(  5x,'(rst(j),zst(j), j = ',i5,',',i5,' [Axis to edge]')
 1040 format(  2x,'(')
 1050 format(5(e12.5,1x,e12.5,')',2x,'('))
 1060 format(  2x,'(',e12.5,1x,e12.5,')' )
 1100 format(  5x,'Psi mesh:')
 1110 format(  5x,'(psivl0(j), j = ',i5,',1 [Axis to edge]: jfinal = '
     &        ,i5)
 1115 format(5(1x,e16.9))
 1200 format(/,5x,'nrunkt      = ',i5,   11x,'rdray       = ',e14.7,/
     &        ,5x,'step1       = ',e14.7, 2x,'stpfac0     = ',e14.7
     &        ,2x,'New step fraction:',1x,e14.7,/
     &        ,5x,'rst(',i5,')  = ',e14.7
     &        ,2x,'rst(',i5,')  = ',e14.7,/)
 1205 format(  5x,'(rst(j),zst(j), j = ',i5,',',i5,' [Axis to edge]')
 1210 format(  2x,'(')
 1215 format(5(e12.5,1x,e12.5,')',2x,'('))
 1220 format(  2x,'(',e12.5,1x,e12.5,')' )
 2000 format(/,5x,'The Runga-Kutta integration is in the'
     &        ,1x,'wrong direction:',/
     &        ,1x,'nrunkt      = ',i5,   11x,'rdray       = ',e14.7
     &        ,2x,'step1       = ',e14.7
     &        ,5x,'rst(',i5,')  = ',e14.7
     &        ,2x,'rst(  1  )  = ',e14.7,/)
 2005 format(  5x,'(rst(j),zst(j), j = ',i5,',',i5,' [Axis to edge]')
 2010 format(  2x,'(',5(e12.5,1x,e12.5,')'))
 2020 format(  2x,'(',e12.5,1x,e12.5,')')
      end
      subroutine setpsim
c
c -------------------------------------------------------------
c  Set up the poloidal mesh interpolation
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
      rndoff       = roundff
c
c
c
c 2.0 Set up the psival flux mesh arrays corresponding to peqmsh1
c     and peqmsh2
c
      do 100 j      = 1,jpsi1
      jvv           = j
      peqval        = psival(jvv)
      ppsim1        = defmesh(peqval,psimax,delpsir,peqpk1,rndoff,
     &                        dpsds1,dpsdss1,ier)
      if(ier .ne. 0) call abortjob
     &        ('setpsim ',  1,   'Mesh construction error: psim1      '
     &        ,'ier     ', ier,      'jvv     ', jvv,      -1)
c
      ppsim2        = defmesh(peqval,psimax,delpsir,peqpk2,rndoff,
     &                        dpsds2,dpsdss2,ier)
      if(ier .ne. 0) call abortjob
     &        ('setpsim ',  2,   'Mesh construction error: psim2      '
     &        ,'ier     ', ier,      'jvv     ', jvv,      -1)
c
      psim1  (jvv)  = ppsim1
      psim2  (jvv)  = ppsim2
      dpsim1 (jvv)  = dpsds1
      dpssim1(jvv)  = dpsdss1
      dpsim2 (jvv)  = dpsds2
      dpssim2(jvv)  = dpsdss2
  100 continue
c
c
c
c 2.0 Set up auxiliary quantities
c
c 2.1 Set rst and zst
c
c 2.1.1 Set the axis values
c
      rst(1)        = seqrps(npsi,1)
      zst(1)        = seqzps(npsi,1)
c
c 2.1.2 Interpolate to find the subsequent points
c
      do 200 j      = 1,jpsi
      jv1           = j+1
      psm1val       = psim1(jv1)
      thstrt        = 0.0
c
      rvst1         = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                               ,psm1val,thstrt,pdsr,ier)
      if(ier .ne. 0) call abortjob
     &        ('setpsim ',  3,   'Spline evaluation error: rst        '
     &        ,'ier     ', ier,      'jv1     ', jv1,      -1)
c
      zvst1         = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                               ,psm1val,thstrt,pdsz,ier)
      if(ier .ne. 0) call abortjob
     &        ('setpsim ',  4,   'Spline evaluation error: zst        '
     &        ,'ier     ', ier,      'jv1     ', jv1,      -1)
c
      rst    (jv1)  = rvst1
      zst    (jv1)  = zvst1
  200 continue
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine surface(kcell)
c
c -------------------------------------------------------------
c  Compute the surface quantities
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Construct the plasma surface if (r,z) equilibrium
c
c 1.1 Initialize parameters
c
c 1.1.1 Set scalar parameters
c
      jsurf     = 0
      maperr    = 0
      maponly   = 1
      nvnt      = nvn
      ithtm     = itht
      psivl     = psilim
      rndoff    = roundff
c
c 1.1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('surface ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.2 Use eqdmap for ktype = 0
c
      if    (ktype .eq. 0) then
c
c 1.2.1 Save the actual flux surface start position
c
        rstp(1)   = rst (1)
        zstp(1)   = zst (1)
c
c 1.2.2 Initialize parameters for call to eqdmap
c
        rst0      = rstp(1)
        zst0      = zstp(1)
c
c 1.2.3 Map the plasma boundary
c
        call eqdmap(jsurf,psivl,ithtm,rst0,zst0,rst1,zst1
     &             ,arprv,svint,nvnt,maponly,mapid,maperr)
c
c 1.2.3 Set output parameters from the mapping
c       arcprev is set to initiate later calls
c
        arcprev   = arprv
        qpvlm     = svint(1)
        fqvlm     = svint(2)
c
c 1.2.4 Save the recomputed start positions
c
        rst (1)   = rst1
        zst (1)   = zst1
c
c
c 1.3 Use toqmap for ktype = 1
c
      elseif(ktype .eq. 1) then
c
c 1.3.1 Map the plasma boundary
c
        call toqmap(ktype,jsurf,maperr,psivl,ithtm,svint,nvnt)
c
c 1.3.2 Set paramaters from the boundary mapping
c
        rst1      = rst(1)
        zst1      = zst(1)
        qpvlm     = svint(1)
        fqvlm     = svint(2)
c
c 1.3.3 Save the new start positions
c       For inverse equilibria these should be unchanged
c
        rst (1)   = rst1
        zst (1)   = zst1
c
c
c 1.4 Use toqmap for ktype = 2
c
      elseif(ktype .eq. 2) then
c
c 1.4.1 Map the plasma boundary
c
        call toqmap(ktype,jsurf,maperr,psivl,ithtm,svint,nvnt)
c
c 1.4.2 Set paramaters from the boundary mapping
c
        rst1      = rst(1)
        zst1      = zst(1)
        qpvlm     = sqvl(nprofl)
        fqvlm     = sfqi(nprofl)
c
c 1.4.3 Save the start positions
c       For inverse equilibria these should be unchanged
c
        rst (1)   = rst1
        zst (1)   = zst1
      endif
c
c
c 1.5 Print a warning if the mapping returned with an error.
c
      if(maperr .ne. 0) then
        call abortjob
     &        ('surface ',  2,   'Plasma boundary mapping error       '
     &        ,'maperr  ', maperr,   'ktype   ', ktype,    +1)
      endif
c
c
c
c 2.0 Define the surface quantities
c
c 2.2 Define xlim and zlim
c     For the EQDSK mapping, xlim and zlim are set to the point
c     where the orthogonal ray intersects the plasma boundary.
c     For the inverse equilibrium, xlim and zlim are set to the first
c     point of the outermost flux surface defined above
c
      xlim      = rst1
      zlim      = zst1
c
c
c 2.3 Set flux function profile values at the limiter
c
c 2.3.1 Set qlim, fqilim, flim, and plim
c
      qlim      = qpvlm
      fqilim    = fqvlm
      flim      = sf   (nprofl)
      plim      = sp   (nprofl)
c
c 2.3.2 Compute fqmlim
c
      rvadjst     = ((xma**nham1)/(xma*xma)) / (xma**nham3)
      bpadjst     = (flim/qlim)**nham2
      fvadjst     = (flim*flim)*(flim**nham3)
      fqmlim      = (rvadjst*bpadjst*fvadjst*fqilim  -
     &               qlim*flim*flim) / flim
c
c 2.3.3 Compute ffplim and pplim
c
      if    (npst .eq. 0) then
        ffplim    = sffp (nprofl)
        pplim     = spp  (nprofl)
      elseif(npst .eq. 1) then
        fp1       = sterpp(psilim,psimsh,sf,csf,nprofl,npp,0,
     &                            rndoff,ierf)
        ffplim    = fp1*flim
        pplim     = sterpp(psilim,psimsh,sp,csp,nprofl,npp,0,
     &                            rndoff,ierp)
c
        if(ierf .ne. 0) call abortjob
     &        ('surface ',  3,   'Differentiation error in f(edge)    '
     &        ,'ierf    ', ierf,     'nprofl  ', nprofl,   -1)
        if(ierp .ne. 0) call abortjob
     &        ('surface ',  4,   'Differentiation error in p(edge)    '
     &        ,'ierp    ', ierp,     'nprofl  ', nprofl,   -1)
      endif
c
c 2.3.4 Compute dnlim and pflim
c
      dnlim     = sdns (nprofl)
      pflim     = spfst(nprofl)
c
c
c
c 3.0 Construct the surface quantities
c
c 3.1 Compute the plasma surface quantities
c
      call surfmap(ktype)
c
c
c 3.2 Compute the cell quantities if kcell = 1
c
      if(kcell .gt. 0) then
c
c 3.2.1 For eqdsk equilibria
c
        if(ktype .eq. 0) call eqdcell(0,psivl,ithtm)
c
c 3.2.2 For inverse equilibria
c
c 3.2.2.1 Compute the mapping coordinates and the equilibrium quantities if ktype = 1
        if(ktype .ge. 1) call toqcell(ktype,0,psivl,ithtm)
c
c 3.2.2.2 Compute the equilibrium quantities if ktype = 2
        if(ktype .eq. 2) call feqsurf
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine surfmap(ktype)
c
c calculate surface quantities
c
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c     chic = normalized poloidal angle coordinate at center of interval
c     chie = normalized poloidal angle coordinate at edge of interval
c     rsrf = radius at center of interval
c     zsrf = altitude at center of interval
c     xjsc = jacobian at center of interval
c     dydx = normal at center of interval
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize constants
c
c 1.1.1 Numerical error tolerances
c
      kercntr   = 0
      rndff     = roundff
      splndf    = tolspln*sqrt(xdim*xdim + zdim*zdim)
c
c 1.1.2 Poloidal normalization
c
      if(igrid .eq. 0) alngth  = arcnrm0
      if(igrid .eq. 1) alngth  = pstnrm0
c
      gtnorm    = alngth/twopi
      if(abs(gtnorm) .lt. rndff) call abortjob
     &        ('surfmap ',  1,   'Surface normalization too small     '
     &        ,'ithtp   ', ithtp,    'ktype   ', ktype,    +1)
c
c 1.1.3 Define normalization for jacobian
c
c
c
c 1.2 Initialize flux function surface values
c
      if(igrid .eq. 0) xjnrm0  = gtnorm
      if(igrid .eq. 1) xjnrm0  = qp(1)/sf(nprofl)
c
c
c 1.3 Initialization for interpolation
c
c 1.3.1 Interpolation coefficients for the inverse mapping (ktype = 1)
c
      if    (ktype .eq. 1) then
        psvs1    = defmesh(psilim,psimax,delpsir,peqpk0,rndff,
     &                     dpsds0,dpsdss0,ier)
        if(ier .ne. 0) call abortjob
     &        ('surfmap ',  2,   'Surface mesh construction error     '
     &        ,'ier     ', ier,      'ktype   ', ktype,    -1)
c
c 1.3.2 Interpolation coefficients for the inverse mapping (ktype = 2)
c
      elseif(ktype .eq. 2) then
        kbdy    = 1
      endif
c
c
c
c 2.0 Construct the plasma surface mesh quantities
c
      do 200 i   = 1,itht
      ivl        = i
c
c
c 2.1 Mesh values
c
c 2.1.1 Compute the chi coordinate according to igrid
c
      if    (igrid .eq. 0) then
        delc    = arcsurf(ivl)
        if(ivl .eq. 1) dele  = 0.0
        if(ivl .gt. 1) dele  = 0.5*(arcsurf( ivl ) + arcsurf(ivl-1))
      elseif(igrid .eq. 1) then
        delc    = pestchi(ivl)
        if(ivl .eq. 1) dele  = 0.0
        if(ivl .gt. 1) dele  = 0.5*(pestchi( ivl ) + pestchi(ivl-1))
      endif
      chic(ivl)  = delc/gtnorm
      chie(ivl)  = dele/gtnorm
c
c 2.1.2 Store the plasma surface coordinates
c
      rval0      = rs (ivl,1)
      zval0      = zs (ivl,1)
      rsrf(ivl)  = rval0
      zsrf(ivl)  = zval0
c
c
c 2.2 Normal derivative and Jacobian
c
c 2.2.1 Construct the partial derivatives
c
c 2.2.1.1 Use the spline derivatives for the free boundary equilibrium case
      if    (ktype .eq. 0) then
        call derivp(rval0,zval0,dpdx,dpdy,dpd2x,dpd2y,dpd2xy)
c
c 2.2.1.2 Interpolate for the inverse equilibrium ktype = 1 case
      elseif(ktype .eq. 1) then
        delcn      = chic(ivl)
        rval1      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvs1,delcn,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('surfmap ',  3,   'Spline evaluation error: r(surf)    '
     &        ,'ier     ', ier,      'ivl     ', ivl,      -1)
c
        zval1      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvs1,delcn,pdsz,ier)
        if(ier .ne. 0) call abortjob
     &        ('surfmap ',  4,   'Spline evaluation error: z(surf)    '
     &        ,'ier     ', ier,      'ivl     ', ivl,      -1)
c
        rvdiff     = rval1 - rval0
        zvdiff     = zval1 - zval0
        if(abs(rvdiff) .ge. splndf  .or.  abs(zvdiff) .ge. splndf) then
          kercntr      = kercntr + 1
          if    (kercntr .lt. nerstop) then
            if(abs(rvdiff) .ge. splndf) call abortjob
     &        ('surfmap ',  5,   '2D and 1D splines differ:r(surf)    '
     &        ,'ivl     ', ivl,      'ktype   ', ktype,     0)
c
            if(abs(zvdiff) .ge. splndf) call abortjob
     &        ('surfmap ',  6,   '2D and 1D splines differ:z(surf)    '
     &        ,'ivl     ', ivl,      'ktype   ', ktype,     0)
            write(kuout,1000) rval0,rval1,zval0,zval1
     &                             ,rvdiff,zvdiff,splndf
          elseif(kercntr .eq. nerstop) then
            call abortjob
     &        ('surfmap ',  7,   'Maximum spline errors reached       '
     &        ,'ivl     ', ivl,      'nerstop ', nerstop,  -1)
          endif
        endif
c
        call derivpsi(pdsr,pdsz,dpsds0,dpsdss0,pdsp,pdsc,rndff,1,ier)
        if(ier .ne. 0) call abortjob
     &        ('surfmap ',  8,   'dr/dpsi and dz/dpsi error           '
     &        ,'ier     ', ier,      'ivl     ', ivl,      -1)
        dpdx       = pdsp(2)
        dpdy       = pdsp(3)
c
c 2.2.1.3 Interpolate for the inverse equilibrium ktype = 2 case
      elseif(ktype .eq. 2) then
        delcn      = chic(ivl)
        dpdx       = sterpl(delcn,thchi,seqdpdr,csdpdr,nthet,ntt,
     &                            kbdy,rndff,ier)
        if(ier .ne. 0) call abortjob
     &        ('surfmap ',  9,   'Interpolation error:dpsi/dr(sur)    '
     &        ,'ier     ', ier,      'ivl     ', ivl,      -1)
c
        dpdy       = sterpl(delcn,thchi,seqdpdz,csdpdz,nthet,ntt,
     &                            kbdy,rndff,ier)
        if(ier .ne. 0) call abortjob
     &        ('surfmap ', 10,   'Interpolation error:dpsi/dz(sur)    '
     &        ,'ier     ', ier,      'ivl     ', ivl,      -1)
      endif
c
c 2.2.2 Compute the normal derivative
c
      if(abs(dpdx) .ge. rndff) dydx(ivl)  = dpdy/dpdx
      if(abs(dpdx) .lt. rndff) dydx(ivl)  = dpdy/rndff
c
c 2.2.3 Compute the Jacobian
c
      gp2        = dpdx*dpdx + dpdy*dpdy
c
      if(igrid .eq. 0) xjsc(ivl)  = xjnrm0*rval0/sqrt(gp2)
      if(igrid .eq. 1) xjsc(ivl)  = xjnrm0*rval0*rval0
  200 continue
c
c
c 2.3 Print a warning if the maximum number of error messages was exceeded
c
      if(kercntr .ge. nerstop) then
            call abortjob
     &        ('surfmap ', 11,   'Maximum spline errors exceeded      '
     &        ,'kercntr ', kercntr,  'nerstop ', nerstop,  -1)
      endif
c
c
c
c 3.0 Impose periodicity on the surface quantities
c
c 3.1 Set the complete poloidal angle maximum
c
      if(igrid .eq. 0) chicmax  = arcsurf(ithtp)/gtnorm
      if(igrid .eq. 1) chicmax  = pestchi(ithtp)/gtnorm
c
c
c 3.2 Impose periodicity
c
      rsrf   (ithtp)       = rsrf   (1)
      zsrf   (ithtp)       = zsrf   (1)
      chic   (ithtp)       = chic   (1) + chicmax
      chie   (ithtp)       = chie   (1) + chicmax
      dydx   (ithtp)       = dydx   (1)
      xjsc   (ithtp)       = xjsc   (1)
c
c
c
c 4.0 Return and end
c
      return
c
 1000 format(1x,'rval0   = ',e16.9,2x,'rval1   = ',e16.9
     &      ,2x,'zval0   = ',e16.9,2x,'zval1   = ',e16.9,/
     &      ,1x,'rvdiff  = ',e16.9,2x,'zvdiff  = ',e16.9
     &      ,2x,'splndf  = ',e16.9)
      end
      subroutine checkeq
c
c -------------------------------------------------------------
c  Check the equilibrium accuracy
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nck=nlx)
      parameter (nsm=13)
c
      character*1   symbl,eqsymbl,tqsymbl
      character*1   symchar
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/dstr/  eqderor(nxx,nxz),toqeror(npp,ntt),surfpsi(nck),
     &              surferr(nck),surfcur(nck),nsrferr(nck),ksrferr(nck),
     &              toteror,toterov
      common/anal/  kntdlf(nsm),dlfac(nsm),symbl(nsm),
     &              eqsymbl(nxx,nxz),tqsymbl(npp,ntt)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c
c 1.0 Initialization
c
c 1.1 Tolerances
c
      wrndf       = roundff
      wrndff      = roundff*abs(delpsir)
      wrndft      = roundff*twopi
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('checkeq ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Mesh search range
c
      if    (ktype .eq. 0) then
        jmin        = 1
        jmn1        = 1
        jmax        = 1
      elseif(ktype .eq. 1) then
        jmin        = 2
        jmn1        = jmin+1
        jmax        = max0(npsi-1,1)
      elseif(ktype .eq. 2) then
        jmin        = 2
        jmn1        = jmin+1
        jmax        = max0(npsi-1,1)
      endif
c
      ljdim       = nck
c
c
c 1.4 Error extrema initialization
c
      kwrterr     =  0
      klerror     =  0
      klerrov     =  0
      maxerii     =  0
      maxeriiv    =  0
      maxerjj     =  0
      maxerjjv    =  0
      erormax     =  0.0
      erormaxv    =  0.0
      delermx     =  0.0
      delermxv    =  0.0
      rhcut       =  abs(delpsir)/(xdim*xdim + zdim*zdim)
c
      kserror     =  0
      ksrfermx    =  0
      srfermx     =  0.0
c
c
c
c 2.0 Initialize error arrays
c
c 2.1 Initialize average global errors
c
      kwtotl      =  0
      kwtotv      =  0
      totlerr     =  0.0
      totlerv     =  0.0
      rhsmax      =  0.0
c
c
c 2.2 Initialize surface averaged errors
c
c 2.2.1 Initialize the error arrays
c
      do 20 lj    = 1,ljdim
      nsrferr(lj) =  0
      ksrferr(lj) =  0
      surferr(lj) =  0.0
      surfcur(lj) = -1.0
   20 continue
c
c 2.2.2 Initialize the surface psi values
c
c 2.2.2.1 Set the size of the array
      if(ktype .eq. 0) ksftotl  = jpsi
      if(ktype .gt. 0) ksftotl  = npsi - jmin + 1
c
      if(ksftotl .gt. ljdim) then
        call abortjob
     &        ('checkeq ',  2,   'Dimension for surfpsi too small     '
     &        ,'ksftotl ', ksftotl,  'ljdim   ', ljdim,    -1)
        ksftotl   = ljdim
      endif
c
c 2.2.2.2 For direct equilibria use a uniform mesh
      if    (ktype .eq. 0) then
        zdelpsi     =  delpsir / float(ksftotl)
        do 30 lj    = 1,ksftotl
        surfpsi(lj) = psilim - (lj-1)*zdelpsi
   30   continue
c
c 2.2.2.3 For inverse equilibria use the equilibrium psi mesh
      elseif(ktype .gt. 0) then
        do 40 lj    = 1,ksftotl
        jjv         = lj + jmin - 1
        surfpsi(lj) = psimsh(jjv)
   40   continue
      endif
c
c
c 2.3 Initialize local error arrays
c
c 2.3.1 For direct equilibria
c
      do 60  i       = 1,nxx
      do 50  j       = 1,nxz
      eqderor(i,j)   = 0.0
   50 continue
   60 continue
c
c 2.3.2 For inverse equilibria
c
      do 80  jj      = 1,npp
      do 70  ii      = 1,ntt
      toqeror(jj,ii) = 0.0
   70 continue
   80 continue
c
c
c
c 3.0 Check accuracy of the Grad Shafranov force balance
c     for a Rectangular equilibrium grid
c
      if    (ktype .eq. 0) then
c
c
c 3.1 Find the plasma boundary extrema
c
c 3.1.1 Search the plasma boundary points for the extrema
c
        inbox0      =  0
        inbox1      =  0
        npdivrt     =  0
        rlf         = +bigno
        rrt         =  0.0
        ztp         = -bigno
        zbt         = +bigno
c
        do 100 i    = 1,itht
        rlf         = amin1(rlf,rs(i,1))
        rrt         = amax1(rrt,rs(i,1))
        zbt         = amin1(zbt,zs(i,1))
        ztp         = amax1(ztp,zs(i,1))
  100   continue
c
c 3.1.2 Set the inner box at the boundary extrema
c
        rleft0      = rlf
        rrght0      = rrt
        zbot0       = zbt
        ztop0       = ztp
c
c 3.1.3 Set the outer box beyond the boundary extrema
c
        rbmin       = x( 1)
        rbmax       = x(nx)
        zbmin       = z( 1)
        zbmax       = z(nz)
c
        delbxl      = delbox*abs(rleft0-rbmin)
        delbxr      = delbox*abs(rbmax -rrght0)
        delbzt      = delboz*abs(zbmax -ztop0 )
        delbzb      = delboz*abs(zbot0 -zbmin )
c
        rleft1      = rleft0 - delbxl
        rrght1      = rrght0 + delbxr
        zbot1       = zbot0  - delbzb
        ztop1       = ztop0  + delbzt
c
c
c 3.2 Loop over grid points
c
        do 200 j    = 2,nz-1
        jv          = j
        jp1         = j+1
        jm1         = j-1
c
        do 150 i    = 2,nx-1
        iv          = i
        ip1         = i+1
        im1         = i-1
c
        psvl        = psarray(iv,jv)
        ijval       = iv + (jv-1)*nz
c
c
c 3.3 Define whether the point is within the plasma
c
c 3.3.1 Set inbox0 for the inner box
c
        if    (((x(iv)-rrght0)*(x(iv)-rleft0) .lt. 0.0)  .and.
     &         ((z(jv)-ztop0 )*(z(jv)-zbot0 ) .lt. 0.0))  then
          inbox0     = 0
        else
          inbox0     = 1
        endif
c
c 3.3.2 Set inbox1 for the outer box
c
        if    (((x(iv)-rrght1)*(x(iv)-rleft1) .lt. 0.0)  .and.
     &         ((z(jv)-ztop1 )*(z(jv)-zbot1 ) .lt. 0.0))  then
          inbox1     = 0
        else
          inbox1     = 1
        endif
c
c
c 3.4 Compute the current density
c
        if    (psvl .le. psilim  .and.  inbox0 .eq. 0) then
c
c 3.4.1 Interpolate the profiles to compute the current density within the plasma
c
c 3.4.1.1 For standard profiles interpolate spp and sffp directly (npst = 0)
          if    (npst .eq. 0) then
            pp1      = sterpl(psvl,psimsh,spp, cspp, nprofl,
     &                             npp,   0,   wrndf,ierf)
            ffp1     = sterpl(psvl,psimsh,sffp,csffp,nprofl,
     &                             npp,   0,   wrndf,ierp)
            if(ierp .ne. 0) call abortjob
     &        ('checkeq ',  3,   'Interpolation error: spp(i,j)       '
     &        ,'ierp    ', ierp,     'ijval   ', ijval,     0)
            if(ierf .ne. 0) call abortjob
     &        ('checkeq ',  4,   'Interpolation error: sffp(i,j)      '
     &        ,'ierf    ', ierf,     'ijval   ', ijval,     0)
c
c 3.4.1.2 For alternative profiles differentiate sp and sffp (npst = 1)
          elseif(npst .eq. 1) then
            pp1      = sterpp(psvl,psimsh,sp,  csp,  nprofl,
     &                             npp,   0,   wrndf,ierp)
            f1       = sterpl(psvl,psimsh,sf,  csf,  nprofl,
     &                             npp,   0,   wrndf,ierf)
            fp1      = sterpp(psvl,psimsh,sf,  csf,  nprofl,
     &                             npp,   0,   wrndf,ierfp)
c
            if(ierp .ne. 0) call abortjob
     &        ('checkeq ',  5,   'Differentiation error for p(i,j)    '
     &        ,'ierp    ', ierp,     'ijval   ', ijval,     0)
            if(ierf .ne. 0) call abortjob
     &        ('checkeq ',  6,   'Interpolation error for f(i,j)      '
     &        ,'ierf    ', ierf,     'ijval   ', ijval,     0)
            if(ierfp .ne. 0) call abortjob
     &        ('checkeq ',  7,   'Differentiation error for f(i,j)    '
     &        ,'ierfp   ', ierfp,    'ijval   ', ijval,     0)
            ffp1     = f1*fp1
          endif
c
c 3.4.2 Set profiles to zero outside the plasma
c
c 3.4.2.1 Set profiles to zero for points outside but near the plasma
        elseif(psvl .gt. psilim  .or.   inbox0 .ne. 0) then
          pp1        = 0.0
          ffp1       = 0.0
c
c 3.4.2.2 Count the number of points outside the plasma with psi .le. psilim
c         and set the profiles to zero
        elseif(psvl .le. psilim  .and.  inbox0 .ne. 0) then
          npdivrt    = npdivrt + 1
          pp1        = 0.0
          ffp1       = 0.0
        endif
c
c
c 3.5 Compute the error in equilibrium solution
c
c 3.5.1 Right hand side
c
        rtside      = -(amu*x(iv)*x(iv)*pp1 + ffp1)
c
c 3.5.2 Left hand side
c
        delstr      = (psarray(ip1,jv ) - 2.0*psarray(iv ,jv )
     &                                  +     psarray(im1,jv ))
     &                                                / (dmx*dmx)
     &              + (psarray(iv ,jp1) - 2.0*psarray(iv ,jv )
     &                                  +     psarray(iv ,jm1))
     &                                                / (dmz*dmz)
     &              - (psarray(ip1,jv ) - psarray(im1,jv ))
     &                                                /(2.0*dmx*x(iv))
c
c 3.5.3 Difference
c
        errlocl     = delstr - rtside
c
c
c 3.6 Compute local and average errors
c
c 3.6.1 Local error
c
c 3.6.1.1 Error
        rhsmax         = amax1(rhsmax,   abs(rtside))
        absnorm        = amax1(abs(rtside),abs(delstr),abs(rhcut))
        if(absnorm .lt. wrndff) absnrm0  = wrndff
        if(absnorm .ge. wrndff) absnrm0  = absnorm
        errnorm        = abs(errlocl)/absnrm0
        eqderor(iv,jv) = errnorm
c
c 3.6.1.2 Ratio
        if    (abs(rtside) .ge. roundff) then
          delratio  = delstr/rtside
        elseif(abs(rtside) .lt. roundff) then
          delratio  = -1.0
        endif
c
c 3.6.2 Average error over interior flux surfaces
c
        if    (psvl .le. psilim  .and.  inbox0 .eq. 0) then
c
c 3.6.2.1 Search surfpsi for the closest value to psvl
          psdiff      = abs(psvl - surfpsi(1))
          ljd         = 1
          do 120 lj   = 1,ksftotl
          psv         = surfpsi(lj)
          psdifv      = psvl - psv
          if(abs(psdifv) .le. psdiff  .and.  psdifv .le. 0.0) then
            psdiff      = abs(psdifv)
            ljd         = lj
          endif
 120      continue
c
c 3.6.2.2 Include this point in the surface error for ljd
          if    (ljd .ge. 1  .and.  ljd .le. ksftotl) then
            surfcur (ljd) = amax1(surfcur(ljd),abs(rtside))
            surferr (ljd) = surferr (ljd) + abs(rtside-delstr)
            nsrferr (ljd) = nsrferr (ljd) + 1
c
c 3.6.2.3 Print a warning if the search failed
          else
            call abortjob
     &        ('checkeq ',  8,   'No. surfaces exceeds dimension      '
     &        ,'ljd     ', ljd,      'ksftotl ', ksftotl,   0)
          endif
        endif
c
c 3.6.3 Average global error inside the plasma
c
        if    (psvl .le. psilim  .and.  inbox0 .eq. 0) then
          kwtotl      = kwtotl  + 1
          totlerr     = totlerr + abs(errlocl)
c
c 3.6.4 Average global error in the vacuum
c
        elseif(psvl .gt. psilim  .or.   inbox0 .ne. 0) then
          kwtotv      = kwtotv  + 1
          totlerv     = totlerv + abs(errlocl)
        endif
c
c
c 3.7 Check for unacceptable local errors
c
c 3.7.1 Local errors in the plasma
c
        if    (psvl .le. psilim  .and.  inbox0 .eq. 0) then
c
c 3.7.1.1 Write the error if it exceeds the input tolerance
          if(errnorm .gt. delstlp) then
            klerror   = klerror + 1
c
            if(klerror .le. maxerlp) then
              kwrterr   = kwrterr + 1
              if(kwrterr .eq. 1) write(kuout,1000) psimax,psilim
     &                                            ,delstlp,delstlv
              write(kuout,1010) iv,jv,x(iv),z(jv),psarray(iv,jv)
     &                         ,delstr,rtside,errlocl,errnorm
     &                                               ,delratio
            endif
          endif
c
c 3.7.1.2 Check for the maximum local relative error in the plasma
          if(errnorm .ge. erormax) then
            maxerii     = iv
            maxerjj     = jv
            erormax     = errnorm
            delermx     = delstr
          endif
c
c 3.7.2 Local errors in the vacuum
c
        elseif(psvl .gt. psilim  .or.   inbox0 .ne. 0) then
c
c 3.7.2.1 Write the error if it exceeds the input tolerance
          if(errnorm .gt. delstlv) then
            klerrov   = klerrov + 1
c
c 3.7.2.2 Write the vacuum error if it is within the outer box
            if(inbox1 .eq. 0) then
              if(klerrov .le. maxerlv) then
                kwrterr   = kwrterr + 1
                if(kwrterr .eq. 1) write(kuout,1000) psimax,psilim
     &                                              ,delstlp,delstlv
                write(kuout,1020) iv,jv,x(iv),z(jv),psarray(iv,jv)
     &                           ,delstr,rtside,errlocl,errnorm
     &                                                 ,delratio
              endif
            endif
c
c 3.7.2.2 Check for the maximum local relative error in the vacuum
            if(errnorm .ge. erormaxv) then
              maxeriiv    = iv
              maxerjjv    = jv
              erormaxv    = errnorm
              delermxv    = delstr
            endif
          endif
        endif
c
  150 continue
c
  200 continue
c
c
c
c 4.0 Inverse equilibrium grid (ktype = 1 or ktype = 2)
c
      elseif(ktype .ge. 1) then
c
c
c 4.1 Loop over grid points
c
        do 400 jj  = jmin,jmax
        jjv        = jj
        psvl       = psimsh (jjv)
        psvs1      = peqmsh0(jjv)
        dpsds      = peqdsd0(jjv)
        dpsdss     = peqdss0(jjv)
c
        do 350 ii  = 1,nthet
        iiv        = ii
        theta      = thchi     (iiv)
        rvalu      = seqrps(jjv,iiv)
        zvalu      = seqzps(jjv,iiv)
        ijval      = iiv + (jjv-1)*nthet
c
c
c 4.2 Interpolate the profiles to compute the current density
c
c 4.2.1 For standard profiles interpolate spp and sffp directly (npst = 0)
c
        if    (npst .eq. 0) then
          pp1        = sterpl(psvl,psimsh,spp, cspp, nprofl,npp,0,
     &                             wrndf, ierp)
          ffp1       = sterpl(psvl,psimsh,sffp,csffp,nprofl,npp,0,
     &                             wrndf, ierf)
          if(ierp .ne. 0) call abortjob
     &        ('checkeq ',  9,   'Interpolation error: spp(jj ii)     '
     &        ,'ierp    ', ierp,     'ijval   ', ijval,     0)
          if(ierf .ne. 0) call abortjob
     &        ('checkeq ', 10,   'Interpolation error: sffp(jj,ii)    '
     &        ,'ierf    ', ierf,     'ijval   ', ijval,     0)
c
c 4.2.2 For alternative profiles differentiate sp and sf (npst = 1)
c
        elseif(npst .eq. 1) then
          pp1        = sterpp(psvl,psimsh,sp,  csp,  nprofl,npp,0,
     &                             wrndf, ierp)
          f1         = sterpl(psvl,psimsh,sf,  csf,  nprofl,npp,0,
     &                             wrndf, ierf)
          fp1        = sterpp(psvl,psimsh,sf,  csf,  nprofl,npp,0,
     &                             wrndf, ierfp)
          if(ierp .ne. 0) call abortjob
     &        ('checkeq ', 11,   'Differentiation error: sp(jj,ii)    '
     &        ,'ierp    ', ierp,     'ijval   ', ijval,     0)
          if(ierf .ne. 0) call abortjob
     &        ('checkeq ', 12,   'Interpolation error: sf(jj,ii)      '
     &        ,'ierf    ', ierf,     'ijval   ', ijval,     0)
          if(ierfp .ne. 0) call abortjob
     &        ('checkeq ', 13,   'Differentiation error: sf(jj,ii)    '
     &        ,'ierfp   ', ierfp,    'ijval   ', ijval,     0)
          ffp1       = f1*fp1
        endif
c
c
c 4.3 Compute the error in equilibrium solution
c
c 4.3.1 Right hand side
c
        rtside     = -(amu*rvalu*rvalu*pp1 + ffp1)
c
c 4.3.2 Left hand side
c
c 4.3.2.1 Compute Bpol**2 at three neighbouring flux values
c
c 4.3.2.1.1 Compute Bpol**2 at the (j,i)'th grid point
        psvlp0     = psvl
        psvsp0     = psvs1
        dpdsp0     = dpsds
        ddssp0     = dpsdss
        thetp0     = theta
        rvp0p0     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsp0,thetp0,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 14,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        zvp0p0     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsp0,thetp0,pdsz,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 15,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c

        if(abs(rvalu-rvp0p0) .ge. wrndff) call abortjob
     &        ('checkeq ', 16,   'Spline reproduced incorrect r       '
     &        ,'jjv     ', jjv,      'iiv     ', iiv,       0)
c
        if(abs(zvalu-zvp0p0) .ge. wrndff) call abortjob
     &        ('checkeq ', 17,   'Spline reproduced incorrect z       '
     &        ,'jjv     ', jjv,      'iiv     ', iiv,       0)
c
        call derivpsi(pdsr,pdsz,dpdsp0,ddssp0,pdsp,pdsc,wrndff,1,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 18,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        xjp0p0     = pdsp(1)
        dxp0p0     = pdsp(2)
        dyp0p0     = pdsp(3)
        bp0p0      = (dxp0p0**2+dyp0p0**2)*xjp0p0/rvp0p0**2
c
c 4.3.2.1.2 For j > jmin construct Bpol**2 at (j-1,i)
        if    (jjv .gt. jmin) then
          psvlm1   = psimsh (jjv-1)
          psvsm1   = peqmsh0(jjv-1)
          dpdsm1   = peqdsd0(jjv-1)
          ddssm1   = peqdss0(jjv-1)
          rvm1p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsm1,thetp0,pdsr,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 19,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          zvm1p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsm1,thetp0,pdsz,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 20,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          call derivpsi(pdsr,pdsz,dpdsm1,ddssm1,pdsp,pdsc,wrndff,1,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 21,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          xjm1p0   = pdsp(1)
          dxm1p0   = pdsp(2)
          dym1p0   = pdsp(3)
          bm1p0    = (dxm1p0**2+dym1p0**2)*xjm1p0/rvm1p0**2
c
c 4.3.2.1.3 For j = jmin construct Bpol**2 at (j+2,i) instead (Provided j+1 < npsi)
        elseif(jjv .eq. jmin  .and.  npsi .gt. jmn1) then
          psvlp2   = psimsh (jjv+2)
          psvsp2   = peqmsh0(jjv+2)
          dpdsp2   = peqdsd0(jjv+2)
          ddssp2   = peqdss0(jjv+2)
          rvp2p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsp2,thetp0,pdsr,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 22,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          zvp2p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsp2,thetp0,pdsz,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 23,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          call derivpsi(pdsr,pdsz,dpdsp2,ddssp2,pdsp,pdsc,wrndff,1,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 24,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          xjp2p0   = pdsp(1)
          dxp2p0   = pdsp(2)
          dyp2p0   = pdsp(3)
          bp2p0    = (dxp2p0**2+dyp2p0**2)*xjp2p0/rvp2p0**2
c
c 4.3.2.1.4 For npsi < jmin+2 print a warning
        elseif(jjv .eq. jmin  .and.  npsi .le. jmn1) then
          call abortjob
     &        ('checkeq ', 25,   'npsi .le. jmin+1 is too small       '
     &        ,'npsi    ', npsi,     'jmin    ', jmin,     -1)
        endif
c
c 4.3.2.1.5 For j < npsi construct Bpol**2 at (j+1,i)
        if    (jjv .lt. npsi) then
          psvlp1   = psimsh (jjv+1)
          psvsp1   = peqmsh0(jjv+1)
          dpdsp1   = peqdsd0(jjv+1)
          ddssp1   = peqdss0(jjv+1)
          rvp1p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsp1,thetp0,pdsr,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 26,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          zvp1p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsp1,thetp0,pdsz,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 27,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          call derivpsi(pdsr,pdsz,dpdsp1,ddssp1,pdsp,pdsc,wrndff,1,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 28,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          xjp1p0   = pdsp(1)
          dxp1p0   = pdsp(2)
          dyp1p0   = pdsp(3)
          bp1p0    = (dxp1p0**2+dyp1p0**2)*xjp1p0/rvp1p0**2
c
c 4.3.2.1.6 For j = npsi construct Bpol**2 at (j-2,i) instead (Provided j > jmin+1)
        elseif(jjv .eq. npsi  .and.  npsi .gt. jmn1) then
          psvlm2   = psimsh (jjv-2)
          psvsm2   = peqmsh0(jjv-2)
          dpdsm2   = peqdsd0(jjv-2)
          ddssm2   = peqdss0(jjv-2)
          rvm2p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsm2,thetp0,pdsr,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 29,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          zvm2p0   = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsm2,thetp0,pdsz,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 30,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          call derivpsi(pdsr,pdsz,dpdsm2,ddssm2,pdsp,pdsc,wrndff,1,ier)
          if(ier .ne. 0) call abortjob
     &        ('checkeq ', 31,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
          xjm2p0   = pdsp(1)
          dxm2p0   = pdsp(2)
          dym2p0   = pdsp(3)
          bm2p0    = (dxm2p0**2+dym2p0**2)*xjm2p0/rvm2p0**2
c
c 4.3.2.1.7 For npsi < jmin+2 print a warning
        elseif(jjv .eq. npsi  .and.  npsi .le. jmn1) then
          call abortjob
     &        ('checkeq ', 32,   'npsi .le. jmin+1 is too small       '
     &        ,'npsi    ', npsi,     'jmin    ', jmin,     +1)
        endif
c
c 4.3.2.2 Construct d/dpsi(Bpol**2) from difference between three non-uniform
c         points
c
c 4.3.2.2.1 For j = jmin use (j,i), (j+1,i), and (j+2,i)
        if    (jjv .lt. npsi-1  .and.  jjv .eq. jmin) then
          deltm    =  psvlp1 - psvlp0
          delt0    =  psvlp2 - psvlp0
          deltp    =  psvlp2 - psvlp1
          bpsim    = -bp0p0*(delt0+deltm)/(deltm*delt0)
          bpsi0    = +bp1p0*(   delt0   )/(deltm*deltp)
          bpsip    = -bp2p0*(   deltm   )/(deltp*delt0)
          bpsi     =  bpsip + bpsi0 + bpsim
c
c 4.3.2.2.2 For j > jmin and j < npsi use (j-1,i), (j,i), and (j+1,i)
        elseif(jjv .lt.  npsi   .and.  jjv .gt. jmin) then
          deltm    =  psvlp0 - psvlm1
          delt0    =  psvlp1 - psvlm1
          deltp    =  psvlp1 - psvlp0
          bpsim    = -bm1p0*(   deltp   )/(deltm*delt0)
          bpsi0    = +bp0p0*(deltp-deltm)/(deltm*deltp)
          bpsip    = +bp1p0*(   deltm   )/(deltp*delt0)
          bpsi     =  bpsip + bpsi0 + bpsim
c
c 4.3.2.2.3 For j = npsi use (j-2,i), (j-1,i), and (j,i)
        elseif(jjv .eq.  npsi   .and.  jjv .gt. jmin) then
          deltm    =  psvlm1 - psvlm2
          delt0    =  psvlp0 - psvlm2
          deltp    =  psvlp0 - psvlm1
          bpsim    = +bm2p0*(   deltp   )/(deltm*delt0)
          bpsi0    = -bm1p0*(   delt0   )/(deltm*deltp)
          bpsip    = -bp0p0*(delt0+deltp)/(deltp*delt0)
          bpsi     =  bpsip + bpsi0 + bpsim
c
c 4.3.2.2.4 For npsi < jmin+2 print a warning
        elseif(npsi .le. jmn1) then
          bpsi     =  0.0
          call abortjob
     &        ('checkeq ', 33,   'npsi .le. jmin+1 is too small       '
     &        ,'npsi    ', npsi,     'jmin    ', jmin,     -1)
        endif
c
c 4.3.2.3 Construct d/dchi(Bpol**2)
c
c 4.3.2.3.1 Set the values at (j,i-1)
        if    (iiv .gt.   1 ) then
          thetm1   =  thchi( iiv-1 )
          delthm   =  0.0
        elseif(iiv .eq.   1 ) then
          thetm1   =  thchi(nthet-1)
          delthm   = +twopi
        endif
        rvp0m1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsp0,thetm1,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 34,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        zvp0m1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsp0,thetm1,pdsz,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 35,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        call derivpsi(pdsr,pdsz,dpdsp0,ddssp0,pdsp,pdsc,wrndff,1,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 36,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        xjp0m1     = pdsp(1)
        dxp0m1     = pdsp(2)
        dyp0m1     = pdsp(3)
        dxc0m1     = pdsc(2)
        dyc0m1     = pdsc(3)
        cp0m1      = (dxp0m1*dxc0m1+dyp0m1*dyc0m1)*xjp0m1/rvp0m1**2
c
c 4.3.2.3.2 Set the values at (j,i+1)
        if    (iiv .lt. nthet) then
          thetp1   =  thchi( iiv+1  )
          delthp   =  0.0
        elseif(iiv .eq. nthet) then
          thetp1   =  thchi(    2   )
          delthp   = +twopi
        endif
c
        rvp0p1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psvsp0,thetp1,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 37,   'Spline error for r(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        zvp0p1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psvsp0,thetp1,pdsz,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 38,   'Spline error for z(psi,theta)       '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        call derivpsi(pdsr,pdsz,dpdsp0,ddssp0,pdsp,pdsc,wrndff,1,ier)
        if(ier .ne. 0) call abortjob
     &        ('checkeq ', 39,   'Differentiation error: dr/dpsi      '
     &        ,'ier     ', ier,      'ijval   ', ijval,    -1)
c
        xjp0p1     = pdsp(1)
        dxp0p1     = pdsp(2)
        dyp0p1     = pdsp(3)
        dxc0p1     = pdsc(2)
        dyc0p1     = pdsc(3)
        cp0p1      = (dxp0p1*dxc0p1+dyp0p1*dyc0p1)*xjp0p1/rvp0p1**2
c
c 4.3.2.3.3 Check the poloidal mesh is equally spaced
        dthetm     = thetp0 - thetm1 + delthm
        dthetp     = thetp1 - thetp0 + delthp
        deltmp     = dthetp - dthetm
        if(abs(deltmp) .gt. wrndff) then
          call abortjob
     &        ('checkeq ', 40,   'Non uniform poloidal mesh           '
     &        ,'jjv     ', jjv,      'iiv     ', iiv,       0)
          write(kuout,1100) jjv,iiv,thetm1,thetp0,thetp1,delthm,delthp
     &                             ,dthetm,dthetp,deltmp,wrndft
        endif
c
c 4.3.2.3.4 Construct the two-point difference in chi
        dtheta     = (thetp1 - thetm1) + (delthm + delthp)
        cpsi       = (cp0p1 - cp0m1) / dtheta
c
c 4.3.2.4 Construct del*(psi)
        delstr     = (bpsi + cpsi)*rvp0p0**2/xjp0p0
c
c 4.3.3 Difference
c
        errlocl    = delstr - rtside
c
c
c 4.4 Compute local and averaged errors
c
c 4.4.1 Local error
c
c 4.4.1.1 Error
        absnorm          = amax1(abs(rtside),abs(delstr),abs(rhcut))
        if(absnorm .lt. wrndff) absnrm0  = -1.0
        if(absnorm .ge. wrndff) absnrm0  = absnorm
        errnorm          = abs(errlocl)/absnrm0
        toqeror(jjv,iiv) = errnorm
c
c 4.4.1.2 Ratio
        if    (abs(rtside) .ge. roundff) then
          delratio  = delstr/rtside
        elseif(abs(rtside) .lt. roundff) then
          delratio  = -1.0
        endif
c
c 4.4.2 Average error over interior flux surfaces
c
c 4.4.2.1 Search surfpsi for the closest value to psvl
        psdiff     = abs(psvl - surfpsi(1))
        ljd        = 1
        do 320 lj  = 1,ksftotl
        psv        = surfpsi(lj)
        psdifv     = psvl - psv
        if(abs(psdifv) .le. psdiff  .and.  psdifv .le. 0.0) then
          psdiff      = abs(psdifv)
          ljd         = lj
        endif
 320    continue
c
c 4.4.2.2 Include this point in the surface error for ljd
        if    (ljd .ge. 1  .and.  ljd .le. ksftotl) then
          surfcur (ljd) = amax1(surfcur(ljd),abs(rtside))
          surferr (ljd) = surferr (ljd) + abs(rtside-delstr)
          nsrferr (ljd) = nsrferr (ljd) + 1
c
c 4.4.2.3 Print a warning if the search failed
        else
          call abortjob
     &        ('checkeq ', 41,   'Number bad surfaces > dimension     '
     &         ,'ljd     ', ljd,       'ksftotl ', ksftotl,   0)
        endif
c
c 4.4.3 Average global error inside the plasma
c
        kwtotl     = kwtotl  + 1
        rhsmax     = amax1(rhsmax,   abs(rtside))
        totlerr    = totlerr + abs(errlocl)
c
c
c 4.5 Check for unacceptable local errors
c
c 4.5.1 Write the error if it exceeds the input tolerance
c
        if(errnorm .gt. delstlp) then
          klerror   = klerror + 1
c
          if(klerror .le. maxerlp) then
            kwrterr   = kwrterr + 1
            if(kwrterr .eq. 1) write(kuout,1110) psimax,psilim,delstlp
            write(kuout,1120) jjv,iiv,psimsh(jjv),thchi(iiv)
     &                        ,delstr,rtside,errlocl,errnorm,delratio
          endif
        endif
c
c 4.5.2 Check for the maximum local relative error in the plasma
c
        if(errnorm .ge. erormax) then
          maxerjj    = jjv
          maxerii    = iiv
          erormax    = errnorm
          delermx    = delstr
        endif
c
  350   continue
  400   continue
      endif
c
c
c
c 5.0 Renormalize the errors
c
c 5.1 Normalize the global error
c
      toteror     =  totlerr / (float(kwtotl+1)*rhsmax)
c
      if(ktype .eq. 0) then
        toterov     =  totlerv / (float(kwtotv+1)*rhsmax)
      endif
c
c
c 5.2 Find the maximum normalized surface error
c
      do 500 lj   = 1,ksftotl
      srferor     = surferr(lj) / (surfcur(lj)*float(nsrferr(lj)+1))
      if(abs(srferor) .ge. srfermx) then
        ksrfermx    = lj
        srfermx     = abs(srferor)
      endif
c
      if    (srferor  .le. delstsf) then
        ksrferr(lj)  = 0
c
      elseif(srferor  .gt. delstsf) then
        kserror      = kserror + 1
        ksrferr(lj)  = 1
      endif
  500 continue
c
c
c
c 6.0 Write out the errors
c
c 6.1 Print a warning if the global or surfarce averaged errors exceed the
c     maximum allowed
c
c 6.1.1 Global error in the plasma
c
      if(toteror .gt. delac) then
        call abortjob
     &        ('checkeq ', 42,   'Global plasma error unacceptable    '
     &        ,'kwtotl  ', kwtotl,   'klerror ', klerror,  -1)
      endif
c
c 6.1.2 Global error in the vacuum
c
      if(ktype .eq. 0) then
        if(toterov .gt. delav) then
          call abortjob
     &        ('checkeq ', 43,   'Global vacuum error unacceptable    '
     &        ,'kwtotv  ', kwtotv,   'klerrov ', klerrov,  -1)
        endif
      endif
c
c 6.1.3 Print a warning if poorly converged surfaces are presnet in the plasma
c
      if(kserror .gt. 0) then
        call abortjob
     &        ('checkeq ', 44,   'Poorly converged surfaces exist     '
     &        ,'ksftotl ', ksftotl,  'kserror ', kserror,  -1)
      endif
c
c
c 6.2 Write the global, and maximum surface errors
c
c 6.2.1 Error in the plasma region
c
c 6.2.1.1 Print the average plasma error
      write(kutty,2000) toteror,kwtotl
      write(kuout,2000) toteror,kwtotl
c
c 6.2.1.2 Print the maximum surface averaged errors
      if(ksrfermx .le. 0) then
        call abortjob
     &        ('checkeq ', 45,   'Maximum surface error not found     '
     &        ,'ksrfermx', ksrfermx, 'kserror ', kserror,  -1)
      endif
      write(kutty,2010) kserror,ksftotl,ksrfermx,srfermx
      write(kuout,2010) kserror,ksftotl,ksrfermx,srfermx
c
c 6.2.1.3 Print the maximum plasma error
      if(maxerii .le. 0  .or.   maxerjj .le. 0) then
        call abortjob
     &        ('checkeq ', 46,   'Maximum plasma error not found      '
     &        ,'maxerii ', maxerii,  'maxerjj ', maxerjj,  -1)
      endif
      if    (ktype .eq. 0) then
        write(kutty,2020) klerror,maxerii,maxerjj,erormax
        write(kuout,2020) klerror,maxerii,maxerjj,erormax
      elseif(ktype .ge. 1) then
        write(kutty,2025) klerror,maxerjj,maxerii,erormax
        write(kuout,2025) klerror,maxerjj,maxerii,erormax
      endif
c
c 6.2.2 Error in the vacuum region
c
      if(ktype .eq. 0) then
c
c 6.2.2.1 Print the average vacuum error
        write(kutty,2100) toterov,kwtotv
        write(kuout,2100) toterov,kwtotv
c
c 6.2.2.2 Print the maximum vacuum error
        if(maxeriiv .le. 0  .or.   maxerjjv .le. 0) then
          call abortjob
     &        ('checkeq ', 47,   'Maximum vacuum error not found      '
     &        ,'maxeriiv', maxeriiv, 'maxerjjv', maxerjjv, -1)
        endif
        write(kutty,2120) klerrov,maxeriiv,maxerjjv,erormaxv
        write(kuout,2120) klerrov,maxeriiv,maxerjjv,erormaxv
c
c 6.2.2.3 Print the number of points in the vacuum found with psi .le. psilim
        if(npdivrt .ne. 0) then
          write(kutty,2130) npdivrt,rleft1,rrght1,zbot1,ztop1
          write(kuout,2130) npdivrt,rleft1,rrght1,zbot1,ztop1
        endif
      endif
c
c
c 6.3 Print a warning if the number of excessive local errors exceeds the
c     maximum
c
c 6.3.1 Local Plasma region errors
c
      if(klerror .gt. maxerlp) then
        call abortjob
     &        ('checkeq ', 48,   'No. bad equilibrium points > max    '
     &        ,'klerror ', klerror,  'maxerlp ', maxerlp,  -1)
        if    (ktype .eq. 0) then
          write(kutty,3200) klerror,maxerlp,maxerii,maxerjj,erormax
     &                                                     ,delermx
          write(kuout,3200) klerror,maxerlp,maxerii,maxerjj,erormax
     &                                                     ,delermx
        elseif(ktype .ge. 1) then
          write(kutty,3205) klerror,maxerlp,maxerjj,maxerii,erormax
     &                                                     ,delermx
          write(kuout,3205) klerror,maxerlp,maxerjj,maxerii,erormax
     &                                                     ,delermx
        endif
      endif
c
c 6.3.2 Local Vacuum region errors
c
      if(ktype .eq. 0  .and.  klerrov .gt. maxerlv) then
        call abortjob
     &        ('checkeq ', 49,   'No. bad vacuum points > maximum     '
     &        ,'klerrov ', klerrov,  'maxerlv ', maxerlv,  -1)
        write(kutty,3210) klerrov,maxerlv,maxeriiv,maxerjjv,erormaxv
     &                                                     ,delermxv
        write(kuout,3210) klerrov,maxerlv,maxeriiv,maxerjjv,erormaxv
     &                                                     ,delermxv
      endif
c
c
c 6.4 Write out the errors on each individual surface
c
      write(kuout,2200)
      write(kuout,2210) ksftotl,delstsf
      do 510 lj   = 1,ksftotl
      srferor     = surferr(lj) / (surfcur(lj)*float(nsrferr(lj)+1))
      write(kuout,2220) lj,surfpsi(lj),srferor,nsrferr(lj),surfcur(lj)
     &                    ,ksrferr(lj)
  510 continue
c
c
c
c 7.0 Return and end
c
      return
c
 1000 format(//,1x,'Unacceptable relative local equilibrium errors:'
     &       ,/,1x,'psimax  = ',e12.5,4x,'psilim  = ',e12.5
     &         ,4x,'delstlp = ',e12.5,4x,'delstlv = ',e12.5
     &      ,//,2x,'Region',4x,'iv',3x,'jv',8x,'x',11x,'z'
     &         ,9x,'psi',9x, 'delstr',7x, 'rtside'
     &         ,3x,'Local error',3x,'Rel error',5x,'Ratio')
 1010 format(2x,'Plasma:',2x,i4,1x,i4,1x,e11.4,1x,e11.4
     &         ,1x,e11.4,2(1x,e12.5),3(1x,e11.4))
 1020 format(2x,'Vacuum:',1x,i4,1x,i4,1x,e11.4,1x,e11.4
     &         ,1x,e11.4,2(1x,e12.5),3(1x,e11.4))
 1100 format(   1x,'Warning: poloidal mesh is not equally spaced:'
     &         ,1x,'jj = ',i5,1x,'ii = ',i5,/
     &         ,1x,'thetm1 = ',e12.5,3x,'thetp0 = ',e12.5
     &         ,3x,'thetp1 = ',e12.5,3x,/
     &         ,1x,'delthm = ',e12.5,3x,'delthp = ',e12.5
     &         ,3x,'dthetm = ',e12.5,3x,'dthetp = ',e12.5,/
     &         ,1x,'deltmp = ',e12.5,3x,'wrndft = ',e12.5)
 1110 format(//,1x,'Unacceptable relative local equilibrium errors:'
     &       ,/,1x, 'psimax  = ',e12.5,4x,'psilim  = ',e12.5
     &         ,4x, 'delstlp = ',e12.5
     &      ,//,4x,'jjv',2x,'iiv',5x,'psimsh',6x,'thchi'
     &         ,7x, 'delstr',7x, 'rtside'
     &         ,4x, 'Local error',2x,'Rel error',6x,'Ratio')
 1120 format(2x,i5,1x,i5,1x,e11.4,1x,e11.4,2(1x,e12.5),3(1x,e11.4))
 2000 format(/, 1x,'Global Plasma Equilibrium Convergence is',9x,e16.6
     &      ,/, 6x,'for',1x,i7,1x,'points in the plasma')
 2010 format(/, 1x,'Number of Poorly Converged Surfaces           = '
     &         ,4x,i6,/,6x,'for',1x,i7,1x,'surfaces in the plasma',/
     &         ,1x,'Maximum normalized error at surface',2x,i4,5x,'='
     &         ,2x,e16.6,/)
 2020 format(   1x,'Number of Poorly Converged Plasma Points      = '
     &         ,4x,i6,1x,'(Direct equilibrium)',/
     &         ,1x,'Maximum normalized local error at mesh point'
     &         ,1x,'(i,j)   = (',i4,',',i4,') is ',1x,e16.6,/)
 2025 format(   1x,'Number of Poorly Converged Plasma Points      = '
     &         ,4x,i6,1x,'(Inverse equilibrium)',/
     &         ,1x,'Maximum normalized local error at mesh point'
     &         ,1x,'(jj,ii) = (',i4,',',i4,') is ',1x,e16.6,/)
 2100 format(/, 1x,'Global Vacuum Equilibrium Convergence is',9x,e16.6
     &      ,/, 6x,'for',1x,i7,1x,'points in the vacuum')
 2120 format(   1x,'Number of Poorly Converged Vacuum Points      = '
     &         ,4x,i6,/,1x,'Maximum normalized local error at'
     &         ,1x,'(',i4,',',i4,') = ',1x,e16.6,/)
 2130 format(   1x,'Number of points outside plasma with psi less than'
     &         ,1x,'psilim = ',i6,/,1x,'Box dimensions:'
     &         ,1x,'rrght1  = ',e16.6,4x,'rleft1  = ',e16.6,/
     &         ,16x,'zbot1   = ',e16.6,4x,'ztop1   = ',e16.6,/)
 2200 format(//,1x,'Average Equilibrium Convergence on Flux Surfaces',/
     &         ,1x,'(From plasma boundary to magnetic axis)',/)
 2210 format(   6x,'ksftotl = ',i6,4x,'delstsf = ',e16.6,//
     &         ,9x,'Psi',8x,'Convergence',3x,'No. of points'
     &         ,5x,'Normalization',3x,'Check')
 2220 format(1x,i4,2(1x,e12.5),4x,i8,9x,e12.5,6x,i1)
 3200 format(   1x,'Number of Poorly Converged Plasma Points = ',i6
     &         ,1x,'exceeds',1x,i6,1x,'(Direct equilibrium)',/
     &         ,1x,'Maximum error at (i,j)   = (',i4,',',i4,') = '
     &         ,1x,e16.6,1x,'for delstr  = ',e16.6,/)
 3205 format(   1x,'Number of Poorly Converged Plasma Points = ',i6
     &         ,1x,'exceeds',1x,i6,1x,'(Inverse equilibrium)',/
     &         ,1x,'Maximum error at (jj,ii) = (',i4,',',i4,') = '
     &         ,1x,e16.6,1x,'for delstr  = ',e16.6,/)
 3210 format(   1x,'Number of Poorly Converged Vacuum Points = ',i6
     &         ,1x,'exceeds',1x,i6,/
     &         ,1x,'Maximum error at (i,j) = (',i4,',',i4,') = '
     &         ,1x,e16.6,1x,'for delstr  = ',e16.6,/)
      end
      subroutine analerr
c
c ------------------------
c analyze equilibrium errors
c ------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nck=nlx)
      parameter (nsm=13)
c
      character*1   symbl,eqsymbl,tqsymbl
      character*1   symchar
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/dstr/  eqderor(nxx,nxz),toqeror(npp,ntt),surfpsi(nck),
     &              surferr(nck),surfcur(nck),nsrferr(nck),ksrferr(nck),
     &              toteror,toterov
      common/anal/  kntdlf(nsm),dlfac(nsm),symbl(nsm),
     &              eqsymbl(nxx,nxz),tqsymbl(npp,ntt)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/pldf/  x0min,x0max,y0min,y0max
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize and check mesh storage
c
      nlxx       = nlx
      ithtp1     = itht + 1
c
      if(jpsi   .gt. nlxx) then
         call abortjob
     &        ('analerr ',  1,   'Skip error analysis: jpsi > nlx     '
     &        ,'jpsi    ', jpsi,     'nlxx    ', nlxx,     -1)
         return
      endif
c
      if(ithtp1 .gt. nlxx) then
         call abortjob
     &        ('analerr ',  2,   'Skip error analysis: ithtp > nlx    '
     &        ,'ithtp1  ', ithtp1,   'nlxx    ', nlxx,     -1)
         return
      endif

      kmap    = nmap
      ktype   = nmtype
c
c
c 1.2 Set the equilibrium type
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('analerr ',  3,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Initialize global counters
c
      kplasma   = 0
      kpacpt    = 0
      kppoor    = 0
      kpvbad    = 0
      kvacuum   = 0
      kvacpt    = 0
      kvpoor    = 0
      kvvbad    = 0
c
c      
c 1.4 Set the constants and symbols
c
      nsymbl     = nsm
      do 10 kf   = 1,nsymbl
      kntdlf(kf) = 0
c
      if    (kf .eq.  1) then
        dlfac(kf)    = 0.0
        symbl(kf)    = ' '
      elseif(kf .gt.  1  .and.  kf .lt. 11) then
        kf1          = kf-1
        write(symchar,1000) kf1
        dlfac(kf)    = float(kf1)
        symbl(kf)    = symchar
      elseif(kf .eq. 11) then
        dlfac(kf)    = float(kf-1)
        symbl(kf)    = '+'
      elseif(kf .eq. 12) then
        dlfac(kf)    = 100.0
        symbl(kf)    = 'x'
      elseif(kf .ge. 13) then
        dlfac(kf)    = 1000.0
        symbl(kf)    = '*'
      endif
 10   continue
c
c
c 1.5 Set the acceptable limit
c
      accept    = dlfac(2)
      unacept   = dlfac(3)
c
c
c
c 2.0 Analyze the equilibrium errors for direct equilibria
c
      if    (ktype  .eq. 0) then
c
c 2.1 Find the plasma boundary extrema
c
        inbox0      =  0
        inbox1      =  0
        rlf         = +bigno
        rrt         =  0.0
        ztp         = -bigno
        zbt         = +bigno
c
        do 50 i     = 1,itht
        rlf         = amin1(rlf,rs(i,1))
        rrt         = amax1(rrt,rs(i,1))
        zbt         = amin1(zbt,zs(i,1))
        ztp         = amax1(ztp,zs(i,1))
   50   continue
c
        rleft0      = rlf
        rrght0      = rrt
        ztop0       = ztp
        zbot0       = zbt
c
c 2.2 Loop over the grid
c
        do 120 i    = 1,nx
        iv          = i
        xch         = x(iv)
        do 100 j    = 1,nz
        jv          = j
        ych         = z(jv)
        psvl        = psarray(iv,jv)
        eqlerr      = abs(eqderor(iv,jv))
c
c 2.3 Define whether the point is within the plasma
c
c 2.3.1 Check if the point is inside the maximum plasma bounds
        if    (((x(iv)-rrght0)*(x(iv)-rleft0) .lt. 0.0)  .and.
     &         ((z(jv)-ztop0 )*(z(jv)-zbot0 ) .lt. 0.0))  then
          inbox0      = 0
        else
          inbox0      = 1
        endif
c
c 2.3.2 Check if psi is also less than psilim and definve delval
        if    (psvl .le. psilim  .and.  inbox0 .eq. 0) then
          inbox1      = 0
          delval      = delstlp
        elseif(psvl .gt. psilim  .or.   inbox0 .eq. 1) then
          inbox1      = 1
          delval      = delstlv
        endif
c
c 2.4 Check the equilibrium error magnitude and set corresponding symbol
c
c 2.4.1 For moderately acceptable errors
        if    (eqlerr .lt. delval ) then
          if(inbox1 .eq. 0) kntdlf(1)      = kntdlf(1) + 1
          eqsymbl(iv,jv) = symbl(1)
        endif
c
c 2.4.2 For unacceptable errors
c
          do 80 kf  = 2,nsymbl-1
          kf1       = kf
          kf2       = kf+1
          if(eqlerr .ge. dlfac(kf1)*delval    .and.
     &       eqlerr .lt. dlfac(kf2)*delval  )     then
            if(inbox1 .eq. 0) kntdlf(kf1)    = kntdlf(kf1) + 1
            eqsymbl(iv,jv) = symbl(kf1)
          endif
  80      continue
c
c 2.4.3 For grossly unacceptable errors
c
          if(eqlerr .ge. dlfac(nsymbl)*delval)     then
            if(inbox1 .eq. 0) kntdlf(nsymbl) = kntdlf(nsymbl) + 1
            eqsymbl(iv,jv) = symbl(nsymbl)
          endif
c
c
c 2.5 Count the number of plasma and vacuum points
c
        if    (inbox1 .eq. 0) then
          kplasma   = kplasma + 1
          if(eqlerr .lt. accept* delval) kpacpt = kpacpt + 1
          if(eqlerr .ge. accept* delval  .and. 
     &       eqlerr .lt. unacept*delval) kppoor = kppoor + 1
          if(eqlerr .ge. unacept*delval) kpvbad = kpvbad + 1
        elseif(inbox1 .eq. 1) then
          kvacuum   = kvacuum + 1
          if(eqlerr .lt. accept* delval) kvacpt = kvacpt + 1
          if(eqlerr .ge. accept* delval  .and. 
     &       eqlerr .lt. unacept*delval) kvpoor = kvpoor + 1
          if(eqlerr .ge. unacept*delval) kvvbad = kvvbad + 1
        endif
c
  100   continue
  120   continue
c
c
c
c 3.0 Analyze the equilibrium errors for inverse equilibria
c
      elseif(ktype  .gt. 0) then
c
c 3.1 Loop over the grid
c
        do 220 jj   = 1,npsi
        jjv         = jj
        do 200 ii   = 1,nthet
        iiv         = ii
c
        xch         = seqrps(jjv,iiv)
        ych         = seqzps(jjv,iiv)
        eqlerr      = abs(toqeror(jjv,iiv))
c
c
c 3.2 Set delval for the inverse equilibrium case to delstlp
c
        delval      = delstlp
c
c
c 3.3 Check the equilibrium error magnitude and plot corresponding symbol
c
c
c 3.3.1 For moderately acceptable errors
        if    (eqlerr .lt. delval ) then
          kntdlf(1)      = kntdlf(1) + 1
          tqsymbl(jjv,iiv) = symbl(1)
        endif
c
c 3.3.2 For unacceptable errors
c
          do 180 kf  = 2,nsymbl-1
          kf1        = kf
          kf2        = kf+1
          if(eqlerr .ge. dlfac(kf1)*delval    .and.
     &       eqlerr .lt. dlfac(kf2)*delval  )     then
            kntdlf(kf1)    = kntdlf(kf1) + 1
            tqsymbl(jjv,iiv) = symbl(kf1)
          endif
  180     continue
c
c 3.3.3 For grossly unacceptable errors
c
          if(eqlerr .ge. dlfac(nsymbl)*delval)     then
            kntdlf(nsymbl) = kntdlf(nsymbl) + 1
            tqsymbl(jjv,iiv) = symbl(nsymbl)
          endif
c
c
c 3.4 Count the number of points
c
        kplasma   = kplasma + 1
        if(eqlerr .lt. accept* delval) kpacpt = kpacpt + 1
        if(eqlerr .ge. accept* delval  .and. 
     &     eqlerr .lt. unacept*delval) kppoor = kppoor + 1
        if(eqlerr .ge. unacept*delval) kpvbad = kpvbad + 1
c
  200   continue
  220   continue
      endif
c
c
c
c 4.0 Write the table of errors
c
c 4.1 Write out the overall count
c
c 4.1.1 Plasma region
c
      acceptdp  = delstlp*accept
      unaceptp  = delstlp*unacept
      write(kuout,2000) delstlp,acceptdp,unaceptp
      write(kuout,2010) kplasma,kpacpt,kppoor,kpvbad
c
c 4.1.2 Vacuum region
c
      if(ktype .eq. 0) then
        acceptdv  = delstlv*accept
        unaceptv  = delstlv*unacept
        write(kuout,2100) delstlv,acceptdv,unaceptv
        write(kuout,2110) kvacuum,kvacpt,kvpoor,kvvbad
      endif
c
c
c 4.2 Write out the full breakdown
c
      write(kuout,3000)
      do 500 kf   = 1,nsymbl-1
      kf1         = kf
      kf2         = kf+1
      write(kuout,3100) kntdlf(kf1),dlfac(kf1),delstlp
     &                             ,dlfac(kf2),delstlp,symbl(kf1)
 500  continue
c
      write(kuout,3110) kntdlf(nsymbl),dlfac(nsymbl),delstlp
     &                 ,symbl (nsymbl)
c
c
c
c 5.0 Return and end
c
      return
 1000 format(i1)
 2000 format(//,10x,'Equilibrium Error in the plasma: Summary'
     &      ,/, 10x,'delstlp  = ',e12.5,4x,'acceptdp = ',e12.5
     &          ,4x,'unaceptp = ',e12.5)
 2010 format(/,  5x,'Total number of plasma points        = ',i8
     &      ,/,  5x,'Number of converged plasma points    = ',i8
     &      ,/,  5x,'Number of acceptable plasma points   = ',i8
     &      ,/,  5x,'Number of unacceptable plasma points = ',i8)
 2100 format(//,10x,'Equilibrium Error in the vacuum: Summary'
     &      ,/, 10x,'delstlp  = ',e12.5,4x,'acceptdp = ',e12.5
     &          ,4x,'unaceptp = ',e12.5)
 2110 format(/,  5x,'Total number of vacuum points        = ',i8
     &      ,/,  5x,'Number of converged vacuum points    = ',i8
     &      ,/,  5x,'Number of acceptable vacuum points   = ',i8
     &      ,/,  5x,'Number of unacceptable vacuum points = ',i8)
 3000 format(//,10x,'Equilibrium Error breakdown by degree:'
     &          ,1x,'(All points)',/)
 3100 format(  5x,'There are',1x,i6,1x,'points with error between'
     &            ,1x,f8.2,1x,'*',1x,e12.5,1x,'and'
     &            ,1x,f8.2,1x,'*',1x,e12.5,10x,'(symbol: ',a1,')')
 3110 format(/,5x,'There are',1x,i6,1x,'points with error greater than'
     &            ,1x,f8.2,1x,'*',1x,e12.5,33x,'(symbol: ',a1,')',/)
      end
      subroutine maprz(kcell)
c
c -------------------------------------------------------------
c  Map the Flux surfaces from psi(r,z)
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Set up parameters
c
      maperr      = 0
      maponly     = 1
      nvnt        = nvn
c
c
c 1.2 Save the original start position for the axis
c
      rstp(jpsi2) = rst(jpsi2)
      zstp(jpsi2) = zst(jpsi2)
c
c
c 1.3 Print header for surface calculation diagnostics
c
      if(kcell .eq. 0) write(kuout,1000)
      if(kcell .ne. 0) write(kuout,1010)
c
c
c
c 2.0 Compute the flux surface equilibrium quantities
c     All saved mapping quantities except qp fqpi and fqim are stored in order
c     from the axis to the edge
c     The mapping is done in reverse order from edge to axis and qp fqpi and fqim
c     are stored in the same order as psival from edge to axis
c
c 2.1 Set up the loop
c
      do 100 j    = 1,jpsi
      jv          = j
      jvp1        = jv + 1
      jp          = jpsi - jv + 1
      psivs       = psival(jv)
      if(jv .lt. jsep) ithtm   = itht
      if(jv .ge. jsep) ithtm   = itht/2
c
c
c 2.2 Compute the flux surface and q profile
c
c 2.2.1 Save the start positions from the Runge Kutta integration
c
      rstp(jvp1)  = rst (jvp1)
      zstp(jvp1)  = zst (jvp1)
c
c 2.2.2 Set the start positions and angle for the mapping
c
      rst0        = rstp(jvp1)
      zst0        = zstp(jvp1)
      arprv       = arcprev
c
c 2.2.3 Compute the mapping
c
      call eqdmap(jv,psivs,ithtm,rst0,zst0,rst1,zst1
     &              ,arprv,svint,nvnt,maponly,mapid,maperr)
c
      if(maperr .ne. 0) call abortjob
     &        ('maprz   ',  1,   'Surface mapping error in eqdmap     '
     &        ,'jv      ', jv,       'maperr  ', maperr,   +1)
c
c
c 2.3 Reset the start positions and angles
c
c 2.3.1 Save the modified start positions
c
      rst (jvp1)  = rst1
      zst (jvp1)  = zst1
c
c 2.3.2 Reset the start angle for the next surface
c
      arcprev     = arprv
c
c
c 2.4 Set the qp(jv) and fqpi(jv) values
c
c 2.4.1 Set q and fqpi
c
      qp  (jv)    = svint(1)
      fqpi(jv)    = svint(2)
c
c 2.4.2 Compute fqim
c
      fjv         = f   (jv)
      qjv         = qp  (jv)
      fqjv        = fqpi(jv)
      rvadjst     = ((xma**nham1)/(xma*xma)) / (xma**nham3)
      bpadjst     = (fjv/qjv)**nham2
      fvadjst     = (fjv*fjv)*(fjv**nham3)
      fqim(jv)    = (rvadjst*bpadjst*fvadjst*fqjv  -
     &               qjv*fjv*fjv) / fjv
c
c
c 2.5 Print warnings if the surface mapping was not accounted
c
      if(mapid .eq. 0) call abortjob
     &        ('maprz   ',  2,   'No mapping was done in eqdmap       '
     &        ,'jv      ', jv,       'maperr  ', maperr,   +1)
c
      if(mapid .lt. -1  .or.  mapid .gt. +2) call abortjob
     &        ('maprz   ',  3,   'Mapping identification error        '
     &        ,'jv      ', jv,       'mapid   ', mapid,    +1)
c
c
c 2.6 Compute the equilibrium quantities
c
      if(kcell .ne. 0) then
         call eqdcell(jv,psivs,ithtm)
      endif
c
c
c 2.7 Write out the mapping summary
c
c 2.7.1 Write out the mapping summary for this surface if this is just the
c       first pass through
c
      if    (kcell .eq. 0) then
         if(mapid .eq. -1) write(kuout,1100) jv,psivs,npcb,npc
     &                                      ,fqpi   (jv),qp     (jv)
         if(mapid .eq. +1) write(kuout,1110) jv,psivs,npcb,npc
     &                                      ,fqpi   (jv),qp     (jv)
         if(mapid .eq. +2) write(kuout,1120) jv,psivs,npcb,npc,npcf
     &                                      ,fqpi   (jv),qp     (jv)
c
c 2.7.2 Write out the mapping summary for this surface if this is the final
c       pass through
c
      elseif(kcell .ne. 0) then
c
         if(mapid .eq. -1) write(kuout,1200) jv,psivs,npcb,npc
     &                                      ,fqpi   (jv),qp     (jv)
     &                                      ,qprime (jp)
         if(mapid .eq. +1) write(kuout,1210) jv,psivs,npcb,npc
     &                                      ,fqpi   (jv),qp     (jv)
     &                                      ,qprime (jp)
         if(mapid .eq. +2) write(kuout,1220) jv,psivs,npcb,npc,npcf
     &                                      ,fqpi   (jv),qp     (jv)
     &                                      ,qprime (jp)
      endif
c
  100 continue
c
c
c
c 3.0 Set the axis values of the flux surface integrals
c
      if(kcell .ne. 0) then
         sntax0         = (twopi*qaxe*xma*xma) / faxe
         sntax1         = sntax0/(xma*xma)
         sntax2         = sint2(1)
         sntax3         = sint3(1)
         sntax4         = sint3(1)/(xma*xma)
c NOTE: savgax tavgax qppaxe dlnaxe dpnlaxe, and dhnlax should be evaluated properly
         savgax         = savge(1)
         tavgax         = tavge(1)
         qppaxe         = qprime(1)
         dlnaxe         = dlnlval(1)
         dpnaxe         = dpnlval(1)
         dhnaxe         = dhnlval(1)
         arcaxe         = 0.0
      endif
c
c
c
c 4.0 Return and end
c
      return
c
 1000 format(//, 5x,'First Internal Flux Surface Mapping:'
     &       ,/, 5x,'----- -------- ---- ------- -------',/)
 1010 format(//, 5x,'Final Internal Flux Surface Mapping:'
     &       ,/, 5x,'----- -------- ---- ------- -------',/)
 1100 format(    1x,'Mapped psi(',i5,') = ',e13.6,2x,'using furplm:'
     &       ,/, 5x,'npc (before removal) = ',i5
     &          ,4x,'npc (after  removal) = ',i5
     &       ,/,50x,'fqpi    = ',e13.6,9x,'qp      = ',e13.6)
 1110 format(    1x,'Mapped psi(',i5,') = ',e13.6,2x,'using cntour:'
     &       ,/, 5x,'npc (before removal) = ',i5
     &          ,4x,'npc (after  removal) = ',i5
     &       ,/,50x,'fqpi    = ',e13.6,9x,'qp      = ',e13.6)
 1120 format(    1x,'Mapped psi(',i5,') = ',e13.6,2x,'using cntour:'
     &       ,/, 5x,'npc (before removal) = ',i5
     &          ,4x,'npc (after  removal) = ',i5
     &          ,4x,'npc (from furplm)    = ',i5
     &       ,/,50x,'fqpi    = ',e13.6,9x,'qp      = ',e13.6)
 1200 format(    1x,'Mapped psi(',i5,') = ',e13.6,2x,'using furplm:'
     &       ,/, 5x,'npc (before removal) = ',i5
     &          ,4x,'npc (after  removal) = ',i5
     &       ,/,50x,'fqpi    = ',e13.6,9x,'qp      = ',e13.6
     &       ,/,50x,'qprime  = ',e13.6)
 1210 format(    1x,'Mapped psi(',i5,') = ',e13.6,2x,'using cntour:'
     &       ,/, 5x,'npc (before removal) = ',i5
     &          ,4x,'npc (after  removal) = ',i5
     &       ,/,50x,'fqpi    = ',e13.6,9x,'qp      = ',e13.6
     &       ,/,50x,'qprime  = ',e13.6)
 1220 format(    1x,'Mapped psi(',i5,') = ',e13.6,2x,'using cntour:'
     &       ,/, 5x,'npc (before removal) = ',i5
     &          ,4x,'npc (after  removal) = ',i5
     &          ,4x,'npc (from furplm)    = ',i5
     &       ,/,50x,'fqpi    = ',e13.6,9x,'qp      = ',e13.6
     &       ,/,50x,'qprime  = ',e13.6)
      end
      subroutine mappc(kcell)
c
c -------------------------------------------------------------
c  Map the Flux surfaces from the inverse equilibrium
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialize
c
c 1.1 Set the scalar parameters
c
      maperr      =  0
      nvnt        = nvn
      ithtm       = itht
      nspbcd      = nspbc0
      tolqp0      = qptol
      rndoff      = roundff
c
c
c 1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .eq.  0) then
         call abortjob
     &        ('mappc   ',  1,   'Called for a direct equilibrium    '
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('mappc   ',  2,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c
c 1.3 Print header for surface calculation diagnostics
c
      if(kcell .eq. 0) write(kuout,1000)
      if(kcell .ne. 0) write(kuout,1010)
c
c
c
c 2.0 Compute the mapping from the inverse equilibrium
c
c 2.1 Loop over flux surfaces
c
      do 100 j    = 1,jpsi
      jv          = j
      jvp1        = jv + 1
      jp          = jpsi - jv + 1
      psvl        = psival(jv)
c
c
c 2.2 Compute the mapping from the inverse equilibrium to the flux surface psvl
c
c 2.2.1 Compute the mapping
c
      call toqmap(ktype,jv,maperr,psvl,ithtm,svint,nvnt)
c
c 2.2.2 Print error message if mapping failed
c
      if(maperr .ne. 0) call abortjob
     &        ('mappc   ',  3,   'Surface mapping error in toqmap     '
     &        ,'maperr  ', maperr,   'kcell   ', kcell,    +1)
c
c 2.2.3 Set the actual starting positions used
c       For inverse equilibria these are not modified
c
      rstp(jvp1)  = rst(jvp1)
      zstp(jvp1)  = zst(jvp1)
c
c 2.2.4 Set the q and fqpi values for ktype = 1
c
c 2.2.4.1 Set q and fqpi
      if(ktype .eq. 1) then
        qp  (jv)    = svint(1)
        fqpi(jv)    = svint(2)
c
c 2.2.4.2 Compute fqim
        fjv         = f   (jv)
        qjv         = qp  (jv)
        fqjv        = fqpi(jv)
c
        rvadjst     = ((xma**nham1)/(xma*xma)) / (xma**nham3)
        bpadjst     = (fjv/qjv)**nham2
        fvadjst     = (fjv*fjv)*(fjv**nham3)
        fqim(jv)    = (rvadjst*bpadjst*fvadjst*fqjv  -
     &                 qjv*fjv*fjv) / fjv
      endif
c
c
c 2.3 Compute the coordinate mesh, arclength, and psi derivatives and write
c     out the mapping summary
c 2.3.1 Write out the mapping summary if this is the first pass through
c
      if    (kcell .eq. 0) then
         write(kuout,1100) jv,psvl,fqpi   (jv),qp     (jv)
c
c
c 2.3.2 Compute the equilibrium quantities for each cell
c
      elseif(kcell .ne. 0) then
         call toqcell(ktype,jv,psvl,ithtm)
         write(kuout,1200) jv,psvl,fqpi   (jv),qp     (jv)
     &                            ,qprime (jp)
      endif
c
c
c 2.4 End loop over mapping
c
  100 continue
c
c
c
c 3.0 Interplolate the profiles to the flux mesh
c
c 3.1 Interplolate to the flux mesh
c
      call fqintp(psimsh,sqvl,csqvl,nprofl,npp,nspbcd,psival,
     &                                     qpint,jpsi,bcb,rndoff)
      call fqintp(psimsh,sfqi,csfqi,nprofl,npp,nspbcd,psival,
     &                                     fqint,jpsi,bcb,rndoff)
c
c
c 3.2 Check interpolated profiles if ktype = 1 or use them if ktype = 2
c
c 3.2.1 Check interpolated profiles if ktype = 1
c
      if    (ktype .eq. 1) then
        do 200 j    = 1,jpsi
        jv          = j
        qpdif       = qp (jv) - qpint(jv)
        tolqp1      = 0.5*tolqp0*(abs(qp(jv)) + abs(qpint(jv)))
        if(abs(qpdif) .gt. tolqp1) then
          call abortjob
     &        ('mappc   ',  4,   'q difference exceeds tolerance      '
     &        ,'jv      ', jv,       'kcell   ', kcell,     0)
          write(kuout,2000) jv,qp (jv),qpint(jv),qpdif,tolqp1
        endif
  200   continue
c
c 3.2.2 Use qpint and fqint if ktype = 2
c
      elseif(ktype .eq. 2) then
        do 220 j    = 1,jpsi
        jv          = j
        qp  (jv)    = qpint(j)
        fqpi(jv)    = fqint(j)
c
c 3.2.4.2 Compute fqim
        fjv        = f   (jv)
        qjv        = qp  (jv)
        fqjv       = fqpi(jv)
c
        rvadjst     = ((xma**nham1)/(xma*xma)) / (xma**nham3)
        bpadjst     = (fjv/qjv)**nham2
        fvadjst     = (fjv*fjv)*(fjv**nham3)
        fqim(jv)    = (rvadjst*bpadjst*fvadjst*fqjv  -
     &                 qjv*fjv*fjv) / fjv
  220   continue
      endif
c
c
c
c 4.0 Compute the remainder of the equilibrium quantities for ktype .eq. 2
c
      if(kcell .ne. 0) then
        if(ktype .eq. 2) call feqspln
      endif
c
c
c
c 5.0 Set the axis values of the flux surface integrals
c
c 5.1 Reset the start position for the axis and edge
c
      rstp(jpsi2) = rst (jpsi2)
      zstp(jpsi2) = zst (jpsi2)
      rstp(  1  ) = rst (  1  )
      zstp(  1  ) = zst (  1  )
c
c
c 5.2 Set the axis values of the flux surface integrals
c
      if(kcell .ne. 0) then
         sntax0         = (twopi*qaxe*xma*xma) / faxe
         sntax1         = sntax0/(xma*xma)
         sntax2         = sint2(1)
         sntax3         = sint3(1)
         sntax4         = sint3(1)/(xma*xma)
c NOTE: savgax tavgax qppaxe dlnaxe dpnlaxe, and dhnlax should be evaluated properly
         savgax         = savge(1)
         tavgax         = tavge(1)
         qppaxe         = qprime(1)
         dlnaxe         = dlnlval(1)
         dpnaxe         = dpnlval(1)
         dhnaxe         = dhnlval(1)
         arcaxe         = 0.0
      endif
c
c
c
c 5.0 Return and end
c
      return
 1000 format(//, 5x,'First Internal Flux Surface Mapping:'
     &       ,/, 5x,'----- -------- ---- ------- -------',/)
 1010 format(//, 5x,'Final Internal Flux Surface Mapping:'
     &       ,/, 5x,'----- -------- ---- ------- -------',/)
 1100 format(    1x,'Mapped psi(',i5,') = ',e13.6
     &       ,/,50x,'fqpi    = ',e13.6,2x,'qp      = ',e13.6)
 1200 format(    1x,'Mapped psi(',i5,') = ',e13.6
     &       ,/,50x,'fqpi    = ',e13.6,2x,'qp      = ',e13.6
     &          ,2x,'qprime  = ',e13.6)
 2000 format(/,1x,'Warning: computed and interpolated profiles'
     &        ,1x,'are significantly different'
     &        ,1x,'for j  = ',i5,/
     &        ,1x,'qp     = ',e16.9,4x,'qpint  = ',e16.9
     &        ,4x,'qpdif  = ',e16.9,4x,'tolqp1 = ',e16.9)
      end
      subroutine prqprof(kase,initmap)
c
c -------------------------------------------------------------
c  Print out the mapped q profile
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Set up parameters
c
      jpp0        = 0
      qdmax0      = +1.0e+05
      psidfn      = delpsir
      if(kase .eq. 0  .and.  initmap .ne. 0) then
        call abortjob
     &        ('prqprof ',  1,   'Invalid options kase and initmap    '
     &        ,'kase    ', kase,     'initmap ', initmap,  -1)
      endif
c
c
c
c 2.0 Print out the q profile
c
c 2.1 Print the profile
c
c 2.1 Print the profile from the initial mapping
c
      if    (kase .eq. 0) then
c
c 2.1.1 Print the profile
c
        write(kutty,1000)
        write(kuout,1000)
c
        write(kutty,1020) (qp (j),j = jpsi1,1,-1),qlim
        write(kuout,1020) (qp (j),j = jpsi1,1,-1),qlim
c
c 2.1.2 Save the profiles
c
        do 100 jpp     = jpsi1,1,-1
        psinitl( jpp ) = psival( jpp )
        qpinitl( jpp ) = qp    ( jpp )
        rsinitl( jpp ) = rst   ( jpp )
        zsinitl( jpp ) = zst   ( jpp )
  100   continue
        rsinitl(jpsi2) = rst   (jpsi2)
        zsinitl(jpsi2) = zst   (jpsi2)
c
c
c 2.2 Print the profile from the final mapping
c
      elseif(kase .eq. 1) then
        if    (initmap .eq. 0) then
          write(kutty,1010)
          write(kuout,1010)
        elseif(initmap .ne. 0) then
          write(kutty,1015)
          write(kuout,1015)
        endif
c
        write(kutty,1020) (qp (j),j = jpsi1,1,-1),qlim
        write(kuout,1020) (qp (j),j = jpsi1,1,-1),qlim
      endif
c
c
c 2.3 Write out the psi mesh data
c
      write(kuout,2000)
      write(kuout,2010) (psival(j),j=jpsi1,1,-1),psilim
c
c
c
c 3.0 Calculate and write out the delta q values
c
c 3.1 Compute the differences
c
      if(kase .eq. 1) then
        qdmax       =  0.0
        do 200 jpp  = 1,jpsi1
        if(jpp .gt. 1) qdel(jpp) = (qp(jpp-1) - qp(jpp))*psidfn
     &                       / (psival(jpp-1) - psival(jpp))
        if(jpp .eq. 1) qdel(jpp) = (qlim      - qp(jpp))*psidfn
     &                       / (psilim        - psival(jpp))
c
        qdmag      = abs(qdel(jpp))
        if(qdmag .gt. qdmax) qdmax  = qdmag
  200   continue
c
c
c 3.2 Write out differences
c
c 3.2.1 Write the difference in fixed format if possible
c
        if    (qdmax .le. qdmax0) then
           write(kuout,2100)
           write(kuout,2105) (qdel(j),j = jpsi1,1,-1)
c
c 3.2.2 Write the difference in floating format if necessary
c
        else
           write(kuout,2110)
           write(kuout,2115) (qdel(j),j = jpsi1,1,-1)
        endif
      endif
c
c
c
c 4.0 Write out the Hamiltonian-like normalization fqpi and fqim values
c
      if(kase .eq. 1) then
        fqpim    = amax1(abs(fqpi(jpsi1)),abs(fqilim))
        fqimm    = amax1(abs(fqim(jpsi1)),abs(fqmlim))
        formmax  = 1.0e+05
        if(fqpim .lt. formmax  .and.  fqimm .lt. formmax) then
          write(kuout,3000)
          write(kuout,3010) (fqpi(j),j = jpsi1,1,-1),fqilim
          write(kuout,3020)
          write(kuout,3030) (fqim(j),j = jpsi1,1,-1),fqmlim
        else
          write(kuout,3100)
          write(kuout,3110) (fqpi(j),j = jpsi1,1,-1),fqilim
          write(kuout,3120)
          write(kuout,3130) (fqim(j),j = jpsi1,1,-1),fqmlim
        endif
      endif
c
c
c
c 5.0 Print out the comparison of the initial and final profiles
c
c 5.1 Print the q profile
c
      if(kase .eq. 1  .and.  initmap .ne. 0) then
        write(kuout,4000)
        write(kuout,4010)
        do 400 jpp  = jpsi1,1,-1
        write(kuout,4020) jpp, psinitl(jpp),psival(jpp)
     &                        ,qpinitl(jpp),qp    (jpp)
  400   continue
        write(kuout,4020) jpp0,psilim,psilim,qlim,qlim
c
c
c 5.2 Print the Runge Kutta start positions
c
        write(kuout,4030)
        do 450 jpp  = jpsi1,1,-1
        write(kuout,4040) jpp, psinitl(jpp),psival(jpp)
     &                        ,rsinitl(jpp),rst   (jpp)
     &                        ,zsinitl(jpp),zst   (jpp)
  450   continue
        write(kuout,4040) jpp0,psilim,psilim
     &                        ,rsinitl(jpsi2),rst(jpsi2)
     &                        ,zsinitl(jpsi2),zst(jpsi2)
      endif
c
c
c
c 6.0 Return and end
c
      return
c
 1000 format(/,5x,'q profile (initial map):',/)
 1010 format(/,5x,'q profile:',/)
 1015 format(/,5x,'q profile (final   map):',/)
 1020 format(5(1x,f14.7))
 2000 format(/,5x,'psi mesh',/)
 2010 format(5(1x,f14.7))
 2100 format(/,5x,'q derivatives from differences',/)
 2105 format(5(1x,f14.7))
 2110 format(/,5x,'q derivatives from differences',/)
 2115 format(5(1x,e14.7))
 3000 format(/,5x,'fqpi profile'/)
 3010 format(5(1x,f14.7))
 3020 format(/,5x,'fqim profile'/)
 3030 format(5(1x,f14.7))
 3100 format(/,5x,'fqpi profile'/)
 3110 format(5(1x,e14.7))
 3120 format(/,5x,'fqim profile'/)
 3130 format(5(1x,e14.7))
 4000 format(/,5x,'Comparison of initial and final profiles:')
 4010 format(/,6x,'j', 7x,'psival (initial)',5x,'psival (final)'
     &               , 5x,'qp     (initial)',5x,'qp     (final)',/)
 4020 format(3x,i6,4(4x,e16.9))
 4030 format(/,6x,'j', 7x,'psival (initial)',5x,'psival (final)'
     &               , 5x,'rst    (initial)',5x,'rst    (final)'
     &               , 5x,'zst    (initial)',5x,'zst    (final)',/)
 4040 format(3x,i6,6(4x,e16.9))
      end
      subroutine toqmap(ktype,jval,maperr,psvl,ithtm,svint,nvnt)
c -------------------------------------------------------------
c  Construct the poloidal mesh and interpolate (r,z) and the
c  poloidal angle variables
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension svint(nvnt)
c
c
c
c 1.0 Initialize
c
c 1.1 Error initialization
c
      maperr    = 0
      splndf    = tolspln*twopi
      rndoff    = roundff
c
c
c 1.2 Interpolation mesh parameters
c
      ntmsh     = ntmax
      ntmsh1    = ntmsh-1
      npc       = ntmsh
c
c
c 1.3 Initialize flux surface constants
c
c 1.3.1 Renormalized psi value
c
      psvs     = defmesh(psvl,psimax,delpsir,peqpk0,rndoff,
     &                   dpsds0,dpsdss0,ier)
c
c 1.3.2 Print a warning if the mesh could not be constructed
c
      if(ier .ne. 0) then
        maperr  = +1
        call abortjob
     &        ('toqmap  ',  1,   'Mesh construction error: defmesh    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
      endif
c
c
c
c 2.0 Define the position coordinates for the flux surface on a fine grid
c
c 2.1 Loop over the poloidal grid points
c
      dsmax     = thchi(nthet)
      dsgrid    = dsmax/float(ntmsh1)
c
      do 100 i  = 1,ntmsh
      dlgd      = (i-1)*dsgrid
c
c
c 2.2 Spline the r and z arrays on to the new grid for this flux surface
c
      drvl      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                   ,psvs,dlgd,pdsr,ier)
      if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  2,   'Spline error for r(psvl,dlgd)       '
     &        ,'ier     ', ier,      'jval    ', jval,      0)
c
      dzvl      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                   ,psvs,dlgd,pdsz,ier)
      if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  3,   'Spline error for z(psvl,dlgd)       '
     &        ,'ier     ', ier,      'jval    ', jval,      0)
c
c
c 2.3 Define the new position values for later splining
c
      xp (i)    = drvl
      zp (i)    = dzvl
  100 continue
c
c
c
c 3.0 Define the fine poloidal grid on the flux surface and compute
c     the other coordinates from it by spline interpolation
c
c
c 3.1 For ktyp = 1 use maparc to integrate over the flux surface
c
      if    (ktype .eq. 1) then
c
c 3.1.1 Compute the normalization for the q value
c
        if(jval .eq. 0) fval      = sf(nprofl)
        if(jval .ne. 0) fval      = sterpl(psvl,psimsh,sf,   csf,
     &                                     nprofl,npp,0,rndoff,ier)
        if(ier .ne. 0) then
          maperr  = -1
          call abortjob
     &        ('toqmap  ',  4,   'Interpolation error: sf(psvl)       '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
        endif
c
c 3.1.2 Integrate over the flux surface
c
        call maparc(ktype,jval,psvl,fval,ithtm,svint,nvnt)
c
c
c 3.2 For ktype = 2 interpolate using the bicubic spline to get the
c     polodal angles
c
      elseif(ktype .eq. 2) then
c
c 3.2.1 Loop over integration mesh points
c
        do 200 i  = 1,ntmsh
        dlgd      = (i-1)*dsgrid
c
c 3.2.2 Spline all arrays on to the new grid for this flux surface
c
        darc      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csarc
     &                     ,psvs,dlgd,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  5,   'Spline error for arcl(psvl,dlgd)    '
     &        ,'ier     ', ier,      'jval    ', jval,      0)
c
        dpst      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cspst
     &                     ,psvs,dlgd,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  6,   'Spline error for pest(psvl,dlgd)    '
     &        ,'ier     ', ier,      'jval    ', jval,      0)
c
        dham      = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csham
     &                     ,psvs,dlgd,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  7,   'Spline error for haml(psvl,dlgd)    '
     &        ,'ier     ', ier,      'jval    ', jval,      0)
c
c 3.2.3 Define the new poloidal grid values for later splining
c
        arc(i)    = darc
        tp (i)    = darc
        st1(i)    = dpst
        st2(i)    = dham
  200   continue
c
c 3.2.4 Define the normalizations for the poloidal angles
c
c 3.2.4.1 Normalization from bicubic spline of the original arrays
        arcmax0 = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csarc
     &                     ,psvs,dsmax,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  8,   'Spline error: arcl normalization    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
        pstmax0 = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cspst
     &                     ,psvs,dsmax,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('toqmap  ',  9,   'Spline error: pest normalization    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
        hammax0 = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csham
     &                     ,psvs,dsmax,pdsr,ier)
        if(ier .ne. 0) call abortjob
     &        ('toqmap  ', 10,   'Spline error: haml normalization    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c 3.2.4.2 Normalization from interpolating the normalization values
c     to this flux surface
        arcmax1   = sterpl(psvs,peqmsh0,arcmax,csarcm,nprofl,npp,0,
     &                          rndoff, ier)
        if(  ier   .ne.  0 ) call abortjob
     &        ('toqmap  ', 11,   'Spline error: arcmax(psvs)          '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
        pstmax1   = sterpl(psvs,peqmsh0,pstmax,cspstm,nprofl,npp,0,
     &                          rndoff, ier)
        if(  ier   .ne.  0 ) call abortjob
     &        ('toqmap  ', 12,   'Spline error: pstmax(psvs)          '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
        hammax1   = sterpl(psvs,peqmsh0,hammax,cshamm,nprofl,npp,0,
     &                          rndoff, ier)
        if(  ier   .ne.  0 ) call abortjob
     &        ('toqmap  ', 13,   'Spline error: hammax(psvs)          '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c 3.2.4.3 Check for zero or negative normalizations
c
c 3.2.4.3.1 Arclength
        if    (arcmax0 .gt. 0.0) then
          arcmaxx   = arcmax0
c
        elseif(arcmax0 .le. 0.0) then
          if    (arcmax1 .gt. 0.0) then
            arcmaxx   = arcmax1
            write(kuout,1000) jval,psvl,arcmax0,arcmax1
            call abortjob
     &        ('toqmap  ', 14,   'Bicubic spline arclength is zero    '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    -1)
          elseif(arcmax1 .le. 0.0) then
            write(kuout,1010) jval,psvl,arcmax0,arcmax1
            call abortjob
     &        ('toqmap  ', 15,   'Arclength is zero both methods      '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    +1)
          endif
        endif
c
c 3.2.4.3.2 PEST angle
        if    (pstmax0 .gt. 0.0) then
          pstmaxx   = pstmax0
c
        elseif(pstmax0 .le. 0.0) then
          if    (pstmax1 .gt. 0.0) then
            pstmaxx   = pstmax1
            write(kuout,1100) jval,psvl,pstmax0,pstmax1
            call abortjob
     &        ('toqmap  ', 16,   'Bicubic spline pstlength is zero    '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    -1)
          elseif(pstmax1 .le. 0.0) then
            write(kuout,1110) jval,psvl,pstmax0,pstmax1
            call abortjob
     &        ('toqmap  ', 17,   'Pestlength is zero: both methods    '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    +1)
          endif
        endif
c
c 3.2.4.3.3 Hamiltonian angle
        if    (hammax0 .gt. 0.0) then
          hammaxx   = hammax0
c
        elseif(hammax0 .le. 0.0) then
          if    (hammax1 .gt. 0.0) then
            hammaxx   = hammax1
            write(kuout,1200) jval,psvl,hammax0,hammax1
            call abortjob
     &        ('toqmap  ', 18,   'Bicubic spline hamlength is zero    '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    -1)
          elseif(hammax1 .le. 0.0) then
            write(kuout,1210) jval,psvl,hammax0,hammax1
            call abortjob
     &        ('toqmap  ', 19,   'Hamllength is zero: both methods    '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    +1)
          endif
        endif
c
c 3.2.5 Check for significant discrepancies
c
c 3.2.5.1 Arclength
c
        if(abs((arcmax1-arcmax0)/arcmaxx) .ge. splndf) then
          call abortjob
     &        ('toqmap  ', 20,   'Arcmax difference > tolerance       '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,     0)
          write(kuout,2000) jval,psvl,arcmax0,arcmax1,splndf
        endif
c
c 3.2.5.2 PEST angle
        if(abs((pstmax1-pstmax0)/pstmaxx) .ge. splndf) then
          call abortjob
     &        ('toqmap  ', 21,   'Pstmax difference > tolerance       '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,     0)
          write(kuout,2010) jval,psvl,pstmax0,pstmax1,splndf
c
c 3.2.5.3 Hamiltonian angle
        endif
        if(abs((hammax1-hammax0)/hammaxx) .ge. splndf) then
          call abortjob
     &        ('toqmap  ', 22,   'Hammax difference > tolerance       '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,     0)
          write(kuout,2020) jval,psvl,hammax0,hammax1,splndf
        endif
      endif
c
c
c
c 4.0 Spline the mapping quantities on to the final poloidal grid
c
      call mapangl(jval,ithtm)
c
c
c
c 5.0 Return and end
c
      return
 1000 format(/,5x,'Warning: non-positive arclength   normalization:',/
     &        ,5x,'Using the 1D spline estimate:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'arcmax0  = ',e14.7,4x,'arcmax1  = ',e14.7)
 1010 format(/,5x,'Fatal Error:   Both arclength   normalizations are'
     &        ,1x,'non-positive:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'arcmax0  = ',e14.7,4x,'arcmax1  = ',e14.7)
 1100 format(/,5x,'Warning: non-positive PEST chi    normalization:',/
     &        ,5x,'Using the 1D spline estimate:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'pstmax0  = ',e14.7,4x,'pstmax1  = ',e14.7)
 1110 format(/,5x,'Fatal Error:   Both PEST chi    normalizations are'
     &        ,1x,'non-positive:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'pstmax0  = ',e14.7,4x,'pstmax1  = ',e14.7)
 1200 format(/,5x,'Warning: non-positive Hamiltonian normalization:',/
     &        ,5x,'Using the 1D spline estimate:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'hammax0  = ',e14.7,4x,'hammax1  = ',e14.7)
 1210 format(/,5x,'Fatal Error:   Both Hamiltonian normalizations are'
     &        ,1x,'non-positive:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'hammax0  = ',e14.7,4x,'hammax1  = ',e14.7)
 2000 format(/,5x,'Warning: inaccurate arclength   normalization:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'arcmax0  = ',e14.7,4x,'arcmax1  = ',e14.7
     &        ,5x,'splndf   = ',e14.7)
 2010 format(/,5x,'Warning: inaccurate PEST chi    normalization:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'pstmax0  = ',e14.7,4x,'pstmax1  = ',e14.7
     &        ,5x,'splndf   = ',e14.7)
 2020 format(/,5x,'Warning: inaccurate Hamiltonian normalization:',/
     &        ,5x,'jval     = ',i5,  13x,'psvl     = ',e14.7,/
     &        ,5x,'hammax0  = ',e14.7,4x,'hammax1  = ',e14.7
     &        ,5x,'splndf   = ',e14.7)
      end
      subroutine toqcell(ktype,jval,psvl,ithtm)
c
c -------------------------------------------------------------
c  Calculate and store the mapping quantities for the inverse equilibrium
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c     Input quantities:
c     jval:       Flux surface label.
c                 jval = 0 corresponds to the plasma surface
c     ithtm:      Number of poloidal angles
c
c     Input from toqmap:
c     rs, zs :    Coordinates of the flux mesh grid points.
c     arcsurf:    Incremented arclength around flux surface.
c     pestchi:    PEST coordinate angle around flux surface.
c     hamlchi:    Hamiltonian-like coordinate angle around flux surface.
c     arcnrm0:    Total arclength around flux surface.
c     pstnrm0:    Total integrated PEST coordinate around flux surface.
c     hamnrm0:    Total integrated Hamiltonian coordinate around flux surface.
c     svint:      Surface integrals
c
c     Output quantities:
c     xjcarcl:    Jacobian for arclength normalized to 2pi
c     xjcpest:    Jacobian for Pest poloidal angle
c     xjchaml:    Jacobian for Hamiltonian poloidal angle
c     alfarcl:    Nonorthogonality for arclength normalized to 2pi
c     alfpest:    Nonorthogonality for Pest poloidal angle
c     alfhaml:    Nonorthogonality for Hamiltonian poloidal angle
c
c     arcnorm:    Total arclength of surface (Period for Arclength coordinate)
c     pstnorm:    Period for PEST coordinate on surface
c     hamnorm:    Period for Hamiltonian coordinate on surface
c
c     dlnlval:    Logarithmic derivative of the arclength   normalization:
c                 [dL/dpsi / L]  (L = arclength normalization)
c     dpnlval:    Logarithmic derivative of the pest angle  normalization:
c                 [dP/dpsi / P]  (P = PEST normalization = q/f)
c     dhnlval:    Logarithmic derivative of the Hamiltonian normalization:
c                 [dH/dpsi / H]  (H = Hamiltonian normalization = fqi/f
c     sint0:      integral[r/grad(psi)]dl
c     sint1:      integral[((1/(r**2)) * (r/grad(psi))]dl
c     sint2:      integral[(d/dpsi(log(grad(psi)**2)) / r**2) * (r/grad(psi))]dl
c     sint3:      integral[(1/(grad(psi)**2)) * (r/grad(psi))]dl
c     sint4:      integral[(1/(r**2 * grad(psi)**2)) * (r/grad(psi))]dl
c     savge:      Surface averaged local shear S
c     tavge:      Surface averaged T - 0.5*S   (T = mu0*j.B/(grad(psi)**2)
c     qprime:     d/dpsi(q) from savge*sint0
c
c     f3 :         f / (r**2)
c     f4 :        -(mu0*jtor) / (r*Bpol)**2
c     f5 :        f * [d/dpsi(J/(r**2))](constant chi)
c     f7 :        2J{ ((mu0*jtor)/(r*Bpol))**2                           + 
c                     ((mu0*jtor)/((r**2)*Bpol))*[d/dpsi(r*Bpol)]normal  -
c                     ((mu0*p'/r)*[dr/dpsi]normal }
c        :        2J{ ((mu0*jtor)/(r*Bpol))**2                           + 
c                     ((mu0*jtor)/(r*Bpol))*[d/dpsi(Bpol)]normal         +
c                     ((ff'/r**3)*[dr/dpsi]normal }
c     f8 :        1 / [J*(r*Bpol)**2]
c     f9 :        J*(Bpol**2)
c     f10:        (r**2) / J
c     f11:        (mu0*gamma*p) / J
c     f12:        (f*J) / (r**2)
c     f13:        J (Jacobian)
c     f14:        [dJ/dpsi](constant chi)
c     f15:        [dJ/dchi](constant psi)
c     f16:         d/dpsi(grad(psi)**2)normal
c     f17:         d/dchi[grad(psi)**2]
c     f18:         d/dchi[grad(psi).grad(chi)]
c     f19:         d/dchi[(dchi/dpsi)normal]
c     f20:        -(grad(psi).grad(chi)) / (grad(psi)**2)
c                      (-nonorthogonality: [-dchi/dpsi]normal)
c     f21:        2*[(r**2)/f] * [d/dpsi(log(r)]]normal         = [1/f] * [dr**2/dpsi]normal
c     f22:        2*[(r**2)/f] * [d/dchi(log(r))](constant psi) = [1/f] * [dr**2/dchi](constant psi)
c     f23:        S = (f/r**2)*[del*(psi) - d/dpsi[grad(psi)**2]normal)] / grad(psi)**2)  -
c                                                     f'/r**2  (Local shear)
c     f24:        T - S  =  mu0*j.B/(grad(psi)**2) - S
c                        = (f/r**2)*[d/dpsi[grad(psi)**2]normal) -  2*del*(psi)] / grad(psi)**2)
c     f25:        +[darcl/dpsi]normal) (i.e. (nonorthogonality) for arclength angle
c     f26:        +[dpest/dpsi]normal) (i.e. (nonorthogonality) for PEST angle
c     f27:        +[dpest/darcl]constant psi
c     f28:        +[dpest/dpsi ]constant arcl
c
c
c
c
c 1.0 Initialize
c
c 1.1 Initialize mesh counters
c
      jvnew     = jpsi-jval+1
c
      if(jvnew .lt. 0) call abortjob
     &        ('toqcell ',  1,   'jvnew is out of range               '
     &        ,'jval    ', jval,     'jvnew   ', jvnew,    +1)
c
c
c 1.2 Initialize error tolerances
c
      kercnt0   = 0
      kercnt1   = 0
      kercntj   = 0
      kercnta   = 0
      wrndff    = roundff
      xscale2   = xdim*xdim + zdim*zdim
      xscalef   = sqrt(xscale2)
      rndoff    = roundff*xscalef
      rndofj    = roundff*xscale2*xscalef/abs(delpsir)
      rndofa    = roundff/abs(delpsir)
      splndf    = tolspln*xscalef
c
      tolqpv    = tolbchi
c
c
c 1.3 Set the renormalized flux value
c
      psvs      = defmesh(psvl,psimax,delpsir,peqpk0,wrndff,
     &                    dpsds0,dpsdss0,ier)
      if(ier .ne. 0) call abortjob
     &        ('toqcell ',  2,   'Mesh construction error: defmesh    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c
c 1.4 Initialize the profile values
c
      if    (jval .eq. 0) then
        pvalu     = plim
        ppvalu    = pplim
        fvalu     = flim
        ffpvalu   = ffplim
        qvalu     = qlim
        fqvalu    = fqilim
        f2valu    = flim*flim
        fpvalu    = ffplim/flim
      elseif(jval .gt. 0) then
        pvalu     = p   (jval)
        ppvalu    = pp  (jval)
        fvalu     = f   (jval)
        ffpvalu   = ffp (jval)
        qvalu     = qp  (jval)
        fqvalu    = fqpi(jval)
        f2valu    = fvalu*fvalu
        fpvalu    = ffpvalu/fvalu
      endif
c
      amuppv    = amu*ppvalu
      amugp     = amu*gamav*pvalu
c
c
c 1.5 Set the parameter defining how close to the edge the cell is
c
      delpv     = psvl - psilim
      if(abs(delpv) .gt. abs(dpedg2)) jpedge =  0
      if(abs(delpv) .le. abs(dpedg2)) jpedge = +1
      if(abs(delpv) .le. abs(dpedg1)) jpedge = +2
c
c
c
c 2.0 Calculate the nonorthogonality and normalizations dlnl, dpnl, and dhnl
c
c 2.1 Nonorthogonality
c
      call betachi(jval,ithtm,dlnl,dpnl,dhnl,kuout)
c
c
c 2.2 Normalization scales 
c

      alfmax    = 0.0
      do 50  i  = 1,ithtm
      ival      = i
      alfa      = alfarc(ival)
      if(abs(alfa) .ge. alfmax) alfmax = abs(alfa)
   50 continue
c
      xjsumm0   = abs((arcnrm0/charcmx)*xscale2/delpsir)
      alsumm0   = alfmax
c
c
c
c 3.0 Set up the surface quantities.
c     The quantities are stored in reverse order in psi (i.e. from
c     psimax at the magnetic axis to psilim).
c
c 3.1 Initialize coefficients.
c
      arcnrm1          = charcmx/arcnrm0
      pstnrm1          = chpstmx/pstnrm0
      hamnrm1          = chhammx/hamnrm0
c
      arcnorm(jvnew)   = arcnrm0
      pstnorm(jvnew)   = pstnrm0
      hamnorm(jvnew)   = hamnrm0
c
c
c 3.2 Set the flux surface integrals.
c
c 3.2.1 Set the fundamental surface integrals from svint from maparc
c
      sint0(jvnew)     = svint(3)
      sint1(jvnew)     = svint(4)
      sint2(jvnew)     = svint(5)
      sint3(jvnew)     = svint(6)
      sint4(jvnew)     = svint(7)
c
c 3.2.2 Set the surface averaged local shear quantities.
c
      savrage          =     fpvalu       *svint(4)  -
     &                       fvalu        *svint(5)  -
     &                       fvalu *amuppv*svint(6)  -
     &                       f2valu*fpvalu*svint(7)
      tavrage          = 0.5*fpvalu       *svint(4)  +
     &                   0.5*fvalu        *svint(5)  +
     &                   1.5*fvalu *amuppv*svint(6)  +
     &                   1.5*f2valu*fpvalu*svint(7)
c
      savge(jvnew)     =     savrage/svint(3)
      tavge(jvnew)     =     tavrage/svint(3)
c
c 3.2.3 Set qprime
c
      qprime (jvnew)   = savrage/twopi
c
c 3.2.4 Set the normalization derivatives dlnlval, dpnlval, and dhnlval
c       from betachi
c
      dlnlval(jvnew)   = dlnl
      dpnlval(jvnew)   = dpnl
      dhnlval(jvnew)   = dhnl
c
c 3.2.5 Set the value for the choice of coordinate system
c
      if(igrid .eq. 0) dnormnl = dlnl
      if(igrid .ne. 0) dnormnl = dpnl
c
c
c
c 4.0 Compute and store the equilibrium quantities over the new mesh
c
c 4.1 Loop over the angles for this flux surface
c
      do 100 i  = 1,ithtm
      ival      = i
      ijval     = ival + (jval-1)*ithtm
      theta     = arcnrm1*arcsurf(ival)
c
c
c 4.2 Set the coordinates
c
      if(jval .eq. 0) rval0  =  rsrf(ival)
      if(jval .gt. 0) rval0  =  rs  (ival,jval)
      if(jval .eq. 0) zval0  =  zsrf(ival)
      if(jval .gt. 0) zval0  =  zs  (ival,jval)
c
c
c 4.3 Compute the inverse derivatives from the bicubic spline
c
c 4.3.1 Evaluate the spline to obtain the derivatives
c
      rval1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                   ,psvs,theta,pdsr,ier)
      if(ier .ne. 0) call abortjob
     &        ('toqcell ',  3,   'Spline interpolation error: rval    '
     &        ,'ier     ', ier,      'ijval   ', ijval,     0)
c
      zval1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                   ,psvs,theta,pdsz,ier)
      if(ier .ne. 0) call abortjob
     &        ('toqcell ',  4,   'Spline interpolation error: zval    '
     &        ,'ier     ', ier,      'ijval   ', ijval,     0)
c
c 4.3.2 Check the difference between the spline value and the original values
c
      rdiff10   = rval1 - rval0
      zdiff10   = zval1 - zval0
      if(abs(rdiff10) .ge. splndf  .or.  abs(zdiff10) .ge. splndf) then
        kercnt0   = kercnt0 + 1
        if    (kercnt0 .lt. nerstop) then
          if(abs(rdiff10) .ge. splndf) call abortjob
     &        ('toqcell ',  5,   'Spline (rval0-rval1) > tolerance    '
     &        ,'jval    ', jval,     'ival    ', ival,      0)
          if(abs(zdiff10) .ge. splndf) call abortjob
     &        ('toqcell ',  6,   'Spline (zval0-zval1) > tolerance    '
     &        ,'jval    ', jval,     'ival    ', ival,      0)
          write(kuout,1000) ijval,ithtm,rval0,rval1,zval0,zval1
     &                                 ,rdiff10,zdiff10,splndf
        elseif(kercnt0 .eq. nerstop) then
          call abortjob
     &        ('toqcell ',  7,   'Maximum spline tolerance errors     '
     &        ,'jval    ', jval,     'nerstop ', nerstop,  -1)
        endif
      endif
c
c
c 4.4 Compute and store the derivatives of psi with respect to r and z
c
c 4.4.1 Compute the derivatives from the inverse derivatives
c
c Input:  s        = psi**alph
c         t        = arclength angle
c         dpsds0   = dpsi/ds
c         dpsds0   = [d**2/ds**2]psi
c         pdsr(1)  = r
c         pdsr(2)  = dr/ds
c         pdsr(3)  = dr/dt
c         pdsr(4)  = [d**2/ds**2]r
c         pdsr(5)  = [d**2/ds*dt]r
c         pdsr(6)  = [d**2/dt**2]r
c         pdsz(1)  = z
c         pdsz(2)  = dz/ds
c         pdsz(3)  = dz/dt
c         pdsz(4)  = [d**2/ds**2]z
c         pdsz(5)  = [d**2/ds*dt]z
c         pdsz(6)  = [d**2/dt**2]z
c
c Output:
c         pdsp(1)  = J
c         pdsp(2)  = dpsi/dr
c         pdsp(3)  = dpsi/dz
c         pdsp(4)  = dJ/dpsi [constant theta]
c         pdsp(5)  = d[grad(psi)]**2} /dpsi [constant theta] 
c         pdsp(6)  = dtheta/dpsi[normal]
c         pdsc(1)  = 1/J
c         pdsc(2)  = dtheta/dr
c         pdsc(3)  = dtheta/dz
c         pdsc(4)  = dJ/dtheta [constant psi]
c         pdsc(5)  = d[grad(psi)]**2} /dtheta [constant psi]
c         pdsc(6)  = dpsi/dtheta[normal to theta]

      call derivpsi(pdsr,pdsz,dpsds0,dpsdss0,pdsp,pdsc,wrndff,2,ier)
      if(ier .ne. 0) call abortjob
     &        ('toqcell ',  8,   'Error inverting dp/dr from dr/dp    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c 4.4.2 Define the r and z points on the mesh
c
c 4.4.2.1 Define the values from the input to derivpsi
      rval2     = pdsr(1)
      zval2     = pdsz(1)
c
c 4.4.2.2 Check the values are not corrupted
      rdiff21   = rval2 - rval1
      zdiff21   = zval2 - zval1
      if(abs(rdiff21) .ge. rndoff  .or.  abs(zdiff21) .ge. rndoff) then
        kercnt1    = kercnt1 + 1
        if    (kercnt1 .lt. nerstop) then
          if(abs(rdiff21) .ge. rndoff) call abortjob
     &        ('toqcell ',  9,   'Spline (rval2-rval1) >  roundoff    '
     &        ,'jval    ', jval,     'ival    ', ival,      0)
          if(abs(zdiff21) .ge. rndoff) call abortjob
     &        ('toqcell ', 10,   'Spline (zval2-zval1) >  roundoff    '
     &        ,'jval    ', jval,     'ival    ', ival,      0)
          write(kuout,1100) ijval,ithtm
     &                     ,rval0,rval1,rval2,rdiff10,rdiff21
     &                     ,zval0,zval1,zval2,zdiff10,zdiff21
     &                     ,splndf,rndoff
        elseif(kercnt1 .eq. nerstop) then
          call abortjob
     &        ('toqcell ', 11,   'Max position tolerance errors       '
     &        ,'jval    ', jval,     'nerstop ', nerstop,  -1)
        endif
      endif
c
c 4.4.2.3 Set rval and zval
      if    (nccellr .lt. 0) then
        rval       = rval0
        zval       = zval0
      elseif(nccellr .eq. 0) then
        rval       = rval1
        zval       = zval1
      elseif(nccellr .gt. 0) then
        rval       = rval2
        zval       = zval2
      endif
c
c 4.4.3 Define the derivatives for the equilibrium arclength coordinate theta
c
c 4.4.3.1 Inverse derivatives with respect to psi and theta
      drdps0    = pdsr(2)/dpsds0
      dzdps0    = pdsz(2)/dpsds0
      drdth0    = pdsr(3)
      dzdth0    = pdsz(3)
c
c 4.4.3.2 Derivatives with respect to r and z
      xjthet    = pdsp(1)
      dpsdr0    = pdsp(2)
      dpsdz0    = pdsp(3)
      dthdr0    = pdsc(2)
      dthdz0    = pdsc(3)
c
c 4.4.3.3 Compute the derivatives of the Jacobian and Poloidal field
c       and the nonorthogonality parameter for the equilibrium
c       arclength coordinate
c
      djcbdp0   = pdsp(4)
      dgp2dp0   = pdsp(5)
      djcbdc0   = pdsc(4)
      dgp2dc0   = pdsc(5)
      alpha0    = pdsp(6)
c
c 4.4.4 Store the computed poloidal coordinates for each surface
c     The quantities are stored in reverse order in psi (i.e. from
c     psimax at the magnetic axis to psilim).
c
c 4.4.4.1 Mesh cell center coordinates.
c         These are forced to be the same as defined in (rs,zs)
c         and (rsrf,zsrf)
      rcell  (jvnew,ival) =  rval0
      zcell  (jvnew,ival) =  zval0
c
c 4.4.4.2 Store the derivatives
      dpsdr  (jvnew,ival) =  dpsdr0
      dpsdz  (jvnew,ival) =  dpsdz0
c
c 4.4.4.3 Set the poloidal angles normalized to charcmx, chpstmx,
c       and chhammx respectively
      chiarcl(jvnew,ival) =  arcnrm1*arcsurf(ival)
      chipest(jvnew,ival) =  pstnrm1*pestchi(ival)
      chihaml(jvnew,ival) =  hamnrm1*hamlchi(ival)
c
c 4.4.4 Construct the current density and poloidal field
c       r*jphi is taken to be  = -del*(psi)= +(mu*r**2 *p' + ff')
c
      rvalsq    =  rval*rval
      cjphi     = -(rval*amuppv + ffpvalu/rval)
      cjphir    =  cjphi/rval
      gpsisq    =  dpsdr0*dpsdr0 + dpsdz0*dpsdz0
      gpsivl    =  sqrt(gpsisq)
      bpolsq    =  gpsisq / rvalsq
      bpoldl    =  sqrt(bpolsq)
      rbpol     =  rval*bpoldl
      rbpol2    =  gpsisq
      btorvl    =  fvalu/rval
      btorsq    =  btorvl*btorvl
      btotsq    =  bpolsq + btorsq
      btotal    =  sqrt(btotsq)
c
c
c 4.5 Set the Jacobian and nonorthogonality
c
c 4.5.1 Construct the Jacobian and non-orthogonality.
c
      xjarc     =  rval/gpsivl
      xjpst     =  rvalsq
      xjham     = (rval**nham1)*(bpoldl**nham2)*
     &            (btotal**nham3)
c
      xjarcv    = (arcnrm0/charcmx)*xjarc
      xjpstv    = (qvalu /fvalu)   *xjpst
      xjhamv    = (fqvalu/fvalu)   *xjham
c
      alarcv    = alfarc(ival)
      alpstv    = alfpst(ival)
      alhamv    = alfham(ival)
c
c 4.5.2 Check xjarcv and  xjthet agree
c       This check is ignored for the plasma boundary with jval = 0 
c       (i.e. jvnew = jpsi1)
c
      xjdiff    =     xjarcv  -     xjthet
      aldiff    =     alarcv  -     alpha0
      xjsumm1   = 0.5*(abs(xjarcv) + abs(xjthet))
      alsumm1   = 0.5*(abs(alarcv) + abs(alpha0))
      if(abs(xjthet) .lt. rndofj) xjratio   = xjarcv/rndoff
      if(abs(xjthet) .ge. rndofj) xjratio   = xjarcv/xjthet
      if(abs(alpha0) .lt. rndofa) alratio   = alarcv/rndoff
      if(abs(alpha0) .ge. rndofa) alratio   = alarcv/alpha0
c
      xjsumm    = amax1(xjsumm0,xjsumm1)
      alsumm    = amax1(alsumm0,alsumm1)
c
      if(jpedge .eq. 0) then
        if(abs(xjdiff) .ge. tolqpv*xjsumm) then
          kercntj   = kercntj + 1
          if    (kercntj .lt. nerstop) then
             call abortjob
     &        ('toqcell ', 12,   'xjthet and L*r/2pi*gradpsi not equal'
     &        ,'jval    ', jval,     'ival    ', ival,     -1)
             xjcomp    = xjsumm
             if(abs(xjcomp) .lt. rndofj) xjdiffd = +abs(xjdiff/rndofj)
             if(abs(xjcomp) .ge. rndofj) xjdiffd = +abs(xjdiff/xjcomp)
             write(kuout,2000) xjarcv,xjthet,xjdiff,xjdiffd,xjratio,
     &                         tolqpv,xjsumm,xjsumm0,xjsumm1
          elseif(kercntj .eq. nerstop) then
            call abortjob
     &        ('toqcell ', 13,   'Maximum Jacobian discrepancy reached'
     &        ,'jval    ', jval,     'nerstop ', nerstop,  -1)
          endif
        endif
c
        if(abs(aldiff) .ge. tolqpv*alsumm) then
          kercnta   = kercnta + 1
          if    (kercnta .lt. nerstop) then
             call abortjob
     &        ('toqcell ', 14,   'alarcv and alpha0 are not equal     '
     &        ,'jval    ', jval,     'ival    ', ival,     -1)
             alcomp    = alsumm
             if(abs(alcomp) .lt. rndofa) aldiffd = +abs(aldiff/rndofa)
             if(abs(alcomp) .ge. rndofa) aldiffd = +abs(aldiff/alcomp)
             write(kuout,2100) alarcv,alpha0, aldiff,aldiffd,alratio,
     &                         tolqpv,alsumm,alsumm0,alsumm1
          elseif(kercnta .eq. nerstop) then
            call abortjob
     &        ('toqcell ', 15,   'Maximum betachi discrepancy reached '
     &        ,'jval    ', jval,     'nerstop ', nerstop,  -1)
          endif
        endif
      endif
c
c 4.5.3 Store the Jacobian and non-orthogonality
c       For cells within an equilibrium grid of the plasma surface use
c       the local value of the nonorthogonality to avoid using the second
c       derivatives of psi at the edge in the betachi calculation
        xjarcl    = xjarcv
        xjpest    = xjpstv
        xjhaml    = xjhamv
        alpest    = alpstv
        alhaml    = alhamv
        if    (jpedge .eq. 0) then
           alarcl    = alarcv
        elseif(jpedge .eq. +1) then
           alarcl    = alpha0
        elseif(jpedge .eq. +2) then
           alarcl    = alpha0
        endif
c
      xjcarcl(jvnew,ival) =  xjarcl
      xjcpest(jvnew,ival) =  xjpest
      xjchaml(jvnew,ival) =  xjhaml
c
      alfarcl(jvnew,ival) =  alarcl
      alfpest(jvnew,ival) =  alpest
      alfhaml(jvnew,ival) =  alhaml
c
c
c
c 4.6 Compute the data needed for the equilibrium flux mesh quantities
c     xjtrans   =  J(arcl)/J(Pest)
c     xjacb     =  J
c     djacbdc   =  [dJ/dchi]psi
c     djacbdp   =  [dJ/dpsi]chi
c     djacbdn   =  [dJ/dpsi]normal
c     alpha     =  [grad(psi).grad(chi)] / [grad(psi)]**2
c     dgps2dp   =  d/dpsi[grad(psi)**2]chi
c     dgps2dc   =  d/dchi[grad(psi)**2]psi
c     drdpsi    =  [dr/dpsi]chi
c     drdchi    =  [dr/dchi]psi
c     drdpsin   =  [dr/dpsi]normal
c     dg2dpsn   =  [d/dpsi(grad(psi)**2]normal
c     dgpsin    =  [d/dpsi(grad(psi)]normal
c     dg2psin   =  [d/dpsi(grad(psi)**2]normal / grad(psi)**2
c     rvalsq    =   r**2
c     cjphi     =   del*(psi)/r = -jphi
c     cjphir    =   del*(psi) / r**2
c     gpsisq    =  [grad(psi)]**2
c     bpolsq    =  [grad(psi) / r]**2  = Bpol**2
c     bpoldl    =   Bpol
c     rbpol     =   grad(psi)     = r*Bpol
c     rbpol2    =  [grad(psi)]**2
c     drjacb    = + J*[dr/dpsi]chi
c     shearv    =   S
c     shearp    =   T - S  =  mu0*j.B/(grad(psi)**2) - S
c     dortdt    =  [dalpha/dchi]psi
c
c 4.6.1 Skip the equilibrium quantity calculations if ktype .ne. 1
c
      if(ktype .eq. 1) then
c
c 4.6.2 Define the values used according to igrid
c
c 4.6.2.1 Set the transformation from equal arc to Pest angle
c
        xjtrans   =  xjarcl/xjpest
c
c 4.6.2.2 For equal arc mesh
        if(igrid .eq. 0) then
c
c 4.6.2.2.1 Jacobian and non-orthogonality
          xjacb     = xjarcl
          alpha     = alarcl

c
c 4.6.2.2.2 Compute the derivatives of r, the Jacobian and Poloidal field
          drdpsi    = drdps0
          djacbdp   = djcbdp0
          dgps2dp   = dgp2dp0
          drdchi    = drdth0
          djacbdc   = djcbdc0
          dgps2dc   = dgp2dc0
c
c 4.6.2.3 For PEST grid
        elseif(igrid .ne. 0) then
c
c 4.6.2.3.1 Jacobian and non-orthogonality
          xjacb     = xjpest
          alpha     = alpest
c
c 4.6.2.3.2 Transformation to PEST coordinates
          dthdchi   = xjtrans
          dthdpsi   = alarcv - alpstv*dthdchi
c
c 4.6.2.3.3 Compute the derivatives of r, the Jacobian and Poloidal field
          drdpsi    = drdps0  + drdth0 *dthdpsi
          djacbdp   = djcbdp0 + djcbdc0*dthdpsi
          dgps2dp   = dgp2dp0 + dgp2dc0*dthdpsi
          drdchi    = drdth0 *dthdchi
          djacbdc   = djcbdc0*dthdchi
          dgps2dc   = dgp2dc0*dthdchi
        endif
c
        drjacb    =  drdpsi*xjacb
c
c 4.6.3 Compute the normal derivatives
c
        drdpsin   = drdpsi  + alpha*drdchi
        djacbdn   = djacbdp + alpha*djacbdc
        dgps2dn   = dgps2dp + alpha*dgps2dc
c
        dgpsin    = 0.5*dgps2dn/rbpol
        dg2psin   =     dgps2dn/rbpol2
c
c 4.6.4 Compute the shear and related quantities
c
        shearv    = (fvalu/rvalsq)*(     rvalsq*cjphir/rbpol2
     &                                           - dg2psin)
     &               +  fpvalu / rvalsq
        shearp    = (fvalu/rvalsq)*(-2.0*rvalsq*cjphir/rbpol2
     &                                           + dg2psin)
        dortdt    = shearv*rvalsq/fvalu - fpvalu/fvalu - 
     &              djacbdn/xjacb       +
     &              2.0*drdpsin/rval
c
c
c 4.7 Construct the equilibrium functions
c
        f3 (jvnew,ival) =  fvalu/rvalsq
        f4 (jvnew,ival) =  cjphir/bpolsq
        f5 (jvnew,ival) =  fvalu*(djacbdp - 2.0*drjacb/rval) /rvalsq
        f7 (jvnew,ival) =  2.0*xjacb*(cjphir*cjphir/bpolsq  -
     &                                cjphir*dgpsin/(rval*bpoldl)  -
     &                                amuppv*drdpsin/rval)
        f8 (jvnew,ival) =  1.0/(xjacb*rbpol2)
        f9 (jvnew,ival) =  xjacb*bpolsq
        f10(jvnew,ival) =  rvalsq/xjacb
        f11(jvnew,ival) =  amugp/xjacb
        f12(jvnew,ival) =  fvalu*xjacb/rvalsq
        f13(jvnew,ival) =  xjacb
        f14(jvnew,ival) =  djacbdp
        f15(jvnew,ival) =  djacbdc
        f16(jvnew,ival) =  dgps2dn
        f17(jvnew,ival) =  dgps2dc
        f18(jvnew,ival) =  gpsisq*dortdt + alpha*dgps2dc
        f19(jvnew,ival) =  dortdt
        f20(jvnew,ival) = -alpha
        f21(jvnew,ival) =  2.0*rval*drdpsin/fvalu
        f22(jvnew,ival) =  2.0*rval*drdchi /fvalu
        f23(jvnew,ival) =  shearv
        f24(jvnew,ival) =  shearp
        f25(jvnew,ival) = +alarcv
        f26(jvnew,ival) = +alpstv
        f27(jvnew,ival) =  xjtrans
        f28(jvnew,ival) =  alpstv + alarcv*xjtrans
      endif
  100 continue
c
c
c 4.8 Print a warning if the number of spline or position errors
c     exceeded the maximum
c
c 4.8.1 Spline errors
c
      if(kercnt0 .ge. nerstop) then
        call abortjob
     &        ('toqcell ', 16,   'Number of  spline errors > allowed  '
     &        ,'jval    ', jval,     'kercnt0 ', kercnt0,  -1)
      endif
c
c 4.8.2 Position errors
c
      if(kercnt1 .ge. nerstop) then
        call abortjob
     &        ('toqcell ', 17,   'Number of position errors > allowed '
     &        ,'jval    ', jval,     'kercnt1 ', kercnt1,  -1)
      endif
c
c 4.8.3 Jacobian errors
c
      if(kercntj .ge. nerstop) then
        call abortjob
     &        ('toqcell ', 18,   'Number of Jacobian errors > allowed '
     &        ,'jval    ', jval,     'kercntj ', kercntj,  -1)
      endif
c
c 4.8.4 JNon-orthogonality errors
c
      if(kercnta .ge. nerstop) then
        call abortjob
     &        ('toqcell ', 19,   'Number of betachi errors > allowed  '
     &        ,'jval    ', jval,     'kercnta ', kercnta,  -1)
      endif
c
c
c
c 5.0 Impose periodicity
c
c 5.1 Impose periodicity on the coordinates
c
      rcell  (jvnew,ithtp) =  rcell  (jvnew,1)
      zcell  (jvnew,ithtp) =  zcell  (jvnew,1)
      dpsdr  (jvnew,ithtp) =  dpsdr  (jvnew,1)
      dpsdz  (jvnew,ithtp) =  dpsdz  (jvnew,1)
      chiarcl(jvnew,ithtp) =  chiarcl(jvnew,1) + charcmx
      chipest(jvnew,ithtp) =  chipest(jvnew,1) + chpstmx
      chihaml(jvnew,ithtp) =  chihaml(jvnew,1) + chhammx
      xjcarcl(jvnew,ithtp) =  xjcarcl(jvnew,1)
      xjcpest(jvnew,ithtp) =  xjcpest(jvnew,1)
      xjchaml(jvnew,ithtp) =  xjchaml(jvnew,1)
      alfarcl(jvnew,ithtp) =  alfarcl(jvnew,1)
      alfpest(jvnew,ithtp) =  alfpest(jvnew,1)
      alfhaml(jvnew,ithtp) =  alfhaml(jvnew,1)
c
c
c 5.2 Impose periodicity on the equilibrium quantities for ktype = 1
c     For ktype = 2 the equilibrium functions are read in and interpolated
c     Periodicity is imposed after the interpolation
c
      if(ktype .eq. 1) then
        f3     (jvnew,ithtp) =  f3     (jvnew,1)
        f4     (jvnew,ithtp) =  f4     (jvnew,1)
        f5     (jvnew,ithtp) =  f5     (jvnew,1)
        f7     (jvnew,ithtp) =  f7     (jvnew,1)
        f8     (jvnew,ithtp) =  f8     (jvnew,1)
        f9     (jvnew,ithtp) =  f9     (jvnew,1)
        f10    (jvnew,ithtp) =  f10    (jvnew,1)
        f11    (jvnew,ithtp) =  f11    (jvnew,1)
        f12    (jvnew,ithtp) =  f12    (jvnew,1)
        f13    (jvnew,ithtp) =  f13    (jvnew,1)
        f14    (jvnew,ithtp) =  f14    (jvnew,1)
        f15    (jvnew,ithtp) =  f15    (jvnew,1)
        f16    (jvnew,ithtp) =  f16    (jvnew,1)
        f17    (jvnew,ithtp) =  f17    (jvnew,1)
        f18    (jvnew,ithtp) =  f18    (jvnew,1)
        f19    (jvnew,ithtp) =  f19    (jvnew,1)
        f20    (jvnew,ithtp) =  f20    (jvnew,1)
        f21    (jvnew,ithtp) =  f21    (jvnew,1)
        f22    (jvnew,ithtp) =  f22    (jvnew,1)
        f23    (jvnew,ithtp) =  f23    (jvnew,1)
        f24    (jvnew,ithtp) =  f24    (jvnew,1)
        f25    (jvnew,ithtp) =  f25    (jvnew,1)
        f26    (jvnew,ithtp) =  f26    (jvnew,1)
        f27    (jvnew,ithtp) =  f27    (jvnew,1)
        f28    (jvnew,ithtp) =  f28    (jvnew,1)
      endif
c
c
c
c 6.0 Return and end
c
      return
c
 1000 format(1x,'Inaccurate bicubic spline interpolation'
     &      ,1x,'ijval   = ',i5,   2x,'ithtm   = ',i5,/
     &      ,1x,'rval0   = ',e16.9,2x,'rval1   = ',e16.9
     &      ,2x,'zval0   = ',e16.9,2x,'zval1   = ',e16.9,/
     &      ,1x,'rdiff10 = ',e16.9,2x,'zdiff10 = ',e16.9
     &      ,2x,'splndf  = ',e16.9)
 1100 format(1x,'Position values inconsistent after differentiation'
     &      ,1x,'ijval   = ',i5,   2x,'ithtm   = ',i5,/
     &      ,1x,'rval0   = ',e16.9,2x,'rval1   = ',e16.9
     &      ,2x,'rval2   = ',e16.9,2x,'rdiff10 = ',e16.9
     &      ,2x,'rdiff11 = ',e16.9,/
     &      ,1x,'zval0   = ',e16.9,2x,'zval1   = ',e16.9
     &      ,2x,'zval2   = ',e16.9,2x,'zdiff10 = ',e16.9
     &      ,2x,'zdiff11 = ',e16.9,/
     &      ,1x,'rndoff  = ',e16.9,2x,'splndf  = ',e16.9)
 2000 format(5x,'xjarcl  = ',e12.5,4x,'xjthet  = ',e12.5
     &      ,4x,'diff    = ',e12.5,4x,'diffd   = ',e12.5
     &      ,4x,'ratio   = ',e12.5
     &    ,/,5x,'tolqpv  = ',e12.5,4x,'xjsumm  = ',e12.5
     &      ,4x,'xjsumm0 = ',e12.5,4x,'xjsumm1 = ',e12.5)
 2100 format(5x,'alarcl  = ',e12.5,4x,'alpha0  = ',e12.5
     &      ,4x,'diff    = ',e12.5,4x,'diffd   = ',e12.5
     &      ,4x,'ratio   = ',e12.5
     &    ,/,5x,'tolqpv  = ',e12.5,4x,'alsumm  = ',e12.5
     &      ,4x,'alsumm0 = ',e12.5,4x,'alsumm1 = ',e12.5)
      end
      subroutine fqintp(seqmsh,seqprf,cseqprf,nsprf,nspr1,nspbc,
     &                  prfval,profil,nprf,bdd,rndff)
c
c -------------------------------------------------------------
c  Interpolate the q and fqpi profiles from the inverse equilibrium
c -------------------------------------------------------------
c
      dimension seqmsh(nspr1),seqprf(nspr1),cseqprf(3,nspr1),bdd(4)
      dimension prfval(nprf),profil(nprf)
c
c
c
c 1.0 Initialize
c
c 1.1 Parameters
c
      smallno     = rndff
c
c
c 1.2 Set up the boundary conditions
c
c 1.2.1 Set up the extrapolation coefficients
c
      nfqbnd     = nspbc
      nsprf1     = nsprf - 1
      nsprf2     = nsprf - 2
      delx21     = seqmsh(  2   ) - seqmsh(   1   )
      delx32     = seqmsh(  3   ) - seqmsh(   2   )
      delx31     = seqmsh(  3   ) - seqmsh(   1   )
      delxn1     = seqmsh(nsprf)  - seqmsh(nsprf1)
      delxnx     = seqmsh(nsprf1) - seqmsh(nsprf2)
      delxn2     = seqmsh(nsprf)  - seqmsh(nsprf2)
      dr3132     = delx31/delx32
      dr2132     = delx21/delx32
      drn2nx     = delxn2/delxnx
      drn1nx     = delxn1/delxnx
      if    (nfqbnd .le. 0) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      elseif(nfqbnd .eq. 1) then
        xtrap1     = 1.0
        xtrap1p    = 0.0
        xtrapn     = 1.0
        xtrapnp    = 0.0
      elseif(nfqbnd .eq. 2) then
        xtrap1     = +dr3132
        xtrap1p    = -dr2132
        xtrapn     = +drn2nx
        xtrapnp    = -drn1nx
      elseif(nfqbnd .gt. 2) then
        xtrap1     = 0.0
        xtrap1p    = 0.0
        xtrapn     = 0.0
        xtrapnp    = 0.0
      endif
c
c 1.2.2 Set up the spline coefficients for the spline boundary conditions
c
c 1.2.2.1 Set the second derivatives at the endpoints
      sp2pp      = f2sx(   2  ,seqprf,seqmsh,nsprf)
      sp3pp      = f2sx(   3  ,seqprf,seqmsh,nsprf)
      spn1pp     = f2sx(nsprf1,seqprf,seqmsh,nsprf)
      spn2pp     = f2sx(nsprf2,seqprf,seqmsh,nsprf)
c
      spbc11     = xtrap1*sp2pp   + xtrap1p*sp3pp
      spbcnn     = xtrapn*spn1pp  + xtrapnp*spn2pp
c
c 1.2.2.2 Set the boundary conditions at the endpoint from the second
c         derivatives
      if    (nfqbnd .ge.  0  .and.  nfqbnd .le.  2) then
        bdd(1)     = 0.0
        bdd(2)     = 2.0*spbc11
        bdd(3)     = 0.0
        bdd(4)     = 2.0*spbcnn
c
c 1.2.2.3 Use natural boundary conditions at the plasma surface but force
c         a near floating condition at the axis
      elseif(nfqbnd .gt. +2) then
        bigval     = abs(float(nfqbnd))
        bdd(1)     = bigval
        bdd(2)     = bigval*sp2pp
        bdd(3)     = bigval
        bdd(4)     = bigval*spn1pp
c
c 1.2.2.4 Use a floating condition at both ends
      elseif(nfqbnd .lt.  0) then
        bigval     = abs(float(nfqbnd))
        bdd(1)     = bigval
        bdd(2)     = bigval*sp2pp
        bdd(3)     = 0.0
        bdd(4)     = 0.0
      endif
c
c
c
c 2.0 Set up the spline coefficients
c
      call icsici(seqmsh,seqprf,nsprf,bdd,cseqprf,nspr1,ier)
      if(ier .ne. 0) call abortjob
     &        ('fqintp  ',  1,   'Interpolation error from icsici     '
     &        ,'ier     ', ier,      'nsprf   ', nsprf,    +1)
c
c
c
c 3.0 Interpolate to the flux mesh
c
      do 100 jv   = 1,nprf
      jvl         = jv
      psvl        = prfval(jvl)
      fvalu       = sterpl(psvl,seqmsh,seqprf,cseqprf,nsprf,nspr1,0,
     &                          smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('fqintp  ',  2,   'Spline evaluation error: sterpl     '
     &        ,'ier     ', ier,      'jvl     ', jvl,      -1)
c
      profil(jvl) = fvalu
  100 continue
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine feqspln
c
c -------------------------------------------------------------
c  Spline the equilibrium functions from the inverse equilibrium
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialize
c
      ibdpd     = -1
      nvu       = max0(npp,ntt)
      ntmsh     = ntmax
      rndoff    = roundff
c
c
c
c 2.0 Compute the equilibrium quantities
c
c 2.1 Interpolate f3
c
      call feqint(f3, psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf3, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.2 Interpolate f4
c
      call feqint(f4, psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf4, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.3 Interpolate f5
c
      call feqint(f5, psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf5, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.4 Interpolate f7
c
      call feqint(f7, psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf7, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c
c 2.5 Interpolate f8
c
      call feqint(f8, psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf8, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.6 Interpolate f9
c
      call feqint(f9, psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf9, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.7 Interpolate f10
c
      call feqint(f10,psim1,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf10,peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.8 Interpolate f11
c
      call feqint(f11,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf11,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.9 Interpolate f12
c
      call feqint(f12,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf12,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.10 Interpolate f13
c
      call feqint(f13,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf13,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.11 Interpolate f14
c
      call feqint(f14,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf14,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.12 Interpolate f15
c
      call feqint(f15,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf15,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.13 Interpolate f16
c
      call feqint(f16,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf16,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.14 Interpolate f17
c
      call feqint(f17,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf17,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.15 Interpolate f18
c
      call feqint(f18,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf18,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.16 Interpolate f19
c
      call feqint(f19,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf19,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.17 Interpolate f20
c
      call feqint(f20,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf20,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.18 Interpolate f21
c
      call feqint(f21,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf21,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.19 Interpolate f22
c
      call feqint(f22,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf22,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.20 Interpolate f23
c
      call feqint(f23,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf23,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.21 Interpolate f24
c
      call feqint(f24,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf24,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.22 Interpolate f25
c
      call feqint(f25,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf25,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.23 Interpolate f26
c
      call feqint(f26,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf26,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.24 Interpolate f27
c
      call feqint(f27,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf27,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c 2.25 Interpolate f28
c
      call feqint(f28,psim2,chic,jpsi,itht,np1,nc1,np1,cseqf,work1
     &           ,vork1,seqf28,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndoff,ibdpd)
c
c
c
c 3.0 Impose periodicity on the equilibrium quantities
c
      do 100 jp = 1,jpsi
      jvnew     = jpsi - jp + 1
      f3     (jvnew,ithtp) =  f3     (jvnew,1)
      f4     (jvnew,ithtp) =  f4     (jvnew,1)
      f5     (jvnew,ithtp) =  f5     (jvnew,1)
      f7     (jvnew,ithtp) =  f7     (jvnew,1)
      f8     (jvnew,ithtp) =  f8     (jvnew,1)
      f9     (jvnew,ithtp) =  f9     (jvnew,1)
      f10    (jvnew,ithtp) =  f10    (jvnew,1)
      f11    (jvnew,ithtp) =  f11    (jvnew,1)
      f12    (jvnew,ithtp) =  f12    (jvnew,1)
      f13    (jvnew,ithtp) =  f13    (jvnew,1)
      f14    (jvnew,ithtp) =  f14    (jvnew,1)
      f15    (jvnew,ithtp) =  f15    (jvnew,1)
      f16    (jvnew,ithtp) =  f16    (jvnew,1)
      f17    (jvnew,ithtp) =  f17    (jvnew,1)
      f18    (jvnew,ithtp) =  f18    (jvnew,1)
      f19    (jvnew,ithtp) =  f19    (jvnew,1)
      f20    (jvnew,ithtp) =  f20    (jvnew,1)
      f21    (jvnew,ithtp) =  f21    (jvnew,1)
      f22    (jvnew,ithtp) =  f22    (jvnew,1)
      f23    (jvnew,ithtp) =  f23    (jvnew,1)
      f24    (jvnew,ithtp) =  f24    (jvnew,1)
      f25    (jvnew,ithtp) =  f25    (jvnew,1)
      f26    (jvnew,ithtp) =  f26    (jvnew,1)
      f27    (jvnew,ithtp) =  f27    (jvnew,1)
      f28    (jvnew,ithtp) =  f28    (jvnew,1)
  100 continue
c
c
c
c 4.0 Return and end
c
      return
c
      end
      subroutine feqint(fval,psivl,thtvl,jpvl,jtvl,jpvu,jtvu,jpvv,csval
     &                 ,wrk,vrk,seqvl,pseqvl,theqvl,npvl,ntvl,npvu,ntvu
     &                 ,tvl,fvl,csfvl,ntmx,ntmm,bc,nvrk,rndff,ibd)
c
      dimension fval (jpvu,jtvu),psivl (jpvv),thtvl (jtvu)
      dimension seqvl(npvu,ntvu),pseqvl(npvu),theqvl(ntvu)
      dimension csval(npvu,ntvu,4),wrk(npvu,ntvu),vrk(nvrk)
      dimension tvl(ntmm),fvl(ntmm),csfvl(3,ntmm)
      dimension pds(6),bc(4)
c
c
c
c 1.0 Initialization
c
      ntm        = ntmx
      ntm1       = ntm - 1
      thmn       = theqvl(1)
      thmx       = theqvl(ntvl)
      dsgd       = (thmx - thmn)/float(ntm1)
      smallno    = rndff
c
c
c
c 2.0 Compute the interpolation coefficients
c
      do 150 jj      = 1,npvl
      do 100 ii      = 1,ntvl
      csval(jj,ii,1) = seqvl(jj,ii)
  100 continue
  150 continue
c
      call bispline(pseqvl,theqvl,npvl,ntvl,npvu,ntvu,csval
     &                                ,wrk,vrk,nvrk,ibd)
c
c
c
c 3.0 Spline to the new (psivl,thtvl) grid
c
      do 300 j   = 1,jpvl
      jvnew      = jpvl-j+1
      psiv       = psivl(j)
c
c
c 3.1 Interpolate to the psivl flux surface
c
      do 200 i   = 1,ntm
      thtv       = thmn + (i-1.0)*dsgd
      fvalue     = dspeval(pseqvl,npvl,npvu,theqvl,ntvl,ntvu,csval
     &                    ,psiv,thtv,pds,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqint  ',  1,   'Spline evaluation error: dspeval    '
     &        ,'ier     ', ier,      'jvnew   ', jvnew,    -1)
c
      tvl(i)     = thtv
      fvl(i)     = fvalue
  200 continue
c
c
c 3.2 Spline the 1D array for this flux surface
c
      bc(1)         = 0.0
      bc(2)         = 2.*f2s(ntm1,fvl,tvl,ntmx)
      bc(3)         = 0.0
      bc(4)         = bc(2)
      call icsici(tvl,fvl,ntm,bc,csfvl,ntmm,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqint  ',  2,   'Spline interpolation error          '
     &        ,'ier     ', ier,      'jvnew   ', jvnew,    +1)
c
c
c 3.3 Interpolate to the thtvl mesh for this flux surface
c
      do 250 i      = 1,jtvl
      thtv          = thtvl(i)
      fvalue        = sterpl(thtv,tvl,fvl,csfvl,ntm,ntmm,1,smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqint  ',  3,   'Spline evaluation error: sterpl     '
     &        ,'ier     ', ier,      'jvnew   ', jvnew,    -1)
c
      fval(jvnew,i) = fvalue
  250 continue
  300 continue
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine feqsurf
c
c -------------------------------------------------------------
c  Interpolate the equilibrium functions from the inverse equilibrium for the surface
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/toq2/  seqdpdr(ntt), seqdpdz(ntt), csdpdr(3,ntt),
     &              csdpdz(3,ntt),bcc(4)
      common/toq3/  arcmax(npp),pstmax(npp),hammax(npp),
     &              csarcm(3,npp),cspstm(3,npp),cshamm(3,npp)
      common/toq4/  seqarc(npp,ntt), seqpst(npp,ntt), seqham(npp,ntt),
     &              seqf3 (npp,ntt), seqf4 (npp,ntt), seqf5 (npp,ntt),
     &              seqf7 (npp,ntt), seqf8 (npp,ntt), seqf9 (npp,ntt),
     &              seqf10(npp,ntt), seqf11(npp,ntt), seqf12(npp,ntt),
     &              seqf13(npp,ntt), seqf14(npp,ntt), seqf15(npp,ntt),
     &              seqf16(npp,ntt), seqf17(npp,ntt), seqf18(npp,ntt),
     &              seqf19(npp,ntt), seqf20(npp,ntt), seqf21(npp,ntt),
     &              seqf22(npp,ntt), seqf23(npp,ntt), seqf24(npp,ntt),
     &              seqf25(npp,ntt), seqf26(npp,ntt),
     &              seqf27(npp,ntt), seqf28(npp,ntt),
     &              csarc(npp,ntt,4),cspst(npp,ntt,4),csham(npp,ntt,4),
     &              cseqf(npp,ntt,4),work1 (npp,ntt), vork1 (npp+ntt)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialize
c
c 1.1 Initialize parameters
c
      ibdpd     = -1
      nvu       = max0(npp,ntt)
      ntmsh     = ntmax
      rndff     = roundff
c
c
c 1.2 Construct the value of psilim corresponding to the meshes
c     peqmsh1 and peqmsh2
c
c 1.2.1 Construct the surface value of peqmsh1
c
      pslm1     = defmesh(psilim,psimax,delpsir,peqpk1,rndff,
     &                    dpsds1,dpsdss1,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqsurf ',  1,   'Surface mesh construction error     '
     &        ,'ier     ', ier,      'npsi    ', npsi,     -1)
      if(abs(pslm1-peqmsh1(npsi)) .gt. rndff) call abortjob
     &        ('feqsurf ',  2,   'pslm1 not equal to peqmsh1(npsi)    '
     &        ,'npsi    ', npsi,     'nthet   ', nthet,    -1)
c
c 1.2.2 Construct the surface value of peqmsh2
c
      pslm2     = defmesh(psilim,psimax,delpsir,peqpk2,rndff,
     &                    dpsds2,dpsdss2,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqsurf ',  3,   'Surface mesh construction error     '
     &        ,'ier     ', ier,      'npsi    ', npsi,     -1)
      if(abs(pslm2-peqmsh2(npsi)) .gt. rndff) call abortjob
     &        ('feqsurf ',  4,   'pslm2 not equal to peqmsh2(npsi)    '
     &        ,'npsi    ', npsi,     'nthet   ', nthet,    -1)
c
c
c
c 2.0 Compute the equilibrium quantities
c
c 2.1 Interpolate f3
c
      call feqins(f3, pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf3, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.2 Interpolate f4
c
      call feqins(f4, pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf4, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.3 Interpolate f5
c
      call feqins(f5, pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf5, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.4 Interpolate f7
c
      call feqins(f7, pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf7, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.5 Interpolate f8
c
      call feqins(f8, pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf8, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.6 Interpolate f9
c
      call feqins(f9, pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf9, peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.7 Interpolate f10
c
      call feqins(f10,pslm1,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf10,peqmsh1,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.8 Interpolate f11
c
      call feqins(f11,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf11,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.9 Interpolate f12
c
      call feqins(f12,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf12,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.10 Interpolate f13
c
      call feqins(f13,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf13,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.11 Interpolate f14
c
      call feqins(f14,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf14,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.12 Interpolate f15
c
      call feqins(f15,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf15,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.13 Interpolate f16
c
      call feqins(f16,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf16,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.14 Interpolate f17
c
      call feqins(f17,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf17,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.15 Interpolate f18
c
      call feqins(f18,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf18,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.16 Interpolate f19
c
      call feqins(f19,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf19,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.17 Interpolate f20
c
      call feqins(f20,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf20,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.18 Interpolate f21
c
      call feqins(f21,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf21,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.19 Interpolate f22
c
      call feqins(f22,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf22,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.20 Interpolate f23
c
      call feqins(f23,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf23,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.21 Interpolate f24
c
      call feqins(f24,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf24,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.22 Interpolate f25
c
      call feqins(f25,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf25,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.23 Interpolate f26
c
      call feqins(f26,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf26,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.24 Interpolate f27
c
      call feqins(f27,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf27,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c 2.25 Interpolate f28
c
      call feqins(f28,pslm2,chic,jpsi,itht,np1,nc1,cseqf,work1
     &           ,vork1,seqf28,peqmsh2,thchi,npsi,nthet,npp,ntt,tp
     &           ,st1,cseq1,ntmsh,nlx,bcd,nvu,rndff,ibdpd)
c
c
c
c 3.0 Impose periodicity on the equilibrium quantities
c
      do 100 jp            = 1,jpsi
      jvnew                = jpsi - jp + 1
      f3     (jvnew,ithtp) =  f3     (jvnew,1)
      f4     (jvnew,ithtp) =  f4     (jvnew,1)
      f5     (jvnew,ithtp) =  f5     (jvnew,1)
      f7     (jvnew,ithtp) =  f7     (jvnew,1)
      f8     (jvnew,ithtp) =  f8     (jvnew,1)
      f9     (jvnew,ithtp) =  f9     (jvnew,1)
      f10    (jvnew,ithtp) =  f10    (jvnew,1)
      f11    (jvnew,ithtp) =  f11    (jvnew,1)
      f12    (jvnew,ithtp) =  f12    (jvnew,1)
      f13    (jvnew,ithtp) =  f13    (jvnew,1)
      f14    (jvnew,ithtp) =  f14    (jvnew,1)
      f15    (jvnew,ithtp) =  f15    (jvnew,1)
      f16    (jvnew,ithtp) =  f16    (jvnew,1)
      f17    (jvnew,ithtp) =  f17    (jvnew,1)
      f18    (jvnew,ithtp) =  f18    (jvnew,1)
      f19    (jvnew,ithtp) =  f19    (jvnew,1)
      f20    (jvnew,ithtp) =  f20    (jvnew,1)
      f21    (jvnew,ithtp) =  f21    (jvnew,1)
      f22    (jvnew,ithtp) =  f22    (jvnew,1)
      f23    (jvnew,ithtp) =  f23    (jvnew,1)
      f24    (jvnew,ithtp) =  f24    (jvnew,1)
      f25    (jvnew,ithtp) =  f25    (jvnew,1)
      f26    (jvnew,ithtp) =  f26    (jvnew,1)
      f27    (jvnew,ithtp) =  f27    (jvnew,1)
      f28    (jvnew,ithtp) =  f28    (jvnew,1)
  100 continue
c
c
c
c 4.0 Return and end
c
      return
c
      end
      subroutine feqins(fval,pslim,thtvl,jpvl,jtvl,jpvu,jtvu,csval
     &                 ,wrk,vrk,seqvl,pseqvl,theqvl,npvl,ntvl,npvu,ntvu
     &                 ,tvl,fvl,csfvl,ntmx,ntmm,bc,nvrk,rndff,ibd)
c
      dimension fval (jpvu,jtvu),thtvl (jtvu)
      dimension seqvl(npvu,ntvu),pseqvl(npvu),theqvl(ntvu)
      dimension csval(npvu,ntvu,4),wrk(npvu,ntvu),vrk(nvrk)
      dimension tvl(ntmm),fvl(ntmm),csfvl(3,ntmm)
      dimension pds(6),bc(4)
c
c
c
c 1.0 Initialization
c
      ntm            = ntmx
      ntm1           = ntm - 1
      thmn           = theqvl(1)
      thmx           = theqvl(ntvl)
      dsgd           = (thmx - thmn)/float(ntm1)
      smallno        = rndff
c
c
c
c 2.0 Compute the interpolation coefficients
c
      do 150 jj      = 1,npvl
      do 100 ii      = 1,ntvl
      csval(jj,ii,1) = seqvl(jj,ii)
  100 continue
  150 continue
c
      call bispline(pseqvl,theqvl,npvl,ntvl,npvu,ntvu,csval
     &                                ,wrk,vrk,nvrk,ibd)
c
c
c
c 3.0 Spline to the new (psivl,thtvl) grid
c
      jvnew          = jpvl+1
      psiv           = pslim
c
c
c 3.1 Interpolate to the psivl flux surface
c
      do 200 i       = 1,ntm
      thtv           = thmn + (i-1.0)*dsgd
      fvalue         = dspeval(pseqvl,npvl,npvu,theqvl,ntvl,ntvu,csval
     &                     ,psiv,thtv,pds,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqins  ',  1,   'Spline evaluation error: dspeval    '
     &        ,'ier     ', ier,      'jvnew   ', jvnew,    -1)
c
      tvl(i)         = thtv
      fvl(i)         = fvalue
  200 continue
c
c
c 3.2 Spline the 1D array for this flux surface
c
      bc(1)          = 0.0
      bc(2)          = 2.*f2s(ntm1,fvl,tvl,ntmx)
      bc(3)          = 0.0
      bc(4)          = bc(2)
      call icsici(tvl,fvl,ntm,bc,csfvl,ntmm,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqins  ',  2,   'Spline interpolation error          '
     &        ,'ier     ', ier,      'jvnew   ', jvnew,    +1)
c
c
c 3.3 Interpolate to the thtvl mesh for this flux surface
c
      do 250 i       = 1,jtvl
      thtv           = thtvl(i)
      fvalue         = sterpl(thtv,tvl,fvl,csfvl,ntm,ntmm,1,
     &                             smallno,ier)
      if(ier .ne. 0) call abortjob
     &        ('feqins  ',  3,   'Spline evaluation error: sterpl     '
     &        ,'ier     ', ier,      'jvnew   ', jvnew,    -1)
c
      fval(jvnew,i)  = fvalue
  250 continue
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine symetry
c
c -------------------------------------------------------------
c  Impose up-down symmetry
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Set the midvalue for the poloidal mesh
c
      itsym    = 1 + itht/2
c
c
c 1.2 Initialize symmetry tolerances
c
c 1.2.1 Compute maxima for scales
c
      qpmx      = 0.0
      svmx      = 0.0
      do 10  jp = 1,jpsi1
      jpv       = jp
      qpvl      = abs(qprime(jpv))
      svvl      = abs(savge (jpv))
      if(qpvl .gt. qpmx) qpmx   = qpvl
      if(svvl .gt. svmx) svmx   = svvl
  10  continue
c
c 1.2.2 Set the scales
c
      augmnt   = tolaugm
      tolsymc  = tolsymm*twopi
      tolsymr  = tolsymm*abs(rcnt)
      tolsymp  = tolsymm*abs(delpsir)
      tolsymf  = tolsymm*(abs(flim) + abs(f(jpsi1)))
      tolsymd  = tolsymm* abs(qpmx)
      tolsyms  = tolsymm* abs(svmx)
c
      tolsymcp = augmnt*tolsymc
      tolsymrp = augmnt*tolsymr
      tolsympp = augmnt*tolsymp
      tolsymfp = augmnt*tolsymf
      tolsymdp = augmnt*tolsymd
      tolsymsp = augmnt*tolsyms
c
c
c 1.3 Set the symmetry check counters
c
c 1.3.1 Poloidal mesh counters
c
      kchic    = 0
      ichic    = 0
      kchie    = 0
      ichie    = 0
c      
      dchicm   = 0.0
      dchiem   = 0.0
c
c 1.3.2 Plasma surface quantity counters
c
      krsrf    = 0
      irsrf    = 0
      kzsrf    = 0
      izsrf    = 0
      kxjsc    = 0
      ixjsc    = 0
      kdydx    = 0
      idydx    = 0
c
      drsrfm   = 0.0
      dzsrfm   = 0.0
      dxjscm   = 0.0
      ddydxm   = 0.0
c
c
c 1.4 Initialization for symchek
c
      kermx     = nerprnt
      nsymetrc  = +1
      nantisym  = -1
      periodic  =  0.0
      nanglsym  = -1
c
c
c
c 2.0 Check for up down symmetry of poloidal quantities in the original mapping
c
      do 200 i = itsym,itht
      iv       = i
      li       = ithtp-iv
      le       = li+1
c
c
c 2.1 Check symmetry on the poloidal angle mesh
c     chie is displaced by 1 index and needs special attention
c
      chicli   = chic(li)
      chiciv   = chic(iv)
      chieli   = chie(le)
      chieiv   = chie(iv)
c
      chictt   = chiciv + chicli - chicmax
      chiett   = chieiv + chieli - chicmax
c
      if(abs(chictt) .ge. tolsymc) then
        kchic   = kchic + 1
        ichic   = iv
        if(abs(chictt) .ge. abs(dchicm)) dchicm  = chictt
      endif
      if(abs(chiett) .ge. tolsymc) then
        kchie   = kchie + 1
        ichie   = iv
        if(abs(chiett) .ge. abs(dchiem)) dchiem  = chiett
      endif
c
c
c 2.2 Check symmetry on the plasma surface quantities
c
      rsrfli   = rsrf(li)
      rsrfiv   = rsrf(iv)
      zsrfli   = zsrf(li)
      zsrfiv   = zsrf(iv)
      xjscli   = xjsc(li)
      xjsciv   = xjsc(iv)
      dydxli   = dydx(li)
      dydxiv   = dydx(iv)
c
      rsrftt   = rsrfiv - rsrfli
      zsrftt   = zsrfiv + zsrfli
      xjsctt   = xjsciv - xjscli
      dydxtt   = dydxiv + dydxli
c
      if(abs(rsrftt) .ge. tolsymr) then
        krsrf    = krsrf + 1
        irsrf    = iv
        if(abs(rsrftt) .ge. abs(drsrfm)) drsrfm  = rsrftt
      endif
      if(abs(zsrftt) .ge. tolsymr) then
        kzsrf    = kzsrf + 1
        izsrf    = iv
        if(abs(zsrftt) .ge. abs(dzsrfm)) dzsrfm  = zsrftt
      endif
      if(abs(xjsctt) .ge. tolsymp) then
        kxjsc    = kxjsc + 1
        ixjsc    = iv
        if(abs(xjsctt) .ge. abs(dxjscm)) dxjscm  = xjsctt
      endif
      if(abs(dydxtt) .ge. tolsymp) then
        kdydx    = kdydx + 1
        idydx    = iv
        if(abs(dydxtt) .ge. abs(ddydxm)) ddydxm  = dydxtt
      endif
 200  continue
c
c
c
c 3.0 Print warnings as needed
c
c 3.1 Poloidal coordinate mesh
c
c 3.1.1 Chi at the cell center
c
      if(kchic .ne. 0) then
        if    (kchic .eq. 1) then
          ichicp  = ithtp - ichic
          call abortjob
     &        ('symetry ',  1,   'Single   asymmetric chic value      '
     &        ,'ichic   ', ichic,    'ichicp  ', ichicp,    0)
          write(kuout,1000) ichic, chic(ichic )
     &                     ,ichicp,chic(ichicp),dchicm
        elseif(kchic .gt. 1) then
          call abortjob
     &        ('symetry ',  2,   'Multiple asymmetric chic values     '
     &        ,'kchic   ', kchic,    'ichic   ', ichic,    -1)
          write(kuout,1050) ithtp,itsym,dchicm
          write(kuout,1060)
          write(kuout,1070) (chic(ii),ii=1,ithtp)
        endif
      endif
c
c 3.1.2 Chi at the cell edge
c
      if(kchie .ne. 0) then
        if    (kchie .eq. 1) then
        ichiep  = ithtp - ichie + 1
          call abortjob
     &        ('symetry ',  3,   'Single   asymmetric chie value      '
     &        ,'ichie   ', ichie,    'ichiep  ', ichiep,    0)
          write(kuout,1100) ichie, chie(ichie )
     &                     ,ichiep,chie(ichiep),dchiem
        elseif(kchie .gt. 1) then
          call abortjob
     &        ('symetry ',  4,   'Multiple asymmetric chie values     '
     &        ,'kchie   ', kchie,    'ichie   ', ichie,    -1)
          write(kuout,1150) ithtp,itsym,dchiem
          write(kuout,1160)
          write(kuout,1170) (chie(ii),ii=1,ithtp)
        endif
      endif
c
c
c 3.2 Plasma surface quantities
c
c 3.2.1 Surface r coordinate
c
      if(krsrf .ne. 0) then
        if    (krsrf .eq. 1) then
          irsrfp  = ithtp - irsrf
          call abortjob
     &        ('symetry ',  5,   'Single   asymmetric rsrf value      '
     &        ,'irsrf   ', irsrf,    'irsrfp  ', irsrfp,    0)
          write(kuout,2000) irsrf, rsrf(irsrf )
     &                     ,irsrfp,rsrf(irsrfp),drsrfm
        elseif(krsrf .gt. 1) then
          call abortjob
     &        ('symetry ',  6,   'Multiple asymmetric rsrf values     '
     &        ,'krsrf   ', krsrf,    'irsrf   ', irsrf,    -1)
          write(kuout,2050) ithtp,itsym,drsrfm
          write(kuout,2060)
          write(kuout,2070) (rsrf(ii),ii=1,ithtp)
        endif
      endif
c
c 3.2.2 Surface z coordinate
c
      if(kzsrf .ne. 0) then
        if    (kzsrf .eq. 1) then
          izsrfp  = ithtp - izsrf
          call abortjob
     &        ('symetry ',  7,   'Single   asymmetric zsrf value      '
     &        ,'izsrf   ', izsrf,    'izsrfp  ', izsrfp,    0)
          write(kuout,2100) izsrf, zsrf(izsrf )
     &                     ,izsrfp,zsrf(izsrfp),dzsrfm
        elseif(kzsrf .gt. 1) then
          call abortjob
     &        ('symetry ',  8,   'Multiple asymmetric zsrf values     '
     &        ,'kzsrf   ', kzsrf,    'izsrf   ', izsrf,    -1)
          write(kuout,2150) ithtp,itsym,dzsrfm
          write(kuout,2160)
          write(kuout,2170) (zsrf(ii),ii=1,ithtp)
        endif
      endif
c
c 3.2.3 Surface Jacobian
c
      if(kxjsc .ne. 0) then
        if    (kxjsc .eq. 1) then
          ixjscp  = ithtp - ixjsc
          call abortjob
     &        ('symetry ',  9,   'Single   asymmetric xjsc value      '
     &        ,'ixjsc   ', ixjsc,    'ixjscp  ', ixjscp,    0)
          write(kuout,2200) ixjsc, xjsc(ixjsc )
     &                     ,ixjscp,xjsc(ixjscp),dxjscm
        elseif(kxjsc .gt. 1) then
          call abortjob
     &        ('symetry ', 10,   'Multiple asymmetric xjsc values     '
     &        ,'kxjsc   ', kxjsc,    'ixjsc   ', ixjsc,    -1)
          write(kuout,2250) ithtp,itsym,dxjscm
          write(kuout,2260)
          write(kuout,2270) (xjsc(ii),ii=1,ithtp)
        endif
      endif
c
c 3.2.4 Surface normal dy/dx
c
      if(kdydx .ne. 0) then
        if    (kdydx .eq. 1) then
          idydxp  = ithtp - idydx
          call abortjob
     &        ('symetry ', 11,   'Single   asymmetric dydx value      '
     &        ,'idydx   ', idydx,    'idydxp  ', idydxp,    0)
          write(kuout,2300) idydx, dydx(idydx )
     &                     ,idydxp,dydx(idydxp),ddydxm
        elseif(kdydx .gt. 1) then
          call abortjob
     &        ('symetry ', 12,   'Multiple asymmetric dydx values     '
     &        ,'kdydx   ', kdydx,    'idydx   ', idydx,    -1)
          write(kuout,2350) ithtp,itsym,ddydxm
          write(kuout,2360)
          write(kuout,2370) (dydx(ii),ii=1,ithtp)
        endif
      endif
c
c
c
c 4.0 Impose up down symmetry on the poloidal variables
c
      do 400 i = itsym,itht
      iv       = i
      li       = ithtp-iv
      le       = li+1
c
c
c 4.1 Impose symmetry on the poloidal angle mesh
c      chie is displaced by 1 index and needs special attention
c
c 4.1.1 Set the symmetric points
c
      chicli   = chic(li)
      chiciv   = chic(iv)
      chieli   = chie(le)
      chieiv   = chie(iv)
c
c 4.1.2 Enforce symmetry on the poloidal mesh
c
      chic(li) = chicli
      chic(iv) = chicmax - chicli
      chie(le) = chieli
      chie(iv) = chicmax - chieli
c
c
c 4.2 Impose symmetry on the plasma surface quantities
c
c 4.2.1 Set the symmetric points
c
      rsrfli   = rsrf(li)
      rsrfiv   = rsrf(iv)
      zsrfli   = zsrf(li)
      zsrfiv   = zsrf(iv)
      xjscli   = xjsc(li)
      xjsciv   = xjsc(iv)
      dydxli   = dydx(li)
      dydxiv   = dydx(iv)
c
c 4.2.2 Enforce symmetry on the surface quantities
c
      rsrf(li) = +rsrfli
      rsrf(iv) = +rsrfli
      zsrf(li) = +zsrfli
      zsrf(iv) = -zsrfli
      xjsc(li) = +xjscli
      xjsc(iv) = +xjscli
      dydx(li) = +dydxli
      dydx(iv) = -dydxli
  400 continue     
c
c
c
c 5.0 Check and enforce symmetry of the two dimensional equilibrium quantities
c
c 5.1 Mesh points
c
c 5.1.1 Mesh cell radial points
c
      call symchek(rcell,  np1,nc1,jpsi,itht,itsym,'rcell',
     &             nsymetrc,periodic,krcel,jrcel,ircel,drcelm,
     &             tolsymr,tolsymrp,kuout,kermx,kerr)
      if(kerr .ne. 0) then
        if(kerr .gt. 0) call abortjob
     &        ('symetry ', 13,   'symchek dimension error for rcell   '
     &        ,'kerr    ', kerr,     'krcel   ', krcel,    -1)
        if(kerr .lt. 0) call abortjob
     &        ('symetry ', 14,   'Symmetization error for rcell       '
     &        ,'kerr    ', kerr,     'krcel   ', krcel,     0)
      endif
c
c 5.1.2 Mesh cell axial points
c
      call symchek(zcell,  np1,nc1,jpsi,itht,itsym,'zcell',
     &             nantisym,periodic,kzcel,jzcel,izcel,dzcelm,
     &             tolsymr,tolsymrp,kuout,kermx,kerz)
      if(kerz .ne. 0) then
        if(kerz .gt. 0) call abortjob
     &        ('symetry ', 15,   'symchek dimension error for zcell   '
     &        ,'kerz    ', kerz,     'kzcel   ', kzcel,    -1)
        if(kerz .lt. 0) call abortjob
     &        ('symetry ', 16,   'Symmetization error for zcell       '
     &        ,'kerz    ', kerz,     'kzcel   ', kzcel,     0)
      endif
c
c
c 5.2 Poloidal flux gradients
c
      call symchek(dpsdr,  np1,nc1,jpsi,itht,itsym,'dpsdr',
     &             nsymetrc,periodic,kdpdr,jdpdr,idpdr,ddpdrm,
     &             tolsymf,tolsymfp,kuout,kermx,kerr)
      if(kerr .ne. 0) then
        if(kerr .gt. 0) call abortjob
     &        ('symetry ', 17,   'symchek dimension error for dpsdr   '
     &        ,'kerr    ', kerr,     'kdpdr   ', kdpdr,    -1)
        if(kerr .lt. 0) call abortjob
     &        ('symetry ', 18,   'Symmetization error for dpsdr       '
     &        ,'kerr    ', kerr,     'kdpdr   ', kdpdr,     0)
      endif
c
      call symchek(dpsdz,  np1,nc1,jpsi,itht,itsym,'dpsdz',
     &             nantisym,periodic,kdpdz,jdpdz,idpdz,ddpdzm,
     &             tolsymf,tolsymfp,kuout,kermx,kerz)
      if(kerz .ne. 0) then
        if(kerz .gt. 0) call abortjob
     &        ('symetry ', 19,   'symchek dimension error for dpsdz   '
     &        ,'kerz    ', kerz,     'kdpdz   ', kdpdz,    -1)
        if(kerz .lt. 0) call abortjob
     &        ('symetry ', 20,   'Symmetization error for dpsdz       '
     &        ,'kerz    ', kerz,     'kdpdz   ', kdpdz,     0)
      endif
c
c
c 5.3 Poloidal angle coordinates
c
c 5.3.1 Mesh cell arclength angle
c
      call symchek(chiarcl,np1,nc1,jpsi,itht,itsym,'chiarcl',
     &             nanglsym,charcmx, karcl,jarcl,iarcl,darclm,
     &             tolsymc,tolsymcp,kuout,kermx,kera)
      if(kera .ne. 0) then
        if(kera .gt. 0) call abortjob
     &        ('symetry ', 21,   'symchek dimension error for chiarcl '
     &        ,'kera    ', kera,     'karcl   ', karcl,    -1)
        if(kera .lt. 0) call abortjob
     &        ('symetry ', 22,   'Symmetization error for chiarcl     '
     &        ,'kera    ', kera,     'karcl   ', karcl,     0)
      endif
c
c 5.3.2 Mesh cell PEST angle
c
      call symchek(chipest,np1,nc1,jpsi,itht,itsym,'chipest',
     &             nanglsym,chpstmx, kpest,jpest,ipest,dpestm,
     &             tolsymc,tolsymcp,kuout,kermx,kerp)
      if(kerp .ne. 0) then
        if(kerp .gt. 0) call abortjob
     &        ('symetry ', 23,   'symchek dimension error for chipest '
     &        ,'kerp    ', kerp,     'kpest   ', kpest,    -1)
        if(kerp .lt. 0) call abortjob
     &        ('symetry ', 24,   'Symmetization error for chipest     '
     &        ,'kerp    ', kerp,     'kpest   ', kpest,     0)
      endif
c
c 5.3.3 Mesh cell Hamiltonian angle
c
      call symchek(chihaml,np1,nc1,jpsi,itht,itsym,'chihaml',
     &             nanglsym,chhammx, khaml,jhaml,ihaml,dhamlm,
     &             tolsymc,tolsymcp,kuout,kermx,kerh)
      if(kerh .ne. 0) then
        if(kerh .gt. 0) call abortjob
     &        ('symetry ', 25,   'symchek dimension error for chihaml '
     &        ,'kerh    ', kerh,     'khaml   ', khaml,    -1)
        if(kerh .lt. 0) call abortjob
     &        ('symetry ', 26,   'Symmetization error for chihaml     '
     &        ,'kerh    ', kerh,     'khaml   ', khaml,     0)
      endif
c
c
c 5.4 Jacobian and nonorthogonality
c
c 5.4.1 Jacobian
c
      call symchek(xjcarcl,np1,nc1,jpsi,itht,itsym,'xjcarcl',
     &             nsymetrc,periodic,kxjca,jxjca,ixjca,dxjcam,
     &             tolsymc,tolsymcp,kuout,kermx,kera)
      if(kera .ne. 0) then
        if(kera .gt. 0) call abortjob
     &        ('symetry ', 27,   'symchek dimension error for xjcarcl '
     &        ,'kera    ', kera,     'kxjca   ', kxjca,    -1)
        if(kera .lt. 0) call abortjob
     &        ('symetry ', 28,   'Symmetization error for xjcarcl     '
     &        ,'kera    ', kera,     'kxjca   ', kxjca,     0)
      endif
c
      call symchek(xjcpest,np1,nc1,jpsi,itht,itsym,'xjcpest',
     &             nsymetrc,periodic,kxjcp,jxjcp,ixjcp,dxjcpm,
     &             tolsymc,tolsymcp,kuout,kermx,kerp)
      if(kerp .ne. 0) then
        if(kerp .gt. 0) call abortjob
     &        ('symetry ', 29,   'symchek dimension error for xjcpest '
     &        ,'kerp    ', kerp,     'kxjcp   ', kxjcp,    -1)
        if(kerp .lt. 0) call abortjob
     &        ('symetry ', 30,   'Symmetization error for xjcpest     '
     &        ,'kerp    ', kerp,     'kxjcp   ', kxjcp,     0)
      endif
c
      call symchek(xjchaml,np1,nc1,jpsi,itht,itsym,'xjchaml',
     &             nsymetrc,periodic,kxjch,jxjch,ixjch,dxjchm,
     &             tolsymc,tolsymcp,kuout,kermx,kerh)
      if(kerh .ne. 0) then
        if(kerh .gt. 0) call abortjob
     &        ('symetry ', 31,   'symchek dimension error for xjchaml '
     &        ,'kerh    ', kerh,     'kxjch   ', kxjch,    -1)
        if(kerh .lt. 0) call abortjob
     &        ('symetry ', 32,   'Symmetization error for xjchaml     '
     &        ,'kerh    ', kerh,     'kxjch   ', kxjch,     0)
      endif
c
c 5.4.2 Non-orthognality
c
      call symchek(alfarcl,np1,nc1,jpsi,itht,itsym,'alfarcl',
     &             nantisym,periodic,kalfa,jalfa,ialfa,dalfam,
     &             tolsymd,tolsymdp,kuout,kermx,kera)
      if(kera .ne. 0) then
        if(kera .gt. 0) call abortjob
     &        ('symetry ', 33,   'symchek dimension error for alfarcl '
     &        ,'kera    ', kera,     'kalfa   ', kalfa,    -1)
        if(kera .lt. 0) call abortjob
     &        ('symetry ', 34,   'Symmetization error for xjcarcl     '
     &        ,'kera    ', kera,     'kxjca   ', kxjca,     0)
      endif
c
      call symchek(alfpest,np1,nc1,jpsi,itht,itsym,'alfpest',
     &             nantisym,periodic,kalfp,jalfp,ialfp,dalfpm,
     &             tolsymd,tolsymdp,kuout,kermx,kerp)
      if(kerp .ne. 0) then
        if(kerp .gt. 0) call abortjob
     &        ('symetry ', 35,   'symchek dimension error for alfpest '
     &        ,'kerp    ', kerp,     'kalfp   ', kalfp,    -1)
        if(kerp .lt. 0) call abortjob
     &        ('symetry ', 36,   'Symmetization error for alfpest     '
     &        ,'kerp    ', kerp,     'kalfp   ', kalfp,     0)
      endif
c
      call symchek(alfhaml,np1,nc1,jpsi,itht,itsym,'alfhaml',
     &             nantisym,periodic,kalfh,jalfh,ialfh,dalfhm,
     &             tolsymd,tolsymdp,kuout,kermx,kerh)
      if(kerh .ne. 0) then
        if(kerh .gt. 0) call abortjob
     &        ('symetry ', 37,   'symchek dimension error for alfhaml '
     &        ,'kerh    ', kerh,     'kalfh   ', kalfh,    -1)
        if(kerh .lt. 0) call abortjob
     &        ('symetry ', 38,   'Symmetization error for alfhaml     '
     &        ,'kerh    ', kerh,     'kalfh   ', kalfh,     0)
      endif
c
c
c 5.5 Equilibrium quantities
c
      call symchek(f3     ,np1,nc1,jpsi,itht,itsym,'f3',
     &             nsymetrc,periodic,kfq03,jfq03,ifq03,dfq03m,
     &             tolsymf,tolsymfp,kuout,kermx,ker03)
      if(ker03 .ne. 0) then
        if(ker03 .gt. 0) call abortjob
     &        ('symetry ', 39,   'symchek dimension error for f3      '
     &        ,'ker03   ', ker03,    'kfq03   ', kfq03,    -1)
        if(ker03  .lt. 0) call abortjob
     &        ('symetry ', 40,   'Symmetization error for f3          '
     &        ,'ker03   ', ker03,    'kfq03   ', kfq03,     0)
      endif
c
      call symchek(f4     ,np1,nc1,jpsi,itht,itsym,'f4',
     &             nsymetrc,periodic,kfq04,jfq04,ifq04,dfq04m,
     &             tolsymf,tolsymfp,kuout,kermx,ker04)
      if(ker04 .ne. 0) then
        if(ker04 .gt. 0) call abortjob
     &        ('symetry ', 41,   'symchek dimension error for f4      '
     &        ,'ker04   ', ker04,    'kfq04   ', kfq04,    -1)
        if(ker04 .lt. 0) call abortjob
     &        ('symetry ', 42,   'Symmetization error for f4          '
     &        ,'ker04   ', ker04,    'kfq04   ', kfq04,     0)
      endif
c
      call symchek(f5     ,np1,nc1,jpsi,itht,itsym,'f5',
     &             nsymetrc,periodic,kfq05,jfq05,ifq05,dfq05m,
     &             tolsymd,tolsymdp,kuout,kermx,ker05)
      if(ker05 .ne. 0) then
        if(ker05 .gt. 0) call abortjob
     &        ('symetry ', 43,   'symchek dimension error for f5      '
     &        ,'ker05   ', ker05,    'kfq05   ', kfq05,    -1)
        if(ker05 .lt. 0) call abortjob
     &        ('symetry ', 44,   'Symmetization error for f5          '
     &        ,'ker05   ', ker05,    'kfq05   ', kfq05,     0)
      endif
c
      call symchek(f7     ,np1,nc1,jpsi,itht,itsym,'f7',
     &             nsymetrc,periodic,kfq07,jfq07,ifq07,dfq07m,
     &             tolsymd,tolsymdp,kuout,kermx,ker07)
      if(ker07 .ne. 0) then
        if(ker07 .gt. 0) call abortjob
     &        ('symetry ', 45,   'symchek dimension error for f7      '
     &        ,'ker07   ', ker07,    'kfq07   ', kfq07,    -1)
        if(ker07 .lt. 0) call abortjob
     &        ('symetry ', 46,   'Symmetization error for f7          '
     &        ,'ker07   ', ker07,    'kfq07   ', kfq07,     0)
      endif
c
      call symchek(f8     ,np1,nc1,jpsi,itht,itsym,'f8',
     &             nsymetrc,periodic,kfq08,jfq08,ifq08,dfq08m,
     &             tolsymf,tolsymfp,kuout,kermx,ker08)
      if(ker08 .ne. 0) then
        if(ker08 .gt. 0) call abortjob
     &        ('symetry ', 47,   'symchek dimension error for f8      '
     &        ,'ker08   ', ker08,    'kfq08   ', kfq08,    -1)
        if(ker08 .lt. 0) call abortjob
     &        ('symetry ', 48,   'Symmetization error for f8          '
     &        ,'ker08   ', ker08,    'kfq08   ', kfq08,     0)
      endif
c
      call symchek(f9     ,np1,nc1,jpsi,itht,itsym,'f9',
     &             nsymetrc,periodic,kfq09,jfq09,ifq09,dfq09m,
     &             tolsymf,tolsymfp,kuout,kermx,ker09)
      if(ker09 .ne. 0) then
        if(ker09 .gt. 0) call abortjob
     &        ('symetry ', 49,   'symchek dimension error for f9      '
     &        ,'ker09   ', ker09,    'kfq09   ', kfq09,    -1)
        if(ker09 .lt. 0) call abortjob
     &        ('symetry ', 50,   'Symmetization error for f9          '
     &        ,'ker09   ', ker09,    'kfq09   ', kfq09,     0)
      endif
c
      call symchek(f10    ,np1,nc1,jpsi,itht,itsym,'f10',
     &             nsymetrc,periodic,kfq10,jfq10,ifq10,dfq10m,
     &             tolsymf,tolsymfp,kuout,kermx,ker10)
      if(ker10 .ne. 0) then
        if(ker10 .gt. 0) call abortjob
     &        ('symetry ', 51,   'symchek dimension error for f10     '
     &        ,'ker10   ', ker10,    'kfq10   ', kfq10,    -1)
        if(ker10 .lt. 0) call abortjob
     &        ('symetry ', 52,   'Symmetization error for f10         '
     &        ,'ker10   ', ker10,    'kfq10   ', kfq10,     0)
      endif
c
      call symchek(f11    ,np1,nc1,jpsi,itht,itsym,'f11',
     &             nsymetrc,periodic,kfq11,jfq11,ifq11,dfq11m,
     &             tolsymf,tolsymfp,kuout,kermx,ker11)
      if(ker11 .ne. 0) then
        if(ker11 .gt. 0) call abortjob
     &        ('symetry ', 53,   'symchek dimension error for f11     '
     &        ,'ker11   ', ker11,    'kfq11   ', kfq11,    -1)
        if(ker11 .lt. 0) call abortjob
     &        ('symetry ', 54,   'Symmetization error for f11         '
     &        ,'ker11   ', ker11,    'kfq11   ', kfq11,     0)
      endif
c
      call symchek(f12    ,np1,nc1,jpsi,itht,itsym,'f12',
     &             nsymetrc,periodic,kfq12,jfq12,ifq12,dfq12m,
     &             tolsymf,tolsymfp,kuout,kermx,ker12)
      if(ker12 .ne. 0) then
        if(ker12 .gt. 0) call abortjob
     &        ('symetry ', 55,   'symchek dimension error for f12     '
     &        ,'ker12   ', ker12,    'kfq12   ', kfq12,    -1)
        if(ker12 .lt. 0) call abortjob
     &        ('symetry ', 56,   'Symmetization error for f12         '
     &        ,'ker12   ', ker12,    'kfq12   ', kfq12,     0)
      endif
c
      call symchek(f13    ,np1,nc1,jpsi,itht,itsym,'f13',
     &             nsymetrc,periodic,kfq13,jfq13,ifq13,dfq13m,
     &             tolsymf,tolsymfp,kuout,kermx,ker13)
      if(ker13 .ne. 0) then
        if(ker13 .gt. 0) call abortjob
     &        ('symetry ', 57,   'symchek dimension error for f13     '
     &        ,'ker13   ', ker13,    'kfq13   ', kfq13,    -1)
        if(ker13 .lt. 0) call abortjob
     &        ('symetry ', 58,   'Symmetization error for f13         '
     &        ,'ker13   ', ker13,    'kfq13   ', kfq13,     0)
      endif
c
      call symchek(f14    ,np1,nc1,jpsi,itht,itsym,'f14',
     &             nsymetrc,periodic,kfq14,jfq14,ifq14,dfq14m,
     &             tolsymd,tolsymdp,kuout,kermx,ker14)
      if(ker14 .ne. 0) then
        if(ker14 .gt. 0) call abortjob
     &        ('symetry ', 59,   'symchek dimension error for f14     '
     &        ,'ker14   ', ker14,    'kfq14   ', kfq14,    -1)
        if(ker14 .lt. 0) call abortjob
     &        ('symetry ', 60,   'Symmetization error for f14         '
     &        ,'ker14   ', ker14,    'kfq14   ', kfq14,     0)
      endif
c
      call symchek(f15    ,np1,nc1,jpsi,itht,itsym,'f15',
     &             nantisym,periodic,kfq15,jfq15,ifq15,dfq15m,
     &             tolsymd,tolsymdp,kuout,kermx,ker15)
      if(ker15 .ne. 0) then
        if(ker15 .gt. 0) call abortjob
     &        ('symetry ', 61,   'symchek dimension error for f15     '
     &        ,'ker15   ', ker15,    'kfq15   ', kfq15,    -1)
        if(ker15 .lt. 0) call abortjob
     &        ('symetry ', 62,   'Symmetization error for f15         '
     &        ,'ker15   ', ker15,    'kfq15   ', kfq15,     0)
      endif
c
      call symchek(f16    ,np1,nc1,jpsi,itht,itsym,'f16',
     &             nsymetrc,periodic,kfq16,jfq16,ifq16,dfq16m,
     &             tolsymd,tolsymdp,kuout,kermx,ker16)
      if(ker16 .ne. 0) then
        if(ker16 .gt. 0) call abortjob
     &        ('symetry ', 63,   'symchek dimension error for f16     '
     &        ,'ker16   ', ker16,    'kfq16   ', kfq16,    -1)
        if(ker16 .lt. 0) call abortjob
     &        ('symetry ', 64,   'Symmetization error for f16         '
     &        ,'ker16   ', ker16,    'kfq16   ', kfq16,     0)
      endif
c
      call symchek(f17    ,np1,nc1,jpsi,itht,itsym,'f17',
     &             nantisym,periodic,kfq17,jfq17,ifq17,dfq17m,
     &             tolsymd,tolsymdp,kuout,kermx,ker17)
      if(ker17 .ne. 0) then
        if(ker17 .gt. 0) call abortjob
     &        ('symetry ', 65,   'symchek dimension error for f17     '
     &        ,'ker17   ', ker17,    'kfq17   ', kfq17,    -1)
        if(ker17 .lt. 0) call abortjob
     &        ('symetry ', 66,   'Symmetization error for f17         '
     &        ,'ker17   ', ker17,    'kfq17   ', kfq17,     0)
      endif
c
      call symchek(f18    ,np1,nc1,jpsi,itht,itsym,'f18',
     &             nsymetrc,periodic,kfq18,jfq18,ifq18,dfq18m,
     &             tolsymd,tolsymdp,kuout,kermx,ker18)
      if(ker18 .ne. 0) then
        if(ker18 .gt. 0) call abortjob
     &        ('symetry ', 67,   'symchek dimension error for f18     '
     &        ,'ker18   ', ker18,    'kfq18   ', kfq18,    -1)
        if(ker18 .lt. 0) call abortjob
     &        ('symetry ', 68,   'Symmetization error for f18         '
     &        ,'ker18   ', ker18,    'kfq18   ', kfq18,     0)
      endif
c
      call symchek(f19    ,np1,nc1,jpsi,itht,itsym,'f19',
     &             nsymetrc,periodic,kfq19,jfq19,ifq19,dfq19m,
     &             tolsymd,tolsymdp,kuout,kermx,ker19)
      if(ker19 .ne. 0) then
        if(ker19 .gt. 0) call abortjob
     &        ('symetry ', 69,   'symchek dimension error for f19     '
     &        ,'ker19   ', ker19,    'kfq19   ', kfq19,    -1)
        if(ker19 .lt. 0) call abortjob
     &        ('symetry ', 70,   'Symmetization error for f19         '
     &        ,'ker19   ', ker19,    'kfq19   ', kfq19,     0)
      endif
c
      call symchek(f20    ,np1,nc1,jpsi,itht,itsym,'f20',
     &             nantisym,periodic,kfq20,jfq20,ifq20,dfq20m,
     &             tolsymd,tolsymdp,kuout,kermx,ker20)
      if(ker20 .ne. 0) then
        if(ker20 .gt. 0) call abortjob
     &        ('symetry ', 71,   'symchek dimension error for f20     '
     &        ,'ker20   ', ker20,    'kfq20   ', kfq20,    -1)
        if(ker20 .lt. 0) call abortjob
     &        ('symetry ', 72,   'Symmetization error for f20         '
     &        ,'ker20   ', ker20,    'kfq20   ', kfq20,     0)
      endif
c
      call symchek(f21    ,np1,nc1,jpsi,itht,itsym,'f21',
     &             nsymetrc,periodic,kfq21,jfq21,ifq21,dfq21m,
     &             tolsymf,tolsymfp,kuout,kermx,ker21)
      if(ker21 .ne. 0) then
        if(ker21 .gt. 0) call abortjob
     &        ('symetry ', 73,   'symchek dimension error for f21     '
     &        ,'ker21   ', ker21,    'kfq21   ', kfq21,    -1)
        if(ker21 .lt. 0) call abortjob
     &        ('symetry ', 74,   'Symmetization error for f21         '
     &        ,'ker21   ', ker21,    'kfq21   ', kfq21,     0)
      endif
c
      call symchek(f22    ,np1,nc1,jpsi,itht,itsym,'f22',
     &             nantisym,periodic,kfq22,jfq22,ifq22,dfq22m,
     &             tolsymf,tolsymfp,kuout,kermx,ker22)
      if(ker22 .ne. 0) then
        if(ker22 .gt. 0) call abortjob
     &        ('symetry ', 75,   'symchek dimension error for f22     '
     &        ,'ker22   ', ker22,    'kfq22   ', kfq22,    -1)
        if(ker22 .lt. 0) call abortjob
     &        ('symetry ', 76,   'Symmetization error for f22         '
     &        ,'ker22   ', ker22,    'kfq22   ', kfq22,     0)
      endif
c
      call symchek(f23    ,np1,nc1,jpsi,itht,itsym,'f23',
     &             nsymetrc,periodic,kfq23,jfq23,ifq23,dfq23m,
     &             tolsyms,tolsymsp,kuout,kermx,ker23)
      if(ker23 .ne. 0) then
        if(ker23 .gt. 0) call abortjob
     &        ('symetry ', 77,   'symchek dimension error for f23     '
     &        ,'ker23   ', ker23,    'kfq23   ', kfq23,    -1)
        if(ker23 .lt. 0) call abortjob
     &        ('symetry ', 78,   'Symmetization error for f23         '
     &        ,'ker23   ', ker23,    'kfq23   ', kfq23,     0)
      endif
c
      call symchek(f24    ,np1,nc1,jpsi,itht,itsym,'f24',
     &             nsymetrc,periodic,kfq24,jfq24,ifq24,dfq24m,
     &             tolsyms,tolsymsp,kuout,kermx,ker24)
      if(ker24 .ne. 0) then
        if(ker24 .gt. 0) call abortjob
     &        ('symetry ', 79,   'symchek dimension error for f24     '
     &        ,'ker24   ', ker24,    'kfq24   ', kfq24,    -1)
        if(ker24 .lt. 0) call abortjob
     &        ('symetry ', 80,   'Symmetization error for f24         '
     &        ,'ker24   ', ker24,    'kfq24   ', kfq24,     0)
      endif
c
      call symchek(f25    ,np1,nc1,jpsi,itht,itsym,'f25',
     &             nantisym,periodic,kfq25,jfq25,ifq25,dfq25m,
     &             tolsymd,tolsymdp,kuout,kermx,ker25)
      if(ker25 .ne. 0) then
        if(ker25 .gt. 0) call abortjob
     &        ('symetry ', 81,   'symchek dimension error for f25     '
     &        ,'ker25   ', ker25,    'kfq25   ', kfq25,    -1)
        if(ker25 .lt. 0) call abortjob
     &        ('symetry ', 82,   'Symmetization error for f25         '
     &        ,'ker25   ', ker25,    'kfq25   ', kfq25,     0)
      endif
c
      call symchek(f26    ,np1,nc1,jpsi,itht,itsym,'f26',
     &             nantisym,periodic,kfq26,jfq26,ifq26,dfq26m,
     &             tolsymd,tolsymdp,kuout,kermx,ker26)
      if(ker26 .ne. 0) then
        if(ker26 .gt. 0) call abortjob
     &        ('symetry ', 83,   'symchek dimension error for f26     '
     &        ,'ker26   ', ker26,    'kfq26   ', kfq26,    -1)
        if(ker26 .lt. 0) call abortjob
     &        ('symetry ', 84,   'Symmetization error for f26         '
     &        ,'ker26   ', ker26,    'kfq26   ', kfq26,     0)
      endif
c
      call symchek(f27    ,np1,nc1,jpsi,itht,itsym,'f27',
     &             nsymetrc,periodic,kfq27,jfq27,ifq27,dfq27m,
     &             tolsymf,tolsymfp,kuout,kermx,ker27)
      if(ker27 .ne. 0) then
        if(ker27 .gt. 0) call abortjob
     &        ('symetry ', 85,   'symchek dimension error for f27     '
     &        ,'ker27   ', ker27,    'kfq27   ', kfq27,    -1)
        if(ker27 .lt. 0) call abortjob
     &        ('symetry ', 86,   'Symmetization error for f27         '
     &        ,'ker27   ', ker27,    'kfq27   ', kfq27,     0)
      endif
c
      call symchek(f28    ,np1,nc1,jpsi,itht,itsym,'f28',
     &             nantisym,periodic,kfq28,jfq28,ifq28,dfq28m,
     &             tolsymd,tolsymdp,kuout,kermx,ker28)
      if(ker28 .ne. 0) then
        if(ker28 .gt. 0) call abortjob
     &        ('symetry ', 87,   'symchek dimension error for f28     '
     &        ,'ker28   ', ker28,    'kfq28   ', kfq28,    -1)
        if(ker28 .lt. 0) call abortjob
     &        ('symetry ', 88,   'Symmetization error for f28         '
     &        ,'ker28   ', ker28,    'kfq28   ', kfq28,     0)
      endif
c
c
c
c 6.0 Return and end
c
      return
 1000 format(/,5x,'chic(',i5,') = ',e13.6,2x,'chic(',i5,') = ',e13.6
     &        ,4x,'dchic(max) = ',e13.6)
 1050 format(/,5x,'chic mesh: ithtp = ',i5,2x,'itsym = ',i5
     &        ,4x,'dchic(max) = ',e13.6)
 1060 format(/,5x,'chic array:')
 1070 format(10(1x,e13.6))
 1100 format(/,5x,'chie(',i5,') = ',e13.6,2x,'chie(',i5,') = ',e13.6
     &        ,4x,'dchie(max) = ',e13.6)
 1150 format(/,5x,'chie mesh: ithtp = ',i5,2x,'itsym = ',i5
     &        ,4x,'dchie(max) = ',e13.6)
 1160 format(/,5x,'chie array:')
 1170 format(10(1x,e13.6))
 2000 format(/,5x,'rsrf(',i5,') = ',e13.6,2x,'rsrf(',i5,') = ',e13.6
     &        ,4x,'drsrf(max) = ',e13.6)
 2050 format(/,5x,'rsrf mesh: ithtp = ',i5,2x,'itsym = ',i5
     &        ,4x,'drsrf(max) = ',e13.6)
 2060 format(/,5x,'rsrf array:')
 2070 format(10(1x,e13.6))
 2100 format(/,5x,'zsrf(',i5,') = ',e13.6,2x,'zsrf(',i5,') = ',e13.6
     &        ,4x,'dzsrf(max) = ',e13.6)
 2150 format(/,5x,'zsrf mesh: ithtp = ',i5,2x,'itsym = ',i5
     &        ,4x,'dzsrf(max) = ',e13.6)
 2160 format(/,5x,'zsrf array:')
 2170 format(10(1x,e13.6))
 2200 format(/,5x,'xjsc(',i5,') = ',e13.6,2x,'xjsc(',i5,') = ',e13.6
     &        ,4x,'dxjsc(max) = ',e13.6)
 2250 format(/,5x,'xjsc mesh: ithtp = ',i5,2x,'itsym = ',i5
     &        ,4x,'dxjsc(max) = ',e13.6)
 2260 format(/,5x,'xjsc array:')
 2270 format(10(1x,e13.6))
 2300 format(/,5x,'dydx(',i5,') = ',e13.6,2x,'dydx(',i5,') = ',e13.6
     &        ,4x,'ddydx(max) = ',e13.6)
 2350 format(/,5x,'dydx mesh: ithtp = ',i5,2x,'itsym = ',i5
     &        ,4x,'ddydx(max) = ',e13.6)
 2360 format(/,5x,'dydx array:')
 2370 format(10(1x,e13.6))
      end
      subroutine symchek(fnct,npd,ncd,jps,ith,itsym,fname,ksign,period
     &          ,kfnct,jfnct,ifnct,dfnctm,tolsym,tolsymp,kout,nerr,ker)
c
c ---------------------------------------------------------------
c
c Check and enforse up-down symmetry of a two dimensional array
c
c ---------------------------------------------------------------
c
      character*(*) fname
      character*36  string
c
      dimension fnct(npd,ncd)
c
c
c
c 1.0 Initialize parameters
c
      jps1     = jps + 1
      ithp     = ith + 1
c
      ker      = 0
      kfnct    = 0
      jfnct    = 0
      ifnct    = 0
      dfnctm   = 0.0
      kermax   = nerr
c
c
c 1.1 Check for input consistency
c
c 1.1.1 Check the dimensions
c
      if(npd .lt. jps1) then
        ker   = +1
        call abortjob
     &        ('symchek ',  1,   'First input array dimension invalid'
     &        ,'npd     ', npd,      'jps1    ', jps1,     -1)
        return
      endif
c
      if(ncd .lt. ithp) then
        ker   = -1
        call abortjob
     &        ('symchek ',  2,   'Second array dimension is invalid  '
     &        ,'ncd     ', ncd,      'ith1    ', ith1,     -1)
      endif

c
c 1.1.2 Check ksign and  period
c
      if(ksign .eq.  0) then
        ker  = +2
        call abortjob
     &        ('symchek ',  3,   'Symmetrization parameter is zero   '
     &        ,'jps     ', jps,      'ksign   ', ksign,    -1)
        return
      endif
c
      if(iabs(ksign) .ne.  +1) then
        ker  = -2
        call abortjob
     &        ('symchek ',  4,   'Invalid symmetrization parameter   '
     &        ,'jps     ', jps,      'ksign   ', ksign,    -1)
      endif
c
      if(period .ne. 0.0  .and.  ksign .ne. -1) then
        ker  = -3
        call abortjob
     &        ('symchek ',  5,   'ksign is inconsistent with period  '
     &        ,'jps     ', jps,      'ksign   ', ksign,    -1)
      endif
c
c
c
c 2.0 Check for up down symmetry
c
      do 200 i = itsym,ith
      iv       = i
      li       = ithp-iv
      le       = li+1
      do 100 j = 1,jps1
      jv       = j
      fnctli   = fnct  (jv,li)
      fnctiv   = fnct  (jv,iv)
      fncttt   = fnctiv - ksign*fnctli  - period
c
      if(abs(fncttt) .ge. tolsym) then
        kfnct    = kfnct + 1
        if(abs(fncttt) .ge. abs(dfnctm)) then
          jfnct    = jv
          ifnct    = iv
          dfnctm  = fncttt
        endif
      endif
  100 continue
  200 continue
c
c
c
c 3.0 Print warnings as needed
c
      if(kfnct .ne. 0) then
c
        ifnctp  = ithp - ifnct
c
        if    (kfnct .eq. 1) then
          write(string,1000) fname
c
          call abortjob
     &        ('symchek ',  6,   string
     &        ,'jfnct   ', jfnct,    'ifnct   ', ifnct,     0)
c
          write(kout,1010) ithp,itsym
          write(kout,1020) fname,jfnct,ifnct, fnct   (jfnct,ifnct ),
     &                     fname,jfnct,ifnctp,fnct   (jfnct,ifnctp),
     &                     dfnctm
        elseif(kfnct .gt. 1) then
          write(string,2000) fname
c
          call abortjob
     &        ('symchek ',  7,   string
     &        ,'kfnct   ', kfnct,    'jfnct   ', jfnct,    -1)
c
          write(kout,2010) fname,jfnct,ifnct,dfnctm
          write(kout,2020) fname,jfnct,ifnct, fnct   (jfnct,ifnct ),
     &                     fname,jfnct,ifnctp,fnct   (jfnct,ifnctp)
          write(kout,2030) fname,ithp,itsym,jps1
          if(kfnct .gt. kermax  .and.  abs(dfnctm) .ge. tolsymp) then
            do 250 jjp  = 1,jps1
            jj          = jjp
            write(kout,2040) jj
            write(kout,2050) (fnct   (jj,ii),ii=1,ithp)
  250       continue
          endif
        endif
      endif
c
c
c
c 4.0 Impose up down symmetry or antisymmetry
c
      do 400 i = itsym,ith
      iv       = i
      li       = ithp-iv
c
      do 300 j = 1,jps1
      jv       = j
c
c 4.3.1 Mesh points
c
c 4.3.1.1 Set the symmetric points
      fnctli   = fnct   (jv,li)
      fnctiv   = fnct   (jv,iv)
      fnct(jv,li) =        fnctli
      fnct(jv,iv) =  ksign*fnctli + period
  300 continue
  400 continue
c
c
c
c 5.0 Return and end
c
      return
 1000 format('Single   asymmetric ',a8,' value  ')
 1010 format(/,5x,'ithp = ',i5,2x,'itsym = ',i5)
 1020 format(  5x,a8,'(',i5,',',i5,') = ',e13.6
     &        ,4x,a8,'(',i5,',',i5,') = ',e13.6
     &        ,4x,'difference = ',e13.6)
 2000 format('Multiple asymmetric ',a8,' values ')
 2010 format(/,5x,'Maximum discrepancy at',1x,a8,'(',i5,',',i5,') = '
     &        ,e13.6)
 2020 format(  5x,a8,'(',i5,',',i5,') = ',e13.6
     &        ,4x,a8,'(',i5,',',i5,') = ',e13.6)
 2030 format(/,5x,a8,1x,'array: ithp = ',i5,2x,'itsym = ',i5
     &        ,2x,'jps1 = ',i5)
 2040 format(5x,'jjp  = ',i5)
 2050 format(10(1x,e13.6))
      end
      subroutine mshcomp
c
c -------------------------------------------------------------
c
c construct the auxiliary mesh data
c
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
      character*8   qlabel
      character*8   qvalue
      character*8   blnklab
c
      character*1   lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst ,lbchvl, lbchsv
      character*8   pclab,  tclab,  labpsi, 
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/labels/lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst, lbchvl, lbchsv,
     &              pclab,  tclab,  labpsi,
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      common/pldf/  x0min,x0max,y0min,y0max 
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
c
c
c 1.0 Initialize
c
      rndoff     = roundff
c
c
c
c 2.0 Set up the auxiliary flux meshes
c
c 2.1 Define psivl1, qp1, fqpi1, qprim1 and sintp0 to include the axis and
c     plasma surface values
c     psival, qp, and fqpi are in reverse order
c***************************************************************************
c     NOTE: qpaxis should be defined properly from limiting values of the flux
c     surface integral savge
c****************************************************************************
c
      fqaxis        = fqiaxe
      fqedge        = fqilim
      qpaxis        = qppaxe
      qpedge        = qprime(jpsi1)
      spaxis        = sntax0
      spedge        = sint0 (jpsi1)
      do 100 jp     = 1,jpsi
      jpv           = jp
      jpp           = jpsi - jp + 2
      psivl1(jpp)   = psival(jpv)
      qp1   (jpp)   = qp    (jpv)
      fqpi1 (jpp)   = fqpi  (jpv)
      qprim1(jpp)   = qprime(jpp-1)
      sintp0(jpp)   = sint0 (jpp-1)
  100 continue
c
      psivl1(  1  ) = psimax
      psivl1(jpsi2) = psilim
      qp1   (  1  ) = qaxe
      qp1   (jpsi2) = qlim
      fqpi1 (  1  ) = fqaxis
      fqpi1 (jpsi2) = fqedge
      qprim1(  1  ) = qpaxis
      qprim1(jpsi2) = qpedge
      sintp0(  1  ) = spaxis
      sintp0(jpsi2) = spedge
c
c
c
c 3.0 Define the psi values corresponding to rational q
c
c 3.1 Initialze psivlq qprimq and lpsiq at zero
c
      if(ntor .eq. 0) ntrat  = 1
      if(ntor .ne. 0) ntrat  = iabs(ntor)
      npqv         = npq
      blnklab      = 'no value'
      do 200  lq   = 1,npqv
      lpsiq  (lq)  = 0
      psivlq (lq)  = 0.0
      qprimq (lq)  = 0.0
      qvalue (lq)  = blnklab
  200 continue
c
c
c 3.2 Find the minimum and maximum of ntrat*q
c
c 3.2.1 Loop over mesh values
c
      qnmin     = ntrat*qp1(jpsi2)
      qnmax     = ntrat*qp1(jpsi2)
      jqmin     = 0
      jqmax     = jpsi2
      do 400 jp = 1,jpsi1
      jpp       = jp
      qpntor    = ntrat*qp1(jpp)
      if(qpntor .le. qnmin) then
         jqmin  = jpp
         qnmin  = qpntor
      endif
      if(qpntor .ge. qnmax) then
         jqmax  = jpp
         qnmax  = qpntor
      endif
  400 continue
c
c 3.2.2 Set the integer range of rational values
c
      lqmin   = ifix(qnmin)
      lqmax   = ifix(qnmax)
c
      qrndof  = qnmin*rndoff
      qxmin   = float(lqmin)
      if(abs(qxmin-qnmin) .le. qrndof) lqmin  = lqmin - 1
c
      lqtot   = lqmax - lqmin + 1
c
c 3.2.3 Set the minimum q by interpolation
c
c 3.2.3.1 Set to the endpoints if that is the minimum
      if    (jqmin .ge. jpsi2) then
         pminvl   =  psivl1(jpsi2)
         qminvl   =  qp1   (jpsi2)
         qpminv   =  qprim1(jpsi2)
      elseif(jqmin .le.   1  ) then
         pminvl   =  psivl1(  1  )
         qminvl   =  qp1   (  1  )
         qpminv   =  qprim1(  1  )
c
c 3.2.3.2 Compute the minimum from the quadratic interpolation
c         coefficients for qp1(psi)
      elseif(jqmin .gt.   1    .and.  jqmin .lt. jpsi2) then
         pmna     = psivl1(jqmin-1)
         pmnb     = psivl1( jqmin )
         pmnc     = psivl1(jqmin+1)
         qmna     = qp1   (jqmin-1)
         qmnb     = qp1   ( jqmin )
         qmnc     = qp1   (jqmin+1)
c
         call intcoef(pmna,pmnb,pmnc,qmna,qmnb,qmnc,amn,bmn,cmn,kermn)
         if(kermn .ne. 0) call abortjob
     &        ('mshcomp ',  1,   'Failed interpolation: minimum q     '
     &        ,'kermn   ', kermn,    'jqmin   ', jqmin,    -1)
c
         if    (abs(amn) .gt. qrndof) then
            pminvl   =      -0.50*bmn/amn
            qminvl   = cmn - 0.25*bmn*bmn/amn
         elseif(abs(amn) .le. qrndof) then
            call abortjob
     &        ('mshcomp ',  2,   'q profile minimum is at endpoint    '
     &        ,'kermn   ', kermn,    'jqmin   ', jqmin,    -1)
            if    (qmna .le. qmnc) then
               pminvl   = pmna
               qminvl   = qmna
            elseif(qmna .gt. qmnc) then
               pminvl   = pmnc
               qminvl   = qmnc
            endif
         endif
c
c 3.2.3.3 Compute the derivative of q at the minimum from the interpolation
c         coefficients as a check
         qpminv    = 2.0*amn*pminvl + bmn
      endif
c
c 3.2.4 Set the maximum q by interpolation
c
c 3.2.4.1 Set to the endpoints if that is the maximum
      if    (jqmax .ge. jpsi2) then
         pmaxvl   =  psivl1(jpsi2)
         qmaxvl   =  qp1   (jpsi2)
         qpmaxv   =  qprim1(jpsi2)
      elseif(jqmax .le.   1  ) then
         call abortjob
     &        ('mshcomp ',  3,   'q profile maximum is at the axis    '
     &        ,'jqmax   ', jqmax,    'jpsi2   ', jpsi2,    -1)
         pmaxvl   =  psivl1(  1  )
         qmaxvl   =  qp1   (  1  )
         qpmaxv   =  qprim1(  1  )
c
c 3.2.4.2 Compute the maximum from the quadratic interpolation
c         coefficients for qp1(psi)
c
      elseif(jqmax .gt.   1    .and.  jqmax .lt. jpsi2) then
         call abortjob
     &        ('mshcomp ',  4,   'q profile maximum not at psilim     '
     &        ,'jqmax   ', jqmax,    'jpsi2   ', jpsi2,    -1)
         pmxa     = psivl1(jqmax-1)
         pmxb     = psivl1( jqmax )
         pmxc     = psivl1(jqmax+1)
         qmxa     = qp1   (jqmax-1)
         qmxb     = qp1   ( jqmax )
         qmxc     = qp1   (jqmax+1)
c
         call intcoef(pmxa,pmxb,pmxc,qmxa,qmxb,qmxc,amx,bmx,cmx,kermx)
         if(kermx .ne. 0) call abortjob
     &        ('mshcomp ',  5,   'Failed interpolation: maximum q     '
     &        ,'kermx   ', kermx,    'jqmax   ', jqmax,    -1)
c
         if    (abs(amx) .gt. qrndof) then
            pmaxvl   =      -0.50*bmx/amx
            qmaxvl   = cmn - 0.25*bmx*bmx/amx
         elseif(abs(amx) .le. qrndof) then
            call abortjob
     &        ('mshcomp ',  6,   'q profile maximum is at endpoint    '
     &        ,'kermx   ', kermx,    'jqmax   ', jqmax,    -1)
            if    (qmxa .ge. qmxc) then
               pmaxvl   = pmxa
               qmaxvl   = qmxa
            elseif(qmxa .lt. qmxc) then
               pmaxvl   = pmxc
               qmaxvl   = qmxc
            endif
         endif
c
c 3.2.4.3 Compute the derivative of q at the maximum from the interpolation
c         coefficients as a check
         qpmaxv    = 2.0*amx*pmaxvl + bmx
c
c 3.2.4.4 Write out the interpolation data for the case where the maximimum is not
c         at the plasma boundary
         write(kuout,1000) pmxa,  pmxb,  pmxc,  qmxa,  qmxb,  qmxc,
     &                     amx,   bmx,   cmx,   pmaxvl,qmaxvl,qpmaxv
      endif
c
c
c 3.3 Set up psivlq and lpsiq by inverse interpolation to the
c     rational q values
c
      if(lqtot .gt. 0) then
c
c 3.3.1 Loop over flux intervals
c
         lqs       = 0
         do 450 jp = 1,jpsi1
         ppa       =    psivl1(jp)
         ppb       =    psivl1(jp+1)
         qqa       = ntrat*qp1(jp)
         qqb       = ntrat*qp1(jp+1)
c
c 3.3.2 Search for rational q between the jp and jp+1 surfaces
c
         do 420 lq = 1,lqtot
         lqrat     = lq + lqmin
         qrat      = float(lqrat)
         qda       = qqa - qrat
         qdb       = qqb - qrat
c
         if(qda*qdb .le. 0.0) then
            if(jp .eq.   1  ) jps  =  1
            if(jp .eq. jpsi1) jps  = jpsi
            if(jp .gt.   1  .and.  jp .lt. jpsi1) then
               if(abs(qda) .le. abs(qdb)) jps  = jp-1
               if(abs(qda) .gt. abs(qdb)) jps  = jp
            endif
c
c 3.3.3 Compute quadratic interpolation coefficients for qp1(psi)
c
            psa      =    psivl1( jps )
            psb      =    psivl1(jps+1)
            psc      =    psivl1(jps+2)
            qsa      = ntrat*qp1( jps ) - qrat
            qsb      = ntrat*qp1(jps+1) - qrat
            qsc      = ntrat*qp1(jps+2) - qrat
c
            call intcoef(psa, psb, psc, qsa, qsb, qsc, acf,bcf,ccf,ker1)
            if(ker1 .ne. 0) call abortjob
     &        ('mshcomp ',  7,   'Failed interpolation for q(psi)     '
     &        ,'ker1    ', ker1,     'jps     ', jps,      -1)
c
c 3.3.4 Inverse interpolation to find psivlq = psi(qrat)
c
            zdisc2   = bcf*bcf - 4.0*acf*ccf
            if(zdisc2 .lt. 0.0) call abortjob
     &        ('mshcomp ',  8,   'Vanishing discriminant in psi(q)    '
     &        ,'lqrat   ', lqrat,    'jps     ', jps,      -1)
c
            zdisc    = sqrt(zdisc2)
            pval1x   = -(bcf + zdisc)/(2.0*acf)
            pval2x   = -(bcf - zdisc)/(2.0*acf)
c
            pvalu1   = amin1(pval1x,pval2x)
            pvalu2   = amax1(pval1x,pval2x)
c
c 3.3.5 Define lpsiq and psivlq for the two possible roots for psi(qp1)
c
            if( (ppa-pvalu1)*(ppb-pvalu1) .le. 0.0)  then
               lqs          = lqs + 1
               lpsiq(lqs)   = lqrat
               psivlq (lqs) = pvalu1
            endif
            if(((ppa-pvalu2)*(ppb-pvalu2) .le. 0.0)  .and.
     &          (pvalu2 .ne. pvalu1)) then
               lqs          = lqs + 1
               lpsiq(lqs)   = lqrat
               psivlq (lqs) = pvalu2
            endif
         endif
c
c
c 3.3.6 End if the number of rational surfaces exceeds the dimension
c       Otherwise continue searching
         if(lqs .eq. npqv) go to 500
c
  420    continue
  450    continue
c
c
c 3.4 Set the number of rational surfaces to zero if there are
c     none in the range from qnmin to qnmax
c
      elseif(lqtot .eq. 0) then
         lqs     = 0
      endif
c
c
c 3.5 Define the final value of numbqs
c
c 3.5.1 Set numbqs
c
  500 numbqs  = lqs
c
c 3.5.2 Check numbqsdoes not exceed the dimensions
c
      if(numbqs .gt. npqv) then
         call abortjob
     &        ('mshcomp ',  9,   'numbqsexceeded the dimension npq    '
     &        ,'numbqs  ', numbqs,   'npqv    ', npqv,     -1)
         numbqs = npqv
      endif
c
c
c 3.6 Interpolate qprim1 to the rational q values
c
      if(numbqs .gt. 0) then
         do 550 lqp   = 1,numbqs
c
c 3.6.1 Set the psi value to be interpolated at
c
         lq           = lqp
         psvq         = psivlq(lq)
c
c 3.6.2 Loop over flux intervals to find nearest quadratic interval
c
            do 520 jp1 = 1,jpsi1
c
c 3.6.2.1 Set the interval
            pva        =    psivl1(jp1)
            pvb        =    psivl1(jp1+1)
            pda        =    pva - psvq
            pdb        =    pvb - psvq

c
c 3.6.2.2 Set the nearest grid point if in the interval
            if    ((pva-psvq)*(pvb-psvq) .lt. 0.0) then
               if(jp1 .eq.   1  ) jps  =  1
               if(jp1 .eq. jpsi1) jps  = jpsi
               if(jp1 .gt.   1  .and.  jp1 .lt. jpsi1) then
                  if(abs(pda) .le. abs(pdb)) jps  = jp1-1
                  if(abs(pda) .gt. abs(pdb)) jps  = jp1
               endif
c
               jponm   = 0
               go to 530
c
c 3.6.2.3 Set the grid point if on the grid value
            elseif((pva-psvq)*(pvb-psvq) .eq. 0.0) then
               if    (abs(pda) .eq. 0.0) then
                  jps     = jp1
                  jponm   = 1
                  go to 530
               elseif(abs(pdb) .eq. 0.0) then
                  if(jp1 .eq. jpsi1) then
                     jps     = jpsi2
                     jponm   = 1
                     go to 530
                  endif
               endif
            endif
 520        continue
c
c 3.6.3 Print an error if psivlq is not in any interval
c
         call abortjob
     &        ('mshcomp ', 10,   'psivlq is not in range of psivl1    '
     &        ,'numbqs  ', numbqs,   'lqp     ', lqp,      -1)
         jps     =  jpsi
         jponm   = -1
c
c 3.6.4 Set up the value for qprimq
c
 530     continue
c
c 3.6.4.1 Set qprimq if psivlq is on a grid point
         if    (jponm .eq. +1) then
            qprval   = qprim1(jps)
c
c 3.6.4.2 Forward interpolation to find qprimq = qprim1(psivlq)
         elseif(jponm .ne. +1) then
c
c 3.6.4.2.1 Set up the interpolation
            ppsa     =    psivl1( jps )
            ppsb     =    psivl1(jps+1)
            ppsc     =    psivl1(jps+2)
            qpsa     =    qprim1( jps )
            qpsb     =    qprim1(jps+1)
            qpsc     =    qprim1(jps+2)
c
c 3.6.4.2.2 Find the interpolation coefficients
            call intcoef(ppsa,ppsb,ppsc,qpsa,qpsb,qpsc,acp,bcp,ccp,ker2)
c
c 3.6.4.2.3 Print an error if interpolation failed
            if(ker2 .ne. 0) call abortjob
     &        ('mshcomp ', 11,   'Failed interpolation for qprime     '
     &        ,'ker2    ', ker2,     'jps     ', jps,      -1)
c
            qprval   = acp*psvq*psvq + bcp*psvq + ccp
         endif
c
c 3.6.4.3 Set qprimq
         qprimq(lq)  = qprval
 550     continue
      endif

c
c
c 3.7 Define the rational surface label
c
      if(numbqs .gt. 0) then
c
c 3.7.1 Loop over rational values
c
         do 600 lq  = 1,numbqs
c
c 3.7.2 Set up the rational value
c
         if(ntor .eq. 0) qrat  = float(lpsiq(lq))
         if(ntor .ne. 0) qrat  = float(lpsiq(lq))/float(ntor)
c
c 5.7.3 Set up the label
c
c 5.7.3.1 Use the full-label for small rationals
         if    (lpsiq(lq) .eq. lpsiq(1)) then
            if    (qrat .lt. 10.0) then
                write(qlabel,2000) qrat
            elseif(qrat .ge. 10.0) then
                write(qlabel,2010) qrat
            endif
c
c 5.7.3.2 Use the pure value for large rationals
         elseif(lpsiq(lq) .ne. lpsiq(1)) then
            if    (qrat .lt. 10.0) then
                write(qlabel,2100) qrat
            elseif(qrat .ge. 10.0) then
                write(qlabel,2110) qrat
            endif
         endif
c
c 5.7.4 Store the label in qvalue
c
         qvalue(lq)  = qlabel
  600    continue
      endif
c
c
c
c 6.0 Return and end
c
      return
 1000 format(10x,'Interpolation values from intcoef:'
     &     ,/,5x,'psi(jqmax-1) = ',e13.6,2x,'psi( jqmax ) = ',e13.6
     &       ,2x,'psi(jqmax+1) = ',e13.6
     &     ,/,5x,'q  (jqmax-1) = ',e13.6,2x,'q  ( jqmax ) = ',e13.6
     &       ,2x,'q  (jqmax+1) = ',e13.6
     &     ,/,5x,'amx          = ',e13.6,2x,'bmx          = ',e13.6
     &       ,2x,'cmx          = ',e13.6
     &     ,/,5x,'psi(max)     = ',e13.6,2x,'q(max)       = ',e13.6
     &       ,2x,'dq/dpsi(max) = ',e13.6)
 2000 format(1x,'q=',f4.2)
 2010 format('q=',f6.2)
 2100 format(1x,f4.2)
 2110 format(f6.2)
      end
      subroutine intcoef(pxa,pxb,pxc,pya,pyb,pyc,pca,pcb,pcc,ktest)
c
c -----------------------------------------------------------------------
c
c  compute quadratic interpolation coefficients for py(px)
c
c -----------------------------------------------------------------------
c
c
c
c 1.0 Return with error if the px are not ordered
c
      ktest  = 0
      if((pxa .eq. pxb) .or.  (pxa .eq. pxc) .or.
     &   (pxb .eq. pxc))                      ktest  = 1
c
      if((pxa .lt. pxb  .and.  pxb .gt. pxc)  .or.
     &   (pxa .gt. pxb  .and.  pxb .lt. pxc)) ktest  = 2
c
      if(ktest .ne. 0) then
         pca   = 0.0
         pcb   = 0.0
         pcc   = 0.0
         return
      endif
c
c
c
c 2.0 Compute the interpolation coefficients
c
      zd1    = (pya-pyb) / (pxa-pxb)
      zd2    = (pya-pyc) / (pxa-pxc)
      zd3    = (zd1-zd2) / (pxb-pxc)
c
      pca    = zd3
      pcb    = zd1  -   pca*(pxa + pxb)
      pcc    = pyb  -  (pca* pxb + pcb)*pxb
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine psicomp
c
c -------------------------------------------------------------
c
c construct the flux mesh values
c
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
      character*8   qvalue
c
      character*1   lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst ,lbchvl, lbchsv
      character*8   pclab,  tclab,  labpsi, 
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/labels/lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst, lbchvl, lbchsv,
     &              pclab,  tclab,  labpsi,
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      common/pldf/  x0min,x0max,y0min,y0max 
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c -------------------------------------------------------------
c
c
c
c 1.0 Initialization
c
c 1.1 Set parameters
c
      rndoff      = roundff
      tolqpr      = qptol
c
c
c 1.2 Set the flux surface labels
c
c 1.2.1 GATO poloidal flux mesh
c
      labpsi      = 'psi'
c
c 1.2.2 Poloidal flux mesh options
c

      labpsiv     = 'psi'
      labpsin     = 'norm psi'
      labsqtp     = 'sqrt psi'
      lbchpv      = 'P'
      lbchsp      = 'p'
c
c 1.2.3 Minor radius mesh options
c
      labrho2     = 'rho**2'
      labrhov     = 'rho'
      labrhon     = 'norm rho'
      labdrh2     = 'dp/drh2'
      labdrho     = 'dp/drho'
      lbchrh      = 'R'
      lbchro      = 'r'
c
c 1.2.4 Toroidal flux mesh options
c
      labtorf     = 'tor flux'
      labtorn     = 'norm flx'
      labsqtt     = 'sqrt flx'
      labdtor     = 'dp/dtorf'
      labdsqt     = 'dp/dsqtf'
      lbchtf      = 'T'
      lbchst      = 't'
c
c 1.2.5 Geometric volume mesh options
c
      labvolm     = 'volume'
      labvoln     = 'norm vol'
      labsqtv     = 'sqrt vol'
      labdvol     = 'dp/dvolm'
      labdsqv     = 'dp/dsqvl'
      lbchvl      = 'V'
      lbchsv      = 'v'
c
c
c 1.3 Initialize the loop data
c
c 1.3.1 Initialize endpoint and range data
c
      dpsiv          = (psilim - psimax)
      sintax         = sntax0
      sintlm         = sintp0(jpsi2)
      qpsm           = 0.5*(abs(qaxe)   + abs(qlim))
      vlsm           = 0.5*(abs(sintax) + abs(sintlm))
      if(sintax .le. 0.0) then
         call abortjob
     &        ('psicomp ',  1,   'sntax0 = sint0(axis) is nonpositive '
     &        ,'jpsi1   ', jpsi1,    'jpsi2   ', jpsi2,    -1)
         write(kuout,1000) sintax,qaxe,faxe
      endif
c
c 1.3.2 Initialize the partial integration sums
c
      torsum         = 0.0
      volsum         = 0.0
c
c
c 1.4 Write out the divertor case
c
      if(ndivert .eq. 0) then
        write(kutty,1100) ndivert
        write(kuout,1100) ndivert
      else
        write(kutty,1110) ndivert
        write(kuout,1100) ndivert
      endif
c
c
c
c 2.0 Set the unnormalized flux values corresponding to the node points
c
      do 100 jp      = 1,jpsi1
      jp0            = jp
      jp1            = jp + 1
c
c
c 2.1 Construct psivalu = poloidal flux in real units reset to zero at the axis
c
      psivalu( jp1)  = psivl1(jp1) - psimax
c
c
c 2.2 Construct psirho2 = square of the poloidal radius from the magnetic axis to
c               the plasma surface
c               psirho2 is taken as rho**2 across the outboard midplane
c
c 2.2.1 Set up the the three-point interploation in z for rho**2
c
      rval0          = rcell(jp0,itht) - xma
      zval0          = zcell(jp0,itht) - zma
      rval1          = rcell(jp0,  1 ) - xma
      zval1          = zcell(jp0,  1 ) - zma
      rval2          = rcell(jp0,  2 ) - xma
      zval2          = zcell(jp0,  2 ) - zma
c
      rhovl0         = (rval0*rval0 + zval0*zval0)
      rhovl1         = (rval1*rval1 + zval1*zval1)
      rhovl2         = (rval2*rval2 + zval2*zval2)
c
c 2.2.2 Interpolate rho**2(psi)
c
      call intcoef(zval0,zval1,zval2,rhovl0,rhovl1,rhovl2
     &                              ,cftrha,cftrhb,cftrhc,ker)
      if(ker .ne. 0) call abortjob
     &        ('psicomp ',  2,   'Failed interpolation for psirho2    '
     &        ,'ker     ', ker,      'jp0     ', jp0,      -1)
c
c 2.2.3 Set the value for rho**2
c
      psrho2         = cftrhc
      psirho2( jp1)  = psrho2
c
c
c 2.3 Construct psitorf = toroidal flux Phi by integrating dPhi/dpsi = q
c
c 2.3.1 Set the integration range
c
c 2.3.1.1 Set the three point values
      psip1       = psivl1( jp0 )
      psip2       = psivl1(jp0+1)
      dtdp1       = qp1   ( jp0 )
      dtdp2       = qp1   (jp0+1)
c
c 2.3.1.2 Save the midpoint value and integration increment
      dtdpsi         = dtdp2
      dpsivl         = psip2 - psip1
c
c 2.3.1.3 Print a warning if the integrand is negative
      if(dtdpsi .lt. 0.0) then
         call abortjob
     &        ('psicomp ',  3,   'Negative integrand dphi/dpsi = qp1  '
     &        ,'jp0     ', jp0,      'jpsi1   ', jpsi1,    -1)
         write(kuout,2000) dtdpsi,psip1,psip2,dtdp1,dtdp2
      endif
c
c 2.3.2 Set the interpolation ranges
c
c 2.3.2.1 Right side three point interpolation
      if    (jp0 .lt. jpsi1) then
         psif1a      = psivl1(  jp0 )
         psif2a      = psivl1(jp0+1)
         psif3a      = psivl1(jp0+2)
         dtdp1a      = qp1   ( jp0 )
         dtdp2a      = qp1   (jp0+1)
         dtdp3a      = qp1   (jp0+2)
      elseif(jp0 .eq. jpsi1) then
         psif1a      = psivl1(jpsi )
         psif2a      = psivl1(jpsi1)
         psif3a      = psivl1(jpsi2)
         dtdp1a      = qp1   (jpsi )
         dtdp2a      = qp1   (jpsi1)
         dtdp3a      = qp1   (jpsi2)
      endif
c
c 2.3.2.2 Left side three point interpolation
      if    (jp0 .lt.   2  ) then
         psif1b      = psimax
         psif2b      = psivl1(  2  )
         psif3b      = psivl1(  3  )
         dtdp1b      = qaxe
         dtdp2b      = qp1   (  2  )
         dtdp3b      = qp1   (  3  )
      elseif(jp0 .ge.   2  ) then
         psif1b      = psivl1(jp0-1)
         psif2b      = psivl1(jp0  )
         psif3b      = psivl1(jp0+1)
         dtdp1b      = qp1   (jp0-1)
         dtdp2b      = qp1   (jp0  )
         dtdp3b      = qp1   (jp0+1)
      endif
c
c 2.3.3 Compute the interpolation coefficients for the quadratic
c
c 2.3.3.1 Right side three point interpolation
      call intcoef(psif1a,psif2a,psif3a,dtdp1a,dtdp2a,dtdp3a
     &            ,ptf1a, ptf2a, ptf3a, kera)
c
      if(kera .ne. 0) call abortjob
     &        ('psicomp ',  4,   'Failed right interpolation in qp    '
     &        ,'kera    ', kera,     'jp0     ', jp0,      -1)
c
c 2.3.3.2 Left  side three point interpolation
      call intcoef(psif1b,psif2b,psif3b,dtdp1b,dtdp2b,dtdp3b
     &            ,ptf1b, ptf2b, ptf3b, kerb)
c
      if(kerb .ne. 0) call abortjob
     &        ('psicomp ',  5,   'Failed left  interpolation in qp    '
     &        ,'kerb    ', kerb,     'jp0     ', jp0,      -1)
c
c 2.3.4 Integrate up to jp0
c
c 2.3.4.1 Integrate using:
c             trapezoidal rule from jp0-1 to jp0
c             quadratic fit    from jp0-1 to jp0+1 (right side three point fit)  and
c             quadratic fit    from jp0-2 to jp0   (left  side three point fit)
c
      dpfacw         = (psip2*psip2 + psip2*psip1 + psip1*psip1)/3.0
      dpfacv         = (psip2       +       psip1)/2.0
c
      dpstor0        = (dtdp2 + dtdp1)/2.0
      dpstor1        =  ptf1a*dpfacw  +  ptf2a*dpfacv  +  ptf3a
      dpstor2        =  ptf1b*dpfacw  +  ptf2b*dpfacv  +  ptf3b
c
c 2.3.4.2 Store the combinations
      toradd0        =      dpstor0
      toradd1        =      dpstor1
      toradd2        =      dpstor2
      toraddq        = 0.50*(toradd1 + toradd2)
      toraddt        = 0.50*(toradd0 + toraddq)
      toradda        = 0.50*(toradd0 + toradd1)
      toraddb        = 0.50*(toradd0 + toradd2)
c
      tornorm        = 0.25*(2.0*abs(toradd0) + abs(toradd1)
     &                                        + abs(toradd2))
c
c 2.3.5 Check for discrepancies between integration schemes
c
c 2.3.5.1 Calculate the discrepancies
      tordf10        = dpstor1 - dpstor0
      tordf20        = dpstor2 - dpstor0
      tordf21        = dpstor2 - dpstor1
c
c 2.3.5.2 Check the three way discrepancies:  Note tordf20 = tordf21 - tordf10
c         Equality of the two quadratic integrations is a special case
c         occuring at jp0 = 1 and jp0 = jpsi1
      kselect        = -10
      kslct21        = -2
      kslct20        = -2
      kslct10        = -2
      toradd         = 0.0
      if(abs(tordf21) .le.  tolqpr*abs(tornorm)) kslct21  =  0
      if(abs(tordf21) .gt.  tolqpr*abs(tornorm)) kslct21  = +1
      if(abs(tordf21) .le.  rndoff*abs(tornorm)) kslct21  = -1
c
      if(abs(tordf20) .le.  tolqpr*abs(tornorm)) kslct20  =  0
      if(abs(tordf20) .gt.  tolqpr*abs(tornorm)) kslct20  = +1
      if(abs(tordf10) .le.  tolqpr*abs(tornorm)) kslct10  =  0
      if(abs(tordf10) .gt.  tolqpr*abs(tornorm)) kslct10  = +1
c
c 2.3.6 Set the integration contribution
c       Use the quadratic result if the result is trusted.
c       Otherwise only accept the quadratic results when they agree with
c       the trapezoidal result which is assumed to be stable
c
c 2.3.6.1 Set the integration contribution if there are no discrepancies
      if    (kslct21 .eq.  0  .and.  kslct20 .eq.  0
     &                        .and.  kslct10 .eq.  0) then
         kselect        =  0
         toradd         = toraddq
      elseif(kslct21 .eq. -1  .and.  kslct20 .eq.  0
     &                        .and.  kslct10 .eq.  0) then
         kselect        =  0

         toradd         = toraddq
c
c 2.3.6.2 Set the integration contribution if there is a discrepancy
c         between the quadratic and the trapezoidal integrations
      elseif(kslct21 .eq.  0  .and.  kslct20 .eq.  0
     &                        .and.  kslct10 .eq. +1) then
         kselect        = +1
         toradd         = toraddb
      elseif(kslct21 .eq.  0  .and.  kslct20 .eq. +1
     &                        .and.  kslct10 .eq.  0) then
         kselect        = +2
         toradd         = toradda
      elseif(kslct21 .eq.  0  .and.  kslct20 .eq. +1
     &                        .and.  kslct10 .eq. +1) then
         kselect        = +3
         toradd         = toradd0
c
c 2.3.6.3 Set the integration contribution if the quadratic integrations
c         are equal but differ from the trapezoidal integrations
      elseif(kslct21 .eq. -1  .and.  kslct20 .eq.  0
     &                        .and.  kslct10 .eq. +1) then
         kselect        = -1
         toradd         = toradd0
      elseif(kslct21 .eq. -1  .and.  kslct20 .eq. +1
     &                        .and.  kslct10 .eq.  0) then
         kselect        = -2
         toradd         = toradd0
      elseif(kslct21 .eq. -1  .and.  kslct20 .eq. +1
     &                        .and.  kslct10 .eq. +1) then
         kselect        = -3
         toradd         = toradd0
c
c 2.3.6.4 Set the integration contribution if there is a discrepancy
c         between the two quadratic integrations
      elseif(kslct21 .eq. +1  .and.  kslct20 .eq.  0
     &                        .and.  kslct10 .eq.  0) then
         kselect        = +4
         toradd         = toradd0
      elseif(kslct21 .eq. +1  .and.  kslct20 .eq.  0
     &                        .and.  kslct10 .eq. +1) then
         kselect        = +5
         toradd         = toraddb
      elseif(kslct21 .eq. +1  .and.  kslct20 .eq. +1
     &                        .and.  kslct10 .eq.  0) then
         kselect        = +6
         toradd         = toradda
c
c 2.3.6.5 Set the integration contribution if there is a discrepancy
c         between all integrations
      elseif(kslct21 .eq. +1  .and.  kslct20 .eq. +1
     &                        .and.  kslct10 .eq. +1) then
         kselect        = +7
         toradd         = toradd0
c
c 2.3.6.6 Set the integration contribution if there is a logic error
      else
         kselect        = -7
         toradd         = toradd0
      endif
c
c 2.3.7 Print a warning if there is a discrepancy
c
      if(kselect .ne. 0) then
         call abortjob
     &        ('psicomp ',  6,   'Integration discrepancy for psitorf '
     &        ,'kselect ', kselect,  'jp0     ', jp0,      -1)
         write(kuout,2010) psip2  ,dpstor0,dpstor1,dpstor2
     &                    ,tordf10,tordf20,tordf21
     &                    ,tolqpr, tornorm,toradd
     &                    ,toradd0,toradd1,toradd2
     &                    ,toraddq,toraddt,toradda,toraddb
     &                    ,dpfacw, dpfacv, dtdp1,  dtdp2
     &                    ,ptf1a,  ptf2a,  ptf3a
     &                    ,ptf1b,  ptf2b,  ptf3b
     &                    ,psif1a, psif2a, psif3a
     &                    ,dtdp1a, dtdp2a, dtdp3a
     &                    ,psif1b, psif2b, psif3b
     &                    ,dtdp1b, dtdp2b, dtdp3b
      endif
c
c 2.3.8 Compute alternative analytic calculation for the last increment
c       assuming a diverted edge with q(jpsi1) -> infinity
c
c 2.3.8.1 Save the quadrature estimate for the penultimate interval
      if(jp0 .eq. jpsi ) toradpn   = toradd
c
c 2.3.8.2 Set up the logarithmic fit to the two end intervals
      if(jp0 .eq. jpsi1) then
         psipn1      = psivl1(jp0-1)
         psipn       = psip1
         psip0       = psip2
         dtdpn1      = qp1   (jp0-1)
         dtdpn       = dtdp1
         dtdp0       = dtdp2
         delpn1      = psip0  - psipn1
         delpn       = psip0  - psipn
         delpnn1     = delpn1 - delpn
         dqval0      = dtdpn  - dtdpn1
         if    (abs(delpn) .ge. rndoff) then
            termv       = delpn1/delpn
         elseif(abs(delpn) .lt. rndoff) then
            termv       = delpn1/rndoff
            call abortjob
     &        ('psicomp ',  7,   'Log correction: psi(jp+1) = psi(jp) '
     &        ,'kselect ', kselect,  'jp0     ', jp0,      -1)
         endif
c
         if    (termv .le. 0.0) then
            dqval       = 0.0
            termlog     = 1.0
            call abortjob
     &        ('psicomp ',  8,   'Analytic log correction is invalid  '
     &        ,'kselect ', kselect,  'jp0     ', jp0,      -1)
         elseif(termv .gt. 0.0) then
            dqval       = dqval0
            termlog     = alog(termv)
         endif
c
c 2.3.8.3 Compute the analytic contribution for the penultimate interval
c         for comparison
         toranpn    = (dtdpn1*delpn1 - dtdpn*delpn) / delpnn1
     &                                              + dqval/termlog
         tordvpn    = toranpn - toradpn
c
c 2.3.8.4 Compute the analytic contribution for the end interval
         toranal    = dtdpn + dqval/termlog
         tordivr    = toranal - toradd
c
c 2.3.8.5 Replace the edge integrated flux by the analytic calculation if
c         the edge is diverted
         if(ndivert .ne. 0) then
            toradd  =  toranal
         endif
      endif
c
c 2.3.9 Set the value for psitorf and the derivative dpsi/dpsitorf
c
c 2.3.9.1 Set the values
      torsum         =       torsum  + toradd*dpsivl
      psitflx        =       torsum
      if(abs(dtdpsi) .gt. rndoff*qpsm) dpsitfx = 1.0/dtdpsi
      if(abs(dtdpsi) .le. rndoff*qpsm) dpsitfx = 1.0/(rndoff*qpsm)
c
c 2.3.9.2 Store the results for psitorf and its derivative with respect to psi
      psitorf( jp1)  =       psitflx
      dpsitor( jp1)  =       dpsitfx
c
c
c 2.4 Construct psivolm = volume contained within flux surface psi
c     by integrating dV/dpsi = sint0
c
c 2.4.1 Set the integration range
c
c 2.4.1.1 Set the three point values
      psip1          = psivl1(jp0  )
      psip2          = psivl1(jp0+1)
      dvdp1          = sintp0(jp0)
      dvdp2          = sintp0(jp0+1)
c
c 2.4.1.2 Save the midpoint value and integration increment
      dvdpsi         = dvdp2
      dpsivl         = psip2 - psip1
c
c
c 2.4.1.3 Print a warning if the integrand is negative
      if(dvdpsi .lt. 0.0) then
         call abortjob
     &        ('psicomp ',  9,   'Negative integrand dV/dpsi ~ sint0  '
     &        ,'jp0     ', jp0,      'jpsi1   ', jpsi1,    -1)
         write(kuout,2100) dvdpsi,psip1,psip2,dvdp1,dvdp2
      endif
c
c 2.4.2 Set the interpolation ranges
c
c 2.4.2.1 Right side three point interpolation
      if    (jp0 .lt. jpsi1) then
         psif1a      = psivl1(jp0  )
         psif2a      = psivl1(jp0+1)
         psif3a      = psivl1(jp0+2)
         dvdp1a      = sintp0(jp0  )
         dvdp2a      = sintp0(jp0+1)
         dvdp3a      = sintp0(jp0+2)
      elseif(jp0 .eq. jpsi1) then
         psif1a      = psivl1(jpsi )
         psif2a      = psivl1(jpsi1)
         psif3a      = psivl1(jpsi2)
         dvdp1a      = sintp0(jpsi )
         dvdp2a      = sintp0(jpsi1)
         dvdp3a      = sintp0(jpsi2)
      endif
c
c 2.4.2.2 Left side three point interpolation
      if    (jp0 .eq.   1  ) then
         psif1b      = psivl1(  1  )
         psif2b      = psivl1(  2  )
         psif3b      = psivl1(  3  )
         dvdp1b      = sintp0(  1  )
         dvdp2b      = sintp0(  2  )
         dvdp3b      = sintp0(  3  )
      elseif(jp0 .gt.   1  ) then
         psif1b      = psivl1(jp0-1)
         psif2b      = psivl1(jp0  )
         psif3b      = psivl1(jp0+1)
         dvdp1b      = sintp0(jp0-1)
         dvdp2b      = sintp0(jp0  )
         dvdp3b      = sintp0(jp0+1)
      endif
c
c 2.4.3 Compute the interpolation coefficients for the quadratic
c
c 2.4.3.1 Right side three point interpolation
      call intcoef(psif1a,psif2a,psif3a,dvdp1a,dvdp2a,dvdp3a
     &                              ,pvm1a, pvm2a, pvm3a, kera)
c
      if(kera .ne. 0) call abortjob
     &        ('psicomp ', 10,   'Failed right interpolation in s0    '
     &        ,'kera    ', kera,     'jp0     ', jp0,      -1)
c
c 2.4.3.2 Left  side three point interpolation
      call intcoef(psif1b,psif2b,psif3b,dvdp1b,dvdp2b,dvdp3b
     &                              ,pvm1b, pvm2b, pvm3b, kerb)
c
      if(kerb .ne. 0) call abortjob
     &        ('psicomp ', 11,   'Failed left  interpolation in s0    '
     &        ,'kerb    ', kerb,     'jp0     ', jp0,      -1)
c
c 2.4.4 Integrate up to jp0
c
c 2.4.4.1 Integrate using:
c             trapezoidal rule from jp0-1 to jp0
c             quadratic fit    from jp0-1 to jp0+1 (right side three point fit)  and
c             quadratic fit    from jp0-2 to jp0   (left  side three point fit)
c
      dpfacw         = (psip2*psip2 + psip2*psip1 + psip1*psip1)/3.0
      dpfacv         = (psip2       +       psip1)/2.0
c
      dpsvol0        = (dvdp2 + dvdp1)/2.0
      dpsvol1        =  pvm1a*dpfacw  +  pvm2a*dpfacv  +  pvm3a
      dpsvol2        =  pvm1b*dpfacw  +  pvm2b*dpfacv  +  pvm3b
c
c 2.4.4.2 Store the combinations
      voladd0        =      dpsvol0
      voladd1        =      dpsvol1
      voladd2        =      dpsvol2
      voladdq        = 0.50*(voladd1 + voladd2)
      voladdt        = 0.50*(voladd0 + voladdq)
      voladda        = 0.50*(voladd0 + voladd1)
      voladdb        = 0.50*(voladd0 + voladd2)
c
      volnorm        = 0.25*(2.0*abs(voladd0) + abs(voladd1)
     &                                        + abs(voladd2))
c
c 2.4.5 Check for discrepancies between integration schemes
c
c 2.4.5.1 Calculate the discrepancies
      voldf10        = dpsvol1 - dpsvol0
      voldf20        = dpsvol2 - dpsvol0
      voldf21        = dpsvol2 - dpsvol1
c
c 2.4.5.2 Check the three way discrepancies:  Note voldf20 = voldf21 - voldf10
c         Equality of the two quadratic integrations is a special case
c         occuring at jp0 = 1 and jp0 = jpsi1
      kselecv        =  10
      kslcv21        = -2
      kslcv20        = -2
      kslcv10        = -2
      voladd         = 0.0
      if(abs(voldf21) .le.  tolqpr*abs(volnorm)) kslcv21  =  0
      if(abs(voldf21) .gt.  tolqpr*abs(volnorm)) kslcv21  = +1
      if(abs(voldf21) .le.  rndoff*abs(volnorm)) kslcv21  = -1
c
      if(abs(voldf20) .le.  tolqpr*abs(volnorm)) kslcv20  =  0
      if(abs(voldf20) .gt.  tolqpr*abs(volnorm)) kslcv20  = +1
      if(abs(voldf10) .le.  tolqpr*abs(volnorm)) kslcv10  =  0
      if(abs(voldf10) .gt.  tolqpr*abs(volnorm)) kslcv10  = +1
c
c 2.4.6 Set the integration contribution
c       Use the quadratic result if the result is trusted.
c       Otherwise only accept the quadratic results when they agree with
c       the trapezoidal result which is assumed to be stable
c
c 2.4.6.1 Set the integration contribution if there are no discrepancies
      if    (kslcv21 .eq.  0  .and.  kslcv20 .eq.  0
     &                        .and.  kslcv10 .eq.  0) then
         kselecv        =  0
         voladd         = voladdq
      elseif(kslcv21 .eq. -1  .and.  kslcv20 .eq.  0
     &                        .and.  kslcv10 .eq.  0) then
         kselecv        =  0
         voladd         = voladdq
c
c 2.4.6.2 Set the integration contribution if there is a discrepancy
c         between the quadratic and the trapezoidal integrations
      elseif(kslcv21 .eq.  0  .and.  kslcv20 .eq.  0
     &                        .and.  kslcv10 .eq. +1) then
         kselecv        = +1
         voladd         = voladdb
      elseif(kslcv21 .eq.  0  .and.  kslcv20 .eq. +1
     &                        .and.  kslcv10 .eq.  0) then
         kselecv        = +2
         voladd         = voladda
      elseif(kslcv21 .eq.  0  .and.  kslcv20 .eq. +1
     &                        .and.  kslcv10 .eq. +1) then
         kselecv        = +3
         voladd         = voladd0
c
c 2.4.6.3 Set the integration contribution if the quadratic integrations
c         are equal but differ from the trapezoidal integrations
      elseif(kslcv21 .eq. -1  .and.  kslcv20 .eq.  0
     &                        .and.  kslcv10 .eq. +1) then
         kselecv        = -1
         voladd         = voladd0
      elseif(kslcv21 .eq. -1  .and.  kslcv20 .eq. +1
     &                        .and.  kslcv10 .eq.  0) then
         kselecv        = -2
         voladd         = voladd0
      elseif(kslcv21 .eq. -1  .and.  kslcv20 .eq. +1
     &                        .and.  kslcv10 .eq. +1) then
         kselecv        = -3
         voladd         = voladd0
c
c 2.4.6.4 Set the integration contribution if there is a discrepancy
c         between the two quadratic integrations
      elseif(kslcv21 .eq. +1  .and.  kslcv20 .eq.  0
     &                        .and.  kslcv10 .eq.  0) then
         kselecv        = +4
         voladd         = voladd0
      elseif(kslcv21 .eq. +1  .and.  kslcv20 .eq.  0
     &                        .and.  kslcv10 .eq. +1) then
         kselecv        = +5
         voladd         = voladdb
      elseif(kslcv21 .eq. +1  .and.  kslcv20 .eq. +1
     &                        .and.  kslcv10 .eq.  0) then
         kselecv        = +6
         voladd         = voladda
c
c 2.4.6.5 Set the integration contribution if there is a discrepancy
c         between all integrations
      elseif(kslcv21 .eq. +1  .and.  kslcv20 .eq. +1
     &                        .and.  kslcv10 .eq. +1) then
         kselecv        = +7
         voladd         = voladd0
c
c 2.4.6.6 Set the integration contribution if there is a logic error
      else
         kselecv        = -7
         voladd         = voladd0
      endif
c
c 2.4.7 Print a warning if there is a discrepancy
c
      if(kselecv .ne. 0) then
         call abortjob
     &        ('psicomp ', 12,   'Integration discrepancy for psivolm '
     &        ,'kselecv ', kselecv,  'jp0     ', jp0,      -1)

         write(kuout,2110) psip2  ,dpsvol0,dpsvol1,dpsvol2
     &                    ,voldf10,voldf20,voldf21
     &                    ,tolqpr, volnorm,voladd
     &                    ,voladd0,voladd1,voladd2
     &                    ,voladdq,voladdt,voladda,voladdb
     &                    ,dpfacw, dpfacv, dvdp1,  dvdp2
     &                    ,pvm1a,  pvm2a,  pvm3a
     &                    ,pvm1b,  pvm2b,  pvm3b
     &                    ,psif1a, psif2a, psif3a
     &                    ,dvdp1a, dvdp2a, dvdp3a
     &                    ,psif1b, psif2b, psif3b
     &                    ,dvdp1b, dvdp2b, dvdp3b
      endif
c
c 2.4.8 Compute alternative analytic calculation for the last increment
c       assuming a diverted edge with sint0(jpsi1) -> infinity
c
c 2.4.8.1 Save the quadrature estimate for the penultimate interval
      if(jp0 .eq. jpsi ) voladpn    = voladd
c
c 2.4.8.2 Set up the logarithmic fit to the two end intervals
      if(jp0 .eq. jpsi1) then
         psipn1      = psivl1(jp0-1)
         psipn       = psip1
         psip0       = psip2
         dvdpn1      = sintp0(jp0-1)
         dvdpn       = dvdp1
         dvdp0       = dvdp2
         delpn1      = psip0  - psipn1
         delpn       = psip0  - psipn
         delpnn1     = delpn1 - delpn
         dvval0      = dvdpn  - dvdpn1
         if    (abs(delpn) .ge. rndoff) then
            termv       = delpn1/delpn
         elseif(abs(delpn) .lt. rndoff) then
            termv       = delpn1/rndoff
            call abortjob
     &        ('psicomp ', 13,   'Volume correction: psi(jp+1)=psi(jp)'
     &        ,'kselecv ', kselecv,  'jp0     ', jp0,      -1)
         endif
c
         if    (termv .le. 0.0) then
            dvval       = 0.0
            termlog     = 1.0
            call abortjob
     &        ('psicomp ', 14,   'Analytic vol correction is invalid  '
     &        ,'kselecv ', kselecv,  'jp0     ', jp0,      -1)
         elseif(termv .gt. 0.0) then
            dvval       = dvval0
            termlog     = alog(termv)
         endif
c
c 2.4.8.3 Compute the analytic contribution for the penultimate interval
c         for comparison
         volanpn    = (dvdpn1*delpn1 - dvdpn*delpn) / delpnn1
     &                                              + dvval/termlog
         voldvpn    = volanpn - voladpn
c
c 2.4.8.4 Compute the analytic contribution for the end interval
         volanal    = dvdpn + dvval/termlog
         voldivr    = volanal - voladd
c
c 2.4.8.5 Replace the edge integrated volume by the analytic calculation if
c         the edge is diverted
         if(ndivert .ne. 0) then
            voladd  =  volanal
         endif
      endif
c
c 2.4.9 Set the value for psivolm and the derivative dpsi/dpsivolm
c
c 2.4.9.1 Set the values
      volsum         =       volsum  + voladd*dpsivl
      psivlvl        = twopi*volsum
      if(abs(dvdpsi) .gt. rndoff*vlsm) dpsivlv = 1.0/(twopi*dvdpsi)
      if(abs(dvdpsi) .le. rndoff*vlsm) dpsivlv = 1.0/(twopi*rndoff*vlsm)
c
c 2.4.9.2 Store the results for psivolm and its derivative with respect to psi
      psivolm( jp1)  = psivlvl
      dpsivol( jp1)  = dpsivlv
  100 continue
c
c
c 2.5 Set the normalization values
c
c 2.5.1 Set the value of rho**2 for the boundary
c
c 2.5.1.1 Set up the interpolation for the surface points
      rvsf0          = rsrf(    itht) - xma
      zvsf0          = zsrf(    itht) - zma
      rvsf1          = rsrf(      1 ) - xma
      zvsf1          = zsrf(      1 ) - zma
      rvsf2          = rsrf(      2 ) - xma
      zvsf2          = zsrf(      2 ) - zma
c
      rhosf0         = (rvsf0*rvsf0 + zvsf0*zvsf0)
      rhosf1         = (rvsf1*rvsf1 + zvsf1*zvsf1)
      rhosf2         = (rvsf2*rvsf2 + zvsf2*zvsf2)
c
c 2.5.1.2 Calculate the interpolation coeffecients from a three point
c         fit to rho**2(z) for the boundary
      call intcoef(zvsf0,zvsf1,zvsf2,rhosf0,rhosf1,rhosf2
     &                              ,cfsfa,cfsfb,cfsfc,kerb)
      if(kerb .ne. 0) call abortjob
     &        ('psicomp ', 15,   'Failed interpolation for rhosurf    '
     &        ,'kerb    ', kerb,     'jp0     ', jp0,      -1)
c
c 2.5.1.3 Check for discrepancies and set the value for rh2tot
      rh2bnd         = psirho2(jpsi2)
      rh2dif         =          rh2bnd  -     cfsfc
      rh2sum         = 0.5*(abs(rh2bnd) + abs(cfsfc))
c
      if(abs(rh2dif) .ge. rndoff*rh2sum) then
         call abortjob
     &        ('psicomp ', 16,   'Surface rho**2 value is incorrect   '
     &        ,'jpsi1   ', jpsi1,    'jpsi2   ', jpsi2,    -1)
         rh2norm   = rh2bnd
      else
         rh2norm   = cfsfc
      endif
c
c 2.5.1.4 Define rho at the boundary
      rh2tot     = rh2norm
      rhotot     = sqrt(rh2tot)
c
c 2.5.2 Set the total toroidal flux and total volume for normalization
c
c 2.5.2.1 Check the analytic contributions from the penultimate interval are
c         consistent with any divertor edge
      anltflxp       = toranpn
      dvrtflxp       = tordvpn
      anltvolp       = volanpn
      dvrtvolp       = voldvpn
      if(ndivert .ne. 0) then
         if(abs(dvrtflxp) .ge. tolqpr*abs(anltflxp)) then
            call abortjob
     &        ('psicomp ', 17,   'Inaccurate flux:   penultimate grid '
     &        ,'jpsi1   ', jpsi1,    'ndivert ', ndivert,  -1)
            write(kuout,2200) toranpn,tordvpn,toranal,tordivr   
         endif
c
         if(abs(dvrtvolp) .ge. tolqpr*abs(anltvolp)) then
            call abortjob
     &        ('psicomp ', 18,   'Inaccurate volume: penultimate grid '
     &        ,'jpsi1   ', jpsi1,    'ndivert ', ndivert,  -1)
            write(kuout,2210) volanpn,voldvpn,volanal,voldivr   
         endif
      endif
c
c 2.5.2.2 Save the analytic contributions from a possible divertor edge
      analtflx       = toranal
      divrtflx       = tordivr 
      analtvol       = volanal
      divrtvol       = voldivr 
c
c 2.5.2.3 Set the values from the total integration over flux
      flxtot         = psitorf(jpsi2)
      voltot         = psivolm(jpsi2)
c
c 2.5.2.4 Check for vanishing toroidal flux
      if(abs(flxtot) .le. rndoff) then
         call abortjob
     &        ('psicomp ', 19,   'Total Toroidal flux is zero         '
     &        ,'jpsi1   ', jpsi1,    'jpsi2   ', jpsi2,    -1)
         if(flxtot .ge. 0.0) flxtot  = +1.0
         if(flxtot .lt. 0.0) flxtot  = -1.0
      endif
c
c 2.5.2.5 Check for zero or negative volume
      if(   voltot   .le. rndoff) then
         call abortjob
     &        ('psicomp ', 20,   'Total volume is non positive        '
     &        ,'jpsi1   ', jpsi1,    'jpsi2   ', jpsi2,    -1)
         if(voltot .ge. 0.0) voltot  = +1.0
         if(voltot .lt. 0.0) voltot  = -1.0
      endif
c
c
c 2.6 Set the end values: The end values for jpsi2 are reset explicitly
c
c 2.6.1 Set psivalu
c
      psivalu(  1  ) = 0.0
      psivalu(jpsi2) = psilim - psimax
c
c 2.6.2 Set psirho2
c       The inverse derivative of psirho2 including endpoints is set after psirho2
c       is completed
      psirho2(  1  ) = 0.0
      psirho2(jpsi2) = rh2tot
c
c 2.6.3 Set psitorf and its inverse derivative dpsitor
c
      psitorf(  1  ) = 0.0
      psitorf(jpsi2) = flxtot
      if(abs(qaxe) .gt. rndoff*qpsm) dpsitor(  1  ) = 1.0/qaxe
      if(abs(qaxe) .le. rndoff*qpsm) dpsitor(  1  ) = 1.0/(rndoff*qpsm)
      if(abs(qlim) .gt. rndoff*qpsm) dpsitor(jpsi2) = 1.0/qlim
      if(abs(qlim) .le. rndoff*qpsm) dpsitor(jpsi2) = 1.0/(rndoff*qpsm)
c
c 2.6.4 Set psivolm and its inverse derivative dpsivol
c
      psivolm(  1  ) = 0.0
      psivolm(jpsi2) = voltot
      if(abs(sintax) .gt. rndoff*vlsm) dpsivol(  1  ) 
     &                                         = 1.0/(twopi*sintax)
      if(abs(sintax) .le. rndoff*vlsm) dpsivol(  1  )
     &                                         = 1.0/(twopi*rndoff*vlsm)
      if(abs(sintlm) .gt. rndoff*vlsm) dpsivol(jpsi2)
     &                                         = 1.0/(twopi*sintlm)
      if(abs(sintlm) .le. rndoff*vlsm) dpsivol(jpsi2)
     &                                         = 1.0/(twopi*rndoff*vlsm)
c
c
c 2.7 Find the derivative of psi(rho2)
c
c 2.7.1 Loop over the whole range and differentiate psi with respect to  psirho2
c
      do 200 jp      = 1,jpsi2
      jp1            = jp
c
c 2.7.2 Set the interpolation range
c
      if(jp1 .eq.   1  ) jp0  = 2
      if(jp1 .eq. jpsi2) jp0  = jpsi1
      if(jp1 .gt.   1    .and.  jp1 .lt. jpsi2) jp0  = jp1
      psir1         = psirho2(jp0-1)
      psir2         = psirho2( jp0 )
      psir3         = psirho2(jp0+1)
      psif1         = psivl1 (jp0-1)
      psif2         = psivl1 ( jp0 )
      psif3         = psivl1 (jp0+1)
c
c 2.7.3 Compute the interpolation coefficients
c
      call intcoef(psir1,psir2,psir3,psif1,psif2,psif3
     &                              ,pcf1, pcf2, pcf3, ker)
      if(ker .ne. 0) call abortjob
     &        ('psicomp ', 21,   'Failed interpolation in rh2(psi)    '
     &        ,'ker     ', ker,      'jp1     ', jp1,      -1)
c
c 2.7.4 Compute the derivative
c
      dpsvrh2        = 2.0*pcf1*psir2 + pcf2
      dpsirh2( jp1 ) = dpsvrh2
  200 continue
c
c
c
c 3.0 Set the alternative normalized flux labels corresponding to the node points
c
      do 300 jp      = 1,jpsi1
      jp0            = jp
      jp1            = jp + 1
c
c
c 3.1 Construct psinorm = normalized poloidal flux from psimax to psilim
c
      psnmvl         = (psivl1(jp1) - psimax)/dpsiv
c
      if(psnmvl   .lt.  0.0   ) then
         call abortjob
     &        ('psicomp ', 22,   'Normalized poloidal flux is negative'
     &        ,'jp0     ', jp0,      'jpsi1   ', jpsi1,    -1)
         psnmvl   = 0.0
      endif
c
      psinorm( jp1)  = psnmvl
c
c
c 3.2 Construct psisqrt = sqrt(normalized poloidal flux)
c
      psvlsq         = sqrt(psnmvl)
      psisqrt( jp1)  = psvlsq
c
c
c 3.3 Construct psirhov = sqrt(rho**2)
c
      psrh2v         =      psirho2(jp1)
      dpsrh2         =      dpsirh2(jp1)
c
      if(psrh2v   .lt.  0.0   ) then
         call abortjob
     &        ('psicomp ', 23,   'Squared poloidal radius is negative '
     &        ,'jp0     ', jp0,      'jpsi1   ', jpsi1,    -1)
         psrh2v   = 0.0
      endif
c
      psrhov         = sqrt(psrh2v)
      dpsrhv         =  2.0*dpsrh2*psrhov
c
      psirhov( jp1)  = psrhov
      dpsirho( jp1)  = dpsrhv
c
c
c 3.4 Construct psinrho = rho normalized to the boundary
c
      psnrhv         = psrhov/rhotot
      dpsnrv         = dpsrhv*rhotot
c
      psinrho( jp1)  = psnrhv
      dpsinrh( jp1)  = dpsnrv
c
c
c 3.5 Construct psintor = normalized toroidal flux
c
      psnflv         = psitorf(jp1)/flxtot
      dpsnfv         = dpsitor(jp1)*flxtot
c
      if(psnflv   .lt.  0.0   ) then
         call abortjob
     &        ('psicomp ', 24,   'Normalized toroidal flux is negative'
     &        ,'jp0     ', jp0,      'jpsi1   ', jpsi1,    -1)
         psnflv   = 0.0
      endif
c
      psintor(jp1)   = psnflv
      dpsintf(jp1)   = dpsnfv
c
c
c 3.6 Construct psisqtf = sqrt(psintor)
c
      pssqfv         = sqrt(psnflv)
      dpssfv         =  2.0*dpsnfv*pssqfv
c
      psisqtf( jp1)  = pssqfv
      dpsisqt(jp1)   = dpssfv
c
c
c 3.7 Construct psinvol = normalized volume contained within flux surface psi
c
      psnvlv         = psivolm(jp1)/voltot
      dpsvln         = dpsivol(jp1)*voltot
c
      if(psnvlv   .lt.  0.0   ) then
         call abortjob
     &        ('psicomp ', 25,   'Normalized volume is negative       '
     &        ,'jp0     ', jp0,      'jpsi1   ', jpsi1,    -1)
         psnvlv   = 0.0
      endif
c
      psinvol( jp1)  = psnvlv
      dpsinvl( jp1)  = dpsvln
c
c
c 3.8 Construct psisqvl = sqrt(normalized volume contained within flux surface psi)
c
      pssqvl         = sqrt(psnvlv)
      dpssvl         = 2.0*dpsvln*pssqvl
c
      psisqvl( jp1)  = pssqvl
      dpsisqv( jp1)  = dpssvl
  300 continue
c
c
c 3.6 Set the end values: The end values for jpsi2 are reset explicitly
c
c 3.6.1 Set psinorm
c
      psinorm(  1  ) = 0.0
      psinorm(jpsi2) = 1.0
c
c 3.6.2 Set psisqrt
c
      psisqrt(  1  ) = 0.0
      psisqrt(jpsi2) = 1.0
c
c 3.6.3 Set psirhov
c
      psirhov(  1  ) = sqrt(psirho2(  1  ))
      psirhov(jpsi2) = sqrt(psirho2(jpsi2))
      dpsirho(  1  ) = 2.0*dpsirh2(  1  )*psirhov(  1  )
      dpsirho(jpsi2) = 2.0*dpsirh2(jpsi2)*psirhov(jpsi2)
c
c 3.6.4 Set psinrho
c
      psinrho(  1  ) = 0.0
      psinrho(jpsi2) = 1.0
      dpsinrh(  1  ) = dpsirho(  1  )*rhotot
      dpsinrh(jpsi2) = dpsirho(jpsi2)*rhotot
c
c 3.6.5 Set psintor
c
      psintor(  1  ) = 0.0
      psintor(jpsi2) = 1.0
      dpsintf(  1  ) = dpsitor(  1  )*flxtot
      dpsintf(jpsi2) = dpsitor(jpsi2)*flxtot
c
c 3.6.6 Set psisqtf
c
      psisqtf(  1  ) = 0.0
      psisqtf(jpsi2) = 1.0
      dpsisqt(  1  ) = 2.0*dpsintf(  1  )*psisqtf(  1  )
      dpsisqt(jpsi2) = 2.0*dpsintf(jpsi2)*psisqtf(jpsi2)
c
c 3.6.7 Set psinvol
c
      psinvol(  1  ) = 0.0
      psinvol(jpsi2) = 1.0
      dpsinvl(  1  ) = dpsivol(  1  )*voltot
      dpsinvl(jpsi2) = dpsivol(jpsi2)*voltot
c
c 3.6.8 Set psisqvl
c
      psisqvl(  1  ) = 0.0
      psisqvl(jpsi2) = 1.0
      dpsisqv(  1  ) = 2.0*dpsinvl(  1  )*psisqvl(  1  )
      dpsisqv(jpsi2) = 2.0*dpsinvl(jpsi2)*psisqvl(jpsi2)
c
c
c
c 5.0 Check that the auxiliary meshes are properly ordered
c
c 5.1 Check ordering of poloidal flux mesh variables
c
c 5.1.1 Check that psivalu is properly ordered
c
c 5.1.1.1 Check the ordering
      kpvalu        = 0
      do 500 jp     = 1,jpsi1
      jpvl          = jp
      pvalu1        = psivalu( jpvl )
      pvalu2        = psivalu(jpvl+1)
      if((pvalu2-pvalu1) .le. 0.0) then
        kpvalu = kpvalu + 1
        call abortjob
     &        ('psicomp ', 26,   'psivalu is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpvalu  ', kpvalu,   -1)
      endif
  500 continue
c
c 5.1.1.2 Print the mesh if improperly ordered
      if(kpvalu .gt. 0) then
        write(kuout,3000) kpvalu
        write(kuout,3005) (psivalu(jj),jj=1,jpsi2)
      endif
c
c 5.1.2 Check that psinorm is properly ordered
c
c 5.1.2.1 Check the ordering
      kpnorm        = 0
      do 510 jp     = 1,jpsi1
      jpvl          = jp
      pnorm1        = psinorm( jpvl )
      pnorm2        = psinorm(jpvl+1)
      if((pnorm2-pnorm1) .le. 0.0) then
        kpnorm = kpnorm + 1
        call abortjob
     &        ('psicomp ', 27,   'psinorm is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpnorm  ', kpnorm,   -1)
      endif
  510 continue
c
c 5.1.2.2 Print the mesh if improperly ordered
      if(kpnorm .gt. 0) then
        write(kuout,3010) kpnorm
        write(kuout,3015) (psinorm(jj),jj=1,jpsi2)
      endif
c
c 5.1.3 Check that psisqrt is properly ordered
c
c 5.1.3.1 Check the ordering
      kpsqrt        = 0
      do 520 jp     = 1,jpsi1
      jpvl          = jp
      psqrt1        = psisqrt( jpvl )
      psqrt2        = psisqrt(jpvl+1)
      if((psqrt2-psqrt1) .le. 0.0) then
        kpsqrt = kpsqrt + 1
        call abortjob
     &        ('psicomp ', 28,   'psisqrt is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpsqrt  ', kpsqrt,   -1)
      endif
  520 continue
c
c 5.1.3.2 Print the mesh if improperly ordered
      if(kpsqrt .gt. 0) then
        write(kuout,3020) kpsqrt
        write(kuout,3025) (psisqrt(jj),jj=1,jpsi2)
      endif
c
c
c 5.2 Check ordering of poloidal flux mesh variables
c
c 5.2.1 Check that psirho2 is properly ordered
c
c 5.2.1.1 Check the ordering
      kprh2v        = 0
      do 530 jp     = 1,jpsi1
      jpvl          = jp
      prh2v1        = psirho2( jpvl )
      prh2v2        = psirho2(jpvl+1)
      if((prh2v2-prh2v1) .le. 0.0) then
        kprh2v = kprh2v + 1
        call abortjob
     &        ('psicomp ', 29,   'psirho2 is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kprh2v  ', kprh2v,   -1)
      endif
  530 continue
c
c 5.2.1.2 Print the mesh if improperly ordered
      if(kprh2v .gt. 0) then
        write(kuout,3100) kprh2v
        write(kuout,3105) (psirho2(jj),jj=1,jpsi2)
      endif
c
c 5.2.2 Check that psirhov is properly ordered
c
c 5.2.2.1 Check the ordering
      kprhov        = 0
      do 540 jp     = 1,jpsi1
      jpvl          = jp
      prhov1        = psirhov( jpvl )
      prhov2        = psirhov(jpvl+1)
      if((prhov2-prhov1) .le. 0.0) then
        kprhov = kprhov + 1
        call abortjob
     &        ('psicomp ', 30,   'psirhov is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kprhov  ', kprhov,   -1)
      endif
  540 continue
c
c 5.2.2.2 Print the mesh if improperly ordered
      if(kprhov .gt. 0) then
        write(kuout,3110) kprhov
        write(kuout,3115) (psirhov(jj),jj=1,jpsi2)
      endif
c
c 5.2.3 Check that psinrho is properly ordered
c
c 5.2.3.1 Check the ordering
      kpnrho        = 0
      do 550 jp     = 1,jpsi1
      jpvl          = jp
      pnrho1        = psinrho( jpvl )
      pnrho2        = psinrho(jpvl+1)
      if((pnrho2-pnrho1) .le. 0.0) then
        kpnrho = kpnrho + 1
        call abortjob
     &        ('psicomp ', 31,   'psinrho is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpnrho  ', kpnrho,   -1)
      endif
  550 continue
c
c 5.2.3.2 Print the mesh if improperly ordered
      if(kpnrho .gt. 0) then
        write(kuout,3120) kpnrho
        write(kuout,3125) (psinrho(jj),jj=1,jpsi2)
      endif
c
c
c 5.3 Check ordering of toroidal flux mesh variables
c
c 5.3.1 Check that psitorf is properly ordered
c
c 5.3.1.1 Check the ordering
      kptorf        = 0
      do 560 jp     = 1,jpsi1
      jpvl          = jp
      ptorf1        = psitorf( jpvl )
      ptorf2        = psitorf(jpvl+1)
      if((ptorf2-ptorf1) .le. 0.0) then
        kptorf = kptorf + 1
        call abortjob
     &        ('psicomp ', 32,   'psitorf is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kptorf  ', kptorf,   -1)
      endif
  560 continue
c
c 5.3.1.2 Print the mesh if improperly ordered
      if(kptorf .gt. 0) then
        write(kuout,3200) kptorf
        write(kuout,3205) (psitorf(jj),jj=1,jpsi2)
      endif
c
c 5.3.2 Check that psintor is properly ordered
c
c 5.3.2.1 Check the ordering
      kpntor        = 0
      do 570 jp     = 1,jpsi1
      jpvl          = jp
      pntor1        = psintor( jpvl )
      pntor2        = psintor(jpvl+1)
      if((pntor2-pntor1) .le. 0.0) then
        kpntor = kpntor + 1
        call abortjob
     &        ('psicomp ', 33,   'psintor is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpntor  ', kpntor,   -1)
      endif
  570 continue
c
c 5.3.2.2 Print the mesh if improperly ordered
      if(kpntor .gt. 0) then
        write(kuout,3210) kpntor
        write(kuout,3215) (psintor(jj),jj=1,jpsi2)
      endif
c
c 5.3.3 Check that psisqtf is properly ordered
c
c 5.3.3.1 Check the ordering
      kpsqtf        = 0
      do 580 jp     = 1,jpsi1
      jpvl          = jp
      psqtf1        = psisqtf( jpvl )
      psqtf2        = psisqtf(jpvl+1)
      if((psqtf2-psqtf1) .le. 0.0) then
        kpsqtf = kpsqtf + 1
        call abortjob
     &        ('psicomp ', 34,   'psisqtf is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpsqtf  ', kpsqtf,   -1)
      endif
  580 continue
c
c 5.3.3.2 Print the mesh if improperly ordered
      if(kpsqtf .gt. 0) then
        write(kuout,3220) kpsqtf
        write(kuout,3225) (psisqtf(jj),jj=1,jpsi2)
      endif
c
c
c 5.4 Check ordering of geometric volume mesh variables
c
c 5.4.1 Check that psivolm is properly ordered
c
c 5.4.1.1 Check the ordering
      kpvolm        = 0
      do 590 jp     = 1,jpsi1
      jpvl          = jp
      pvolm1        = psivolm( jpvl )
      pvolm2        = psivolm(jpvl+1)
      if((pvolm2-pvolm1) .le. 0.0) then
        kpvolm = kpvolm + 1
        call abortjob
     &        ('psicomp ', 35,   'psivolm is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpvolm  ', kpvolm,   -1)
      endif
  590 continue
c
c 5.4.1.2 Print the mesh if improperly ordered
      if(kpvolm .gt. 0) then
        write(kuout,3300) kpvolm
        write(kuout,3305) (psivolm(jj),jj=1,jpsi2)
      endif
c
c 5.4.2 Check that psinvol is properly ordered
c
c 5.4.2.1 Check the ordering
      kpnvol        = 0
      do 600 jp     = 1,jpsi1
      jpvl          = jp
      pnvol1        = psinvol( jpvl )
      pnvol2        = psinvol(jpvl+1)
      if((pnvol2-pnvol1) .le. 0.0) then
        kpnvol = kpnvol + 1
        call abortjob
     &        ('psicomp ', 36,   'psinvol is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpnvol  ', kpnvol,   -1)
      endif
  600 continue
c
c 5.4.2.2 Print the mesh if improperly ordered
      if(kpnvol .gt. 0) then
        write(kuout,3310) kpnvol
        write(kuout,3315) (psinvol(jj),jj=1,jpsi2)
      endif
c
c 5.4.3 Check that psisqvl is properly ordered
c
c 5.4.3.1 Check the ordering
      kpsqvl        = 0
      do 610 jp     = 1,jpsi1
      jpvl          = jp
      psqvl1        = psisqvl( jpvl )
      psqvl2        = psisqvl(jpvl+1)
      if((psqvl2-psqvl1) .le. 0.0) then
        kpsqvl = kpsqvl + 1
        call abortjob
     &        ('psicomp ', 37,   'psisqvl is improperly ordered       '
     &        ,'jpvl    ', jpvl,     'kpsqvl  ', kpsqvl,   -1)
      endif
  610 continue
c
c 5.4.3.2 Print the mesh if improperly ordered
      if(kpsqvl .gt. 0) then
        write(kuout,3320) kpsqvl
        write(kuout,3325) (psisqvl(jj),jj=1,jpsi2)
      endif
c
c
c
c 6.0 Set psivmsh for plotting profiles
c
c 6.1 Set the default label
c
      pclab       = labsqtv
c
c
c 6.2 Set the mesh
c
      do 700 jv  = 1,jpsi2
      psivmsh(jv) = psisqvl(jv)
  700 continue
c
c
c
c 7.0 Return and end
c
      return
 1000 format(   10x,'sintax   = ',e13.6,2x,'qaxe     = ',e13.6
     &          ,2x,'faxe     = ',e13.6,/)
 1100 format(//,10x,'Limiter  Equilibrium assumed: ndivert = ',i5
     &       ,/,10x,'-------  ----------- -------',/)
 1110 format(//,10x,'Divertor Equilibrium assumed: ndivert = ',i5
     &       ,/,10x,'-------- ----------- -------',/)
 2000 format(   10x,'dtdpsi   = ',e13.6
     &       ,/,10x,'psip1    = ',e13.6,2x,'psip2    = ',e13.6
     &          ,2x,'dtdp1    = ',e13.6,2x,'dtdp2    = ',e13.6,/)
 2010 format(   10x,'psip2    = ',e13.6
     &       ,/,10x,'dpstor0  = ',e13.6,2x,'dpstor1  = ',e13.6
     &          ,2x,'dpstor2  = ',e13.6
     &       ,/,10x,'tordf10  = ',e13.6,2x,'tordf20  = ',e13.6
     &          ,2x,'tordf21  = ',e13.6
     &       ,/,10x,'tolqpr   = ',e13.6,2x,'tornorm  = ',e13.6
     &          ,2x,'toradd   = ',e13.6
     &       ,/,10x,'toradd0  = ',e13.6,2x,'toradd1  = ',e13.6
     &          ,2x,'toradd2  = ',e13.6
     &       ,/,10x,'toraddq  = ',e13.6,2x,'toraddt  = ',e13.6
     &          ,2x,'toradda  = ',e13.6,2x,'toraddb  = ',e13.6
     &       ,/,10x,'dpfacw   = ',e13.6,2x,'dpfacv   = ',e13.6
     &          ,2x,'dtdp1    = ',e13.6,2x,'dtdp2    = ',e13.6
     &       ,/,10x,'ptf1a    = ',e13.6,2x,'ptf2a    = ',e13.6
     &          ,2x,'ptf3a    = ',e13.6
     &       ,/,10x,'ptf1b    = ',e13.6,2x,'ptf2b    = ',e13.6
     &          ,2x,'ptf3b    = ',e13.6
     &       ,/,10x,'psif1a   = ',e13.6,2x,'psif2a   = ',e13.6
     &          ,2x,'psif3a   = ',e13.6
     &       ,/,10x,'dtdp1a   = ',e13.6,2x,'dtdp2a   = ',e13.6
     &          ,2x,'dtdp3a   = ',e13.6
     &       ,/,10x,'psif1b   = ',e13.6,2x,'psif2b   = ',e13.6
     &          ,2x,'psif3b   = ',e13.6
     &       ,/,10x,'dtdp1b   = ',e13.6,2x,'dtdp2b   = ',e13.6
     &          ,2x,'dtdp3b   = ',e13.6,/)
 2100 format(   10x,'dvdpsi   = ',e13.6
     &       ,/,10x,'psip1    = ',e13.6,2x,'psip2    = ',e13.6
     &          ,2x,'dvdp1    = ',e13.6,2x,'dvdp2    = ',e13.6,/)
 2110 format(   10x,'psip2    = ',e13.6
     &       ,/,10x,'dpsvol0  = ',e13.6,2x,'dpsvol1  = ',e13.6
     &          ,2x,'dpsvol2  = ',e13.6
     &       ,/,10x,'voldf10  = ',e13.6,2x,'voldf20  = ',e13.6
     &          ,2x,'voldf21  = ',e13.6
     &       ,/,10x,'volqpl   = ',e13.6,2x,'volnorm  = ',e13.6
     &          ,2x,'voladd   = ',e13.6
     &       ,/,10x,'voladd0  = ',e13.6,2x,'voladd1  = ',e13.6
     &          ,2x,'voladd2  = ',e13.6
     &       ,/,10x,'voladdq  = ',e13.6,2x,'voladdt  = ',e13.6
     &          ,2x,'voladda  = ',e13.6,2x,'voladdb  = ',e13.6
     &       ,/,10x,'dpfacw   = ',e13.6,2x,'dpfacv   = ',e13.6
     &          ,2x,'dvdp1    = ',e13.6,2x,'dvdp2    = ',e13.6
     &       ,/,10x,'pvm1a    = ',e13.6,2x,'pvm2a    = ',e13.6
     &          ,2x,'pvm3a    = ',e13.6
     &       ,/,10x,'pvm1b    = ',e13.6,2x,'pvm2b    = ',e13.6
     &          ,2x,'pvm3b    = ',e13.6
     &       ,/,10x,'psif1a   = ',e13.6,2x,'psif2a   = ',e13.6
     &          ,2x,'psif3a   = ',e13.6
     &       ,/,10x,'dvdp1a   = ',e13.6,2x,'dvdp2a   = ',e13.6
     &          ,2x,'dvdp3a   = ',e13.6
     &       ,/,10x,'psif1b   = ',e13.6,2x,'psif2b   = ',e13.6
     &          ,2x,'psif3b   = ',e13.6
     &       ,/,10x,'dvdp1b   = ',e13.6,2x,'dvdp2b   = ',e13.6
     &          ,2x,'dvdp3b   = ',e13.6,/)
 2200 format(   10x,'toranpn  = ',e13.6,2x,'tordvpn  = ',e13.6
     &       ,/,10x,'toranal  = ',e13.6,2x,'tordivr  = ',e13.6,/)
 2210 format(   10x,'volanpn  = ',e13.6,2x,'voldvpn  = ',e13.6
     &       ,/,10x,'volanal  = ',e13.6,2x,'voldivr  = ',e13.6,/)
 3000 format(    1x,'psivalu array:',1x,i5,1x,'points are misordered')
 3005 format(10(1x,e12.5))
 3010 format(    1x,'psinorm array:',1x,i5,1x,'points are misordered')
 3015 format(10(1x,e12.5))
 3020 format(    1x,'psisqrt array:',1x,i5,1x,'points are misordered')
 3025 format(10(1x,e12.5))
 3100 format(    1x,'psirho2 array:',1x,i5,1x,'points are misordered')
 3105 format(10(1x,e12.5))
 3110 format(    1x,'psirhov array:',1x,i5,1x,'points are misordered')
 3115 format(10(1x,e12.5))
 3120 format(    1x,'psinrho array:',1x,i5,1x,'points are misordered')
 3125 format(10(1x,e12.5))
 3200 format(    1x,'psitorf array:',1x,i5,1x,'points are misordered')
 3205 format(10(1x,e12.5))
 3210 format(    1x,'psintor array:',1x,i5,1x,'points are misordered')
 3215 format(10(1x,e12.5))
 3220 format(    1x,'psisqtf array:',1x,i5,1x,'points are misordered')
 3225 format(10(1x,e12.5))
 3300 format(    1x,'psivolm array:',1x,i5,1x,'points are misordered')
 3305 format(10(1x,e12.5))
 3310 format(    1x,'psinvol array:',1x,i5,1x,'points are misordered')
 3315 format(10(1x,e12.5))
 3320 format(    1x,'psisqvl array:',1x,i5,1x,'points are misordered')
 3325 format(10(1x,e12.5))
      end
      subroutine ratcomp
c
c -------------------------------------------------------------
c
c construct the flux mesh values at rational surfaces
c
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
      character*8   qvalue
c
      character*1   lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst ,lbchvl, lbchsv
      character*8   pclab,  tclab,  labpsi, 
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/labels/lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst, lbchvl, lbchsv,
     &              pclab,  tclab,  labpsi,
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      common/pldf/  x0min,x0max,y0min,y0max 
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c -------------------------------------------------------------
c
c
c
c 1.0 Initialization
c
c 1.1 Set the counters
c
      lqcount    = 0
c
c
c 1.2 Set the constants
c
      tolqpr     = qptol
      rndoff     = roundff
      bignum     = bigno
      sheartol   = rndoff
c
c
c 1.3 Initialize the data
c
      dpsiv      = (psilim - psimax)
c
c
c 1.4 Define miscellaneous equilibrium parameters
c
c 1.4.1 Find the plasma surface extrema
c
      xmnp      = +bignum
      xmxp      = -bignum
      zmnp      = +bignum
      zmxp      = -bignum
      do 50  ip = 1,itht
      xmnp      = amin1(xmnp,rsrf(ip))
      xmxp      = amax1(xmxp,rsrf(ip))
      zmnp      = amin1(zmnp,zsrf(ip))
      zmxp      = amax1(zmxp,zsrf(ip))
   50 continue
c
c 1.4.2 Radial and Horizontal geometric centers
c
      rcentr   = 0.5*(xmxp + xmnp)
      zcentr   = 0.5*(zmxp + zmnp)
c
c 1.4.3 Radial and Horizontal geometric extent
c
      rminor   = 0.5*(xmxp - xmnp)
      zminor   = 0.5*(zmxp - zmnp)
c
c 1.4.4 Aspect ratio
c
      asprat00  = rminor/rcnt
      asprat01  = rminor/rcentr
c
      asprat10  = sqrt(rminor*zminor)/rcnt
      asprat11  = sqrt(rminor*zminor)/rcentr
c
c 1.4.5 Select the normalization for the shear at q = 1
c
      asnorm     = asprat01
c
c
c
c
c 2.0 Set the corresponding rational surface values from psivlq
c
      if(numbqs .gt. 0) then
c
c 2.1 Set the rational surface values for poloidal flux variables
c
c 2.1.1 Set the rational surface values for psivalu in psivalq
c
        do 100  lq     = 1,numbqs
        lqval          = lq
        psivalq(lqval) = psivlq(lqval) - psimax
  100   continue
c
c 2.1.2 Set the rational surface values for psinorm in psinrmq
c
        do 120  lq     = 1,numbqs
        lqval          = lq
        psvlnq         = (psivlq(lqval) - psimax)/dpsiv
        psinrmq(lqval) = psvlnq
  120   continue
c
c 2.1.3 Set the rational surface values for psisqrt in psisqrq
c
        do 130  lq     = 1,numbqs
        lqval          = lq
        psvlnq         = (psivlq(lqval) - psimax)/dpsiv
        if(psvlnq .lt. 0.0) then
           call abortjob
     &        ('ratcomp ',  1,   'psivlq is less than psimax          '
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   -1)
          psvlnq  = 0.0
        endif
        psisqrq(lqval) = sqrt(psvlnq)
  130  continue
c
c
c 2.2 Set the rational surface values for poloidal distance variables
c
c 2.2.1 Set the corresponding rational surface values for psirh2q
c
c 2.2.1.1 Loop over rational surfaces
        do 145 lq  = 1,numbqs
        lqval      = lq
        psvlq      = psivlq(lqval)
c
c 2.2.1.2 Search for the nearest point in psivl1
        jrt        = 1
        do 135  jp = 1,jpsi1
        psivv1     = psivl1 ( jp )  -  psvlq
        psivv2     = psivl1 (jp+1)  -  psvlq
        if(psivv1*psivv2 .le. 0.0) then
          if(abs(psivv1) .le. abs(psivv2)) jrt  = jp
          if(abs(psivv1) .gt. abs(psivv2)) jrt  = jp + 1
          go to 140
        endif
  135   continue
c
c 2.2.1.3 Terminate with an error if no nearest point found
        call abortjob
     &        ('ratcomp ',  2,   'Failed to find psi near rational q  '
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   +1)
c
c 2.2.1.4 Set the interpolation range
  140   if(jrt .eq.   1  ) jrt0  = 2
        if(jrt .eq. jpsi2) jrt0  = jpsi1
        if(jrt .gt.   1    .and.  jrt .lt. jpsi2) jrt0  = jrt
c
        psif1   = psivl1 (jrt0-1)
        psif2   = psivl1 ( jrt0 )
        psif3   = psivl1 (jrt0+1)
        psir1   = psirho2(jrt0-1)
        psir2   = psirho2( jrt0 )
        psir3   = psirho2(jrt0+1)
        psdr1   = dpsirh2(jrt0-1)
        psdr2   = dpsirh2( jrt0 )
        psdr3   = dpsirh2(jrt0+1)
c
c 2.2.1.5 Compute the interpolation coefficients for rho2(psi) and dpsi/drho2
c         at the rational q value
        call intcoef(psif1,psif2,psif3,psir1,psir2,psir3
     &                                ,pcf1, pcf2, pcf3, ker1)
c
        call intcoef(psif1,psif2,psif3,psdr1,psdr2,psdr3
     &                                ,pdf1, pdf2, pdf3, ker2)
c
        if(ker1 .ne. 0) call abortjob
     &        ('ratcomp ',  3,   'Failed interpolation for rho2(q)    '
     &        ,'ker1    ', ker1,     'jrt0    ', jrt0,     -1)
c
        if(ker2 .ne. 0) call abortjob
     &        ('ratcomp ',  4,   'Failed interpolation for drho2(q)   '
     &        ,'ker2    ', ker2,     'jrt0    ', jrt0,     -1)
c
c 2.2.1.6 Compute the interpolated value
        psvrhq    =     pcf1*psvlq*psvlq  +  pcf2*psvlq  +  pcf3
        psdrhq    =     pdf1*psvlq*psvlq  +  pdf2*psvlq  +  pdf3
        psdrhqp   = 1.0/(2.0*pcf1*psvlq   +  pcf2)
        psdnrm    = amax1((abs(psdrhqp) + abs(psdrhq)),rndoff)
        prhddif   = psdrhqp - psdrhq
c
c 2.2.1.7 Check for errors in interpolation
c
c 2.2.1.7.1 Check that the derivative is consistent with the polynomial fit
c           to rho**2
        if(abs(prhddif) .gt. tolqpr*psdnrm) then
           call abortjob
     &        ('ratcomp ',  5,   'dpsi/drho2(q) interpolation error   '
     &        ,'lqval   ', lqval,    'jrt0    ', jrt0,     -1)
           write(kuout,1000) jrt,  jrt0, psvlq,psvrhq, psdrhq
     &                      ,psdrhqp,prhddif,psif1,psif2,psif3
     &                      ,psir1,psir2,psir3,psdr1,psdr2,psdr3
     &                      ,pcf1, pcf2, pcf3, pdf1, pdf2, pdf3 
        endif
c
c 2.2.1.7.2 Check rh2(q) is in the range used by the interpolation: rho**2 should
c           be monotonic
        if((psvrhq-psir1)*(psvrhq-psir3) .gt. 0.0) then
           call abortjob
     &        ('ratcomp ',  6,   'Interpolated rho2(q) is out of range'
     &        ,'lqval   ', lqval,    'jrt0    ', jrt0,     -1)
           write(kuout,1010) psvlq,psir2,psir1,psvrhq,psir3
     &                      ,pcf1, pcf2, pcf3
        endif
c
c 2.2.1.8 Set the value of psirh2q
        psirh2q(lqval) = psvrhq
        dpsir2q(lqval) = psdrhq
  145   continue
c
c 2.2.2 Set the corresponding rational surface values for psirhov in psirhoq
c
        do 150  lq     = 1,numbqs
        lqval          = lq
        psrh2q         = psirh2q(lqval)
        dpsrh2q        = dpsir2q(lqval)
        if(psrh2q .lt. 0.0) then
           call abortjob
     &        ('ratcomp ',  7,   'psirh2q = rho**2(q) is negative     '
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   -1)
           psrh2q         = 0.0
        endif
c
        psrhoq         = sqrt(psrh2q)
        psirhoq(lqval) =      psrhoq
        dpsirhq(lqval) =  2.0*dpsrh2q*psrhoq
  150   continue
c
c 2.2.3 Set the corresponding rational surface values for psinrho in psinrhq
c
        do 160  lq     = 1,numbqs
        lqval          = lq
        psrhoq         = psirhoq(lqval)/rhotot
        dpsrhn         = dpsirhq(lqval)*rhotot
        psinrhq(lqval) = psrhoq
        dpsinrq(lqval) = dpsrhn
  160   continue
c
c
c 2.3 Set the rational surface values for toroidal flux variables
c
c 2.3.1 Set the corresponding rational surface values for psitorf
c
c 2.3.1.1 Loop over rational surfaces
        do 175 lq  = 1,numbqs
        lqval      = lq
        psvlq      = psivlq(lqval)
c
c 2.3.1.2 Search for the nearest point in psivl1
        do 165  jp = 1,jpsi1
        psivv1     = psivl1 ( jp )  -  psvlq
        psivv2     = psivl1 (jp+1)  -  psvlq
        if(psivv1*psivv2 .le. 0.0) then
          if(abs(psivv1) .le. abs(psivv2)) jrt  = jp
          if(abs(psivv1) .gt. abs(psivv2)) jrt  = jp + 1
          go to 170
        endif
  165   continue
c
c 2.3.1.3 Terminate with an error if no nearest point found
        call abortjob
     &        ('ratcomp ',  8,   'Failed to find psi near rational q  '
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   +1)
c
c 2.3.1.4 Set the interpolation range
  170   if(jrt .eq.   1  ) jrt0  = 2
        if(jrt .eq. jpsi2) jrt0  = jpsi1
        if(jrt .gt.   1    .and.  jrt .lt. jpsi2) jrt0  = jrt
c
        psif1      = psivl1 (jrt0-1)
        psif2      = psivl1 ( jrt0 )
        psif3      = psivl1 (jrt0+1)
        psit1      = psitorf(jrt0-1)
        psit2      = psitorf( jrt0 )
        psit3      = psitorf(jrt0+1)
        psdt1      = dpsitor(jrt0-1)
        psdt2      = dpsitor( jrt0 )
        psdt3      = dpsitor(jrt0+1)
c
c 2.3.1.5 Compute the interpolation coefficients for tor(psi) and dtor/dpsi
c         at the rational q value
        call intcoef(psif1,psif2,psif3,psit1,psit2,psit3
     &                                ,pct1, pct2, pct3, ker1)
c
        call intcoef(psif1,psif2,psif3,psdt1,psdt2,psdt3
     &                                ,pdt1, pdt2, pdt3, ker2)
c
        if(ker1 .ne. 0) call abortjob
     &        ('ratcomp ',  9,   'Failed interpolation for torf(q)    '
     &        ,'ker1    ', ker1,     'jrt0    ', jrt0,     -1)
        if(ker2 .ne. 0) call abortjob
     &        ('ratcomp ', 10,   'Failed interpolation for dtor(q)    '
     &        ,'ker2    ', ker2,     'jrt0    ', jrt0,     -1)
c
c 2.3.1.6 Compute the interpolated value
        pstorq     =     pct1*psvlq*psvlq  +  pct2*psvlq  +  pct3
        psdtfq     =     pdt1*psvlq*psvlq  +  pdt2*psvlq  +  pdt3
        psdtfqp    = 1.0/(2.0*pct1*psvlq   +  pct2)
        psdnrm     = amax1((abs(psdtfqp) + abs(psdtfq)),rndoff)
        ptfddif    = psdtfqp - psdtfq
c
c 2.3.1.7 Check for errors in interpolation
c
c 2.3.1.7.1 Check that the derivative is consistent with the polynomial fit
c         for torf
        if(abs(ptfddif) .gt. tolqpr*psdnrm) then
           call abortjob
     &        ('ratcomp ', 11,   'dtor/dpsi(q) interpolation error    '
     &        ,'lqval   ', lqval,    'jrt0    ', jrt0,     -1)
           write(kuout,1100) jrt,  jrt0, psvlq,pstorq, psdtfq
     &                      ,psdtfqp,ptfddif,psif1,psif2,psif3
     &                      ,psit1,psit2,psit3,psdt1,psdt2,psdt3
     &                      ,pct1, pct2, pct3, pdt1, pdt2, pdt3
        endif
c
c 2.3.1.7.2 Check the value is in the range used by the interpolation: torf should
c           be monotonic
        if((pstorq-psit1)*(pstorq-psit3) .gt. 0.0) then
           call abortjob
     &        ('ratcomp ', 12,   'Interpolated tor(q) is out of range '
     &        ,'lqval   ', lqval,    'jrt0    ', jrt0,     -1)
           write(kuout,1110) psvlq,psit2,psit1,pstorq,psit3
     &                      ,pct1, pct2, pct3
        endif
c
c 2.3.1.8 Set the value of psitorq
        psitorq(lqval) = pstorq
        dpsitfq(lqval) = psdtfq
  175   continue
c
c 2.3.2 Set the corresponding rational surface values for psintor in psintfq
c
        do 180  lq     = 1,numbqs
        lqval          = lq
        psintfq(lqval) = psitorq(lqval)/flxtot
        dpsintq(lqval) = dpsitfq(lqval)*flxtot
  180   continue
c
c 2.3.3 Set the corresponding rational surface values for psisqtf in psisqtq
c
        do 190  lq     = 1,numbqs
        lqval          = lq
        psntfq         = psintfq(lqval)
        dpstfn         = dpsintq(lqval)
        if(psntfq .lt. 0.0) then
           call abortjob
     &        ('ratcomp ', 13,   'Normalized toroidal flux is negative'
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   -1)
           psntfq         = 0.0
        endif
c
        pssqtv         = sqrt(psntfq)
        psisqtq(lqval) = pssqtv
        dpsistq(lqval) = 2.0*dpstfn*pssqtv
  190   continue
c
c
c 2.4 Set the rational surface values for geometric volume variables
c
c 2.4.1 Set the corresponding rational surface values for psivolm
c
c 2.4.1.1 Loop over rational surfaces
        do 215 lq      = 1,numbqs
        lqval          = lq
        psvlq          = psivlq(lqval)
c
c 2.4.1.2 Search for the nearest point in psivl1
        do 200  jp = 1,jpsi1
        psivv1     = psivl1 ( jp )  -  psvlq
        psivv2     = psivl1 (jp+1)  -  psvlq
        if(psivv1*psivv2 .le. 0.0) then
          if(abs(psivv1) .le. abs(psivv2)) jrt  = jp
          if(abs(psivv1) .gt. abs(psivv2)) jrt  = jp + 1
          go to 210
        endif
  200   continue
c
c 2.4.1.3 Terminate with an error if no nearest point found
        call abortjob
     &        ('ratcomp ', 14,   'Failed to find psi near rational q  '
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   +1)
c
c 2.4.1.4 Set the interpolation range
  210   if(jrt .eq.   1  ) jrt0  = 2
        if(jrt .eq. jpsi2) jrt0  = jpsi1
        if(jrt .gt.   1    .and.  jrt .lt. jpsi2) jrt0  = jrt
c
        psif1      = psivl1 (jrt0-1)
        psif2      = psivl1 ( jrt0 )
        psif3      = psivl1 (jrt0+1)
        psvl1      = psivolm(jrt0-1)
        psvl2      = psivolm( jrt0 )
        psvl3      = psivolm(jrt0+1)
        psdv1      = dpsivol(jrt0-1)
        psdv2      = dpsivol( jrt0 )
        psdv3      = dpsivol(jrt0+1)
c
c 2.4.1.5 Compute the interpolation coefficients for vol(psi) and dvol/dpsi
c         at the rational q value
        call intcoef(psif1,psif2,psif3,psvl1,psvl2,psvl3
     &                                ,pcv1, pcv2, pcv3, ker1)
c
        call intcoef(psif1,psif2,psif3,psdv1,psdv2,psdv3
     &                                ,pdv1, pdv2, pdv3, ker2)
c
        if(ker1 .ne. 0) call abortjob
     &        ('ratcomp ', 15,   'Failed interpolation for vol(q)     '
     &        ,'ker1    ', ker1,     'jrt0    ', jrt0,     -1)
        if(ker2 .ne. 0) call abortjob
     &        ('ratcomp ', 16,   'Failed interpolation for dvol(q)    '
     &        ,'ker2    ', ker2,     'jrt0    ', jrt0,     -1)
c
c 2.4.1.6 Compute the interpolated value
        psvolq     =     pcv1*psvlq*psvlq  +  pcv2*psvlq  +  pcv3
        psdvlq     =     pdv1*psvlq*psvlq  +  pdv2*psvlq  +  pdv3
        psdvlqp    = 1.0/(2.0*pcv1*psvlq   +  pcv2)
        psdnrm     = amax1((abs(psdvlqp) + abs(psdvlq)),rndoff)
        pvlddif    = psdvlqp - psdvlq
c
c 2.4.1.7 Check for errors in interpolation
c
c 2.4.1.7.1 Check that the derivative is consistent with the polynomial fit
c           to volm
        if(abs(pvlddif) .gt. tolqpr*psdnrm) then
           call abortjob
     &        ('ratcomp ', 17,   'dvol/dpsi(q) interpolation error    '
     &        ,'lqval   ', lqval,    'jrt0    ', jrt0,     -1)
           write(kuout,1200) jrt,  jrt0, psvlq,psvolq, psdvlq
     &                      ,psdvlqp,pvlddif,psif1,psif2,psif3
     &                      ,psvl1,psvl2,psvl3,psdv1,psdv2,psdv3
     &                      ,pcv1, pcv2, pcv3, pdv1, pdv2, pdv3
        endif
c
c 2.4.1.7.2 Check the value is in the range used by the interpolation: volm should
c           be monotonic
        if((psvolq-psvl1)*(psvolq-psvl3) .gt. 0.0) then
           call abortjob
     &        ('ratcomp ', 18,   'Interpolated vol(q) is out of range '
     &        ,'lqval   ', lqval,    'jrt0    ', jrt0,     -1)
           write(kuout,1210) psvlq,psvl2,psvl1,psvolq,psvl3
     &                      ,pcv1, pcv2, pcv3
        endif
c
c 2.4.1.8 Set the value of psivolq
        psivolq(lqval) = psvolq
        dpsivlq(lqval) = psdvlq
  215   continue
c
c 2.4.2 Set the corresponding rational surface values for psinvol in psinvlq
c
        do 220  lq     = 1,numbqs
        lqval          = lq
        psinvlq(lqval) = psivolq(lqval)/voltot
        dpsinvq(lqval) = dpsivlq(lqval)*voltot
  220   continue
c
c 2.4.3 Set the corresponding rational surface values for psisqvl in psisqvq
c
        do 230  lq     = 1,numbqs
        lqval          = lq
        psnvlq         = psinvlq(lqval)
        dpsvln         = dpsinvq(lqval)
        if(psnvlq .lt. 0.0) then
           call abortjob
     &        ('ratcomp ', 19,   'Normalized volume is negative       '
     &        ,'lqval   ', lqval,    'numbqs  ', numbqs,   -1)
           psnvlq         = 0.0
        endif
c
        pssqvv         = sqrt(psnvlq)
        psisqvq(lqval) =      pssqvv
        dpsisvq(lqval) =  2.0*dpsvln*pssqvv
  230   continue
      endif
c
c
c
c
c 3.0 Set the shear scale lengths at the rational surfaces
c     For poloidal flux this uses the flux from the magnetic axis
c     For poloidal radius this uses rho**2
c     For toroidal flux this uses the calculated toroidal flux from the
c     magnetic axis
c     For surface volume this uses the calculated volume from the
c     magnetic axis
c     The factor 2.0 then accounts for the fact that these variables are
c     like rho**2.  Thus, the shear lengths are with respect to the linear
c     rho-like coordinate in each case.
c
      if(numbqs .gt. 0) then
        do 300 lq        = 1,numbqs
        lqval            = lq
        dqval            = qprimq (lqval)
c
        psvalq           = psivalq(lqval)
        psvrhq           = psirh2q(lqval)
        psvtfq           = psitorq(lqval)
        psvvlq           = psivolq(lqval)
c
        psdrhq           = dpsir2q(lqval)
        psdtfq           = dpsitfq(lqval)
        psdvlq           = dpsivlq(lqval)
c
        shearps(lqval)   = 2.0*psvalq*dqval
        shearrh(lqval)   = 2.0*psvrhq*dqval*psdrhq
        sheartf(lqval)   = 2.0*psvtfq*dqval*psdtfq
        shearvl(lqval)   = 2.0*psvvlq*dqval*psdvlq
 300    continue
      endif
c
c
c
c 4.0 Set the radial values for the minimum and maximum of q
c
c 4.1 Search for the nearest point to the maximum and minimum q
c     in psivl1 and save the indices
c
c 4.1.1 Search over the grid
c
        pvlmn      = pminvl
        pvlmx      = pmaxvl
c
        kstmn      = 0
        kstmx      = 0
        jrtmn      = 1
        jrtmx      = 1
        do 400  jp = 1,jpsi1
        psmin1     = psivl1 ( jp )  -  pvlmn
        psmin2     = psivl1 (jp+1)  -  pvlmn
        psmax1     = psivl1 ( jp )  -  pvlmx
        psmax2     = psivl1 (jp+1)  -  pvlmx
        if(kstmn .eq. 0  .and.  psmin1*psmin2 .le. 0.0) then
          if(abs(psmin1) .le. abs(psmin2)) jrtmn  = jp
          if(abs(psmin1) .gt. abs(psmin2)) jrtmn  = jp + 1
        endif
        if(kstmx .eq. 0  .and.  psmax1*psmax2 .le. 0.0) then
          if(abs(psmax1) .le. abs(psmax2)) jrtmx  = jp
          if(abs(psmax1) .gt. abs(psmax2)) jrtmx  = jp + 1
        endif
  400   continue
c
c 4.1.2 Save the indices
c
        if(jrtmn .eq.   1  ) jrtmn0  = 2
        if(jrtmn .eq. jpsi2) jrtmn0  = jpsi1
        if(jrtmn .gt.   1  .and.  jrtmn .lt. jpsi2) jrtmn0  = jrtmn
c
        if(jrtmx .eq.   1  ) jrtmx0  = 2
        if(jrtmx .eq. jpsi2) jrtmx0  = jpsi1
        if(jrtmx .gt.   1  .and.  jrtmx .lt. jpsi2) jrtmx0  = jrtmx
c
c 4.1.3 Save the psivl1 values for interpolation
c
        psmnf1     = psivl1 (jrtmn0-1)
        psmnf2     = psivl1 ( jrtmn0 )
        psmnf3     = psivl1 (jrtmn0+1)
        psmxf1     = psivl1 (jrtmx0-1)
        psmxf2     = psivl1 ( jrtmx0 )
        psmxf3     = psivl1 (jrtmx0+1)
c
c
c 4.2 Set the values for poloidal flux variables
c
c 4.2.1 Values for psivalu
c
        psivlmnq   = pminvl - psimax
        psivlmxq   = pmaxvl - psimax
c
c 4.2.2 Values for psinorm
c
        psivnmnq   = (pminvl - psimax)/dpsiv
        psivnmxq   = (pmaxvl - psimax)/dpsiv

c
c 4.2.3 Values for psisqrt
c
        pvlnmn     = (pminvl - psimax)/dpsiv
        if(pvlnmn .lt. 0.0) then
           call abortjob
     &        ('ratcomp ', 20,   'pvlnmn is less than psimax          '
     &        ,'numbqs  ', numbqs,   'jpsi2   ', jpsi2,    -1)
          pvlnmn     = 0.0
        endif
c
        pvlnmx     = (pmaxvl - psimax)/dpsiv
        if(pvlnmx .lt. 0.0) then
           call abortjob
     &        ('ratcomp ', 21,   'pvlnmx is less than psimax          '
     &        ,'numbqs  ', numbqs,   'jpsi2   ', jpsi2,    -1)
          pvlnmx     = 0.0
        endif
c
        psisqmnq   = sqrt(pvlnmn)
        psisqmxq   = sqrt(pvlnmx)
c
c
c 4.3 Set the values for poloidal distance variables
c
c 4.3.1 Values for psirho2 from interpolation of psirho2(psivl1)
c
c 4.3.1.1 Compute the interpolation coefficients for rho2(psi)
c         and dpsi/drho2 at the maximum and minimum q value
        psmnr1     = psirho2(jrtmn0-1)
        psmnr2     = psirho2( jrtmn0 )
        psmnr3     = psirho2(jrtmn0+1)
        pmndr1     = dpsirh2(jrtmn0-1)
        pmndr2     = dpsirh2( jrtmn0 )
        pmndr3     = dpsirh2(jrtmn0+1)
c
        psmxr1     = psirho2(jrtmx0-1)
        psmxr2     = psirho2( jrtmx0 )
        psmxr3     = psirho2(jrtmx0+1)
        pmxdr1     = dpsirh2(jrtmx0-1)
        pmxdr2     = dpsirh2( jrtmx0 )
        pmxdr3     = dpsirh2(jrtmx0+1)
c
        call intcoef(psmnf1,psmnf2,psmnf3,psmnr1,psmnr2,psmnr3
     &                                   ,pcmnf1,pcmnf2,pcmnf3,kermn1)
c
        call intcoef(psmnf1,psmnf2,psmnf3,pmndr1,pmndr2,pmndr3
     &                                   ,pdmnf1,pdmnf2,pdmnf3,kermn2)
c
        call intcoef(psmxf1,psmxf2,psmxf3,psmxr1,psmxr2,psmxr3
     &                                   ,pcmxf1,pcmxf2,pcmxf3,kermx1)
c
        call intcoef(psmxf1,psmxf2,psmxf3,pmxdr1,pmxdr2,pmxdr3
     &                                   ,pdmxf1,pdmxf2,pdmxf3,kermx2)
c
c 4.3.1.2 Check for interpolation errors
        if(kermn1 .ne. 0) call abortjob
     &        ('ratcomp ', 22,   'Failed interpolation: rho2(qmin)    '
     &        ,'kermn1  ', kermn1,   'jrtmn0  ', jrtmn0,   -1)
        if(kermn2 .ne. 0) call abortjob
     &        ('ratcomp ', 23,   'Failed interpolation: drho2(qmin)   '
     &        ,'kermn2  ', kermn2,   'jrtmn0  ', jrtmn0,   -1)
        if(kermx1 .ne. 0) call abortjob
     &        ('ratcomp ', 24,   'Failed interpolation: rho2(qmax)    '
     &        ,'kermx1  ', kermx1,   'jrtmx0  ', jrtmx0,   -1)
        if(kermx2 .ne. 0) call abortjob
     &        ('ratcomp ', 25,   'Failed interpolation: drho2(qmax)   '
     &        ,'kermx2  ', kermx2,   'jrtmx0  ', jrtmx0,   -1)
c
c 4.3.1.3 Compute the interpolated values
        pvrhmn     =     pcmnf1*pvlmn*pvlmn  +  pcmnf2*pvlmn  +
     &                                          pcmnf3
        pdrhmn     =     pdmnf1*pvlmn*pvlmn  +  pdmnf2*pvlmn  +
     &                                          pdmnf3
        pdrhqpmn   = 1.0/(2.0*pcmnf1*pvlmn   +  pcmnf2)
        pdnrmmn    = amax1((abs(pdrhqpmn) + abs(pdrhmn)),rndoff)
        prhdfmn    = pdrhqpmn - pdrhmn
c
        pvrhmx     =     pcmxf1*pvlmx*pvlmx  +  pcmxf2*pvlmx  +
     &                                          pcmxf3
        pdrhmx     =     pdmxf1*pvlmx*pvlmx  +  pdmxf2*pvlmx  +
     &                                          pdmxf3
        pdrhqpmx   = 1.0/(2.0*pcmxf1*pvlmx   +  pcmxf2)
        pdnrmmx    = amax1((abs(pdrhqpmx) + abs(pdrhmx)),rndoff)
        prhdfmx    = pdrhqpmx - pdrhmx
c
c 4.3.1.4 Check that the derivatives are consistent with the polynomial
c         fits to rho**2
        if(abs(prhdfmn) .gt. tolqpr*pdnrmmn) then
           call abortjob
     &        ('ratcomp ', 26,   'dpsi/drho2(qmin) interpolation error'
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           write(kuout,2000) jrtmn,   jrtmn0, pvlmn, pvrhmn,pdrhmn
     &                      ,pdrhqpmn,prhdfmn,psmnf1,psmnf2,psmnf3
     &                                       ,psmnr1,psmnr2,psmnr3
     &                                       ,pmndr1,pmndr2,pmndr3
     &                                       ,pcmnf1,pcmnf2,pcmnf3
     &                                       ,pdmnf1,pdmnf2,pdmnf3
        endif
c
        if(abs(prhdfmx) .gt. tolqpr*pdnrmmx) then
           call abortjob
     &        ('ratcomp ', 27,   'dpsi/drho2(qmax) interpolation error'
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           write(kuout,2010) jrtmx,   jrtmx0, pvlmx, pvrhmx,pdrhmx
     &                      ,pdrhqpmx,prhdfmx,psmxf1,psmxf2,psmxf3
     &                                       ,psmxr1,psmxr2,psmxr3
     &                                       ,pmxdr1,pmxdr2,pmxdr3
     &                                       ,pcmxf1,pcmxf2,pcmxf3
     &                                       ,pdmxf1,pdmxf2,pdmxf3
        endif
c
c 4.3.1.5 Check rh2(qmin) and rh2(qmax) are in the respective ranges
c         used by the interpolation: rho**2 should be monotonic
        if((pvrhmn-psmnr1)*(pvrhmn-psmnr3) .gt. 0.0) then
           if((abs(pvrhmn-psmnr1) .ge. rndoff*rh2tot) .and.
     &        (abs(pvrhmn-psmnr3) .ge. rndoff*rh2tot))    call abortjob
     &        ('ratcomp ', 28,   'Interpolated r(min) out of range    '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           if((abs(pvrhmn-psmnr1) .lt. rndoff*rh2tot) .or.
     &        (abs(pvrhmn-psmnr3) .lt. rndoff*rh2tot))    call abortjob
     &        ('ratcomp ', 29,   'r(min) is slightly out of range     '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,    0)
           write(kuout,2020) pvlmn, psmnr2,psmnr1,pvrhmn,psmnr3
     &                      ,pcmnf1,pcmnf2,pcmnf3
        endif
c
        if((pvrhmx-psmxr1)*(pvrhmx-psmxr3) .gt. 0.0) then
           if((abs(pvrhmx-psmxr1) .ge. rndoff*rh2tot) .and.
     &        (abs(pvrhmx-psmxr3) .ge. rndoff*rh2tot))    call abortjob
     &        ('ratcomp ', 30,   'Interpolated r(max) is out of range '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           if((abs(pvrhmx-psmxr1) .lt. rndoff*rh2tot) .or.
     &        (abs(pvrhmx-psmxr3) .lt. rndoff*rh2tot))    call abortjob
     &        ('ratcomp ', 31,   'r(max) is slightly out of range     '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,    0)
           write(kuout,2030) pvlmx, psmxr2,psmxr1,pvrhmx,psmxr3
     &                      ,pcmxf1,pcmxf2,pcmxf3
        endif
c
c 4.3.1.6 Set the values of psirho2
        psir2mnq   = pvrhmn
        dpsr2mnq   = pdrhmn
c
        psir2mxq   = pvrhmx
        dpsr2mxq   = pdrhmx
c
c 4.3.2 Set the corresponding values for psirhov
c
        psrh2mn    = psir2mnq
        psrh2mx    = psir2mxq
        dpsr2mn    = dpsr2mnq
        dpsr2mx    = dpsr2mxq
        if(psrh2mn .lt. 0.0) then
           if(abs(psrh2mn) .ge. rndoff*rh2tot) call abortjob
     &        ('ratcomp ', 32,   'Negative psir2mnq = rho**2(qmin)    '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           psrh2mn   = 0.0
        endif
        if(psrh2mx .lt. 0.0) then
           if(abs(psrh2mx) .ge. rndoff*rh2tot) call abortjob
     &        ('ratcomp ', 33,   'Negative psir2mxq = rho**2(qmax)    '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           psrh2mx   = 0.0
        endif
        psrhomn    = sqrt(psrh2mn)
        psirhmnq   =      psrhomn
        dpsrhmnq   =  2.0*dpsr2mn*psrhomn
c
        psrhomx    = sqrt(psrh2mx)
        psirhmxq   =      psrhomx
        dpsrhmxq   =  2.0*dpsr2mx*psrhomx
c
c 4.3.3 Set the corresponding values for psinrho
c
        psinrmnq   = psirhmnq/rhotot
        dpsnrmnq   = dpsrhmnq*rhotot
c
        psinrmxq   = psirhmxq/rhotot
        dpsnrmxq   = dpsrhmxq*rhotot
c
c
c 4.4 Set the values for toroidal flux variables
c
c 4.4.1 Set the corresponding values for psitorf
c
c 4.4.1.1 Compute the interpolation coefficients for torf(psi)
c         and dpsi/dtorf at the maximum and minimum q value
        psmnt1     = psitorf(jrtmn0-1)
        psmnt2     = psitorf( jrtmn0 )
        psmnt3     = psitorf(jrtmn0+1)
        pmndt1     = dpsitor(jrtmn0-1)
        pmndt2     = dpsitor( jrtmn0 )
        pmndt3     = dpsitor(jrtmn0+1)
c
        psmxt1     = psitorf(jrtmx0-1)
        psmxt2     = psitorf( jrtmx0 )
        psmxt3     = psitorf(jrtmx0+1)
        pmxdt1     = dpsitor(jrtmx0-1)
        pmxdt2     = dpsitor( jrtmx0 )
        pmxdt3     = dpsitor(jrtmx0+1)
c
        call intcoef(psmnf1,psmnf2,psmnf3,psmnt1,psmnt2,psmnt3
     &                                   ,pcmnt1,pcmnt2,pcmnt3,kermn1)
c
        call intcoef(psmnf1,psmnf2,psmnf3,pmndt1,pmndt2,pmndt3
     &                                   ,pdmnt1,pdmnt2,pdmnt3,kermn2)
c
        call intcoef(psmxf1,psmxf2,psmxf3,psmxt1,psmxt2,psmxt3
     &                                   ,pcmxt1,pcmxt2,pcmxt3,kermx1)
c
        call intcoef(psmxf1,psmxf2,psmxf3,pmxdt1,pmxdt2,pmxdt3
     &                                   ,pdmxt1,pdmxt2,pdmxt3,kermx2)
c
c 4.4.1.2 Check for interpolation errors
        if(kermn1 .ne. 0) call abortjob
     &        ('ratcomp ', 34,   'Failed interpolation for torf(qmin) '
     &        ,'kermn1  ', kermn1,   'jrtmn0  ', jrtmn0,   -1)
        if(kermn2 .ne. 0) call abortjob
     &        ('ratcomp ', 35,   'Failed interpolation for dtorf(qmin)'
     &        ,'kermn2  ', kermn2,   'jrtmn0  ', jrtmn0,   -1)
        if(kermx1 .ne. 0) call abortjob
     &        ('ratcomp ', 36,   'Failed interpolation for torf(qmax) '
     &        ,'kermx1  ', kermx1,   'jrtmx0  ', jrtmx0,   -1)
        if(kermx2 .ne. 0) call abortjob
     &        ('ratcomp ', 37,   'Failed interpolation for dtorf(qmax)'
     &        ,'kermx2  ', kermx2,   'jrtmx0  ', jrtmx0,   -1)
c
c 4.4.1.3 Compute the interpolated values
        pvtfmn     =     pcmnt1*pvlmn*pvlmn  +  pcmnt2*pvlmn  +
     &                                          pcmnt3
        pdtfmn     =     pdmnt1*pvlmn*pvlmn  +  pdmnt2*pvlmn  +
     &                                          pdmnt3
        pdtfqpmn   = 1.0/(2.0*pcmnt1*pvlmn   +  pcmnt2)
        pdntmmn    = amax1((abs(pdtfqpmn) + abs(pdtfmn)),rndoff)
        ptfdfmn    = pdtfqpmn - pdtfmn
c
        pvtfmx     =     pcmxt1*pvlmx*pvlmx  +  pcmxt2*pvlmx  +
     &                                          pcmxt3
        pdtfmx     =     pdmxt1*pvlmx*pvlmx  +  pdmxt2*pvlmx  +
     &                                          pdmxt3
        pdtfqpmx   = 1.0/(2.0*pcmxt1*pvlmx   +  pcmxt2)
        pdntmmx    = amax1((abs(pdtfqpmx) + abs(pdtfmx)),rndoff)
        ptfdfmx    = pdtfqpmx - pdtfmx
c
c 4.4.1.4 Check that the derivatives are consistent with the polynomial
c         fits to torf
        if(abs(ptfdfmn) .gt. tolqpr*pdntmmn) then
           call abortjob
     &        ('ratcomp ', 38,   'dpsi/dtorf(qmin) interpolation error'
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           write(kuout,2100) jrtmn,   jrtmn0, pvlmn, pvtfmn,pdtfmn
     &                      ,pdtfqpmn,ptfdfmn,psmnf1,psmnf2,psmnf3
     &                                       ,psmnt1,psmnt2,psmnt3
     &                                       ,pmndt1,pmndt2,pmndt3
     &                                       ,pcmnt1,pcmnt2,pcmnt3
     &                                       ,pdmnt1,pdmnt2,pdmnt3
        endif
c
        if(abs(ptfdfmx) .gt. tolqpr*pdntmmx) then
           call abortjob
     &        ('ratcomp ', 39,   'dpsi/dtorf(qmax) interpolation error'
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           write(kuout,2110) jrtmx,   jrtmx0, pvlmx, pvtfmx,pdtfmx
     &                      ,pdtfqpmx,ptfdfmx,psmxf1,psmxf2,psmxf3
     &                                       ,psmxt1,psmxt2,psmxt3
     &                                       ,pmxdt1,pmxdt2,pmxdt3
     &                                       ,pcmxt1,pcmxt2,pcmxt3
     &                                       ,pdmxt1,pdmxt2,pdmxt3
        endif
c
c 4.4.1.5 Check torf(qmin) and torf(qmax) are in the respective ranges
c         used by the interpolation: torf should be monotonic
        if((pvtfmn-psmnt1)*(pvtfmn-psmnt3) .gt. 0.0) then
           if((abs(pvtfmn-psmnt1) .ge. rndoff*flxtot) .and.
     &        (abs(pvtfmn-psmnt3) .ge. rndoff*flxtot))    call abortjob
     &        ('ratcomp ', 40,   'Interpolated t(min) is out of range '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           if((abs(pvtfmn-psmnt1) .lt. rndoff*flxtot) .or.
     &        (abs(pvtfmn-psmnt3) .lt. rndoff*flxtot))    call abortjob
     &        ('ratcomp ', 41,   't(min) is slightly out of range     '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,    0)
           pvtdf1    = pvtfmn - psmnt1
           pvtdf3    = pvtfmn - psmnt3
           write(kuout,2120) pvlmn, psmnt2,psmnt1,pvtfmn,psmnt3
     &                      ,pcmnt1,pcmnt2,pcmnt3,pvtdf1,pvtdf3
        endif
c
        if((pvtfmx-psmxt1)*(pvtfmx-psmxt3) .gt. 0.0) then
           if((abs(pvtfmx-psmxt1) .ge. rndoff*flxtot) .and.
     &        (abs(pvtfmx-psmxt3) .ge. rndoff*flxtot))    call abortjob
     &        ('ratcomp ', 42,   'Interpolated t(max) is out of range '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           if((abs(pvtfmx-psmxt1) .lt. rndoff*flxtot) .or.
     &        (abs(pvtfmx-psmxt3) .lt. rndoff*flxtot))    call abortjob
     &        ('ratcomp ', 43,   't(max) is slightly out of range     '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,    0)
           pvtdf1    = pvtfmx - psmxt1
           pvtdf3    = pvtfmx - psmxt3
           write(kuout,2130) pvlmx, psmxt2,psmxt1,pvtfmx,psmxt3
     &                      ,pcmxt1,pcmxt2,pcmxt3,pvtdf1,pvtdf3
        endif
c
c 4.4.1.6 Set the values of psitorf
        psitfmnq   = pvtfmn
        dpstfmnq   = pdtfmn
c
        psitfmxq   = pvtfmx
        dpstfmxq   = pdtfmx
c
c 4.4.2 Set the corresponding values for psintor
c
        psintmnq   = psitfmnq/flxtot
        dpsntmnq   = dpstfmnq*flxtot
c
        psintmxq   = psitfmxq/flxtot
        dpsntmxq   = dpstfmxq*flxtot
c
c 4.4.3 Set the corresponding values for psisqtf
c
        pstormn    = psintmnq
        pstormx    = psintmxq
        dpstfmn    = dpstfmnq
        dpstfmx    = dpstfmxq
        if(pstormn .lt. 0.0) then
           if(abs(pstormn) .ge. rndoff*flxtot) call abortjob
     &        ('ratcomp ', 44,   'Negative psitfmnq = psitor(qmin)    '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           pstormn   = 0.0
        endif
        if(pstormx .lt. 0.0) then
           if(abs(pstormx) .ge. rndoff*flxtot) call abortjob
     &        ('ratcomp ', 45,   'Negative psitfmxq = psitor(qmax)    '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           pstormx   = 0.0
        endif
c
        psistmnq   = sqrt(pstormn)
        dpsstmnq   =  2.0*dpstfmn*pstormn
        psistmxq   = sqrt(pstormx)
        dpsstmxq   =  2.0*dpstfmx*pstormx
c
c
c 4.5 Set the values for volume variables
c
c 4.5.1 Set the corresponding values for psivolm
c
c 4.5.1.1 Compute the interpolation coefficients for volm(psi)
c         and dpsi/dvolm at the maximum and minimum q value
        psmnv1     = psivolm(jrtmn0-1)
        psmnv2     = psivolm( jrtmn0 )
        psmnv3     = psivolm(jrtmn0+1)
        pmndv1     = dpsivol(jrtmn0-1)
        pmndv2     = dpsivol( jrtmn0 )
        pmndv3     = dpsivol(jrtmn0+1)
c
        psmxv1     = psivolm(jrtmx0-1)
        psmxv2     = psivolm( jrtmx0 )
        psmxv3     = psivolm(jrtmx0+1)
        pmxdv1     = dpsivol(jrtmx0-1)
        pmxdv2     = dpsivol( jrtmx0 )
        pmxdv3     = dpsivol(jrtmx0+1)
c
        call intcoef(psmnf1,psmnf2,psmnf3,psmnv1,psmnv2,psmnv3
     &                                   ,pcmnv1,pcmnv2,pcmnv3,kermn1)
c
        call intcoef(psmnf1,psmnf2,psmnf3,pmndv1,pmndv2,pmndv3
     &                                   ,pdmnv1,pdmnv2,pdmnv3,kermn2)
c
        call intcoef(psmxf1,psmxf2,psmxf3,psmxv1,psmxv2,psmxv3
     &                                   ,pcmxv1,pcmxv2,pcmxv3,kermx1)
c
        call intcoef(psmxf1,psmxf2,psmxf3,pmxdv1,pmxdv2,pmxdv3
     &                                   ,pdmxv1,pdmxv2,pdmxv3,kermx2)
c
c 4.5.1.2 Check for interpolation errors
        if(kermn1 .ne. 0) call abortjob
     &        ('ratcomp ', 46,   'Failed interpolation for volm(qmin) '
     &        ,'kermn1  ', kermn1,   'jrtmn0  ', jrtmn0,   -1)
        if(kermn2 .ne. 0) call abortjob
     &        ('ratcomp ', 47,   'Failed interpolation for dvolm(qmin)'
     &        ,'kermn2  ', kermn2,   'jrtmn0  ', jrtmn0,   -1)
        if(kermx1 .ne. 0) call abortjob
     &        ('ratcomp ', 48,   'Failed interpolation for volm(qmax) '
     &        ,'kermx1  ', kermx1,   'jrtmx0  ', jrtmx0,   -1)
        if(kermx2 .ne. 0) call abortjob
     &        ('ratcomp ', 49,   'Failed interpolation for dvolm(qmax)'
     &        ,'kermx2  ', kermx2,   'jrtmx0  ', jrtmx0,   -1)
c
c 4.5.1.3 Compute the interpolated values
        pvvmmn     =     pcmnv1*pvlmn*pvlmn  +  pcmnv2*pvlmn  +
     &                                          pcmnv3
        pdvmmn     =     pdmnv1*pvlmn*pvlmn  +  pdmnv2*pvlmn  +
     &                                          pdmnv3
        pdvmqpmn   = 1.0/(2.0*pcmnv1*pvlmn   +  pcmnv2)
        pdnvmmn    = amax1((abs(pdvmqpmn) + abs(pdvmmn)),rndoff)
        pvmdfmn    = pdvmqpmn - pdvmmn
c
        pvvmmx     =     pcmxv1*pvlmx*pvlmx  +  pcmxv2*pvlmx  +
     &                                          pcmxv3
        pdvmmx     =     pdmxv1*pvlmx*pvlmx  +  pdmxv2*pvlmx  +
     &                                          pdmxv3
        pdvmqpmx   = 1.0/(2.0*pcmxv1*pvlmx   +  pcmxv2)
        pdnvmmx    = amax1((abs(pdvmqpmx) + abs(pdvmmx)),rndoff)
        pvmdfmx    = pdvmqpmx - pdvmmx
c
c 4.5.1.4 Check that the derivatives are consistent with the polynomial
c         fits to volm
        if(abs(pvmdfmn) .gt. tolqpr*pdnvmmn) then
           call abortjob
     &        ('ratcomp ', 50,   'dpsi/dvolm(qmin) interpolation error'
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           write(kuout,2200) jrtmn,   jrtmn0, pvlmn, pvvmmn,pdvmmn
     &                      ,pdvmqpmn,pvmdfmn,psmnf1,psmnf2,psmnf3
     &                                       ,psmnv1,psmnv2,psmnv3
     &                                       ,pmndv1,pmndv2,pmndv3
     &                                       ,pcmnv1,pcmnv2,pcmnv3
     &                                       ,pdmnv1,pdmnv2,pdmnv3
        endif
c
        if(abs(pvmdfmx) .gt. tolqpr*pdnvmmx) then
           call abortjob
     &        ('ratcomp ', 51,   'dpsi/dvolm(qmax) interpolation error'
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           write(kuout,2210) jrtmx,   jrtmx0, pvlmx, pvvmmx,pdvmmx
     &                      ,pdvmqpmx,pvmdfmx,psmxf1,psmxf2,psmxf3
     &                                       ,psmxv1,psmxv2,psmxv3
     &                                       ,pmxdv1,pmxdv2,pmxdv3
     &                                       ,pcmxv1,pcmxv2,pcmxv3
     &                                       ,pdmxv1,pdmxv2,pdmxv3
        endif
c
c 4.5.1.5 Check volm(qmin) and volm(qmax) are in the respective ranges
c           used by the interpolation: volm should be monotonic
        if((pvvmmn-psmnv1)*(pvvmmn-psmnv3) .gt. 0.0) then
           if((abs(pvvmmn-psmnv1) .ge. rndoff*voltot) .and.
     &        (abs(pvvmmn-psmnv3) .ge. rndoff*voltot))    call abortjob
     &        ('ratcomp ', 52,   'Interpolated V(min) is out of range '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           if((abs(pvvmmn-psmnv1) .lt. rndoff*voltot) .or.
     &        (abs(pvvmmn-psmnv3) .lt. rndoff*voltot))    call abortjob
     &        ('ratcomp ', 53,   'V(min) is slightly out of range     '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,    0)
           pvvdf1    = pvvmmn - psmnv1
           pvvdf3    = pvvmmn - psmnv3
           write(kuout,2220) pvlmn, psmnv2,psmnv1,pvvmmn,psmnv3
     &                      ,pcmnv1,pcmnv2,pcmnv3,pvvdf1,pvvdf3
        endif
c
        if((pvvmmx-psmxv1)*(pvvmmx-psmxv3) .gt. 0.0) then
           if((abs(pvvmmx-psmxv1) .ge. rndoff*voltot) .and.
     &        (abs(pvvmmx-psmxv3) .ge. rndoff*voltot))    call abortjob
     &        ('ratcomp ', 54,   'Interpolated V(max) is out of range '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           if((abs(pvvmmx-psmxv1) .lt. rndoff*voltot) .or.
     &        (abs(pvvmmx-psmxv3) .lt. rndoff*voltot))    call abortjob
     &        ('ratcomp ', 55,   'V(max) is slightly out of range     '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,    0)
           pvvdf1    = pvvmmx - psmxv1
           pvvdf3    = pvvmmx - psmxv3
           write(kuout,2230) pvlmx, psmxv2,psmxv1,pvvmmx,psmxv3
     &                      ,pcmxv1,pcmxv2,pcmxv3,pvvdf1,pvvdf3
        endif
c
c 4.5.1.6 Set the values of psivolm
        psivmmnq   = pvvmmn
        dpsvmmnq   = pdvmmn
c
        psivmmxq   = pvvmmx
        dpsvmmxq   = pdvmmx
c
c 4.5.2 Set the corresponding values for psinvol
c
        psinvmnq   = psivmmnq/voltot
        dpsnvmnq   = dpsvmmnq*voltot
c
        psinvmxq   = psivmmxq/voltot
        dpsnvmxq   = dpsvmmxq*voltot
c
c 4.5.3 Set the corresponding values for psisqvl
c
        psvolmn    = psinvmnq
        psvolmx    = psinvmxq
        dpsvmmn    = dpsvmmnq
        dpsvmmx    = dpsvmmxq
        if(psvolmn .lt. 0.0) then
           if(abs(psvolmn) .ge. rndoff*voltot) call abortjob
     &        ('ratcomp ', 56,   'Negative psivmmnq = psivol(qmin)    '
     &        ,'numbqs  ', numbqs,   'jrtmn0  ', jrtmn0,   -1)
           psvolmn   = 0.0
        endif
        if(psvolmx .lt. 0.0) then
           if(abs(psvolmx) .ge. rndoff*voltot) call abortjob
     &        ('ratcomp ', 57,   'Negative psivmmxq = psivol(qmax)    '
     &        ,'numbqs  ', numbqs,   'jrtmx0  ', jrtmx0,   -1)
           psvolmx   = 0.0
        endif
c
        psisvmnq   = sqrt(psvolmn)
        dpssvmnq   =  2.0*dpsvmmn*psvolmn
        psisvmxq   = sqrt(psvolmx)
        dpssvmxq   =  2.0*dpsvmmx*psvolmx
c
c
c
c 5.0 Select the q = 1 surfaces
c
c 5.1 Find the q = 1 surfaces from lpsiq/ntor = 1 and set the shear and
c     aspect ratio
c
      if(numbqs .gt. 0) then
         do 500 lq  = 1,numbqs
         if(lpsiq(lq) .eq. ntor) then
            lqeq1      = lq
            lqcount    = lqcount + 1
c
c 5.1.1 Estimate using the normalized outboard distance as the radius estimate
c
            shrrh1     = shearrh(lqeq1)
            epsrh1     = psinrhq(lqeq1)*asnorm
            shrfcrh0   = epsrh1*epsrh1*shrrh1
            if    (abs(shrfcrh0) .le. sheartol) then
               shrfcrh    = -1.0
               call abortjob
     &        ('ratcomp ', 58,   'Vanishing shear w.r.t. rho at q = 1 '
     &        ,'lqcount ', lqcount,  'lqeq1   ', lqeq1,    -1)
            elseif(abs(shrfcrh0) .gt. sheartol) then
               shrfcrh    =  shrfcrh0
            endif
c
c 5.1.2 Estimate using the sqrt volume as the radius estimate
c
            shrvl1     = shearvl(lqeq1)
            epsvl1     = psisqvq(lqeq1)*asnorm
            shrfcvl0   = epsvl1*epsvl1*shrvl1
            if    (abs(shrfcvl0) .le. sheartol) then
               shrfcvl    = -1.0
               call abortjob
     &        ('ratcomp ', 59,   'Vanishing shear w.r.t. volm at q = 1'
     &        ,'lqcount ', lqcount,  'lqeq1   ', lqeq1,    -1)
            elseif(abs(shrfcvl0) .gt. sheartol) then
               shrfcvl    =  shrfcvl0
            endif
c
c 5.1.3 Save the values
c
            shearrh1(lqcount)   = shrrh1
            epslrh1 (lqcount)   = epsrh1
            shearfrh(lqcount)   = shrfcrh
            shearvl1(lqcount)   = shrvl1
            epslvl1 (lqcount)   = epsvl1
            shearfvl(lqcount)   = shrfcvl
         endif
 500     continue
      endif
c
c
c 5.2 Set the count of q = 1 surfaces
c
      nq1totl   = lqcount
c
c
c
c
c 6.0 Return and end
c
      return
 1000 format(   10x,'jrt      = ',i5,10x,  'jrt0     = ',i5 
     &         ,10x,'psvlq    = ',e13.6,2x,'psvrhq   = ',e13.6
     &       ,/,10x,'psdrhq   = ',e13.6,2x,'psdrhqp  = ',e13.6
     &          ,2x,'prhddif  = ',e13.6
     &       ,/,10x,'psif1    = ',e13.6,2x,'psif2    = ',e13.6
     &          ,2x,'psif3    = ',e13.6
     &       ,/,10x,'psir1    = ',e13.6,2x,'psir2    = ',e13.6
     &          ,2x,'psir3    = ',e13.6
     &       ,/,10x,'psdr1    = ',e13.6,2x,'psdr2    = ',e13.6
     &          ,2x,'psdr3    = ',e13.6
     &       ,/,10x,'pcf1     = ',e13.6,2x,'pcf2     = ',e13.6
     &          ,2x,'pcf3     = ',e13.6
     &       ,/,10x,'pdf1     = ',e13.6,2x,'pdf2     = ',e13.6
     &          ,2x,'pdf3     = ',e13.6,/)
 1010 format(   10x,'psvlq    = ',e13.6,2x,'psir2    = ',e13.6
     &       ,/,10x,'psir1    = ',e13.6,2x,'psvrhq   = ',e13.6
     &          ,2x,'psir3    = ',e13.6
     &       ,/,10x,'pcf1     = ',e13.6,2x,'pcf2     = ',e13.6
     &          ,2x,'pcf3     = ',e13.6,/)
 1100 format(   10x,'jrt      = ',i5,10x,  'jrt0     = ',i5    
     &         ,10x,'psvlq    = ',e13.6,2x,'pstorq   = ',e13.6
     &       ,/,10x,'psdtfq   = ',e13.6,2x,'psdtfqp  = ',e13.6
     &          ,2x,'ptfddif  = ',e13.6
     &       ,/,10x,'psif1    = ',e13.6,2x,'psif2    = ',e13.6
     &          ,2x,'psif3    = ',e13.6
     &       ,/,10x,'psit1    = ',e13.6,2x,'psit2    = ',e13.6
     &          ,2x,'psit3    = ',e13.6
     &       ,/,10x,'psdt1    = ',e13.6,2x,'psdt2    = ',e13.6
     &          ,2x,'psdt3    = ',e13.6
     &       ,/,10x,'pct1     = ',e13.6,2x,'pct2     = ',e13.6
     &          ,2x,'pct3     = ',e13.6
     &       ,/,10x,'pdt1     = ',e13.6,2x,'pdt2     = ',e13.6
     &          ,2x,'pdt3     = ',e13.6,/)
 1110 format(   10x,'psvlq    = ',e13.6,2x,'psit2    = ',e13.6
     &       ,/,10x,'psit1    = ',e13.6,2x,'psvtfq   = ',e13.6
     &          ,2x,'psit3    = ',e13.6
     &       ,/,10x,'pct1     = ',e13.6,2x,'pct2     = ',e13.6
     &          ,2x,'pct3     = ',e13.6,/)
 1200 format(   10x,'jrt      = ',i5,10x,  'jrt0     = ',i5 
     &         ,10x,'psvlq    = ',e13.6,2x,'psvolq   = ',e13.6
     &       ,/,10x,'psdvlq   = ',e13.6,2x,'psdvlqp  = ',e13.6
     &          ,2x,'pvlddif  = ',e13.6
     &       ,/,10x,'psif1    = ',e13.6,2x,'psif2    = ',e13.6
     &          ,2x,'psif3    = ',e13.6
     &       ,/,10x,'psvl1    = ',e13.6,2x,'psvl2    = ',e13.6
     &          ,2x,'psvl3    = ',e13.6
     &       ,/,10x,'psdv1    = ',e13.6,2x,'psdv2    = ',e13.6
     &          ,2x,'psdv3    = ',e13.6
     &       ,/,10x,'pcv1     = ',e13.6,2x,'pcv2     = ',e13.6
     &          ,2x,'pcv3     = ',e13.6
     &       ,/,10x,'pdv1     = ',e13.6,2x,'pdv2     = ',e13.6
     &          ,2x,'pdv3     = ',e13.6,/)
 1210 format(   10x,'psvlq    = ',e13.6,2x,'psvl2    = ',e13.6
     &       ,/,10x,'psvl1    = ',e13.6,2x,'psvolq   = ',e13.6
     &          ,2x,'psvl3    = ',e13.6
     &       ,/,10x,'pcv1     = ',e13.6,2x,'pcv2     = ',e13.6
     &          ,2x,'pcv3     = ',e13.6,/)
 2000 format(   10x,'jrtmn    = ',i5,10x,  'jrtmn0   = ',i5 
     &         ,10x,'pvlmn    = ',e13.6,2x,'pvrhmn   = ',e13.6
     &       ,/,10x,'pdrhmn   = ',e13.6,2x,'pdrhqpmn = ',e13.6
     &          ,2x,'prhdfmn  = ',e13.6
     &       ,/,10x,'psmnf1   = ',e13.6,2x,'psmnf2   = ',e13.6
     &          ,2x,'psmnf3   = ',e13.6
     &       ,/,10x,'psmnr1   = ',e13.6,2x,'psmnr2   = ',e13.6
     &          ,2x,'psmnr3   = ',e13.6
     &       ,/,10x,'pmndr1   = ',e13.6,2x,'pmndr2   = ',e13.6
     &          ,2x,'pmndr3   = ',e13.6
     &       ,/,10x,'pcmnf1   = ',e13.6,2x,'pcmnf2   = ',e13.6
     &          ,2x,'pcmnf3   = ',e13.6
     &       ,/,10x,'pdmnf1   = ',e13.6,2x,'pdmnf2   = ',e13.6
     &          ,2x,'pdmnf3   = ',e13.6,/)
 2010 format(   10x,'jrtmx    = ',i5,10x,  'jrtmx0   = ',i5 
     &         ,10x,'pvlmx    = ',e13.6,2x,'pvrhmx   = ',e13.6
     &       ,/,10x,'pdrhmx   = ',e13.6,2x,'pdrhqpmx = ',e13.6
     &          ,2x,'prhdfmx  = ',e13.6
     &       ,/,10x,'psmxf1   = ',e13.6,2x,'psmxf2   = ',e13.6
     &          ,2x,'psmxf3   = ',e13.6
     &       ,/,10x,'psmxr1   = ',e13.6,2x,'psmxr2   = ',e13.6
     &          ,2x,'psmxr3   = ',e13.6
     &       ,/,10x,'pmxdr1   = ',e13.6,2x,'pmxdr2   = ',e13.6
     &          ,2x,'pmxdr3   = ',e13.6
     &       ,/,10x,'pcmxf1   = ',e13.6,2x,'pcmxf2   = ',e13.6
     &          ,2x,'pcmxf3   = ',e13.6
     &       ,/,10x,'pdmxf1   = ',e13.6,2x,'pdmxf2   = ',e13.6
     &          ,2x,'pdmxf3   = ',e13.6,/)
 2020 format(   10x,'pvlmn    = ',e13.6,2x,'psmnr2   = ',e13.6
     &       ,/,10x,'psmnr1   = ',e13.6,2x,'pvrhmn   = ',e13.6
     &          ,2x,'psmnr3   = ',e13.6
     &       ,/,10x,'pcmnf1   = ',e13.6,2x,'pcmnf2   = ',e13.6
     &          ,2x,'pcmnf3   = ',e13.6,/)
 2030 format(   10x,'pvlmx    = ',e13.6,2x,'psmxr2   = ',e13.6
     &       ,/,10x,'psmxr1   = ',e13.6,2x,'pvrhmx   = ',e13.6
     &          ,2x,'psmxr3   = ',e13.6
     &       ,/,10x,'pcmxf1   = ',e13.6,2x,'pcmxf2   = ',e13.6
     &          ,2x,'pcmxf3   = ',e13.6,/)
 2100 format(   10x,'jrtmn    = ',i5,10x,  'jrtmn0   = ',i5 
     &         ,10x,'pvlmn    = ',e13.6,2x,'pvtfmn   = ',e13.6
     &       ,/,10x,'pdtfmn   = ',e13.6,2x,'pdtfqpmn = ',e13.6
     &          ,2x,'ptfdfmn  = ',e13.6
     &       ,/,10x,'psmnf1   = ',e13.6,2x,'psmnf2   = ',e13.6
     &          ,2x,'psmnf3   = ',e13.6
     &       ,/,10x,'psmnt1   = ',e13.6,2x,'psmnt2   = ',e13.6
     &          ,2x,'psmnt3   = ',e13.6
     &       ,/,10x,'pmndt1   = ',e13.6,2x,'pmndt2   = ',e13.6
     &          ,2x,'pmndt3   = ',e13.6
     &       ,/,10x,'pcmnt1   = ',e13.6,2x,'pcmnt2   = ',e13.6
     &          ,2x,'pcmnt3   = ',e13.6
     &       ,/,10x,'pdmnt1   = ',e13.6,2x,'pdmnt2   = ',e13.6
     &          ,2x,'pdmnt3   = ',e13.6,/)
 2110 format(   10x,'jrtmx    = ',i5,10x,  'jrtmx0   = ',i5 
     &         ,10x,'pvlmx    = ',e13.6,2x,'pvtfmx   = ',e13.6
     &       ,/,10x,'pdtfmx   = ',e13.6,2x,'pdtfqpmx = ',e13.6
     &          ,2x,'ptfdfmx  = ',e13.6
     &       ,/,10x,'psmxf1   = ',e13.6,2x,'psmxf2   = ',e13.6
     &          ,2x,'psmxf3   = ',e13.6
     &       ,/,10x,'psmxt1   = ',e13.6,2x,'psmxt2   = ',e13.6
     &          ,2x,'psmxt3   = ',e13.6
     &       ,/,10x,'pmxdt1   = ',e13.6,2x,'pmxdt2   = ',e13.6
     &          ,2x,'pmxdt3   = ',e13.6
     &       ,/,10x,'pcmxt1   = ',e13.6,2x,'pcmxt2   = ',e13.6
     &          ,2x,'pcmxt3   = ',e13.6
     &       ,/,10x,'pdmxt1   = ',e13.6,2x,'pdmxt2   = ',e13.6
     &          ,2x,'pdmxt3   = ',e13.6,/)
 2120 format(   10x,'pvlmn    = ',e13.6,2x,'psmnt2   = ',e13.6
     &       ,/,10x,'psmnt1   = ',e13.6,2x,'pvtfmn   = ',e13.6
     &          ,2x,'psmnt3   = ',e13.6
     &       ,/,10x,'pcmnt1   = ',e13.6,2x,'pcmnt2   = ',e13.6
     &          ,2x,'pcmnt3   = ',e13.6
     &       ,/,10x,'pvtdf1   = ',e13.6,2x,'pvtdf1   = ',e13.6,/)
 2130 format(   10x,'pvlmx    = ',e13.6,2x,'psmxt2   = ',e13.6
     &       ,/,10x,'psmxt1   = ',e13.6,2x,'pvtfmx   = ',e13.6
     &          ,2x,'psmxt3   = ',e13.6
     &       ,/,10x,'pcmxt1   = ',e13.6,2x,'pcmxt2   = ',e13.6
     &          ,2x,'pcmxt3   = ',e13.6
     &       ,/,10x,'pvtdf1   = ',e13.6,2x,'pvtdf1   = ',e13.6,/)
 2200 format(   10x,'jrtmn    = ',i5,10x,  'jrtmn0   = ',i5 
     &         ,10x,'pvlmn    = ',e13.6,2x,'pvvmmn   = ',e13.6
     &       ,/,10x,'pdvmmn   = ',e13.6,2x,'pdvmqpmn = ',e13.6
     &          ,2x,'pvmdfmn  = ',e13.6
     &       ,/,10x,'psmnf1   = ',e13.6,2x,'psmnf2   = ',e13.6
     &          ,2x,'psmnf3   = ',e13.6
     &       ,/,10x,'psmnv1   = ',e13.6,2x,'psmnv2   = ',e13.6
     &          ,2x,'psmnv3   = ',e13.6
     &       ,/,10x,'pmndv1   = ',e13.6,2x,'pmndv2   = ',e13.6
     &          ,2x,'pmndv3   = ',e13.6
     &       ,/,10x,'pcmnv1   = ',e13.6,2x,'pcmnv2   = ',e13.6
     &          ,2x,'pcmnv3   = ',e13.6
     &       ,/,10x,'pdmnv1   = ',e13.6,2x,'pdmnv2   = ',e13.6
     &          ,2x,'pdmnv3   = ',e13.6,/)
 2210 format(   10x,'jrtmx    = ',i5,10x,  'jrtmx0   = ',i5 
     &         ,10x,'pvlmx    = ',e13.6,2x,'pvvmmx   = ',e13.6
     &       ,/,10x,'pdvmmx   = ',e13.6,2x,'pdvmqpmx = ',e13.6
     &          ,2x,'pvmdfmx  = ',e13.6
     &       ,/,10x,'psmxf1   = ',e13.6,2x,'psmxf2   = ',e13.6
     &          ,2x,'psmxf3   = ',e13.6
     &       ,/,10x,'psmxv1   = ',e13.6,2x,'psmxv2   = ',e13.6
     &          ,2x,'psmxv3   = ',e13.6
     &       ,/,10x,'pmxdv1   = ',e13.6,2x,'pmxdv2   = ',e13.6
     &          ,2x,'pmxdv3   = ',e13.6
     &       ,/,10x,'pcmxv1   = ',e13.6,2x,'pcmxv2   = ',e13.6
     &          ,2x,'pcmxv3   = ',e13.6
     &       ,/,10x,'pdmxv1   = ',e13.6,2x,'pdmxv2   = ',e13.6
     &          ,2x,'pdmxv3   = ',e13.6,/)
 2220 format(   10x,'pvlmn    = ',e13.6,2x,'psmnv2   = ',e13.6
     &       ,/,10x,'psmnv1   = ',e13.6,2x,'pvvmmn   = ',e13.6
     &          ,2x,'psmnv3   = ',e13.6
     &       ,/,10x,'pcmnv1   = ',e13.6,2x,'pcmnv2   = ',e13.6
     &          ,2x,'pcmnv3   = ',e13.6
     &       ,/,10x,'pvvdf1   = ',e13.6,2x,'pvvdf1   = ',e13.6,/)
 2230 format(   10x,'pvlmx    = ',e13.6,2x,'psmxv2   = ',e13.6
     &       ,/,10x,'psmxv1   = ',e13.6,2x,'pvvmmx   = ',e13.6
     &          ,2x,'psmxv3   = ',e13.6
     &       ,/,10x,'pcmxv1   = ',e13.6,2x,'pcmxv2   = ',e13.6
     &          ,2x,'pcmxv3   = ',e13.6
     &       ,/,10x,'pvvdf1   = ',e13.6,2x,'pvvdf1   = ',e13.6,/)
      end
      subroutine writeout
c
c -------------------------------------------------------------
c  Write out the mapping quantities
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
      character*1   lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst ,lbchvl, lbchsv
      character*8   pclab,  tclab,  labpsi, 
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/kinetc/pfactr,tfactr,dfactr,pffact,deutp,dmass,dnnova(np2),
     &              pfnova(np2), ptnova(np2), prnova(np2),pbnova(np2), 
     &              tenova(np2), tinova(np2), denova(np2),dinova(np2)
      common/labels/lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst, lbchvl, lbchsv,
     &              pclab,  tclab,  labpsi,
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize constants
c
      rndoff     = roundff
c
c
c
c 2.0 Write out the profile tables
c
c 2.1 Write out the equilibrium profiles
c
      write(kuout,1000) psimax,psilim,delpsir
      write(kuout,1010)
      write(kuout,1020) jpsi1,psimax,    ppaxe,     ffpaxe,     paxe,
     &                        faxe,      dnaxe,     pfaxe,      qaxe,
     &                        fqiaxe,    fqmaxe
      write(kuout,1030)
      do 20  j     = 1,jpsi1
      jj           = jpsi1-j+1
      write(kuout,1040) jj,psival(jj),   pp(jj),    ffp(jj),    p(jj),
     &                     f(jj),        dnsty (jj),pfast(jj),  qp (jj),
     &                     fqpi(jj),     fqim(jj)
  20  continue
c
      write(kuout,1050)    psilim,       pplim,      ffplim,    plim,
     &                     flim,         dnlim,      pflim,     qlim,
     &                     fqilim,       fqmlim
c
c
c 2.2 Write out the equilibrium coordinate profiles
c
      arcmaxp  = 0.0
      pstmaxp  = pstnorm(1)
      hammaxp  = hamnorm(1)
      dlnaxep  = dlnaxe
      dpnaxep  = dpnaxe
      dhnaxep  = dhnaxe
      write(kuout,1100)
      write(kuout,1110)    psimax,arcmaxp,pstmaxp,hammaxp,
     &                            dlnaxep,dpnaxep,dhnaxep
      do 30  j     = 1,jpsi1
      j0           = j
      write(kuout,1115) j0,psivl1(j0),arcnorm(j0),pstnorm(j0),
     &                                hamnorm(j0),dlnlval(j0),
     &                                dpnlval(j0),dhnlval(j0)
  30  continue
c
c
c 2.3 Write out the auxiliary profiles
c
      write(kuout,1200)
      write(kuout,1210) xlim,zlim
      write(kuout,1220)
      do 40  j     = 1,jpsi1+1
      jj2          = jpsi1-j+2
      rstdif       = rstp(jj2) - rst(jj2)
      zstdif       = zstp(jj2) - zst(jj2)
      write(kuout,1230) jj2,psivl0(jj2),rst (jj2),rstp(jj2),
     &                      rstdif,     zst (jj2),zstp(jj2),zstdif
  40  continue
c
      write(kuout,1250)
      do 45  j     = 1,jpsi1
      jj0          = j
      jj1          = jpsi1-j+1
      psihalf      = 0.5*(psivl0(jj1) - psivl0(jj1+1))
      qdelv        = qdel(jj1)
      write(kuout,1260) jj0,jj1,psihalf,qdelv
 45   continue
c
c
c 2.4 Write out the surface integrals
c
c 2.4.1 Basic surface integrals
c
      write(kuout,1300)
      write(kuout,1310)     psimax,sntax0,sntax1,sntax2,
     &                                    sntax3,sntax4
      do 50  j     = 1,jpsi1
      jj0          = j
      write(kuout,1315) jj0,psivl1(jj0),sint0 (jj0),sint1 (jj0),
     &                      sint2 (jj0),sint3 (jj0),sint4 (jj0)
  50  continue
c
c 2.4.2 Normalized surface integrals
c
      snt10        = sntax1/sntax0
      snt20        = sntax2/sntax0
      snt30        = sntax3/sntax0
      snt40        = sntax4/sntax0
      write(kuout,1320)
      write(kuout,1330)     psimax,snt10,snt20,snt30,snt40,
     &                      savgax,tavgax
      do 60  j     = 1,jpsi1
      jj0          = j
      snt10        = sint1(jj0)/sint0(jj0)
      snt20        = sint2(jj0)/sint0(jj0)
      snt30        = sint3(jj0)/sint0(jj0)
      snt40        = sint4(jj0)/sint0(jj0)
      write(kuout,1335) jj0,psivl1(jj0),snt10,snt20,snt30,snt40,
     &                      savge (jj0),tavge(jj0)
  60  continue
c
c 2.4.3 Comparisons
c
c 2.4.3.1 Comparison of qprime from S, dpnlval, and qdel
      write(kuout,1350)
      qvals        = sntax1*faxe/twopi
      qpvals       = qppaxe
      qpvalt       = qaxe*(dpnaxe + ffpaxe/(faxe*faxe))
      write(kuout,1360)     psimax,qaxe,qvals,qpvals,qpvalt
c
      do 70 j      = 1,jpsi1
      jj0          = j
      jj1          = jpsi1-j
      jj2          = jpsi1-j+1
c
      if    (jj1 .eq. 0) then
         fvalu       = flim
         ffpvalu     = ffplim
         qvalu       = qlim
      elseif(jj1 .gt. 0) then
         fvalu       = f  (jj1)
         ffpvalu     = ffp(jj1)
         qvalu       = qp (jj1)
      endif
c
      if(jj2 .eq. 1) qpvalu  =      qdel(jj2)/delpsir
      if(jj2 .gt. 1) qpvalu  = 0.5*(qdel(jj2-1) + qdel(jj2))/delpsir
c
      qvals        = sint1(jj0)*fvalu/twopi
      qpvals       = qprime(jj0)
      qpvalt       = qvalu*(dpnlval(jj0) + ffpvalu/(fvalu*fvalu))
      write(kuout,1365) jj0,psivl1(jj0),qvalu,qvals,qpvalu,qpvals,qpvalt
  70  continue
c
c 2.4.3.2 Comparison of S and  <f23> and T and <T+1/2S>
      write(kuout,1370)
c
      do 80 j      = 1,jpsi1
      jj0          = j
c
      anml         = arcnorm(jj0)/twopi
      sav          = savge(jj0) * sint0(jj0)/twopi
      tav          = tavge(jj0) * sint0(jj0)/twopi
c
      avef23       = 0.0
      avef24       = 0.0
      do 75 i      = 1,itht
      ii0          = i
      ii1          = i + 1
      bpol         = sqrt(f9(jj0,ii0)/f13(jj0,ii0))
      delarc       = chiarcl(jj0,ii1) - chiarcl(jj0,ii0)
      delth        = anml*delarc
      f23p         = f23(jj0,ii0)
      f24p         = f24(jj0,ii0)
      ajacob       = 1.0/bpol
      avef23       = avef23 + f23p*ajacob*delth
      avef24       = avef24 + f24p*ajacob*delth
 75   continue
c
      avef23       = avef23/twopi
      avef24       = avef24/twopi
      avef24a      = avef24 + 0.5*avef23
      if(abs(sav)   .gt. roundff) ratios  = avef23 / sav
      if(abs(sav)   .le. roundff) ratios  = 1.0 + avef23
      if(abs(tav)   .gt. roundff) ratiot  = avef24a/ tav
      if(abs(tav)   .le. roundff) ratiot  = 1.0 + avef24a
c
      diff23       = ratios - 1.0
      diff24a      = ratiot - 1.0
c
      write(kuout,1375) jj0,psivl1(jj0),sav,avef23, ratios,diff23
     &                          ,avef24,tav,avef24a,ratiot,diff24a
 80   continue
c 
c
c 2.5 Write out the plasma boundary quantities
c
      write(kuout,1400)
      do 95  i     = 1,ithtp
      ii           = i
      write(kuout,1410) ii,rsrf(ii),zsrf(ii),chic(ii),chie(ii),
     &                     dydx(ii),xjsc(ii)
 95   continue
c
c
c
c 3.0 Write out the basic mapping quantities
c
c 3.1 Print the tables of alternative flux mesh into standard output file
c
c 3.1.1 Print the tables of alternative flux mesh: psi, sqrt(psi), and rho into
c
      write(kuout,2000)
      write(kuout,2020) rh2tot,rhotot
      write(kuout,2025)
      write(kuout,2030) (jj,  qp1    (jj),psivl1 (jj)
     &                                   ,psivalu(jj),psinorm(jj)
     &                                   ,psisqrt(jj),psirho2(jj)
     &                                   ,psirhov(jj),psinrho(jj)
     &                                               ,jj=1,jpsi2)
c
c 3.1.2 Print the tables of alternative flux mesh: toroidal flux and volume
c
c 3.1.2.1 Print the logarithmic contributions in divertor cases
      if    (ndivert .eq. 0) then
         write(kuout,2035) anltflxp,dvrtflxp,anltvolp,dvrtvolp
         write(kuout,2040) analtflx,divrtflx,analtvol,divrtvol
         write(kuout,2045) ndivert,flxtot,voltot
      elseif(ndivert .ne. 0) then
         write(kuout,2035) anltflxp,dvrtflxp,anltvolp,dvrtvolp
         write(kuout,2040) analtflx,divrtflx,analtvol,divrtvol
         write(kuout,2050) ndivert,flxtot,voltot
         write(kutty,2035) anltflxp,dvrtflxp,anltvolp,dvrtvolp
         write(kutty,2040) analtflx,divrtflx,analtvol,divrtvol
         write(kutty,2050) ndivert,flxtot,voltot
      endif
c
c 3.1.2.2 Print the tables
      write(kuout,2060)
      write(kuout,2065) (jj,  qp1    (jj),psivl1 (jj)
     &                                   ,psitorf(jj),psintor(jj)
     &                                   ,psisqtf(jj),psivolm(jj)
     &                                   ,psinvol(jj),psisqvl(jj)
     &                                   ,jj=1,jpsi2)
c
c 3.1.3 Print the derivatives
c
       write(kuout,2070)
       write(kuout,2075) (jj,  qp1    (jj),qprim1 (jj),psivl1 (jj)
     &                        ,dpsirh2(jj),dpsirho(jj),dpsinrh(jj)
     &                        ,jj=1,jpsi2)
       write(kuout,2080)
       write(kuout,2085) (jj,  qp1    (jj),qprim1 (jj),psivl1 (jj)
     &                        ,dpsitor(jj),dpsintf(jj),dpsisqt(jj)
     &                        ,jj=1,jpsi2)
       write(kuout,2090)
       write(kuout,2095) (jj,  qp1    (jj),qprim1 (jj),psivl1 (jj)
     &                        ,dpsivol(jj),dpsinvl(jj),dpsisqv(jj)
     &                        ,jj=1,jpsi2)
c
c
c 3.2 Print the q specific data
c
c 3.2.1 Print the q profile extrema
c
      if    (jqmin .le.   1                         ) then
         write(kuout,2100)
         write(kutty,2100)
      elseif(jqmin .gt.   1  .and.  jqmin .lt. jpsi2) then
         write(kuout,2105)
         write(kutty,2105)
      elseif(jqmin .ge. jpsi2                       ) then
         write(kuout,2110)
         write(kutty,2110)
      endif
c
      if    (jqmax .lt. jpsi2) then
         write(kuout,2115)
         write(kutty,2115)
      endif
c
      write(kuout,2120) jqmin,jqmax,jpsi2
     &                             ,psimax,pminvl,pmaxvl,psilim
     &                             ,qaxe,  qminvl,qpminv
     &                                ,qmaxvl,qlim,  qpmaxv
      write(kutty,2120) jqmin,jqmax,jpsi2
     &                             ,psimax,pminvl,pmaxvl,psilim
     &                             ,qaxe,  qminvl,qpminv
     &                             ,qmaxvl,qlim,  qpmaxv
c
      write(kuout,2125) psivlmnq,psivlmxq,psivnmnq,psivnmxq
     &                 ,psisqmnq,psisqmxq
     &                 ,psir2mnq,psir2mxq,dpsr2mnq,dpsr2mxq
     &                 ,psirhmnq,psirhmxq,dpsrhmnq,dpsrhmxq
     &                 ,psinrmnq,psinrmxq,dpsnrmnq,dpsnrmxq
     &                 ,psitfmnq,psitfmxq,dpstfmnq,dpstfmxq
     &                 ,psintmnq,psintmxq,dpsntmnq,dpsntmxq
     &                 ,psistmnq,psistmxq,dpsstmnq,dpsstmxq
     &                 ,psivmmnq,psivmmxq,dpsvmmnq,dpsvmmxq
     &                 ,psinvmnq,psinvmxq,dpsnvmnq,dpsnvmxq
     &                 ,psisvmnq,psisvmxq,dpssvmnq,dpssvmxq
      write(kutty,2130) psivlmnq,psivlmxq,psivnmnq,psivnmxq
     &                 ,psisqmnq,psisqmxq
     &                 ,psinrmnq,psinrmxq,dpsnrmnq,dpsnrmxq
     &                 ,psisvmnq,psisvmxq,dpssvmnq,dpssvmxq
c
c 3.2.2 Print out the q = 1 data
c
      if    (nq1totl .ne. 0) then
         write(kuout,2140) nq1totl
         write(kuout,2145)
         write(kuout,2150) (lq,psinrhq (lq),epslrh1 (lq)
     &                        ,shearrh1(lq),shearfrh(lq)
     &                                     ,lq=1,nq1totl)
         write(kuout,2155)
         write(kuout,2160) (lq,psisqvq (lq),epslvl1 (lq)
     &                        ,shearvl1(lq),shearfvl(lq)
     &                                     ,lq=1,nq1totl)
c
         write(kutty,2140) nq1totl
         write(kutty,2145)
         write(kutty,2150) (lq,psinrhq (lq),epslrh1 (lq)
     &                        ,shearrh1(lq),shearfrh(lq)
     &                                     ,lq=1,nq1totl)
         write(kutty,2155)
         write(kutty,2160) (lq,psisqvq (lq),epslvl1 (lq)
     &                        ,shearvl1(lq),shearfvl(lq)
     &                                     ,lq=1,nq1totl)
      endif
c
c 3.2.3 Print the mesh values at rational surfaces
c
      write(kuout,2200) rminor,  zminor,  rcentr,  rcnt
     &                 ,asprat00,asprat01,asprat10,asprat11
      write(kuout,2210) numbqs
      if(numbqs .gt. 0) then
         write(kuout,2215)
         write(kuout,2220) (lpsiq  (lq)
     &                     ,qvalue (lq),psivlq (lq)
     &                     ,psivalq(lq),psinrmq(lq),psisqrq(lq)
     &                     ,psirh2q(lq),psirhoq(lq),psinrhq(lq)
     &                     ,lq=1,numbqs)
c
         write(kuout,2230) asprat00,asprat01,asprat10,asprat11
         write(kuout,2240)
         write(kuout,2250) (lpsiq  (lq)
     &                     ,qvalue (lq),psivlq (lq)
     &                     ,psitorq(lq),psintfq(lq),psisqtq(lq)
     &                     ,psivolq(lq),psinvlq(lq),psisqvq(lq)
     &                     ,lq=1,numbqs)
c
         write(kuout,2260)
         write(kuout,2265) (lpsiq  (lq)
     &                     ,qvalue (lq),psivlq (lq),qprimq (lq)
     &                     ,dpsir2q(lq),dpsirhq(lq),dpsinrq(lq)
     &                                                ,lq=1,numbqs)
c
         write(kuout,2270)
         write(kuout,2275) (lpsiq  (lq)
     &                     ,qvalue (lq),psivlq (lq),qprimq (lq)
     &                     ,dpsitfq(lq),dpsintq(lq),dpsistq(lq)
     &                                                ,lq=1,numbqs)
c
         write(kuout,2280)
         write(kuout,2285) (lpsiq  (lq)
     &                     ,qvalue (lq),psivlq (lq),qprimq (lq)
     &                     ,dpsivlq(lq),dpsinvq(lq),dpsisvq(lq)
     &                                                ,lq=1,numbqs)
c
         write(kuout,2230) asprat00,asprat01,asprat10,asprat11
         write(kuout,2290)
         write(kuout,2295) (lpsiq  (lq)
     &                     ,qvalue (lq),psivlq (lq),qprimq (lq)
     &                     ,shearps(lq),shearrh(lq),sheartf(lq)
     &                     ,shearvl(lq),lq=1,numbqs)
      endif
c
c
c 3.3 Print tables of profiles for mapping from poloidal and toroidal flux
c
c 3.3.1 Print tables of the profiles versus toroidal flux and
c       sqrt(toroidal flux)
c
c 3.3.1.1 Equilibrium profiles versus toroidal flux
      write(kuout,2300)
      write(kuout,2305)
      write(kuout,2310)       psinorm(  1  ),psintor(  1  )
     &                       ,psisqtf(  1  ),qp1    (  1  )
     &                       ,paxe,          ppaxe
     &                       ,faxe,          ffpaxe
      do 100 jj = 1,jpsi
      jjj       = jj
      jj0       = jpsi1 - jjj
      jj1       = jjj + 1
      write(kuout,2315) jjj,  psinorm(jj1),  psintor(jj1)
     &                       ,psisqtf(jj1),  qp1    (jj1)
     &                       ,p      (jj0),  pp     (jj0)
     &                       ,f      (jj0),  ffp    (jj0)
  100 continue
      write(kuout,2315) jpsi1,psinorm(jpsi2),psintor(jpsi2)
     &                       ,psisqtf(jpsi2),qp1    (jpsi2)
     &                       ,plim,          pplim
     &                       ,flim,          ffplim
c
c 3.3.1.2 Density and fast pressure profiles versus toroidal flux
      write(kuout,2320)
      write(kuout,2325)
      do 120 jj = 1,jpsi2
      jj0       = jj  - 1
      jj1       = jj
      write(kuout,2330) jj0,  psintor(jj1),  psisqtf(jj1)
     &                       ,psinorm(jj1),  psisqrt(jj1)
     &                       ,qp1    (jj1),  dnnova (jj1)
     &                                      ,pfnova (jj1)
  120 continue

c
c 3.3.1.3 Kinetic and fast ion pressure (kPa) versus sqrt(toroidal flux)
c
      write(kuout,2350) betaf,pfnorm,pffact
      write(kuout,2355)
      do 150 jj = 1,jpsi2
      jj0       = jj  - 1
      jj1       = jj
      write(kuout,2360) jj0,  psintor(jj1),  psisqtf(jj1)
     &                       ,psinorm(jj1),  psisqrt(jj1)
     &                       ,qp1    (jj1),  ptnova (jj1)
     &                       ,prnova (jj1),  pbnova (jj1)
  150 continue
c
c 3.3.1.4 Number density (10^19/m^3) and temperature (keV)
c         versus sqrt(toroidal flux)
c         This assumes Deuterium ion mass and p = nkT

c
      write(kuout,2370) zeffect,deutp
      write(kuout,2375)

      do 160 jj = 1,jpsi2
      jj0       = jj  - 1
      jj1       = jj
      write(kuout,2380) jj0,  psintor(jj1),  psisqtf(jj1)
     &                       ,psinorm(jj1),  qp1    (jj1)
     &                       ,tenova (jj1),  tinova (jj1)
     &                       ,denova (jj1),  dinova (jj1)
  160 continue
c
c
c 3.4 Write out the flux coordinate mesh
c
      if(ioutm .gt. 2) then
        write(kuout,2500)
        do 180 j       = 1,jpsi
        jj             = jpsi + 1 - j
c
        if(j .eq.   1 ) write(kuout,2510) jj,psival(jj)
        if(j .ne.   1   .and.  j .ne. jpsi) 
     &                  write(kuout,2515) jj,psival(jj)
        if(j .eq. jpsi) write(kuout,2520) jj,psival(jj)
        write(kuout,2530)
        do 170 i       = 1,itht,4
        ii0            = i
        ii1            = i+1
        ii2            = i+2
        ii3            = i+3
        if    (ii3 .le. itht) then
          write(kuout,2540) ii0,rs(ii0,jj),zs(ii0,jj)
     &                     ,ii1,rs(ii1,jj),zs(ii1,jj)
     &                     ,ii2,rs(ii2,jj),zs(ii2,jj)
     &                     ,ii3,rs(ii3,jj),zs(ii3,jj)
        elseif(ii3 .gt. itht  .and.  ii2 .le. itht) then
          write(kuout,2545) ii0,rs(ii0,jj),zs(ii0,jj)
     &                     ,ii1,rs(ii1,jj),zs(ii1,jj)
     &                     ,ii2,rs(ii2,jj),zs(ii2,jj)
        elseif(ii2 .gt. itht  .and.  ii1 .le. itht) then
          write(kuout,2550) ii0,rs(ii0,jj),zs(ii0,jj)
     &                     ,ii1,rs(ii1,jj),zs(ii1,jj)
        elseif(ii1 .gt. itht  .and.  ii0 .le. itht) then
          write(kuout,2555) ii0,rs(ii0,jj),zs(ii0,jj)
        endif
  170   continue
  180   continue
      endif
c
c
c
c 4.0 Write out the equilibrium surface quantities
c
      if(ioutm .gt. 1) then
c
c
c 4.1 Write out the mesh quantities
c
c 4.1.1 Grid point values
c
        write(kuout,3000)
        do 220 j       = 1,jpsi1
        jj             = jpsi-j+1
c
        if(j .eq.   1  ) write(kuout,3005) j,jj,psival(jj)
        if(j .ne.   1  .and.  j .ne. jpsi1)
     &                   write(kuout,3010) j,jj,psival(jj)
        if(j .eq. jpsi1) write(kuout,3015) j,jj,psilim
        write(kuout,3020)
        do 200 i       = 1,ithtp
        write(kuout,3030) i, rcell  (j,i), zcell  (j,i),
     &                       dpsdr  (j,i), dpsdz  (j,i),
     &                       chiarcl(j,i), chipest(j,i),
     &                       chihaml(j,i)
  200   continue
  220   continue
c
c 4.1.2 Poloidal angle Jacobian and nonorthogonality
c
        write(kuout,3050)
        do 270 j       = 1,jpsi1
        jj             = jpsi-j+1
c
        if(j .eq.   1  ) write(kuout,3055) j,jj,psival(jj)
        if(j .ne.   1  .and.  j .ne. jpsi1)
     &                   write(kuout,3060) j,jj,psival(jj)
        if(j .eq. jpsi1) write(kuout,3065) j,jj,psilim
        write(kuout,3070)
        do 250 i       = 1,ithtp
        write(kuout,3080) i, xjcarcl(j,i), xjcpest(j,i),
     &                       xjchaml(j,i), alfarcl(j,i),
     &                       alfpest(j,i), alfhaml(j,i)
  250   continue
  270   continue
c
c
c 4.2 Write out the equilibrium quantities
c
        if(ioutm .gt. 2) then
          write(kuout,3100)
          do 320 j       = 1,jpsi1
          jj             = jpsi-j+1
c
          if(j .eq.   1  ) write(kuout,3105) j,jj,psival(jj)
          if(j .ne.   1  .and.  j .ne. jpsi1)
     &                     write(kuout,3110) j,jj,psival(jj)
          if(j .eq. jpsi1) write(kuout,3115) j,jj,psilim
          write(kuout,3120)
          do 300 i       = 1,ithtp
          write(kuout,3130) i, f3 (j,i), f4 (j,i), f5 (j,i), f7 (j,i),
     &                         f8 (j,i), f9 (j,i), f10(j,i)
  300     continue
  320     continue
c
c
c 4.3 Write out more equilibrium quantities
c
          write(kuout,3200)
          do 420 j       = 1,jpsi1
          jj             = jpsi-j+1
c
          if(j .eq.   1  ) write(kuout,3205) j,jj,psival(jj)
          if(j .ne.   1  .and.  j .ne. jpsi1)
     &                     write(kuout,3210) j,jj,psival(jj)
          if(j .eq. jpsi1) write(kuout,3215) j,jj,psilim
          write(kuout,3220)
          do 400 i       = 1,ithtp
          write(kuout,3230) i, f11(j,i), f12(j,i), f13(j,i), f14(j,i),
     &                         f15(j,i), f16(j,i), f17(j,i)
  400     continue
  420     continue
c
c
c 4.4 Write out more equilibrium quantities
c
          write(kuout,3300)
          do 520 j       = 1,jpsi1
          jj             = jpsi-j+1
          if(j .eq.   1  ) write(kuout,3305) j,jj,psival(jj)
          if(j .ne.   1  .and.  j .ne. jpsi1)
     &                     write(kuout,3310) j,jj,psival(jj)
          if(j .eq. jpsi1) write(kuout,3315) j,jj,psilim
c
          write(kuout,3320)
          do 500 i       = 1,ithtp
          write(kuout,3330) i, f18(j,i), f19(j,i), f20(j,i), f21(j,i),
     &                         f22(j,i), f23(j,i), f24(j,i)
  500     continue
  520     continue
c
c
c 4.5 Write out the remainder of the equilibrium quantities
c
          write(kuout,3400)
          do 620 j       = 1,jpsi1
          jj             = jpsi-j+1
c
          if(j .eq.   1  ) write(kuout,3405) j,jj,psival(jj)
          if(j .ne.   1  .and.  j .ne. jpsi1)
     &                     write(kuout,3410) j,jj,psival(jj)
          if(j .eq. jpsi1) write(kuout,3415) j,jj,psilim
          write(kuout,3420)
          do 600 i       = 1,ithtp
          write(kuout,3430) i, f25(j,i), f26(j,i), f27(j,i), f28(j,i)
  600     continue
  620     continue
        endif
      endif
c
c
c
c 5.0 Write out the global integrated deta
c
c 5.1 Write out the scalar data
c
      write(kutty,4000)
      write(kutty,4010) rcnt,rcgeom,aminor,epslon,capa,triangl,volme
      write(kutty,4020) btor,btnew,btave,bpave,totcur
      write(kutty,4030) faxe,flim,qaxe,qlim,psimax,psilim,psisep
      write(kutty,4040) betat,betap,betax0,betax1,bpornl,allim
     &                 ,deltal,vhalf
      write(kutty,4050) vp0,pmantl,welln,eaxe,taxe,btmer,qmer
     &                 ,qsurf,q0surf,qcyl
c
      write(kuout,4000)
      write(kuout,4010) rcnt,rcgeom,aminor,epslon,capa,triangl,volme
      write(kuout,4020) btor,btnew,btave,bpave,totcur
      write(kuout,4030) faxe,flim,qaxe,qlim,psimax,psilim,psisep
      write(kuout,4040) betat,betap,betax0,betax1,bpornl,allim
     &                 ,deltal,vhalf
      write(kuout,4050) vp0,pmantl,welln,eaxe,taxe,btmer,qmer
     &                 ,qsurf,q0surf,qcyl
c
c
c 5.2 Print out the flux average quantities
c
      write(kuout,5000)
      write(kuout,5010)
      do 700 j     = 1,jpsi1
      write(kuout,5020)  j, psival(j), p    (j), pp   (j), f     (j)
     &                    , ffp   (j), qp   (j), vpm  (j), apm   (j) 
     &                    , vcurnt(j),vdpsi(jpsi+2-j),well (jpsi+2-j)
  700 continue
c
c
c 5.3 Print data for EFIT input
c
      write(kuout,6000)
      write(kuout,6010) jpsi2,ithtp
      write(kuout,6020) totcur,bfieldf,rdefolt
      write(kuout,6030) xma,zma
      write(kuout,6100) jpsi1
      write(kuout,6110) (psinorm(j),j=1,jpsi2)
      write(kuout,6200) jpsi1
      write(kuout,6210) paxe,  (p      (j),j=jpsi,1,-1),plim
      write(kuout,6220) jpsi1
      write(kuout,6230) faxe,  (f      (j),j=jpsi,1,-1),flim
      write(kuout,6240) jpsi1
      write(kuout,6250) ppaxe, (pp     (j),j=jpsi,1,-1),pplim
      write(kuout,6260) jpsi1
      write(kuout,6270) ffpaxe,(ffp    (j),j=jpsi,1,-1),ffplim
c
      write(kuout,6300) ithtp
      write(kuout,6310) (rsrf(i),i=1,ithtp)
      write(kuout,6320) ithtp
      write(kuout,6330) (zsrf(i),i=1,ithtp)
c
c
c
c 6.0 Return and end
c
      return
 1000 format(//,5x, 'Equilibrium Flux Quantities:'
     &      ,//,5x,'psimax   = ',e14.7,4x,'psilim   = ',e14.7
     &         ,4x,'delpsir  = ',e14.7)
 1010 format(//,10x,'Source flux quantities:'
     &      ,//,5x,'Plasma axis values:'
     &       ,/,11x,'psimax',7x,'ppaxe',8x,'ffpaxe',8x,'paxe'
     &         ,9x,'faxe',8x,'dnaxe',8x,'pfaxe',7x,'qaxe'
     &         ,8x,'fqiaxe',8x,'fqmaxe',/)
 1020 format(1x,i5,10(1x,e12.5))
 1030 format(//,5x,'Internal plasma values:'
     &       ,/,5x,'j',5x,'psival',9x,'pp',10x,'ffp',12x,'p'
     &         ,12x,'f',9x,'dnsty',8x,'pfast',10x,'q',10x,'fqpi'
     &         ,9x,'fqim'/)
 1040 format(1x,i5,10(1x,e12.5))
 1050 format(5x,'0',10(1x,e12.5))
 1100 format(//,10x,'Equilibrium coordinate flux quantities:'
     &       ,/,5x,'j',5x,'psival',6x,'arcnorm',6x,'pstnorm'
     &         ,6x,'hamnorm',6x,'dlnlval',6x,'dpnlval'
     &         ,6x,'dhnlval',/)
 1110 format(5x,'0',7(1x,e12.5))
 1115 format(1x,i5,7(1x,e12.5))
 1200 format(//,10x,'Auxiliary flux quantities:')
 1210 format(/,  5x,'Nominal Limiter positions:' 
     &       /,  5x,'xlim     = ',e14.7,4x,'zlim     = ',e14.7)
 1220 format(    5x,'j',5x,'psivl0',10x,'rst',10x,'rstp'
     &          ,8x,'rstdif',10x,'zst',9x,'zstp'
     &          ,8x,'zstdif',/)
 1230 format(1x,i5,1x,e12.5,2x,3(1x,e12.5),2x,3(1x,e12.5))
 1250 format(//,10x,'Shear at half mesh points:'
     &       ,/,5x,'j',4x,'jp',5x,'psihalf',7x,'qdel',/)
 1260 format(2(1x,i5),2(1x,e12.5))
 1300 format(//,10x,'Flux surface integrals:'
     &       ,/,5x,'j',5x,'psival',7x,'sint0',8x,'sint1',8x,'sint2'
     &         ,8x,'sint3',8x,'sint4',/)
 1310 format(5x,'0',6(1x,e12.5))
 1315 format(1x,i5,6(1x,e12.5))
 1320 format(//,10x,'Normalized Flux surface integrals:'
     &       ,/,5x,'j',5x,'psival',4x,'sint1/sint0',2x,'sint2/sint0'
     &         ,2x,'sint3/sint0',2x,'sint4/sint0',5x,'savge'
     &         ,8x,'tavge',/)
 1330 format(5x,'0',7(1x,e12.5))
 1335 format(1x,i5,7(1x,e12.5))
 1350 format(//,10x,'Integrals compared to qp and qdel:'
     &       ,/,5x,'j',5x,'psival',8x,'qp',11x,'qval'
     &         ,9x,'qdel',7x,'qprime',5x,'q(dpnl-fp/f)',/)
 1360 format(5x,'0',3(1x,e12.5),14x,e12.5,1x,e12.5)
 1365 format(1x,i5,6(1x,e12.5))
 1370 format(//,10x,'Integrals compared to f23 and f24 averages:'
     &       ,/,5x,'j',4x,'psival',5x,'savge*sint0'
     &         ,5x,'avef23',6x,'avef23/S',4x,'avef23-S'
     &         ,6x,'avef24',4x,'tavge*sint0',1x,'ave(f24+1/2S)'
     &         ,1x,'ave(T+1/2S)/T',1x,'ave(f24+1/2S)-T',/)
 1375 format(1x,i5,10(1x,e12.5))
 1400 format(//,5x,'Plasma surface quantities:',/
     &         ,4x,'i',6x,'rsrf',10x,'zsrf',9x,'chic'
     &                ,9x,'chie',9x,'dydx',9x,'xjsc',/)
 1410 format(1x,i5,6(1x,e12.5))
 2000 format(//, 5x,'Radial Mesh Data')
 2020 format(/, 10x,'Meshes:'
     &      ,//,10x,'rh2tot  = ',e12.5,4x,'rhotot  = ',e12.5)
 2025 format(/,  4x,'jj',7x,'qp1',12x,'psivl1'
     &                  ,8x,'psivalu',8x,'psinorm',8x,'psisqrt'
     &                  ,8x,'psirho2',8x,'psirhov',8x,'psinrho'/)
 2030 format((2x,i5,1x,e14.7,7(1x,e14.7)))
 2035 format(//,5x,'Analytic divertor contributions:'
     &         ,1x,'Penultimate interval:'
     &       ,/,5x,'anltflxp = ',e12.5,4x,'dvrtflxp = ',e12.5
     &       ,/,5x,'anltvolp = ',e12.5,4x,'dvrtvolp = ',e12.5)
 2040 format(//,5x,'Analytic divertor contributions:'
     &         ,1x,'Final interval:'
     &       ,/,5x,'analtflx = ',e12.5,4x,'divrtflx = ',e12.5
     &       ,/,5x,'analtvol = ',e12.5,4x,'divrtvol = ',e12.5)
 2045 format(/, 5x,'Analytic contributions not included in'
     &         ,1x,'final interval:'
     &         ,2x,'ndivert  = 'i5
     &       ,/,5x,'flxtot   = ',e12.5,4x,'voltot   = ',e12.5)
 2050 format(/, 5x,'Analytic contributions are included in'
     &         ,1x,'final interval:'
     &         ,2x,'ndivert  = 'i5
     &       ,/,5x,'flxtot   = ',e12.5,4x,'voltot   = ',e12.5)
 2060 format(/,4x,'jj',7x,'qp1',12x,'psivl1'
     &                ,8x,'psitorf',8x,'psintor',8x,'psisqtf'
     &                ,8x,'psivolm',8x,'psinvol',8x,'psisqvl'/)
 2065 format((2x,i5,1x,e14.7,7(1x,e14.7)))
 2070 format(//,10x,'Radial Derivatives:'
     &     ,//,4x,'jj',7x,'qp1',12x,'qprim1',8x,'psivl1'
     &        ,8x,'dpsi/drho2',5x,'dpsi/drhov',5x,'dpsi/dnrho',/)
 2075 format((2x,i5,1x,e14.7,5(1x,e14.7)))
 2080 format(//,4x,'jj',7x,'qp1',12x,'qprim1',8x,'psivl1'
     &        ,8x,'dpsi/dtorf',5x,'dpsi/dntor',5x,'dpsi/dsqtf',/)
 2085 format((2x,i5,1x,e14.7,5(1x,e14.7)))
 2090 format(//,4x,'jj',7x,'qp1',12x,'qprim1',8x,'psivl1'
     &        ,8x,'dpsi/dvolm',5x,'dpsi/dnvol',5x,'dpsi/dsqvl',/)
 2095 format((2x,i5,1x,e14.7,5(1x,e14.7)))
 2100 format(//,10x,'Safety Factor Extrema:'
     &      ,//, 5x,'Minimum q coincides with q on axis:')
 2105 format(//,10x,'Safety Factor Extrema:'
     &       ,/, 5x,'Minimum q is off axis:')
 2110 format(//,10x,'Safety Factor Extrema:'
     &       ,/, 5x,'Strongly Inverted q profile:'
     &       ,/, 5x,'Minimum q is at the plasma surface:')
 2115 format( /, 5x,'Strongly Inverted q profile:'
     &       ,/, 5x,'Maximum q is not at the plasma surface :')
 2120 format(    5x,'jqmin    = ',i5,   11x,'jqmax    = ',i5
     &         ,11x,'jpsi2    = ',i5
     &       ,/, 5x,'psimax   = ',e12.5, 4x,'pminvl   = ',e12.5
     &         , 4x,'pmaxvl   = ',e12.5, 4x,'psilim   = ',e12.5
     &       ,/, 5x,'qaxe     = ',e12.5, 4x,'qminvl   = ',e12.5
     &         , 4x,'qpminv   = ',e12.5
     &       ,/, 5x,'qmaxvl   = ',e12.5, 4x,'qlim     = ',e12.5
     &         , 4x,'qpmaxv   = ',e12.5)
 2125 format(/,  5x,'Radius of minimum and maximum q:'
     &      ,//,19x,'Minimum',20x,'Maximum',6x,'(Radial Variable)'
     &       ,/, 5x,'psivlmnq = ',e12.5, 4x,'psivlmxq = ',e12.5
     &         , 4x,'(Poloidal flux)'
     &       ,/, 5x,'psinmmnq = ',e12.5, 4x,'psinmmxq = ',e12.5
     &         , 4x,'(Normalized poloidal flux)'
     &       ,/, 5x,'psisqmnq = ',e12.5, 4x,'psisqmxq = ',e12.5
     &         , 4x,'(Square root of normalized poloidal flux)'
     &      ,//, 5x,'psir2mnq = ',e12.5, 4x,'psir2mxq = ',e12.5
     &         , 4x,'(Square of radius on outboard midplane)'
     &       ,/, 5x,'dpsr2mnq = ',e12.5, 4x,'dpsr2mxq = ',e12.5
     &      ,//, 5x,'psirhmnq = ',e12.5, 4x,'psirhmxq = ',e12.5
     &         , 4x,'(Radius on outboard midplane)'
     &       ,/, 5x,'dpsrhmnq = ',e12.5, 4x,'dpsrhmxq = ',e12.5
     &      ,//, 5x,'psinrmnq = ',e12.5, 4x,'psinrmxq = ',e12.5
     &         , 4x,'(Normalized radius on outboard midplane)'
     &       ,/, 5x,'dpsnrmnq = ',e12.5, 4x,'dpsnrmxq = ',e12.5
     &      ,//, 5x,'psitfmnq = ',e12.5, 4x,'psitfmxq = ',e12.5
     &         , 4x,'(Toroidal flux)'
     &       ,/, 5x,'dpstfmnq = ',e12.5, 4x,'dpstfmxq = ',e12.5
     &      ,//, 5x,'psintmnq = ',e12.5, 4x,'psintmxq = ',e12.5
     &         , 4x,'(Normalized toroidal flux)'
     &       ,/, 5x,'dpsntmnq = ',e12.5, 4x,'dpsntmxq = ',e12.5
     &      ,//, 5x,'psistmnq = ',e12.5, 4x,'psistmxq = ',e12.5
     &         , 4x,'(Square root of normalized toroidal flux)'
     &       ,/, 5x,'dpsstmnq = ',e12.5, 4x,'dpsstmxq = ',e12.5
     &      ,//, 5x,'psivmmnq = ',e12.5, 4x,'psivmmxq = ',e12.5
     &         , 4x,'(Volume within the surface)'
     &       ,/, 5x,'dpsvmmnq = ',e12.5, 4x,'dpsvmmxq = ',e12.5
     &      ,//, 5x,'psinvmnq = ',e12.5, 4x,'psinvmxq = ',e12.5
     &         , 4x,'(Normalized Volume)'
     &       ,/, 5x,'dpsnvmnq = ',e12.5, 4x,'dpsnvmxq = ',e12.5
     &      ,//, 5x,'psisvmnq = ',e12.5, 4x,'psisvmxq = ',e12.5
     &         , 4x,'(Square root of normalized volume)'
     &       ,/, 5x,'dpssvmnq = ',e12.5, 4x,'dpssvmxq = ',e12.5)
 2130 format(/,  5x,'Radius of minimum and maximum q:'
     &       ,/, 5x,'psivlmnq = ',e12.5, 4x,'psivlmxq = ',e12.5
     &         , 4x,'(Poloidal flux)'
     &       ,/, 5x,'psinmmnq = ',e12.5, 4x,'psinmmxq = ',e12.5
     &         , 4x,'(Normalized poloidal flux)'
     &       ,/, 5x,'psisqmnq = ',e12.5, 4x,'psisqmxq = ',e12.5
     &         , 4x,'(Square root of normalized poloidal flux)'
     &      ,//, 5x,'psinrmnq = ',e12.5, 4x,'psinrmxq = ',e12.5
     &         , 4x,'(Normalized radius on outboard midplane)'
     &       ,/, 5x,'dpsnrmnq = ',e12.5, 4x,'dpsnrmxq = ',e12.5
     &      ,//, 5x,'psisvmnq = ',e12.5, 4x,'psisvmxq = ',e12.5
     &         , 4x,'(Square root of normalized volume)'
     &       ,/, 5x,'dpssvmnq = ',e12.5, 4x,'dpssvmxq = ',e12.5)
 2140 format(// ,5x,'Equilibrium analysis at q = 1 surfaces:'
     &          ,3x,'nq1totl  = ',i5,1x,':')
 2145 format(    5x,'Using r = rho:')
 2150 format(    5x,'For q = 1 surface #',i5
     &      ,/, 10x,'r(q=1)/a                  (psinrhq)  = ',e16.8
     &      ,/, 10x,'r(q=1)/R0                 (epslrh1)  = ',e16.8
     &      ,/ ,10x,'shear(q=1)                (shearrh1) = ',e16.8
     &      ,/ ,10x,'shear(q=1)*(r(q=1)/R0)**2 (shearfrh) = ',e16.8)
 2155 format(    5x,'Using r = sqrt(vol):')
 2160 format(    5x,'For q = 1 surface #',i5
     &      ,/, 10x,'r(q=1)/a                  (psisqvq)  = ',e16.8
     &      ,/ ,10x,'r(q=1)/R0                 (epslvl1)  = ',e16.8
     &      ,/ ,10x,'shear(q=1)                (shearvl1) = ',e16.8
     &      ,/ ,10x,'shear(q=1)*(r(q=1)/R0)**2 (shearfvl) = ',e16.8)
 2200 format(/, 10x,'Plasma Geometrical Normalizations:' 
     &      ,/,  5x,'rminor   = ',e12.5,4x,'zminor   = ',e12.5
     &          ,4x,'rcentr   = ',e12.5,4x,'rcnt     = ',e12.5
     &      ,/,  5x,'asprat00 (rminor/rcnt)                 = ',e12.5
     &      ,/,  5x,'asprat01 (rminor/rcentr)               = ',e12.5
     &      ,/,  5x,'asprat10 (sqrt(rminor*zminor) / rcnt)  = ',e12.5
     &      ,/,  5x,'asprat11 (sqrt(rminor*zminor) / rcentr)= ',e12.5)
 2210 format(//,10x,'Rational Psi values:  numbqs = ',i6)
 2215 format(/  ,5x, 'lpsiq', 3x,'qvalue', 7x,'psivlq'
     &          ,8x,'psivalq',8x,'psinrmq',8x,'psisqrq'
     &          ,8x,'psirh2q',8x,'psirhoq',8x,'psinrhq',/)
 2220 format((   2x,i6,4x,a8,7(1x,e14.7)))
 2230 format(//, 5x,'asprat00 = ',e12.5,4x,'asprat01 = ',e12.5
     &          ,4x,'asprat10 = ',e12.5,4x,'asprat11 = ',e12.5)
 2240 format(/  ,5x, 'lpsiq', 3x,'qvalue', 7x,'psivlq'
     &          ,8x,'psitorq',8x,'psintfq',8x,'psisqtq'
     &          ,8x,'psivolq',8x,'psinvlq',8x,'psisqvq',/)
 2250 format((   2x,i6,4x,a8,7(1x,e14.7)))
 2260 format(/  ,5x, 'lpsiq',3x,'qvalue',7x,'psivlq',9x,'qprimq'
     &          ,8x,'dpsir2q',8x,'dpsirhq',8x,'dpsinrq',/)
 2265 format((   2x,i6,4x,a8,5(1x,e14.7)))
 2270 format(/  ,5x, 'lpsiq',3x,'qvalue',7x,'psivlq',9x,'qprimq'
     &          ,8x,'dpsitfq',8x,'dpsintq',8x,'dpsistq',/)
 2275 format((   2x,i6,4x,a8,5(1x,e14.7)))
 2280 format(/  ,5x, 'lpsiq',3x,'qvalue',7x,'psivlq',9x,'qprimq'
     &          ,8x,'dpsivlq',8x,'dpsinvq',8x,'dpsisvq',/)
 2285 format((   2x,i6,4x,a8,5(1x,e14.7)))
 2290 format(/  ,5x, 'lpsiq',3x,'qvalue',7x,'psivlq',9x,'qprimq'
     &          ,8x,'shearps',8x,'shearrh',8x,'sheartf',8x,'shearvl'/)
 2295 format((   2x,i6,4x,a8,6(1x,e14.7)))
 2300 format(//, 5x,'Equilibrium profiles in terms of Toroidal Flux')
 2305 format(/  ,4x,'jj',6x,'psinorm',9x,'psintor',8x,'psisqtf'
     &          ,9x,'qp',14x,'p',11x,'pprime',12x,'f'
     &          ,10x,'ffprime',/)
 2310 format((6x,'0',8(1x,e14.7)))
 2315 format((2x,i5,8(1x,e14.7)))
 2320 format(//, 5x,'Normalized mass density and fast ion pressure'
     &          ,1x,'in terms of Toroidal Flux')
 2325 format(/  ,4x,'jj',6x,'psintor',8x,'psisqtf',8x,'psinorm'
     &          ,8x,'psisqrt',10x,'qp',12x,'dnsty',10x,'pfast'/)
 2330 format((2x,i5,7(1x,e14.7)))
 2350 format(//, 5x,'Pressure profiles in terms of'
     &          ,1x,'sqrt(Toroidal Flux)'
     &      ,//, 5x,'betaf   = ',f8.4,10x,'pfnorm = ',e14.7
     &          ,4x,'pffact  = ',e14.7)
 2355 format(/  ,4x,'jj',6x,'psintor',8x,'psisqtf',8x,'psinorm'
     &          ,8x,'psisqrt',10x,'qp',8x,'Ptotal (kPa)'
     &          ,3x,'Pthermal (kPa)',1x,'betaf*Pf (kPa)',/)
 2360 format((2x,i5,8(1x,e14.7)))
 2370 format(//, 5x,'Temperature and density profiles in terms of'
     &          ,1x,'sqrt(Toroidal Flux)'
     &      ,//, 5x,'zeffct  = ',f8.4,4x,'deutp  = ',f8.4)
 2375 format(/  ,4x,'jj',6x,'psintor',8x,'psisqtf',8x,'psinorm'
     &          ,10x,'qp',11x,'Te (keV)',7x,'Ti (keV)'
     &           ,4x,'ne (10^19/m^3)',1x,'ni (10^19/m^3)',/)
 2380 format((2x,i5,8(1x,e14.7)))
 2500 format(//,5x,'Equilibrium mapping quantities:')
 2510 format(/,5x,'j = ',i5,3x,'psi = ',e12.5,2x,'(Innermost surface)'
     &      ,/)
 2515 format(/,5x,'j = ',i5,3x,'psi = ',e12.5)
 2520 format(/,5x,'j = ',i5,3x,'psi = ',e12.5,2x,'(Outermost surface)'
     &      ,/)
 2530 format(5x,'i',6x,'rs',10x,'zs',10x,'i',6x,'rs',10x,'zs'
     &     ,10x,'i',6x,'rs',10x,'zs',10x,'i',6x,'rs',10x,'zs')
 2540 format(1x,4(i5,2(1x,e12.5)))
 2545 format(1x,3(i5,2(1x,e12.5)))
 2550 format(1x,2(i5,2(1x,e12.5)))
 2555 format(1x,i5,2(1x,e12.5))
 3000 format(//,5x,'Flux surface mesh quantities:')
 3005 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Innermost surface)',/)
 3010 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5,/)
 3015 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Plasma boundary surface)')
 3020 format(5x,'i',5x,'rcell',9x,'zcell',7x,'dpsdr',8x,'dpsdz'
     &                        ,8x,'arcl', 9x,'pest', 9x,'haml',/)
 3030 format(1x,i5,7(1x,e12.5))
 3050 format(//,5x,'Flux surface Jacobian quantities:')
 3055 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Innermost surface)',/)
 3060 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5,/)
 3065 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Plasma boundary surface)')
 3070 format(5x,'i',4x,'xjcarcl',6x,'xjcpest',6x,'xjchaml'
     &             ,6x,'alfarcl',6x,'alfpest',6x,'alfhaml',/)
 3080 format(1x,i5,6(1x,e12.5))
 3100 format(//,5x,'Flux surface equilibrium quantities:')
 3105 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Innermost surface)',/)
 3110 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5,/)
 3115 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Plasma boundary surface)',/)
 3120 format(5x,'i',6x,'f3 ',10x,'f4 ',10x,'f5 ',10x,'f7 '
     &       ,10x,'f8 ',10x,'f9 ',9x,'f10',/)
 3130 format(1x,i5,7(1x,e12.5))
 3200 format(//,5x,'Flux surface equilibrium quantities:')
 3205 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Innermost surface)',/)
 3210 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5,/)
 3215 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Plasma boundary surface)',/)
 3220 format(5x,'i',6x,'f11',10x,'f12',10x,'f13',10x,'f14'
     &       ,10x,'f15',10x,'f16',10x,'f17',/)
 3230 format(1x,i5,7(1x,e12.5))
 3300 format(//,5x,'Flux surface equilibrium quantities:')
 3305 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Innermost surface)',/)
 3310 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5,/)
 3315 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Plasma boundary surface)',/)
 3320 format(5x,'i',6x,'f18',10x,'f19',10x,'f20',10x,'f21'
     &       ,10x,'f22',10x,'f23',10x,'f24',/)
 3330 format(1x,i5,7(1x,e12.5))
 3400 format(//,5x,'Flux surface equilibrium quantities:')
 3405 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Innermost surface)',/)
 3410 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5,/)
 3415 format(/,5x,'j = ',i5,3x,'jj = ',i5,3x,'psi = ',e12.5
     &        ,2x,'(Plasma boundary surface)',/)
 3420 format(5x,'i',6x,'f25',10x,'f26',10x,'f27',10x,'f28',/)
 3430 format(1x,i5,4(1x,e12.5))
 4000 format(//,5x,'Global integrated data:')
 4010 format(/, 5x,'rcnt    = ',e14.7,4x,'rcgeom  = ',e14.7,/
     &         ,5x,'aminor  = ',e14.7,4x,'epslon  = ',e14.7,/
     &         ,5x,'kappa   = ',e14.7,4x,'triangl = ',e14.7,/
     &         ,5x,'volume  = ',e14.7)
 4020 format(/ ,5x,'btor    = ',e14.7,4x,'btnew   = ',e14.7,/
     &         ,5x,'btave   = ',e14.7,4x,'bpave   = ',e14.7,/
     &         ,5x,'totcur  = ',e14.7)
 4030 format(/, 5x,'faxe    = ',e14.7,4x,'flim    = ',e14.7,/
     &         ,5x,'qaxe    = ',e14.7,4x,'qlim    = ',e14.7,/
     &         ,5x,'psimax  = ',e14.7,4x,'psilim  = ',e14.7,/
     &         ,5x,'psisep  = ',e14.7)
 4040 format(/, 5x,'betat   = ',e14.7,4x,'betap   = ',e14.7,/
     &         ,5x,'betax0  = ',e14.7,4x,'betax1  = ',e14.7,/
     &         ,5x,'bpornl  = ',e14.7,4x,'allim   = ',e14.7,/
     &         ,5x,'deltal  = ',e14.7,4x,'vhalf   = ',e14.7)
 4050 format(/, 5x,'vp0     = ',e14.7,4x,'mantle  = ',e14.7
     &         ,4x,'well    = ',e14.7,/
     &         ,5x,'eaxe    = ',e14.7,4x,'taxe    = ',e14.7,/
     &         ,5x,'btmer   = ',e14.7,4x,'qmer    = ',e14.7,/
     &         ,5x,'qsurf   = ',e14.7,4x,'q0surf  = ',e14.7,/
     &         ,5x,'qcyl    = ',e14.7)
 5000 format(//,5x,'Flux averaged Magnetic Well quantities:')
 5010 format(/, 4x,'j',5x,'psi',11x,'p',10x,'pp',11x,'f',9x,'ffp'
     &        ,10x,'q',10x,'vpm',9x,'apm',7x,'currnt',7x,'vdpsi'
     &        ,8x,'well',/)
 5020 format(1x,i4,11(1x,e11.4))
 6000 format(//,1x,'Input Data for Fixed Boundary EFIT:')
 6010 format(/ ,1x,'jpsi2   = ',i5,4x,'ithtp   = ',i5)
 6020 format(/, 1x,'totcur  = ',e14.7
     &      ,/, 1x,'bfieldf = ',e14.7
     &      ,/, 1x,'rdefolt = ',e14.7)
 6030 format(/, 1x,'xmaxis  = ',e14.7
     &      ,/, 1x,'zmaxis  = ',e14.7)
 6100 format(/ ,1x,'Normalized psi values: j = 0,',i5)
 6110 format(10(1x,e12.5))
 6200 format(/ ,1x,'Pressure values: j = 0,',i5)
 6210 format(10(1x,e12.5))
 6220 format(/ ,1x,'Toroidal Field function values: j = 0,',i5)
 6230 format(10(1x,e12.5))
 6240 format(/ ,1x,'Pressure gradient values: j = 0,',i5)
 6250 format(10(1x,e12.5))
 6260 format(/ ,1x,'ffprime values: j = 0,',i5)
 6270 format(10(1x,e12.5))
 6300 format(/ ,1x,'R boundary values: i = 0,',i5)
 6310 format(10(1x,e12.5))
 6320 format(/ ,1x,'Z boundary values: i = 0,',i5)
 6330 format(10(1x,e12.5))
      end
      subroutine writegrd
c
c -------------------------------------------------------------
c  Write out the mapped grid
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
      character*1   lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst ,lbchvl, lbchsv
      character*8   pclab,  tclab,  labpsi, 
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/labels/lbchpv, lbchsp, lbchrh, lbchro,
     &              lbchtf, lbchst, lbchvl, lbchsv,
     &              pclab,  tclab,  labpsi,
     &              labpsiv,labpsin,labsqtp,
     &              labrhov,labrho2,labrhon,
     &              labtorf,labtorn,labsqtt,
     &              labvolm,labvoln,labsqtv,
     &              labdrh2,labdrho,labdtor,
     &              labdsqt,labdvol,labdsqv
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c
c 1.0 Write out the scalar data
c
      write(kugrd,1000)
      write(kugrd,1010) jpsi1,ithtp
      write(kugrd,1020) psimax
c
c
c
c 2.0 Write out the flux functions
c
c 2.1 Psi mesh including axis value
c
      write(kugrd,2000)
      write(kugrd,2010)  psivalu(1)
      write(kugrd,2020) (psivalu(jj),jj=2,jpsi2)
c
c
c 2.2 Volume coordinate including axis value
c
      write(kugrd,2100)
      write(kugrd,2110)  psivolm(1)
      write(kugrd,2120) (psivolm(jj),jj=2,jpsi2)
c
c
c 2.3 Volume derivative including axis value
c
      write(kugrd,2200)
      write(kugrd,2210)  dpsivol(1)
      write(kugrd,2220) (dpsivol(jj),jj=2,jpsi2)
c
c
c
c 3.0 Write out the mesh quantities
c
c 3.1 r cell centers
c
        write(kugrd,3000)
        do 200 j     = 1,jpsi1
        jj           = j
        write(kugrd,3050) (rcell  (jj,ii),ii = 1,ithtp)
  200   continue
c
c
c 3.2 z cell centers
c
        write(kugrd,3100)
        do 220 j     = 1,jpsi1
        jj           = j
        write(kugrd,3150) (zcell  (jj,ii),ii = 1,ithtp)
  220   continue
c
c
c
c 4.0 Return and end
c
      return
 1000 format(1x,'jpsi',3x,'itht')
 1010 format(2(1x,i6))
 1020 format(1x,'psi offset: psimax = ',e23.16)
 2000 format(1x,'psi mesh:')
 2010 format(1x,e23.16)
 2020 format(5(1x,e23.16))
 2100 format(1x,'Volume(psi):')
 2110 format(1x,e23.16)
 2120 format(5(1x,e23.16))
 2200 format(1x,'dVol/dpsi:')
 2210 format(1x,e23.16)
 2220 format(5(1x,e23.16))
 3000 format(1x,'r(psi,theta) mesh (cell centers):')
 3050 format(5(1x,e23.17))
 3100 format(1x,'z(psi,theta) mesh (cell centers):')
 3150 format(5(1x,e23.16))
      end
      subroutine volint
c
c -------------------------------------------------------------
c compute volume and line integrals
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize parameters
c
c 1.1.1 Initialize error flags and dimensions
c
      ier        = 0
      rndff      = roundff*sqrt(xdim*xdim + zdim*zdim)
c
      ngd1       = ndim1
      npd1       = np1
c
c 1.1.2 Set the mapping type
c
      kmap    = nmap
      ktype   = nmtype
c
      if(ktype .lt.  0  .or.  ktype .gt. 2) then
         call abortjob
     &        ('volint  ',  1,   'Invalid equilibrium type parameter  ' 
     &        ,'ktype   ', ktype,    'kmap    ', kmap,     -1)
         return
      endif
c
c 1.1.3 Initialize dimension parameters
c
      nlxv       = nlx
      ithlf      = itht/2
c
c 1.1.4 Initialize the search for the call to hbf
c
      if(ktype .eq. 0) then
        is         = 1
        js         = 1
        delxi      = 1.0/dmx
        delzi      = 1.0/dmz
      endif
c
c
c 1.2 Define the major radius and aspect ratio
c
      pi4        = twopi*twopi
      scmamp     = 1.0e+06
      pcutoff    = pvansh
      rmaxis     = smax(1)
      wfactr     = amu*rmaxis**2
      aminor     = 0.5*(rsrf(1)-rsrf(itht/2+1))
      rcgeom     = 0.5*(rsrf(1)+rsrf(itht/2+1))
      epslon     = aminor/rcgeom
      btold      = btor
      btnew      = btold*rcnt/rcgeom
      qcyl       = 5.0*scmamp*aminor**2*btnew/(rcgeom*totcur)
c
c
c 1.3 Scale q0 for qlim=qsurf
c
      zdisc      = 1.0  +  (flim/faxe)**2*((qsurf/qlim)**2 - 1.0)
      if(zdisc .ge. 0.0) then
        q0surf     = qaxe*sqrt(zdisc)
      else
        q0surf     = 0.0
      endif
c
c
c 1.4 Compute the plasma height
c
c 1.4.1 Find the highest grid point
      zzmax      = -bigno
      do 10 i    = 1,itht
      if(zsrf(i) .ge. zzmax) then
        zzmax      = zsrf(i)
        izmax      = i
      endif
  10  continue
c
      if(izmax .le.   1 ) izmax  = 2
      if(izmax .ge. itht) izmax  = itht-1
c
c 1.4.2 Fit the neighbouring points to a quadratic
c
      zr1        = rsrf(izmax-1)
      zr2        = rsrf(izmax)
      zr3        = rsrf(izmax+1)
      zz1        = zsrf(izmax-1)
      zz2        = zsrf(izmax)
      zz3        = zsrf(izmax+1)
c
c 1.4.3 Find the maximum of the fitted quadratic
c
      call intqad(zr1,zr2,zr3,zz1,zz2,zz3,za,zb,zc,ier)
      if(ier .ne. 0) call abortjob
     &        ('volint  ',  2,   'Interpolation error in intqad       '
     &        ,'ier     ', ier,      'izmax   ', izmax,    -1)
c
      zr0        = -0.5*zb/za
      zmax       = za*zr0**2 + zb*zr0 + zc
      capa       = zmax/aminor
      triangl    = (rcgeom-zr0)/aminor
c
c
c
c 2.0 Initialize
c
c 2.1.1 Initialize the volume integrated quantities
c
      btave      = 0.0
      bpave      = 0.0
      betap      = 0.0
      betat      = 0.0
      betax0     = 0.0
      betax1     = 0.0
      volme      = 0.0
      vhalf      = 0.0
      vp0        = 0.0
      pmantl     = 0.0
      allim      = 0.0
      bpornl     = 0.0
      deltal     = 0.0
      welln      = 0.0
c
c
c 2.2 Initialize the arrays for local bave, volume, and beta
c
      do 30 kf      = 1,3
      do 20 jjv     = 1,ngd1
      bavet(kf,jjv) = 0.0
      bavep(kf,jjv) = 0.0
      pvolm(kf,jjv) = 0.0
      betav(kf,jjv) = 0.0
  20  continue
  30  continue
c
c
c 2.3 Initialize the line integrated differential volumes
c     for vpm, apm, the magnetic well, vdpsi and vcurnt
c
      do 40 jv     = 1,npd1
      vpm   (jv)   = 0.0
      apm   (jv)   = 0.0
      well  (jv)   = 0.0
      vdpsi (jv)   = 0.0
      vcurnt(jv)   = 0.0
   40 continue
c
c
c 2.4 Check for consistent dimensions
c
c 2.4.1 Return if not a direct equilibrium
c
      if(ktype .ne. 0) return
c
c 2.4.2 Check the dimensions are consistent for using xp and zp
c
      if(jpsi1 .gt. nlxv) then
        call abortjob
     &        ('volint  ',  3,   'Dimension nlx insufficient cf. jpsi1'
     &        ,'jpsi1   ', jpsi1,    'nlxv    ', nlxv,     -2)
        return
      endif
c
c 2.4.3 Check the dimensions are consistent for calling vset and vcalc
c
      if(nx    .gt. nlxv) then
        call abortjob
     &        ('volint  ',  4,   'Dimension nlx insufficient for vset '
     &        ,'nx      ', nx,       'nlxv    ', nlxv,     -2)
        return
      endif
c
c 2.4.4 Check nx is odd for vcalc
c
      nxprime  = 2*(nx/2) + 1
      if(nxprime .ne. nx) call abortjob
     &        ('volint  ',  5,   'nx is even: last row will be ignored'
     &        ,'nx      ', nx,       'nxprime ', nxprime,  -1)
c
c
c
c 2.0 Compute the volume integrals
c
c 2.1 Initialize indices for the loop over grid points
c
      jb         = 1
      jm         = 2
      jt         = 3
      call vset(jb,1)
c
c
c 2.2 Loop over grid points and integrate
c
      do 50 jz   = 2,nz,2
c
c 2.2.1 Set the integrand for rows jz and jz+1 stored in rows jm and jt
c       respectively
c
         call vset(jm,jz)
         call vset(jt,jz+1)
c
c 2.2.2 Integrate the contribution from these two rows
c
         call vcalc(jb,jm,jt,nxprime)
c
c 2.2.3 Switch the storage rows
c
         jbs        = jb
         jb         = jt
         jt         = jbs
   50 continue
c
c
c 2.3 Normalize and define beta and the volume averaged B fields
c
      delar      = twopi*dmx*dmz
c
      volme      = volme*delar
      bpave      = bpave*delar/volme
      btave      = btave*delar/volme
      betat      = betat*delar/volme
      betat      = betat*rcgeom**2/rcnt**2
c
      baxe0      = btor
      baxe1      = faxe/rmaxis
      betax0     = 2.0*amu*paxe/(baxe0*baxe0)
      betax1     = 2.0*amu*paxe/(baxe1*baxe1)
c
c
c
c 3.0 Calculate v(psi), a(psi), and the magnetic well
c
c 3.1 Loop over flux surfaces
c
      do 70 j    = 1,jpsi
      jv         = jpsi - j + 1
c
c 3.1.1 Initialize line integrals
c
      wsvp       = 0.0
      wsap       = 0.0
      zwell      = 0.0
      if(j .lt. jsep) ithtm   = itht
      if(j .ge. jsep) ithtm   = itht/2
c
      dlnorm     = 0.5*twopi*arcnorm(jv)/twopi
c
      chithm1    = chiarcl(jv,ithtm-1)
      chithm0    = chiarcl(jv,ithtm)
      chithp1    = twopi
c
c 3.1.2 Compute the line integrals
c
      do 60 i    = 1,ithtm
      im1        = i-1
      ip1        = i+1
      if    (i .eq. 1) then
        dl         = dlnorm*(    chiarcl(jv, 1 ) +     chiarcl(jv, 2 )
     &             +         0.5*chithp1         - 0.5*chithm0        )
      elseif(i .gt. 1  .and.  i .lt. ithtm) then
        dl         = dlnorm*(    chiarcl(jv,ip1) -     chiarcl(jv,im1))
      elseif(i .eq. ithtm) then
        dl         = dlnorm*(0.5*chiarcl(jv, 1 ) + 1.5*chithp1
     &             -             chithm1         - 0.5*chithm0        )
      endif
c
      r1         = rs(i,j)
      z1         = zs(i,j)
      call hbf(x,z,nx,nz,psarray,nxd,nzd,psilim,ipestg,
     &         delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier)
      if(ier .ne. 0) call abortjob
     &        ('volint  ',  6,   'Problem in equilibrium fit hbf      '
     &        ,'ier     ', ier,      'jv      ', jv,       +1)
c
      psx        = fcn(gpx,    nx,nz,nxd,nzd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ier)
      psy        = fcn(gpy,    nx,nz,nxd,nzd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,jer)
c
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('volint  ',  7,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('volint  ',  8,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
      gp2        = psx*psx + psy*psy
      bp1        = sqrt(gp2)/r1
      zwadd      = p(j)  +  0.5*((f(j)/r1)**2 + bp1**2)/amu
c
      wsvp       = wsvp   +       dl/bp1
      wsap       = wsap   +       dl/(r1*bp1)
      zwell      = zwell  + zwadd*dl/bp1
   60 continue
c
c 3.1.3 Define the line integrated differential volumes
c      for vpm, apm, and the magnetic well
c
      vpm (j)    = wsvp
      apm (j)    = wsap/twopi
      well(jv+1) = zwell
   70 continue
c
c
c 3.2 Account for the magnetic axes and internal separatrices
c
c 3.2.1 Set the axis values
c
      vpm(jpsi1) = (twopi*smax(1))**2*qaxe/f(jpsi1)
      apm(jpsi1) = vpm(jpsi1)/(twopi*smax(1))
c
c 3.2.2 Correct the values outside the separatrix
c
      if(jpsi .ge. jsep) then
        do 100 j    = 1,jpsi1
        if(j .ge. jsep) then
          vpm(j)    = 2.0*vpm(j)
          apm(j)    = 2.0*apm(j)
        endif
  100   continue
      endif
c
c
c 3.3 Compute V(psi) and normalize the magnetic well
c
c 3.3.1 Integrate vpm = integral(dl/Bpol) to get the volume in a flux surface
c
      vdpsi(1)   = 0.0
      do 120 j   = 1,jpsi
      ljp        = jpsi1-j
      lj1        = ljp + 1
      well (j+1) = well(j+1)/vpm(ljp)
      vdpsi(j+1) = vdpsi(j)  +  0.5*(vpm   (lj1) + vpm   (ljp))
     &                             *(psival(ljp) - psival(lj1))
  120  continue
c
c 3.3.2 Normalize the total magnetic well with respect to the volume
c
      paxis      = p(jpsi1)
      well(1)    = paxis + 0.5*(f(jpsi1)/smax(1))**2/amu
      welln      = 1.0 - well(1)/well(jpsi1)
c
c
c
c 4.0 Compute the correction for a cold mantle
c
c 4.1 Compute the pressure cut-off
c
      if(paxis .gt. 0.0) then
        pnorm     = paxis
      else
        if(paxis .eq. 0.0) kpaxer = +1
        if(paxis .lt. 0.0) kpaxer = -1
        call abortjob
     &        ('volint  ',  9,   'Pressure on axis is non-positive    '
     &        ,'kpaxer  ', kpaxer,   'jpsi1   ', jpsi1,    -1)
        pnorm     = 1.0
      endif
c
      do 130 j   = 1,jpsi
      ljp        = jpsi1-j
      lj1        = ljp + 1
      if((p(ljp)/pnorm) .ge. pcutoff) ip0  = ljp
  130 continue
c
c
c 4.2 Compute the volume correction
c
      if    (paxis .gt. 0.0) then
        za         = (p(ip0+1)-p(ip0)) / (psival(ip0+1)-psival(ip0))
        zb         =  p(ip0+1) - za*vdpsi(jpsi1-ip0+1)
        vp0        = -zb/za
        ratv       =  volme/vp0
        if(abs(ratv-1.0) .le. rmantl) ratv  = 1.0
      elseif(paxis .eq. 0.0) then
        ratv       =  0.0
      endif
c
c
c 4.3 Compute the correction to total beta
c
      betat      = betat*ratv
      pmantl     = sqrt(ratv)
c
c
c
c 5.0 Compute the poloidal beta
c
c 5.1 Integrate to find betap
c
      betap0     = 0.0
      wsbpa      = 0.0
      do 150 j   = 1,jpsi
      ljp        = jpsi1 - j
      lj1        = ljp + 1
      wsbpb      = vdpsi(j+1)*qp(ljp)*ffp(ljp)/(vpm(ljp)*f(ljp))
      betap0     = betap0 + 0.5*(wsbpa + wsbpb)
     &                         *(psival(ljp) - psival(lj1))
      wsbpa      = wsbpb
  150 continue
c
c
c 5.2 Standard definition of betap
c
      betap0     =  betap0 + wsbpa*(psilim-psival(1))
      betap1     = -betap0*twopi**2/amu
      betap2     =  betat*btold**2/(2.0*amu)*volme
      betap      =  betap2/(betap1 + betap2)
c
c
c 5.3 Compute bpornl, allim, and deltal
c
c 5.3.1 Integrate around the surface
c
      zsuml      = 0.0
      do 200 i   = 1,itht-1
      zsuml      = zsuml  +  sqrt((rsrf(i+1)-rsrf(i))**2
     &                          + (zsrf(i+1)-zsrf(i))**2)
      if(i .le. (itht/2)  .and.  rsrf(i) .ge. rcgeom) then
        ilimx       = i
        alimx       = zsuml
      endif
  200 continue
c
c 5.3.2 Compute bpornl
c
      zsuml      = zsuml  +  sqrt((rsrf(1)-rsrf(itht))**2
     &                         +  (zsrf(1)-zsrf(itht))**2)
      bpornl     = betat  * (btnew*zsuml/(amu*totcur))**2
c
c 5.3.3 Find the orientation of the points on the surface
c
      if(rsrf(1) .gt. rsrf(ithlf)) ksense = +1
      if(rsrf(1) .lt. rsrf(ithlf)) ksense = -1
      if(rsrf(1) .eq. rsrf(ithlf)) ksense =  0
      if(ksense .eq. -1) call abortjob
     &        ('volint  ', 10,   'rsrf mesh has reverse sense         '
     &        ,'ksense  ', ksense,   'ithlf   ', ithlf,    -1)
      if(ksense .eq.  0) call abortjob
     &        ('volint  ', 11,   'rsrf mesh appears badly ordered     '
     &        ,'ksense  ', ksense,   'ithlf   ', ithlf,    -1)
c
c 5.3.4 Compute allim and deltal
c
      allim      = zsuml
      ilimx1     = ilimx + ksense
      delx1      = rsrf(ilimx1) - rsrf(ilimx)
      delz1      = zsrf(ilimx1) - zsrf(ilimx)
      if(abs(delx1) .le. rndff) then
        call abortjob
     &        ('volint  ', 12,   'rsrf(ilimx1)-rsrf(ilimx) < rndff    '
     &        ,'ilimx   ', ilimx,    'ilimx1  ', ilimx1,   -1)
        delx1      = rndff
      endif
c
      za         = delz1/delx1
      zb         =  zsrf(ilimx) - za*rsrf(ilimx)
      zcgeom     = zb + za*rcgeom
      alimx      = 2.0*(alimx - sqrt((zsrf(ilimx1)-zcgeom)**2
     &                            +  (rsrf(ilimx1)-rcgeom)**2))
      alimx      = alimx  +  sqrt((zsrf(1)-zsrf(itht))**2
     &                          + (rsrf(1)-rsrf(itht))**2)
      deltal     = (allim - 2.0*alimx)/allim
c
c
c
c 6.0 Calculate the total current and current half width
c
      do 300 j   = 1,jpsi
      vfactr     =  amu*vpm(j)*f(j)
      xp(j)      = -rmaxis*(pp(j) + pi4*qp(j)*ffp(j)/vfactr)
      zp(j)      =  0.5*(vpm(j)+vpm(j+1)) * (psival(j)-psival(j+1))
  300 continue
c
      xp(jpsi1)  = -rmaxis*(pp(jpsi1) + ffp(jpsi1)/wfactr)
      call cvcal(xp,jpsi1,zp,rmaxis,vcurnt,vhalf)
c
c
c
c 7.0 Return and end
c
      return
      end
      subroutine vset(jtp,jsp)
c
c----------------------------------------------
c calculates data for row for volume integrals
c----------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
c
c
c
c
c 1.0 Initialization
c
      smallno    = roundff
c
c
c
c 2.0 Compute the contributions for this row with jz = jsp
c
      do 20 ix   = 1,nx
      psvl       = psarray(ix,jsp)
c
c
c 2.1 Set contributions from outside plasma to zero
c
      if    ((psimax-psvl)*(psilim-psvl) .gt. 0.0) then
        bavet(jtp,ix) = 0.0
        bavep(jtp,ix) = 0.0
        pvolm(jtp,ix) = 0.0
        betav(jtp,ix) = 0.0
c
c
c 2.2 Set contributions from inside the plasma
c
      elseif((psimax-psvl)*(psilim-psvl) .le. 0.0) then
        r1           = x(ix)
        px           = gpx(ix,jsp)
        py           = gpy(ix,jsp)
        gp2          = px*px + py*py
        bp1          = sqrt(gp2)/r1
        f1           = sterpl(psvl,psimsh,sf,csf,nprofl,npp,0,
     &                             smallno,ier)
        if(ier .ne. 0) call abortjob
     &        ('vset    ',  1,   'Spline evaluation error: sf(psi)    '
     &        ,'ier     ', ier,      'jsp     ', jsp,      -1)
c
        p1           = sterpl(psvl,psimsh,sp,csp,nprofl,npp,0,
     &                             smallno,ier)
        if(ier .ne. 0) call abortjob
     &        ('vset    ',  2,   'Spline evaluation error: sp(psi)    '
     &        ,'ier     ', ier,      'jsp     ', jsp,      -1)
c
        bavet(jtp,ix) = f1
        bavep(jtp,ix) = r1*bp1
        pvolm(jtp,ix) = r1
        betav(jtp,ix) = 2.0*amu*p1*r1/(btor*btor)
      endif
   20 continue
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine vcalc(jb,jm,jt,nxprime)
c
c does bilinear simpson integration: requires apparently nx odd
c      Previous comment claims this requires nx = 2**k + 1
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
c
c
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
c
      data w1/1.777777777777/,w2/.111111111111/,w3/.444444444444/
c
c
      do 10 i  = 2,nxprime,2
      btave  = btave   +   w1* bavet(jm, i )
     &                 +   w2*(bavet(jt,i-1)  +  bavet(jt,i+1)  +
     &                         bavet(jb,i-1)  +  bavet(jb,i+1))
     &                 +   w3*(bavet(jt, i )  +  bavet(jb, i )  +
     &                         bavet(jm,i-1)  +  bavet(jm,i+1))
      bpave  = bpave   +   w1* bavep(jm, i )
     &                 +   w2*(bavep(jt,i-1)  +  bavep(jt,i+1)  +
     &                         bavep(jb,i-1)  +  bavep(jb,i+1))
     &                 +   w3*(bavep(jt, i )  +  bavep(jb, i )  +
     &                         bavep(jm,i-1)  +  bavep(jm,i+1))
      volme  = volme   +   w1* pvolm(jm, i )
     &                 +   w2*(pvolm(jt,i-1)  +  pvolm(jt,i+1)  +
     &                         pvolm(jb,i-1)  +  pvolm(jb,i+1))
     &                 +   w3*(pvolm(jt, i )  +  pvolm(jb, i )  +
     &                         pvolm(jm,i-1)  +  pvolm(jm,i+1))
      betat  = betat   +   w1* betav(jm, i )
     &                 +   w2*(betav(jt,i-1)  +  betav(jt,i+1)  +
     &                         betav(jb,i-1)  +  betav(jb,i+1))
     &                 +   w3*(betav(jt, i )  +  betav(jb, i )  +
     &                         betav(jm,i-1)  +  betav(jm,i+1))
   10 continue
c
      return
      end
      subroutine writemap
c
c -------------------------------------------------------------
c write map file into egta
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npq=np2)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nhd1=5,nhd2=3)
      parameter (nvn=7)
c
      character*8   headr
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*16  sourcnam,sourcdat
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
       common/ratnl/jqmin, jqmax, numbqs,nq1totl,
     &              rcentr,zcentr,rminor,zminor,
     &              asprat00,asprat01,asprat10,asprat11,
     &              pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv,
     &              psivlmnq,    psivnmnq,    psisqmnq,
     &              psir2mnq,    psirhmnq,    psinrmnq,
     &              psitfmnq,    psintmnq,    psistmnq,
     &              psivmmnq,    psinvmnq,    psisvmnq,
     &              dpsr2mnq,    dpsrhmnq,    dpsnrmnq,
     &              dpstfmnq,    dpsntmnq,    dpsstmnq,
     &              dpsvmmnq,    dpsnvmnq,    dpssvmnq,
     &              psivlmxq,    psivnmxq,    psisqmxq,
     &              psir2mxq,    psirhmxq,    psinrmxq,
     &              psitfmxq,    psintmxq,    psistmxq,
     &              psivmmxq,    psinvmxq,    psisvmxq,
     &              dpsr2mxq,    dpsrhmxq,    dpsnrmxq,
     &              dpstfmxq,    dpsntmxq,    dpsstmxq,
     &              dpsvmmxq,    dpsnvmxq,    dpssvmxq,
     &              lpsiq  (npq),psivlq (npq),
     &              qprimq (npq),qvalue (npq),psimshq(npq),
     &              psivalq(npq),psinrmq(npq),psisqrq(npq),
     &              psirh2q(npq),psirhoq(npq),psinrhq(npq),
     &              psitorq(npq),psintfq(npq),psisqtq(npq),
     &              psivolq(npq),psinvlq(npq),psisqvq(npq),
     &              dpsir2q(npq),dpsirhq(npq),dpsinrq(npq),
     &              dpsitfq(npq),dpsintq(npq),dpsistq(npq),
     &              dpsivlq(npq),dpsinvq(npq),dpsisvq(npq),
     &              shearps(npq),shearrh(npq),
     &              sheartf(npq),shearvl(npq),
     &              epslrh1 (npq),shearrh1(npq),shearfrh(npq),
     &              epslvl1 (npq),shearvl1(npq),shearfvl(npq)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Write the map file
c
      write(kumap)  version
      write(kumap)  ndim1,ndim2,xdim,zdim,rcnt,redge
      write(kumap)  jpsi,itht,jsep,numax
c
      write(kumap) (smap(k),smax(k),smaz(k),k=1,2)
      write(kumap)  psimax,xma,zma,psilim,xlim,zlim,qlim,flim
      write(kumap)  psisep,xsep,zsep
      write(kumap)  btor,totcur,qaxe,fqiaxe,paxe,ppaxe,faxe,ffpaxe
     &             ,dnaxe,pfaxe,dnnorm,pfnorm
      write(kumap)  betap,bpave,btave
c
      write(kumap)  pminvl,qminvl,qpminv,pmaxvl,qmaxvl,qpmaxv
      write(kumap) (psival(j),p(j),f(j),pp(j),ffp(j),qp(j),fqpi(j)
     &             ,dnsty(j),pfast(j),j=jpsi,1,-1)
     &             ,psilim,plim,flim,pplim,ffplim,qlim,fqilim,dnlim
     &             ,pflim
c
      write(kumap)  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4
     &             ,qppaxe,dlnaxe,dpnaxe,dhnaxe,arcaxe
      write(kumap) (sint0(j),sint1(j),sint2(j),sint3(j),sint4(j)
     &             ,savge(j),tavge(j),qprime(j),dlnlval(j),dpnlval(j)
     &             ,dhnlval(j),arcnorm(j),pstnorm(j),hamnorm(j)
     &                  ,j=1,jpsi1)
c
      write(kumap)  numbqs,nq1totl
      write(kumap) (psivalu (jp),psirhov (jp),psitorf( jp)
     &                                       ,psivolm (jp),jp=1,np2)
      write(kumap) (dpsirho (jp),dpsitor (jp),dpsivol (jp),jp=1,np2)
c
      write(kumap) (psivlq  (jq),qprimq  (jq),qvalue  (jq)
     &             ,psirhoq (jq),psitorq (jq),psivolq (jq),jq=1,npq)
      write(kumap) (dpsirhq (jq),dpsitfq (jq),dpsivlq (jq),jq=1,npq)
      write(kumap) (shearps (jq),shearrh (jq),sheartf (jq)
     &             ,shearvl (jq),epslrh1 (jq),shearrh1(jq)
     &             ,shearfrh(jq),epslvl1 (jq),shearvl1(jq)
     &                                       ,shearfvl(jq),jq=1,npq)
c
      write(kumap) (rsrf(i),zsrf(i),xjsc(i),chic(i),chie(i),dydx(i)
     &                  ,i=1,ithtp)
c
      write(kumap) ((rcell  (j,i), zcell  (j,i)
     &                  , j=1,jpsi1) ,i=1,ithtp)
      write(kumap) ((dpsdr  (j,i), dpsdz  (j,i)
     &                  , j=1,jpsi1) ,i=1,ithtp)
      write(kumap) ((chiarcl(j,i), chipest(j,i) ,chihaml(j,i)
     &                  , j=1,jpsi1) ,i=1,ithtp)
      write(kumap) ((xjcarcl(j,i), xjcpest(j,i) ,xjchaml(j,i)
     &                  , j=1,jpsi1) ,i=1,ithtp)
      write(kumap) ((alfarcl(j,i), alfpest(j,i) ,alfhaml(j,i)
     &                  , j=1,jpsi1) ,i=1,ithtp)
c
      write(kumap) ((f3 (j,i), f4 (j,i), f5 (j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f7 (j,i), f8 (j,i), f9 (j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f10(j,i), f11(j,i), f12(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f13(j,i), f14(j,i), f20(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f13(j,i), f14(j,i), f15(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f16(j,i), f17(j,i), f18(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f19(j,i), f20(j,i), f21(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f22(j,i), f23(j,i), f24(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f25(j,i), f26(j,i), f27(j,i), j=1,jpsi1),i=1,ithtp)
      write(kumap) ((f28(j,i), j=1,jpsi1),i=1,ithtp)
      return
      end
      subroutine eqdmap(jval,psiv,ithtm,rst0,zst0,rst1,zst1
     &                 ,arprev,svint,nvnt,maponly,mapid,maperr)
c
c calculate xp, zp, arclength, and the Pest and Hamiltonian chi
c coordinates on the flux contour psi = psiv
c the (x,z), arclength, and pest chi values corresponding to the
c poloidal grid points around the surface are stored in
c rs(i,jval), zs(i,jval), arcsurf(i), and pestchi(i) and hamlchi(i)
c for i = 1,ithtm in the poloidal direction.
c For jval = 0 this computes the plasma surface and stores rs(i,1) and zs(i,1)
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/cntd/  nbpmx,nwtmx,nslmx,nhfmx,bperr,dang,arcl,
     &              serrs,serrt,delgp,stfrac,rnderr,
     &              xaxd,yaxd,xmin,xmax,ymin,ymax
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension pds(6)
      dimension svint(nvnt)
c
c
c     Input quantities:
c     rst0, zst0:      Starting values for ordering of intersection points
c                      of the contour and (x,z) grid computed in runkut
c     psiv:            Psi value of the flux contour.
c     jval:            Index for the flux value: psiv = psival(jval) for jval > 0.
c                      jval = 0 corresponds to the plasma surface where psiv = psilim
c     arprev:          Total arclength on previous call for initializing cntour.
c     nvnt:            Number of surface integrals required (dimension of svint)
c     maponly:         Identifier: Compute surface coordinates only if maponly = 0
c
c     Output quantities:
c     rst1, zst1:      Actual starting values used for ordering of intersection
c                      points of the contour and (x,z) grid computed in runkut
c     svint:           Surface integrals for the given surface:
c                         svint(1) = qpval:    Safety factor value on this flux surface
c                         svint(2) = fqval:    Value of fqpi on this flux surface
c     rs, zs:          Grid points (r,z) corresponding to the flux mesh
c                      indexed with (i,jval) corresponding to the jval'th
c                      flux surface and the i'th poloidal angle
c                      (i = 1,ithtm).
c
c     arcsurf(i):      Arclength coordinate around the contour corresponding
c                      to the i'th poloidal coordinate.
c     pestchi(i):      Pest angle coordinate around the contour corresponding
c                      to the i'th poloidal coordinate.
c     hamlchi(i):      Hamiltonian-like angle coordinate around the contour
c                      corresponding to the i'th poloidal coordinate.
c
c     Auxiliary output quantities required for eqdcell:
c     npc:             Number of coordinate line intersections with the flux
c                      contour. (k = 1,npc for xp(k), zp(k), arc(k), csx(l,k),
c                      and csz(l,k)).
c     xp(k), zp(k):    Points on the contour corresponding to intersections
c                      of the contour with the (r,z) coordinate grid.
c     arc(k):          Arclength around contour corresponding to the (xp,zp)
c                      intersection points.
c     csx(l,k):        Interpolation coefficients (l = 1,3) for xp(arc).
c     csz(l,k):        Interpolation coefficients (l = 1,3) for zp(arc).
c     ntmsh:           Number of values for arclength stored in tp
c     tp(kk):          Arclength around the contour corresponding to
c                      arclength increments spaced optimally for accurate
c                      integration (kk = 1, ntmsh, where ntmsh .le. nlx).
c     arcnrm0:         Total arclength around the flux surface.
c     pstnrm0:         Total PEST coordinate around the flux surface.
c     hamnrm0:         Total Hamiltonian coordinate around the flux surface.
c     mapid:           Identifier denoting whether furplm or cntour is used
c     maperr:          Mapping error flag.
c
c
c
c 1.0 Initialization.
c
c 1.1 Initialize error flags and counters.
c
c 1.1.1 Basic parameters
c
      ier      = 0
      ier0     = 0
      ier1     = 0
      ier2     = 0
      ker      = 0
      ker0     = 0
      ker1     = 0
      ker2     = 0
      kcerr    = 0
      maperr   = 0
      kpunit   = kuout
c
      npfit0   = npfit
      npc      = 1
      npcb     = 1
      npcf     = 1
      mapfp    = 0
      mapcn    = 0
      if(maptrace .eq. 0)                            mtrace  = 0
      if(maptrace .lt. 0  .and.  jval .ne.    0    ) mtrace  = 0
      if(maptrace .lt. 0  .and.  jval .eq.    0    ) mtrace  = 1
      if(maptrace .gt. 0  .and.  jval .ne. maptrace) mtrace  = 0
      if(maptrace .gt. 0  .and.  jval .eq. maptrace) mtrace  = 1
c
      bigvl    = bigno
      scalrz   = amin1((x(2)-x(1)),(z(2)-z(1)))
      errorx   = errsep*scalrz
      small    = errsep*scalrz*scalrz
c
c 1.1.2 Parameters for furplm
c
      mxcutc   = maxcutc
      korient  = norient
      nwtmxp   = nwtfitp
      nwtmxm   = nwtfitm
      dreslv   = dresolv
      clcrve   = dlclose
      ptshft   = pntshft
      tolnwp   = tolnwtp
      tolnwm   = tolnwtm
      rndf     = roundff*amin1((x(2)-x(1)),(z(2)-z(1)))
      delxzf   = delpkf* amin1((x(2)-x(1)),(z(2)-z(1)))
c
c 1.1.3 Parameters for cntour
c
      nbpmx    = nbpmax
      nwtmx    = nwtmax
      nslmx    = nslmax
      nhfmx    = nhfmax
      bperr    = bperor
      serrs    = sersnm
      serrt    = sertnm
      delgp    = delgap
      stfrac   = stepcut
      rnderr   = roundff
      psidf    = delpsir
      dpsibdy  = dpedg1
c
c
c 1.2 Set the central point of the mesh.
c
      if(psiv .lt. psisep) then
c
c 1.2.1 For D shapes:
c
         rcn1   = xma
         zcn1   = zma
      else
c
c 1.2.2 For doublets:
c
         rcn1   = xsep
         zcn1   = zsep
      endif
c
c
c
c 2.0 Initialize the contour searching.
c
c 2.1 Initialize data.
c
c 2.1.1 Initialize restart for npfit adjustment
c
      npfitp   = npfit0
      knpfit   = 0
   10 continue
      knpfit   = knpfit + 1
c
c 2.1.2 Set up the starting points ist0 and jst0 for use in furplm.
c     is and js are starting values for the flux surface search.
c
      ist0     = 1
      jst0     = 1
      delxi    = 1.0/dmx
      delzi    = 1.0/dmz
c
c 2.1.3 Initialize the searching for cntour and restart.
c
      xaxd     = rcn1
      yaxd     = zcn1
      xmin     = x(1)
      xmax     = x(nx)
      ymin     = z(1)
      ymax     = z(nz)
c
c
c 2.2 Reset the starting point for the contour by converging the
c       initial point obtained from the runga kutta integration.
c
c 2.2.1 Reset the start
c
c 2.2.1.1 Reset
      rs0      = rst0
      zs0      = zst0
      psiv0    = psiv
      call restart(x,nx,z,nz,cspl1,nxd,nzd,rs0,zs0,psiv0,rs1,zs1)
c
c 2.2.1.2 Save the start position
      rst1     = rs1
      zst1     = zs1
c
c 2.2.2 Find the grid index nearest the magnetic axis to use as a
c       starting point for finding grid intersections
c       The fitting coefficients from hbf are ignored.
c       Starting at the axis ensures the contour begins on the outboard side
c
      call hbf(x,z,nx,nz,psarray,nxd,nzd,psilim,ipestg,
     &         delxi,delzi,ist0,jst0,rcn1,zcn1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,ier0)

c
      if(ier0 .ne. 0) call abortjob
     &        ('eqdmap  ',  1,   'Problem in equilibrium fit hbf      '
     &        ,'ier0    ', ier0,     'jval    ', jval,     +1)
c
c
c 2.3 Recompute  grad(psi) squared at the initialization point (rs1,zs1).
c
      call dbcevl(x,nx,z,nz,cspl1,nxd,nzd,rs1,zs1,pds,ier1)
      if(ier1 .ne. 0) call abortjob
     &        ('eqdmap  ',  2,   'Spline evaluation error:psi(r,z)    '
     &        ,'ier1    ', ier1,     'jval    ', jval,     +1)
c
      psvl1a   = pds(1)
      gs1      = pds(2)*pds(2) + pds(3)*pds(3)
c
      psichkk  = psichek*abs(psidf)
      psidiff  = psvl1a - psiv
      if(abs(psidiff) .gt. psichkk) then
         call abortjob
     &        ('eqdmap  ',  3,   'psi from spline .ne. input psiv     '
     &        ,'jval    ', jval,     'ithtm   ', ithtm,    -1)
         write(kuout,1000) psvl1a,psiv,psichek,psidf,psichkk,psidiff
      endif
c
c
c
c 3.0 Compute the contour intersections of the contour psiv with the
c     (x,z) rectangular grid points using:
c       furplm    if maponly .eq. 0   .or.  jval .eq. 0   .or. psiv .ge. psispl0
c       cntour    if maponly .ne. 0  .and.  jval .ne. 0  .and. either
c                    psiv .lt. psispl0   .or.  furplm failed
c     Store the (x,z) coordinates of the intersections in vectors
c     (xp(ii),zp(ii)) for ii = 1,npc where npc .le. nlx
c
c 3.1 Contouring using furplm for outer contours:
c     This is forced if maponly = 0 or jval = 0
c     delxzf is a minimum distance allowed between points on the contour.
c     remove is used to remove excessively close points.
c
      psispl0 = psimax + psispl*psidf
      if    (maponly .eq. 0  .or.  jval .eq. 0  .or.
     &                             psiv .ge. psispl0) then
c
c 3.1.1  Contouring from furplm
c
c 3.1.1.1 Set the mapping identifier
         mapfp    = +1
c
c 3.1.1.2 Calculate the contour from grid line crossings
         call furplm(psarray,grsq,x,z,psiv,xp,zp,gsq,npc,nx,nz,ntmax,
     &               nxd,nzd,ist0,jst0,isp,jsp,jval,mxcutc,
     &               nwtmxp,nwtmxm,dreslv,clcrve,ptshft,
     &               tolnwp,tolnwm,rndf,kpunit,korient,mtrace,
     &               ninit,ker0)
c
c 3.1.1.3 Print a warning if an error occured:
c         Return if the error is fatal
         if(ker0 .ne. 0) then
           if    (iabs(ker0) .lt. 12) then
              if(maponly .ne. 0) then
                 call abortjob
     &        ('eqdmap  ',  4,   'Unable to map the flux surface      '
     &        ,'ker0    ', ker0,     'jval    ', jval,     -1)
              endif
c
              maperr = ker0
              return
c
           elseif(iabs(ker0) .ge. 12) then
              if(maponly .ne. 0) then
                 call abortjob
     &        ('eqdmap  ',  5,   'Flux surface not properly closed    '
     &        ,'ker0    ', ker0,     'jval    ', jval,     -1)
              endif
           endif
         endif
c
c 3.1.2  Diagnostics, resorting, checking, and packing of contour points.
c        The diagnostics, resorting, checking and packing is skipped
c        if not enough points were found.  cntour is then used instead.
c
         if    (npc .lt. npfitp) then
            maptyp   = 1
         elseif(npc .ge. npfitp) then
            maptyp   = 0
c
c 3.1.2.1  Resort contour points from furplm in the required order
            call sorter(xp,zp,gsq,npc,rcn1,zcn1,rs1,zs1,gs1,bigvl,small
     &              ,ksense,korder,ker)
            if(ker .ne. 0) then
               call abortjob
     &        ('eqdmap  ',  6,   'Sorting error in furplm points      '
     &        ,'ker     ', ker,      'jval    ', jval,     -1)
         endif
c
c 3.1.2.2 Print a warning if the point order was reversed
         if(ksense .ne. 0) then
            call abortjob
     &        ('eqdmap  ',  7,   'Point order from furplm reversed    '
     &        ,'ksense  ', ksense,   'jval    ', jval,     -1)
         endif
c
c 3.1.2.3 Print a warning if the points were reordered by a quarter cycle
c         or more
         korderp  = iabs(korder)
         npclw    = ifix(1.0*float(npc)/4.0)
         npcup    = ifix(3.0*float(npc)/4.0)
         if(korderp .gt. npclw  .and.  korderp .lt. npcup) then
            call abortjob
     &        ('eqdmap  ',  8,   'Points from furplm reinitialized    '
     &        ,'korder  ', korder,   'jval    ', jval,     -1)
         endif
c
c 3.1.2.4  Check that only the upper half of the separatrix is included
c          if a separatrix is present
            do 20 i = 2,npc
            ii      = i
            if(abs(xp(i)-xp(1)) .lt. errorx  .and.
     1         abs(zp(i)-zp(1)) .lt. errorx) go to 30
  20        continue
            ii      = npc + 1
  30        if(ii .le. npc) npc = ii
c
c 3.1.2.5  Remove points found by furplm that are too close together
            npcb    = npc
            call remove(xp,zp,gsq,npcb,npc,delpakf,delxzf)
c
c 3.1.2.6 Reset for using cntour if too few points
            if(npc .lt. npfitp) then
              maptyp  = 1
            endif
         endif
c
c 3.1.2.7 Return if maponly = 0 and an error occured in mapping
         if(maponly .eq. 0) then
            if(maptyp  .ne. 0) maperr  = -1
            if(ker     .ne. 0) maperr  = -2
            return
         endif
c
c 3.1.3 Set maptyp if psiv .lt. psispl0
c
      elseif(maponly .ne. 0  .and.  jval .ne. 0  .and.
     &                              psiv .lt. psispl0) then
         maptyp    = 0
      endif
c
c
c 3.2 Contouring using cntour if psiv .lt. psispl0 or if furplm failed
c
      if(psiv .lt. psispl0  .or.  maptyp .eq. 1) then
c
c 3.2.1 Print a warning if jval = 0 or psiv is too close to psilim
c
c 3.2.1.1 Print an error if jval is zero and cntour is being used
c         and restart the mapping with readjusted npfitp if possible
         if    (jval .eq. 0) then
            call abortjob
     &        ('eqdmap  ',  9,   'Attempted map psilim with cntour    '
     &        ,'jval    ', jval,     'maptyp  ', maptyp,   -1)
            if(maptyp .eq. 1  .and.  npc .lt. npfitp) then
               npc      = 1
               npcb     = 1
               npcf     = 1
               mapfp    = 0
               mapcn    = 0
               npfitp   = npfitp/2
               if(npfitp .ge. npcmin) then
                  call abortjob
     &        ('eqdmap  ', 10,   'Restart mapping with npfitp halved  '
     &        ,'knpfit  ', knpfit,   'npfitp  ', npfitp,   -1)
                  go to 10
               else
                  call abortjob
     &        ('eqdmap  ', 11,   'Cannot redo mapping with new npfit  '
     &        ,'knpfit  ', knpfit,   'npfitp  ', npfitp,   +1)
               endif
            endif
c
c 3.2.1.2 Print an error if jval = 1 and cntour is being used
         elseif(jval .eq. 1) then
            call abortjob
     &        ('eqdmap  ', 12,   'Attempted cntour map:  First surface'
     &        ,'jval    ', jval,     'maptyp  ', maptyp,   -1)
               write(kuout,1100) npc, npfitp, psiv,    psispl,  psispl0,
     &                                        psimax,  psilim,  delpsir,
     &                                        dpsibdy
c
c 3.2.1.3 Print a warning if psiv is within dpsisv of psilim and cntour is being used
         elseif(jval .gt. 1) then
            if(abs(psiv-psilim) .le. abs(dpsibdy)) then
               call abortjob
     &        ('eqdmap  ', 13,   'Using cntour to map near psilim     '
     &        ,'jval    ', jval,     'maptyp  ', maptyp,   -1)
               write(kuout,1100) npc, npfitp, psiv,    psispl,  psispl0,
     &                                        psimax,  psilim,  delpsir,
     &                                        dpsibdy
            endif
         endif
c
c 3.2.2  Initialization
c
         npcf     = npc
         mapcn    = +1
         dangax   = 1.0/float(nangax)
         danglm   = 1.0/float(nanglm)
         psit     = (psiv-psimax)/delpsir
         dang     = dangax - (dangax-danglm)*psit
c
         arcl0    = arcmin*rcn1
         narcl1   = narcln
         if    (jval .le. 1) then
            arcl    = arcl0
         elseif(jval .gt. 1) then
            arcl    = arprev/float(narcl1)
            if(arcl .eq. 0.0) arcl = arcl0
         endif
c
         delxzc   = delpkc*amin1((x(2)-x(1)),(z(2)-z(1)))
c
c 3.2.3  Contouring from cntour
c
         call cntour(x,nx,z,nz,cspl1,nxd,nzd,xp,zp,gsq,npc,dmx,dmz,ntmax
     &              ,jval,psiv,kcerr)
c
c 3.2.4 Check and account for errors
c
         if(kcerr .ne. 0) then
c
c 3.2.4.1 Print a warning if the polar contour mapping was not initialized
c         correctly.
            if    (kcerr .lt. 0) then
               call abortjob
     &        ('eqdmap  ', 14,   'Initialization error in contour map '
     &        ,'jval    ', jval,     'kcerr   ', kcerr,    -1)
c
c 3.2.4.2 Print a warning if the polar contour mapping failed.
            elseif(kcerr .gt. 0) then
               call abortjob
     &        ('eqdmap  ', 15,   'Polar contour mapping routine failed'
     &        ,'jval    ', jval,     'kcerr   ', kcerr,    -1)
c
c 3.2.4.3 Attempt to remap if the failure occured after a failure in furplm.
               if(maptyp .eq. 1  .and.  npc .lt. npfitp) then
                  npc      = 1
                  npcb     = 1
                  npcf     = 1
                  mapfp    = 0
                  mapcn    = 0
                  npfitp   = npfitp/2
                  if(npfitp .ge. npcmin) then
                     call abortjob
     &        ('eqdmap  ', 16,   'Restart mapping with npfitp halved  '
     &        ,'knpfit  ', knpfit,   'npfitp  ', npfitp,   -1)
                     go to 10
                  else
                     call abortjob
     &        ('eqdmap  ', 17,   'Cannot redo mapping with new npfit  '
     &        ,'knpfit  ', knpfit,   'npfitp  ', npfitp,   +1)
                  endif
               endif
            endif
         endif
c
c 3.2.5  Resort contour points from cntour in the required order.
c
c 3.2.5.1 Sort the points.
         call sorter(xp,zp,gsq,npc,rcn1,zcn1,rs1,zs1,gs1,bigvl,small
     &              ,isense,iorder,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('eqdmap  ', 18,   'Sorting error in cntour points      '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
         endif
c
c 3.2.5.2 Print a warning if the point order was reversed.
         if(isense .ne. 0) then
            call abortjob
     &        ('eqdmap  ', 19,   'Point order from cntour reversed    '
     &        ,'isense  ', isense,   'jval    ', jval,     -1)
         endif
c
c 3.2.5.3 Print a warning if the points were reordered by a quarter cycle
c         or more
         iorderp  = iabs(iorder)
         npclw    = ifix(1.0*float(npc)/4.0)
         npcup    = ifix(3.0*float(npc)/4.0)
         if(iorderp .gt. npclw  .and.  iorderp .lt. npcup) then
            call abortjob
     &        ('eqdmap  ', 20,   'Points from cntour reinitialized    '
     &        ,'iorder  ', iorder,   'jval    ', jval,     -1)
         endif
c
c 3.2.5.4  Remove points found by cntour that are too close together
         npcb    = npc
         call remove(xp,zp,gsq,npcb,npc,delpakc,delxzc)
      endif
c
c
c 3.3 Print error or warning if not enough points were found
c
      if    (npc .lt. npfit0  .and.  npc .gt. npcmin) then
         call abortjob
     &        ('eqdmap  ', 21,   'Number of contour points < npfit    '
     &        ,'jval    ', jval,     'npc     ', npc,       0)
            write(kuout, 2000) jval,psiv,npc,npfit0,npcb
c
      elseif(npc .lt. npfit0  .and. npc .lt. npcmin) then
         call abortjob
     &        ('eqdmap  ', 22,   'Insufficient points in arc grid     '
     &        ,'jval    ', jval,     'npc     ', npc,      -2)
         write(kuout, 2010) jval,psiv,npc,npcb,npfit0,npcmin
c
      elseif(npc .ge. npfit0  .and. npc .lt. npcmin) then
         call abortjob
     &        ('eqdmap  ', 23,   'Insufficient points in arc grid     '
     &        ,'jval    ', jval,     'npc     ', npc,      -2)
         write(kuout, 2020) jval,psiv,npc,npcb,npfit0,npcmin
      endif
c
c
c 3.4 Set the map identifier
c
      if(mapfp .eq. 0  .and.  mapcn .eq. 0) mapid  =  0
      if(mapfp .ne. 0  .and.  mapcn .eq. 0) mapid  = -1
      if(mapfp .eq. 0  .and.  mapcn .ne. 0) mapid  = +1
      if(mapfp .ne. 0  .and.  mapcn .ne. 0) mapid  = +2
c
c
c
c 4.0 Compute the mapping of the flux surface.
c
c 4.1 Compute the normalization for the q value
c
      fval     = sterpl(psiv,psimsh,sf,   csf,   nprofl,npp,0,
     &                       rnderr,ier2)
      if(ier2 .ne. 0) call abortjob
     &        ('eqdmap  ', 24,   'Spline evaluation error: sf(psi)    '
     &        ,'ier2    ', ier2,     'jval    ', jval,     -1)
c
c
c 4.2 Compute the arclength mesh and integrate to obtain the
c     poloidal angle coordinates
c     This requires npc, xp, and zp passed through sarc
c
      call maparc(0,jval,psiv,fval,ithtm,svint,nvnt)
c
c
c 4.3 Construct the poloidal mesh
c     This requires ntmsh, tp, tpp, arc, arcc, st1, st2,
c     cseq1, and cseq2 computed from maparc
      call mapangl(jval,ithtm)
c
c
c
c 5.0 Clean up for the next call to eqdcell and to eqdmap
c
c 5.1 Recompute the coefficients csx and csz of the functions xp(arc)
c     and zp(arc).  These are passed through to eqdcell
c
      npcm1    = npc-1
      bcd(1)   = 0.0
      bcd(2)   = 2.*f2s(npcm1,xp,arc,ntmax)
      bcd(3)   = 0.0
      bcd(4)   = bcd(2)
      call icsici(arc,xp,npc,bcd,csx,nlx,ker1)
      if(ker1 .ne. 0) call abortjob
     &        ('eqdmap  ', 25,   'Spline interpolation error:r(th)    '
     &        ,'ker1    ', ker1,     'jval    ', jval,     +1)
c
      bcd(2)   = 2.*f2s(npcm1,zp,arc,ntmax)
      bcd(4)   = bcd(2)
      call icsici(arc,zp,npc,bcd,csz,nlx,ker2)
      if(ker2 .ne. 0) call abortjob
     &        ('eqdmap  ', 26,   'Spline interpolation error:z(th)    '
     &        ,'ker2    ', ker2,     'jval    ', jval,     +1)
c
c
c 5.2 Store auxiliary quantities
c
c 5.2.1 Save the actual final surface starting point
c
      rst1     = rs1
      zst1     = zs1
c
c 5.2.2 Store the total arclength for the next call
c
      arprev   = arcsurf(ithtp)
c
c
c
c 6.0 Return and end
c
      return
c
 1000 format(  4x,'Warning: starting psi value is inaccurate:',/
     &        ,4x,'psi(rs1,zs1) = ',e16.9,2x,'psiv    = ',e16.9,/
     &        ,4x,'psichek      = ',e16.9,2x,'psdf    = ',e16.9
     &        ,2x,'psichkk      = ',e16.9,2x,'psidiff = ',e16.9)
 1100 format(  4x,'npc      = ',i5,  11x,'npfitp   = ',i5,/
     &        ,4x,'psiv     = ',e12.5,4x,'psispl   = ',e12.5
     &        ,4x,'psispl0  = ',e12.5,/
     &        ,4x,'psimax   = ',e12.5,4x,'psilim   = ',e12.5
     &        ,4x,'delpsir  = ',e12.5,4x,'dpsibdy  = ',e12.5,/)
 2000 format(/,4x,'For psi(',i5,') = ',e12.5
     &        ,2x,'cntour found only',1x,i5
     &        ,1x,'points: npfit0 = ',i5
     &        ,3x,'Before removal npc = ',i5,/)
 2010 format(/,4x,'For psi(',i5,') = ',e12.5
     &        ,2x,'cntour found only',1x,i5,' points:'
     &        ,3x,'Before removal npc = ',i5,/
     &        ,4x,'npfit0   = ',i5,2x,'npcmin  = ',i5,/)
 2020 format(/,4x,'npfit0 is less than npcmin:',/
     &        ,4x,'For psi(',i5,') = ',e12.5
     &        ,2x,'cntour found only',1x,i5,' points:'
     &        ,3x,'Before removal npc = ',i5,/
     &        ,4x,'npfit0   = ',i5,2x,'npcmin  = ',i5,/)
      end
      subroutine betachi(jval,ithtm,dlnlvl,dpnlvl,dhnlvl,kunit)
c
c------------------------------------
c  Integrate to find Jacobian non-orthogonality
c------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c     Input quantities:
c     jval:       Flux surface label.
c                 jval = 0 corresponds to the plasma surface
c     ithtm:      Number of poloidal angles
c
c     Input from eqdmap:
c     rs, zs :    Coordinates of the flux mesh grid points.
c     arcsurf:    Incremented arclength around flux surface.
c     pestchi:    PEST coordinate angle around flux surface.
c     hamlchi:    Hamiltonian-like coordinate angle around flux surface.
c     arcnrm0:    Total arclength around flux surface.
c     pstnrm0:    Total integrated PEST coordinate around flux surface.
c     hamnrm0:    Total integrated Hamiltonian coordinate around flux surface.
c     npc :       Number of intersections between the jval'th flux surface and
c                 the (x,z) rectangular equilibrium grid lines.
c     ntmsh:      Number of integration points on the flux surface for tp.
c     xp, zp :    Coordinates of the intersections between the jval'th flux
c                 surface and the (x,z) rectangular equilibrium grid lines.
c     arc :       Incremented arclength corresponding to the points (xp,zp).
c     tp :        Arclength grid optimally spaced around the flux contour
c                 for arclength integration.  tp is dimensioned at ntmsh.
c     csx, csz :  Interpolation coefficients for the functions xp(arc)
c                 and zp(arc).
c
c     sv0(i):      r/grad(psi) on arc
c     sv1(i):      r*(1/(r**2)) / (grad(psi)) on arc
c     sv2(i):      r*(d/dpsi(log(grad(psi)**2)) / r**2) / (grad(psi) on arc
c     sv3(i):      r*(1/(grad(psi)**2)) / (grad(psi)) on arc
c     sv4(i):      r*(1/(r*grad(psi)**2)) / (grad(psi)) on arc
c     sv5(i):      r*(dlog(r**2)/dpsi) / (grad(psi)) on arc
c
c     Output quantities:
c     dlnlvl:     [dL/dpsi / L]  (L = total arclength/2pi)
c     dpnlvl:     [dH/dpsi / H]  (H = fqi/f)
c     dhnlvl:     [dH/dpsi / H]  (H = q  /f)
c     alfarc:      Nonorthogonality for arclength poloidal angle on this surface
c     alfpst:      Nonorthogonality for Pest poloidal angle on this surface
c     alfham:      Nonorthogonality for Hamiltonian poloidal angle on this surface
c
c
c
c 1.0 Initialize parameters.
c
c 1.1 Initialize parameters
c
      ntmsh1     = ntmsh - 1
      rndff      = roundff
      rndoff     = roundff*sqrt(xdim*xdim + zdim*zdim)
      splndf     = tolspln*sqrt(xdim*xdim + zdim*zdim)
c
c 1.2 Set the flux surface index
c
      jvnew      = jpsi-jval+1
c
      if(jvnew .lt.   0  ) then
        call abortjob
     &        ('betachi ',  1,   'jvnew is out of range: jval > jpsi1 '
     &        ,'jval    ', jval,     'jvnew   ', jvnew,    +1)
      endif
      if(jvnew .gt. jpsi1) then
        call abortjob
     &        ('betachi ',  2,   'jvnew is out of range: jval < 0     '
     &        ,'jval    ', jval,     'jvnew   ', jvnew,    +1)
      endif
c
c
c 1.3 Set the flux surface values
c
      if    (jval .eq. 0) then
         fvalp     =  flim
         ppvalp    =  pplim
         ffpvalp   =  ffplim
         qvalp     =  qlim
         fqvalp    =  fqilim
         f2valp    =  flim*flim
      elseif(jval .gt. 0) then
         fvalp     =  f   (jval)
         ppvalp    =  pp  (jval)
         ffpvalp   =  ffp (jval)
         qvalp     =  qp  (jval)
         fqvalp    =  fqpi(jval)
         f2valp    =  fvalp*fvalp
      endif
c
      amuppv      =  amu*ppvalp
c
c
c 1.3 Initialize integration.
c       Integration is done over the coordinate l = arclength with
c       Jacobian J = r/grad(psi)
c
      if(arcnrm0 .ne. arc(npc)) then
        call abortjob
     &        ('betachi ',  3,   'arcnrm0 and arc(npc) not equal      '
     &        ,'jval    ', jval,     'npc     ', npc,      -1)
        arcnrm0   = arc(npc)
      endif
c
      arclen      = arcnrm0
      arctot      = charcmx
      psttot      = pstnrm0
      hamtot      = hamnrm0
c
c
c 1.4 Jacobian factors
c
      arcjfac     = arclen/charcmx
      pstjfac     = qvalp /fvalp
      hamjfac     = fqvalp/fvalp
c
c
c
c 2.0 Compute Integrands for:
c             dlnlval(jval) = dL/dpsi for L = arclength
c             dpnlval(jval) = dP/dpsi for P = q/f
c             dhnlval(jval) = dH/dpsi for H = fqi/f
c     from integration around the contour.
c
c 2.1 Integrate around the contour using the optimal tp mesh.
c     Store the integrand for dl/dpsi in st1.
c
c 2.1.1 Loop over the optimal arclength mesh.
c
      krdiff      =  0
      itmaxv      =  0
      r1dmax      =  0.0
      r1maxv      =  0.0
      r1pmaxv     =  0.0
      do 10 i     =  1,ntmsh
      it          =  i
      arctp       =  tp (it)
      xjai        =  sv0(it)
      xjpi        =  sv1(it)
      dgdpln2a    =  sv2(it)
      drdpln2a    =  sv5(it)
c
      if(abs(xjai) .lt. rndoff) then
       call abortjob
     &        ('betachi ',  4,   'Integrand sv0 is zero: Using rndoff '
     &        ,'jval    ', jval,     'it      ', it,       -1)
        xjai         = rndoff
      endif
      if(abs(xjpi) .lt. rndoff) then
       call abortjob
     &        ('betachi ',  5,   'Integrand sv1 is zero: Using rndoff '
     &        ,'jval    ', jval,     'it      ', it,       -1)
        xjpi         = rndoff
      endif
c
      r2          = xjai/xjpi
      r1          = sqrt(r2)
c
      r1p         = sterpl(arctp,arc,xp,csx,npc,nlx,1,rndff,ier)
      if(ier .ne. 0) call abortjob
     &        ('betachi ',  6,   'Spline evaluation error: r(arc)     '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c 2.1.2 Check for consistency in r1 calculation
c
      r1diff      = r1 - r1p
      if(abs(r1diff) .ge. splndf) then
        if(abs(r1diff) .ge. abs(r1dmax)) then
          krdiff    = krdiff + 1
          itmaxv    = it
          r1dmax    = r1diff
          r1maxv    = r1
          r1pmaxv   = r1p
        endif
        call abortjob
     &        ('betachi ',  7,   'r1 from xp and sv0/sv1 are different'
     &        ,'jval    ', jval,     'it      ', it,       -1)
      endif
c
c 2.1.3 Get grad(psi) squared, d/dpsi(gradpsi**2) (normal) and r*jphi.
c
      gp          =  r1/xjai
      gp2         =  gp**2
      dgdpln2     =  r2*dgdpln2a / xjai
      drdpln2     =     drdpln2a / xjai
      dbdpln2     =  dgdpln2 - drdpln2
      dlnrbt2     = (gp2*dgdpln2 + 2*fvalp*ffpvalp) / (gp2 + f2valp)
      dlnbtot2    =  dlnrbt2 - drdpln2
c
      curb        = -(r2*amuppv + ffpvalp) / gp2

c
c 2.2.3 Construct the integrand for dH/dpsi with
c       H = L/2pi, H = q/f, and H = fqi/f
c
c 2.2.3.1 Construct the normalized Jacobians
      xjarc       =  xjai
      xjtht       =  xjarc*arcjfac
      xjpst       =  r2*pstjfac
c
      xjrvl       =  r1
      xjbpl       =  1.0/xjarc
      xjbtl       =  sqrt(gp2/r2 + f2valp/r2)
      xjhml       = (xjrvl**nham1)*(xjbpl**nham2)*(xjbtl**nham3)
      xjham       =  xjhml*hamjfac
c
      xthtarc     =  xjarc/xjtht
      xpstarc     =  xjarc/xjpst
      xhamarc     =  xjarc/xjham
c
c 2.2.3.2 Construct the integrands
      derivn      =      dbdpln2
      derivarc    = -0.5*dbdpln2
      derivpst    = +1.0*drdpln2
      derivham    = +0.5*(nham1*drdpln2 + nham2*dbdpln2 + 
     &                                    nham3*dlnbtot2)
c
      st1(it)     =  xthtarc*(curb - (derivn + derivarc))
      st2(it)     =  xpstarc*(curb - (derivn + derivpst))
      st3(it)     =  xhamarc*(curb - (derivn + derivham))
   10 continue
c
c 2.3 Print a warning if discrepancies in r1 and r1p were found
c
      if(krdiff .gt. 0) then
        if(krdiff .le. 1) call abortjob
     &        ('betachi ',  8,   'Single difference between r1, r1p   '
     &        ,'jval    ', jval,     'krdiff  ', krdiff,   -1)
        if(krdiff .gt. 1) call abortjob
     &        ('betachi ',  9,   'Multiple differences between r1, r1p'
     &        ,'jval    ', jval,     'krdiff  ', krdiff,   -1)
        write(kunit,1000) itmaxv,r1maxv,r1pmaxv,r1dmax
      endif
c
c
c
c 3.0 Integrate st1(tp) for dL/dpsi
c
c 3.1 Compute interpolation coefficients for integration of st1(tp).
c
      bcd(1)      = 0.0
      bcd(2)      = 2.0*f2s(ntmsh1,st1,tp,ntmax)
      bcd(3)      = 0.0
      bcd(4)      = bcd(2)
      call icsici(tp,st1,ntmsh,bcd,cseq2,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('betachi ', 10,   'Spline interpolation error: st1(tp) '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c
c 3.2 Compute dlnlvl = dL/dpsi / L  (L = arclength).
c     Integrate around the contour for dl/dpsi and normalize.
c       st1 contains d/dpsi(arclength) in the normal direction as a
c       function of the poloidal coordinate.
c
      call garcq(tp,st1,cseq2,ntmsh,nlx,ans)
c
c
c 3.3 Set the value for this surface.
c
      dlnlvl      = ans/arctot
c
c
c 3.4 Calculate the nonorthogonality parameter
c              alpha = (darcl/dpsi)(normal)
c     where arcl is the arclength poloidal angle coordinate.
c
c 3.4.1 Construct the integrand from st1 and dlnlvl
c
      glnorm      =  charcmx/arctot
      do 100 i    =  1,ntmsh
      it          =  i
      xjai        =  sv0(it)
      xjarc       =  xjai
      xjtht       =  xjarc*arcjfac
      xthtarc     =  xjarc/xjtht
c
      st1(it)     =  glnorm*(st1(it) - xthtarc*dlnlvl)
  100 continue
c
c 3.4.2 Compute the interpolation coefficients for integration of st1.
c
      bcd(2)      = 2.0*f2s(ntmsh1,st1,tp,ntmax)
      bcd(4)      = bcd(2)
      call icsici(tp,st1,ntmsh,bcd,cseq2,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('betachi ', 11,   'Spline interpolation error: st1(tp) '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c 3.4.3 Integrate st1 incrementally to compute the nonorthogonality alpha.
c     Integration in garea for second last argument = 3 computes incremental
c     integral from d1 to d2 of st1*dl with l = arclength.
c
      alph0       = 0.0
      do 120 i    = 1,ithtm
      ip          = i
      if(ip .eq. 1) d1  = 0.0
      if(ip .gt. 1) d1  = arcsurf(ip-1)
      d2          = arcsurf(ip)
      call garea(d1,d2,tp,st1,cseq2,ntmsh,nlx,3,ans)
      alfarc(ip)  = alph0 + ans
      alph0       = alfarc(ip)
  120 continue
c
c
c
c 4.0 Integrate st2(tp) for d/dpsi(q/f)
c
c 4.1 Compute interpolation coefficients for integration of st2(tp).
c
      bcd(1)      = 0.0
      bcd(2)      = 2.0*f2s(ntmsh1,st2,tp,ntmax)
      bcd(3)      = 0.0
      bcd(4)      = bcd(2)
      call icsici(tp,st2,ntmsh,bcd,cseq2,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('betachi ', 12,   'Spline interpolation error: st2(tp) '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c
c 4.2 Compute dpnlvl = d/dpsi(q/f)
c     Integrate around the contour for dpest/dpsi and normalize.
c
      call garcq(tp,st2,cseq2,ntmsh,nlx,ans)
c
c
c 4.3 Set the value for this surface.
c
      dpnlvl      = ans/psttot
c
c
c 4.4 Calculate the nonorthogonality parameter
c              alpha = (dpest/dpsi)(normal)
c     where pest is the PEST poloidal angle coordinate.
c
c 4.4.1 Construct the integrand from st2 and dpnlvl.
c
      gpnorm      =  charcmx/psttot
      do 200 i    =  1,ntmsh
      it          =  i
      xjai        =  sv0(it)
      xjpi        =  sv1(it)
      xjarc       =  xjai
      xjpst       = (xjai/xjpi)*pstjfac
      xpstarc     =  xjarc/xjpst
c
      st2(it)     =  gpnorm*(st2(it) - xpstarc*dpnlvl)
  200 continue
c
c 4.4.2 Compute the interpolation coefficients for integration of st2.
c
      bcd(2)      = 2.0*f2s(ntmsh1,st2,tp,ntmax)
      bcd(4)      = bcd(2)
      call icsici(tp,st2,ntmsh,bcd,cseq2,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('eqdcell ', 13,   'Spline interpolation error: st2(tp) '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c 4.4.3 Integrate st2 incrementally to compute the nonorthogonality alpha.
c     Integration in garea for second last argument = 3 computes incremental
c     integral from d1 to d2 of st2*dl with l = arclength.
c
      alph0       = 0.0
      do 220 i    = 1,ithtm
      ip          = i
      if(ip .eq. 1) d1  = 0.0
      if(ip .gt. 1) d1  = arcsurf(ip-1)
      d2          = arcsurf(ip)
      call garea(d1,d2,tp,st2,cseq2,ntmsh,nlx,3,ans)
      alfpst(ip)  = alph0 + ans
      alph0       = alfpst(ip)
  220 continue
c
c
c 5.0 Integrate st3(tp) for d/dpsi(fqpi/f)
c
c 5.1 Compute interpolation coefficients for integration of st3(tp).
c
      bcd(1)      = 0.0
      bcd(2)      = 2.0*f2s(ntmsh1,st3,tp,ntmax)
      bcd(3)      = 0.0
      bcd(4)      = bcd(2)
      call icsici(tp,st3,ntmsh,bcd,cseq2,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('betachi ', 14,   'Spline interpolation error: st3(tp) '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c
c 5.2 Compute dhnlvl = d/dpsi(fqpi/f)
c     Integrate around the contour for dham/dpsi and normalize.
c
      call garcq(tp,st3,cseq2,ntmsh,nlx,ans)
c
c
c 5.3 Set the value for this surface.
c
      dhnlvl      = ans/hamtot
c
c
c 5.4 Calculate the nonorthogonality parameter
c              alpha = (dhaml/dpsi)(normal)
c     where haml is the Hamiltonian poloidal angle coordinate.
c
c 5.4.1 Construct the integrand from st3 and dhnlvl.
c
      ghnorm      =  charcmx/hamtot
      do 300 i    =  1,ntmsh
      it          =  i
      xjai        =  sv0(it)
      xjpi        =  sv1(it)
c
      r2          =  xjai/xjpi
      r1          =  sqrt(r2)
      gp          =  r1/xjai
      gp2         =  gp**2
      btot        =  sqrt(gp2/r2 + f2valp/r2)
c
      xjarc       =  xjai
      xjbpl       =  1.0/xjtht
      xjrvl       =  r1
      xjbtl       =  btot
      xjhml       = (xjrvl**nham1)*(xjbpl**nham2)*(xjbtl**nham3)
      xjham       =  xjhml*hamjfac
      xhamarc     =  xjarc/xjham
c
      st3(it)     =  ghnorm*(st3(it) - xhamarc*dhnlvl)
  300 continue
c
c 5.4.2 Compute the interpolation coefficients for integration of st3.
c
      bcd(2)      = 2.0*f2s(ntmsh1,st3,tp,ntmax)
      bcd(4)      = bcd(2)
      call icsici(tp,st3,ntmsh,bcd,cseq2,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('betachi ', 15,   'Spline interpolation error: st3(tp) '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c 5.4.3 Integrate st3 incrementally to compute the nonorthogonality alpha.
c     Integration in garea for second last argument = 3 computes incremental
c     integral from d1 to d2 of st3*dl with l = arclength.
c
      alph0       = 0.0
      do 320 i    = 1,ithtm
      ip          = i
      if(ip .eq. 1) d1  = 0.0
      if(ip .gt. 1) d1  = arcsurf(ip-1)
      d2          = arcsurf(ip)
      call garea(d1,d2,tp,st3,cseq2,ntmsh,nlx,3,ans)
      alfham(ip)  = alph0 + ans
      alph0       = alfham(ip)
  320 continue
c
c
c
c 6.0 Return and end
c
      return
 1000 format(6x,'Poloidal position of maximum difference: it = ',i5
     &    ,/,6x,'r1   = ',e14.7,4x,'r1p   = ',e14.7
     &      ,4x,'Maximum difference = ',e14.7)
      end
      subroutine eqdcell(jval,psiv,ithtm)
c
c------------------------------------
c  evaluate cell center quantities
c------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
      parameter (nvn=7)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c     Input quantities:
c     jval:       Flux surface label.
c                 jval = 0 corresponds to the plasma surface
c     ithtm:      Number of poloidal angles
c
c     Input from eqdmap:
c     rs, zs :    Coordinates of the flux mesh grid points.
c     arcsurf:    Incremented arclength around flux surface.
c     pestchi:    PEST coordinate angle around flux surface.
c     hamlchi:    Hamiltonian-like coordinate angle around flux surface.
c     arcnrm0:    Total arclength around flux surface.
c     pstnrm0:    Total integrated PEST coordinate around flux surface.
c     hamnrm0:    Total integrated Hamiltonian coordinate around flux surface.
c     npc :       Number of intersections between the jval'th flux surface and
c                 the (x,z) rectangular equilibrium grid lines.
c     ntmsh:      Number of integration points on the flux surface for tp.
c     xp, zp :    Coordinates of the intersections between the jval'th flux
c                 surface and the (x,z) rectangular equilibrium grid lines.
c     arc :       Incremented arclength corresponding to the points (xp,zp).
c     tp :        Arclength grid optimally spaced around the flux contour
c                 for arclength integration.  tp is dimensioned at ntmsh.
c     csx, csz :  Interpolation coefficients for the functions xp(arc)
c                 and zp(arc).
c     svint:      Surface integrals
c
c     Output quantities:
c     xjcarcl:    Jacobian for arclength normalized to 2pi
c     xjcpest:    Jacobian for Pest poloidal angle
c     xjchaml:    Jacobian for Hamiltonian poloidal angle
c     alfarcl:    Nonorthogonality for arclength normalized to 2pi
c     alfpest:    Nonorthogonality for Pest poloidal angle
c     alfhaml:    Nonorthogonality for Hamiltonian poloidal angle
c
c     arcnorm:    Total arclength of surface (Period for Arclength coordinate)
c     pstnorm:    Period for PEST coordinate on surface
c     hamnorm:    Period for Hamiltonian coordinate on surface
c
c     dlnlval:    Logarithmic derivative of the arclength   normalization:
c                 [dL/dpsi / L]  (L = arclength normalization)
c     dpnlval:    Logarithmic derivative of the pest angle  normalization:
c                 [dP/dpsi / P]  (P = PEST normalization = q/f)
c     dhnlval:    Logarithmic derivative of the Hamiltonian normalization:
c                 [dH/dpsi / H]  (H = Hamiltonian normalization = fqi/f
c     sint0:      integral[r/grad(psi)]dl
c     sint1:      integral[((1/(r**2)) * (r/grad(psi))]dl
c     sint2:      integral[(d/dpsi(log(grad(psi)**2)) / r**2) * (r/grad(psi))]dl
c     sint3:      integral[(1/(grad(psi)**2)) * (r/grad(psi))]dl
c     sint4:      integral[(1/(r**2 * grad(psi)**2)) * (r/grad(psi))]dl
c     savge:      Surface averaged local shear S
c     tavge:      Surface averaged T - 0.5*S   (T = mu0*j.B/(grad(psi)**2)
c     qprime:     d/dpsi(q) from savge*sint0
c
c     f3 :         f / (r**2)
c     f4 :        -(mu0*jtor) / (r*Bpol)**2
c     f5 :        f * [d/dpsi(J/(r**2))](constant chi)
c     f7 :        2J{ ((mu0*jtor)/(r*Bpol))**2                           + 
c                     ((mu0*jtor)/((r**2)*Bpol))*[d/dpsi(r*Bpol)]normal  -
c                     ((mu0*p'/r)*[dr/dpsi]normal }
c        :        2J{ ((mu0*jtor)/(r*Bpol))**2                           + 
c                     ((mu0*jtor)/(r*Bpol))*[d/dpsi(Bpol)]normal         +
c                     ((ff'/r**3)*[dr/dpsi]normal }
c     f8 :        1 / [J*(r*Bpol)**2]
c     f9 :        J*(Bpol**2)
c     f10:        (r**2) / J
c     f11:        (mu0*gamma*p) / J
c     f12:        (f*J) / (r**2)
c     f13:        J (Jacobian)
c     f14:        [dJ/dpsi](constant chi)
c     f15:        [dJ/dchi](constant psi)
c     f16:         d/dpsi(grad(psi)**2)normal
c     f17:         d/dchi[grad(psi)**2]
c     f18:         d/dchi[grad(psi).grad(chi)]
c     f19:         d/dchi[(dchi/dpsi)normal]
c     f20:        -(grad(psi).grad(chi)) / (grad(psi)**2)
c                      (-nonorthogonality: [-dchi/dpsi]normal)
c     f21:        2*[(r**2)/f] * [d/dpsi(log(r)]]normal         = [1/f] * [dr**2/dpsi]normal
c     f22:        2*[(r**2)/f] * [d/dchi(log(r))](constant psi) = [1/f] * [dr**2/dchi](constant psi)
c     f23:        S = (f/r**2)*[del*(psi) - d/dpsi[grad(psi)**2]normal)] / grad(psi)**2)  -
c                                                     f'/r**2  (Local shear)
c     f24:        T - S  =  mu0*j.B/(grad(psi)**2) - S
c                        = (f/r**2)*[d/dpsi[grad(psi)**2]normal) -  2*del*(psi)] / grad(psi)**2)
c     f25:        +[darcl/dpsi]normal) (i.e. (nonorthogonality) for arclength angle
c     f26:        +[dpest/dpsi]normal) (i.e. (nonorthogonality) for PEST angle
c     f27:        +[dpest/darcl]constant psi
c     f28:        +[dpest/dpsi ]constant arcl
c
c
c
c
c 1.0 Initialize parameters.
c
c 1.1 Set the flux surface index
c
      jvnew      = jpsi-jval+1
c
      if(jvnew .lt.   0  ) then
        call abortjob
     &        ('eqdcell ',  1,   'jvnew is out of range: jval > jpsi1 '
     &        ,'jval    ', jval,     'jvnew   ', jvnew,    +1)
      endif
      if(jvnew .gt. jpsi1) then
        call abortjob
     &        ('eqdcell ',  2,   'jvnew is out of range: jval < 0     '
     &        ,'jval    ', jval,     'jvnew   ', jvnew,    +1)
      endif
c
c
c 1.2 Set the flux surface values
c
      if    (jval .eq. 0) then
         fvalp     =  flim
         pvalp     =  plim
         ppvalp    =  pplim
         ffpvalp   =  ffplim
         qvalp     =  qlim
         fqvalp    =  fqilim
         f2valp    =  flim*flim
         fpvalp    =  ffplim/flim
      elseif(jval .gt. 0) then
         fvalp     =  f   (jval)
         pvalp     =  p   (jval)
         ppvalp    =  pp  (jval)
         ffpvalp   =  ffp (jval)
         qvalp     =  qp  (jval)
         fqvalp    =  fqpi(jval)
         f2valp    =  fvalp*fvalp
         fpvalp    =  ffpvalp/fvalp
      endif
c
      amuppv     =  amu*ppvalp
      amugp      =  amu*gamav*pvalp
c
c
c 1.3 Initialize integration.
c       Integration is done over the coordinate l = arclength with
c       Jacobian J = r/grad(psi)
c
      ntmsh1     = ntmsh-1
c
      if(arcnrm0 .ne. arc(npc)) then
        call abortjob
     &        ('eqdcell ',  3,   'arcnrm0 and arc(npc) not equal      '
     &        ,'jval    ', jval,     'npc     ', npc,      -1)
        arcnrm0   = arc(npc)
      endif
c
      arclen     = arcnrm0
c
c
c
c 2.0 Calculate the nonorthogonality and normalizations dlnl, dpnl, and dhnl
c
      call betachi(jval,ithtm,dlnl,dpnl,dhnl,kuout)
c
c
c
c 3.0 Set up the surface quantities.
c     The quantities are stored in reverse order in psi (i.e. from
c     psimax at the magnetic axis to psilim).
c
c 3.1 Initialize coefficients.
c
      arcnrm1          = charcmx/arcnrm0
      pstnrm1          = chpstmx/pstnrm0
      hamnrm1          = chhammx/hamnrm0
c
c
c 3.2 Set the normalizations for the poloidal angles.
c
      arcnorm(jvnew)   = arcnrm0
      pstnorm(jvnew)   = pstnrm0
      hamnorm(jvnew)   = hamnrm0
c
c
c 3.3 Set the flux surface integrals.
c
c 3.3.1 Set the basic surface integrals from svint from maparc.
c
      sint0(jvnew)     = svint(3)
      sint1(jvnew)     = svint(4)
      sint2(jvnew)     = svint(5)
      sint3(jvnew)     = svint(6)
      sint4(jvnew)     = svint(7)
c
c 3.3.2 Set the surface averaged local shear quantities.
c
      savrage          =     fpvalp       *svint(4)  - 
     &                       fvalp        *svint(5)  -
     &                       fvalp*amuppv *svint(6)  - 
     &                       f2valp*fpvalp*svint(7)
      tavrage          = 0.5*fpvalp       *svint(4)  + 
     &                   0.5*fvalp        *svint(5)  +
     &                   1.5*fvalp*amuppv *svint(6)  + 
     &                   1.5*f2valp*fpvalp*svint(7)
c
      savge(jvnew)     =     savrage/svint(3)
      tavge(jvnew)     =     tavrage/svint(3)
c
c 3.3.3 Set qprime
c
      qprime (jvnew)   = savrage/twopi
c
c 3.3.4 Set dlnlval, dpnlval, and dhnlval from betachi.
c
      dlnlval(jvnew)   = dlnl
      dpnlval(jvnew)   = dpnl
      dhnlval(jvnew)   = dhnl
c
c 3.3.5 Set the value for the choice of coordinate system
c
      if(igrid .eq. 0) dnormnl   = dlnl
      if(igrid .ne. 0) dnormnl   = dpnl
c
c
c
c 4.0 Set up the arrays containing the mesh cell quantities.
c     The quantities are stored in reverse order in psi (i.e. from
c     psimax at the magnetic axis to psilim).
c
c 4.1 Loop over the chi mesh points and construct the mesh quantities.
c
c     gp2        = [grad(psi)]**2
c     bp2        =  Bpol**2  = [grad(psi) / r]**2
c     gp         =  grad(psi)
c     bpol       =  Bpol
c     bt2        =  Btor**2
c     btot2      =  (Bpol**2 + Btor**2)
c     curvalp    =  del*psi/r**2 = -jphi/r
c
c     dnormnl    =  (1/L) dL/dpsi      (igrid = 0)
c                =  (f/q*d/dpsi(q/f)   (igrid = 1)
c     xjarc      =  r/grad(psi)
c     xjpst      =  r**2
c     xjham      =  (r**nham1)*(Bpol**nham2)*(Btot**nham3)
c     xjarcl     =  (L/2pi) (r/grad(psi)
c     xjpest     =  (q/f)   * r**2
c     xjhaml     =  (fqpi/f)*(r**nham1)*(Bpol**nham2)*(Btot**nham3)
c     alarcl     =  d/dpsi(arcl)[normal]
c     alpest     =  d/dpsi(pest)[normal]
c     alhaml     =  d/dpsi(haml)[normal]
c
c     xjxvalp    =   J
c     ugap       =  (mu0*p) /J
c     dlnrc      =  (1/r)* [dr/dchi]psi   = [dlog(r)/dchi]psi
c     dlnrp      =   1/r*[dr/dpsi]chi     = [dlog(r)/dpsi]chi
c     dlnrpn     =   1/r*[dr/dpsi]normal  = [dlog(r)/dpsi]normal
c     dir2p      = -(1/r**2)*[dlog(r**2)/dpsi]normal
c     dgc1       =  [d/dchi(grad(psi)**2)]psi
c     dgpn1      =  [d/dpsi (grad(psi)**2)]normal
c     dgpn2      =  (1/grad(psi)**2) * [d/dpsi (grad(psi)**2)]normal
c     dlnbc      =  [d/dchi (log(Bpol))]psi
c     dlnbp      =  [d/dpsi (log(Bpol))]chi
c     dlnbpn     =  [d/dpsi (log(Bpol))]normal
c     dlnbpi     =  [d/dpsi (log(1/Bpol))]chi
c     dlnbci     =  [d/dchi (log(1/Bpol))]psi
c     dlnrp2     =  [dlog(r**2)/dpsi]chi   +2.0*dlnrp
c     dlnrc2     =  [dlog(r**2)/dchi]psi
c     djdc       =  [dJ/dchi]psi
c     djdp       =  [dJ/dpsi]chi
c     djdpn      =  [dJ/dpsi]normal
c     alpha      = +[grad(psi).grad(chi)]/(grad(psi))**2
c     shearv     =   S
c     shearp     =   T - S  =  mu0*j.B/(grad(psi)**2) - S
c     dlnlval    =  [dL/dpsi / L]  (L = arclength) (igrid=0)
c     dpnlval    =  [d(q/f)/dpsi / (q/f)]          (igrid = 1)
c     dortdt     =  [dalpha/dchi]psi
c
c 4.1.1 Loop over the mesh points.
c
      do 100 i   = 1,ithtm
      ip         = i
      if(jval .eq. 0) rvalp   = rsrf(ip)
      if(jval .gt. 0) rvalp   = rs  (ip,jval)
      if(jval .eq. 0) zvalp   = zsrf(ip)
      if(jval .gt. 0) zvalp   = zs  (ip,jval)
      r2valp     = rvalp*rvalp
c
c 4.1.2 Construct grad(psi).
c
      call derivp(rvalp,zvalp,dpdx,dpdy,dpd2x,dpd2y,dpd2xy)
      gp2        =  dpdx*dpdx + dpdy*dpdy
      bp2        =  gp2   /r2valp
      bt2        =  f2valp/r2valp
      gp         =  sqrt(gp2)
      bpol       =  gp/rvalp
      btot2      =  bp2 + bt2
      btot       =  sqrt(btot2)
c
c 4.1.3 Construct jphi.
c       r*jphi is taken to be  = -del*(psi) = +(mu*r**2 *p' + ff')
c
      curvalp    = -(amuppv + ffpvalp/r2valp)
c
c 4.1.4 Construct the Jacobian and non-orthogonality.
c
      xjarc      =  rvalp/gp
      xjpst      =  r2valp
      xjham      = (rvalp**nham1)*(bpol**nham2)*
     &             (btot**nham3)
c
      xjarcl     = (arclen/charcmx)*xjarc
      xjpest     = (qvalp /fvalp)  *xjpst
      xjhaml     = (fqvalp/fvalp)  *xjham
c
      alarcl     =  alfarc(ip)
      alpest     =  alfpst(ip)
      alhaml     =  alfham(ip)
c
      if    (igrid .eq. 0) then
        xjcvalp    =  xjarcl
        alpha      =  alarcl
      elseif(igrid .ne. 0) then
        xjcvalp    =  xjpest
        alpha      =  alpest
      endif
c
c 4.1.5 Set the transformation between arclength and Pest angle.
c
      xjtrans    =  xjarcl/xjpest
c
c 4.1.6 Construct the various nonorthogonal derivatives.
c
      ugap       =  amugp/xjcvalp
      dlnrc      = -xjcvalp*dpdy/r2valp
      dlnrpn     =  dpdx/(rvalp*gp2)
      dlnrp      =  dlnrpn - alpha*dlnrc
      dir2p      = -2.0*dlnrpn/r2valp
      dlnbc      =  (dpdx*dpdy*(dpd2y   - dpd2x)    + 
     &               dpd2xy*   (dpdx*dpdx - dpdy*dpdy))
     &                                  * xjcvalp/(rvalp*gp2)
     &                                              - dlnrc
      dgc1       =  2.0*gp2*(dlnbc + dlnrc)
      dgpn1      =  2.0*(dpdx*dpdx*dpd2x + 2.0*dpdx*dpdy*dpd2xy
     &                                   + dpdy*dpdy*dpd2y) / gp2
      dgpn2      =  dgpn1 / gp2
      dlnbpn     =  0.5*dgpn2 - dlnrpn
      dlnbp      =   dlnbpn - alpha*dlnbc
c
      shearv     = (fvalp/r2valp)*(     r2valp*curvalp/gp2  - dgpn2) +
     &                                         fpvalp / r2valp
      shearp     = (fvalp/r2valp)*(-2.0*r2valp*curvalp/gp2  +
     &                                                dgpn2)
c
c 4.1.7 Construct the Jacobian derivatives
c
c 4.1.7.1 Derivatives of 1/Bpol and r**2
      dlnbpi     = -dlnbp
      dlnbci     = -dlnbc
      dlnrp2     = +2.0*dlnrp
      dlnrc2     = +2.0*dlnrc
c
c 4.1.7.2 Coordinate derivatives of the appropriate Jacobian.
      if    (igrid .eq. 0) then
        djdc       = +xjcvalp* dlnbci
        djdp       = +xjcvalp*(dlnbpi + dnormnl)
      elseif(igrid .ne. 0) then
        djdc       = +xjcvalp* dlnrc2
        djdp       = +xjcvalp*(dlnrp2 + dnormnl)
      endif
c
c 4.1.7.3 Normal derivative of the Jacobian.
      djdpn      = djdp + alpha*djdc
      dortdt     = shearv*r2valp/fvalp - ffpvalp/fvalp - 
     &             djdpn/xjcvalp  + 2.0*dlnrpn
c
c
c 4.2 Save the mesh cell center quantities.
c
c 4.2.1 Mesh cell center coordinates.
c
      rcell  (jvnew,ip) =  rvalp
      zcell  (jvnew,ip) =  zvalp
c
c 4.2.2 Define the derivatives of psi.
c
      dpsdr  (jvnew,ip) =  dpdx
      dpsdz  (jvnew,ip) =  dpdy
c
c 4.2.3 Poloidal angle coordinates normalized to charcmx, chpstmx,
c       and chhammx respectively.
c
c
      chiarcl(jvnew,ip) =  arcnrm1*arcsurf(i)
      chipest(jvnew,ip) =  pstnrm1*pestchi(i)
      chihaml(jvnew,ip) =  hamnrm1*hamlchi(i)
c
c 4.2.4 Jacobians.
c
      xjcarcl(jvnew,ip) = xjarcl
      xjcpest(jvnew,ip) = xjpest
      xjchaml(jvnew,ip) = xjhaml
c
c 4.2.5 Non-orthogonality
c
      alfarcl(jvnew,ip) = alarcl
      alfpest(jvnew,ip) = alpest
      alfhaml(jvnew,ip) = alhaml
c
c
c 4.4 Define the f quantities.
c
      f3     (jvnew,ip) =  fvalp/r2valp
      f4     (jvnew,ip) =  curvalp/bp2
      f5     (jvnew,ip) =  fvalp*(djdp/r2valp                 -
     &                                   2.0*xjcvalp*dlnrp/r2valp)
      f7     (jvnew,ip) =  xjcvalp*(2.0*curvalp*curvalp/bp2   -
     &                                       curvalp*dgpn2    +
     &                                       amuppv*r2valp*dir2p)
      f8     (jvnew,ip) =  1.0/(xjcvalp*gp2)
      f9     (jvnew,ip) =  xjcvalp*bp2
      f10    (jvnew,ip) =  r2valp/xjcvalp
      f11    (jvnew,ip) =  ugap
      f12    (jvnew,ip) =  fvalp*xjcvalp/r2valp
      f13    (jvnew,ip) =  xjcvalp
      f14    (jvnew,ip) =  djdp
      f15    (jvnew,ip) =  djdc
      f16    (jvnew,ip) =  dgpn1
      f17    (jvnew,ip) =  dgc1
      f18    (jvnew,ip) =  gp2*dortdt + alpha*dgc1
      f19    (jvnew,ip) =  dortdt
      f20    (jvnew,ip) = -alpha
      f21    (jvnew,ip) =  2.0*r2valp*dlnrpn/fvalp
      f22    (jvnew,ip) =  2.0*r2valp*dlnrc /fvalp
      f23    (jvnew,ip) =  shearv
      f24    (jvnew,ip) =  shearp
      f25    (jvnew,ip) = +alarcl
      f26    (jvnew,ip) = +alpest
      f27    (jvnew,ip) =  xjtrans
      f28    (jvnew,ip) =  alpest - alarcl*xjtrans
  100 continue
c
c
c
c 5.0 Impose periodicity
c
c 5.1 Impose periodicity on the coordinates
c
      rcell  (jvnew,ithtp) =  rcell  (jvnew,1)
      zcell  (jvnew,ithtp) =  zcell  (jvnew,1)
      dpsdr  (jvnew,ithtp) =  dpsdr  (jvnew,1)
      dpsdz  (jvnew,ithtp) =  dpsdz  (jvnew,1)
c
      chiarcl(jvnew,ithtp) =  chiarcl(jvnew,1) + charcmx
      chipest(jvnew,ithtp) =  chipest(jvnew,1) + chpstmx
      chihaml(jvnew,ithtp) =  chihaml(jvnew,1) + chhammx
c
      xjcarcl(jvnew,ithtp) =  xjcarcl(jvnew,1)
      xjcpest(jvnew,ithtp) =  xjcpest(jvnew,1)
      xjchaml(jvnew,ithtp) =  xjchaml(jvnew,1)
c
      alfarcl(jvnew,ithtp) =  alfarcl(jvnew,1)
      alfpest(jvnew,ithtp) =  alfpest(jvnew,1)
      alfhaml(jvnew,ithtp) =  alfhaml(jvnew,1)
c
c
c 5.2 Impose periodicity on the equilibrium quantities
c
      f3     (jvnew,ithtp) =  f3     (jvnew,1)
      f4     (jvnew,ithtp) =  f4     (jvnew,1)
      f5     (jvnew,ithtp) =  f5     (jvnew,1)
      f7     (jvnew,ithtp) =  f7     (jvnew,1)
      f8     (jvnew,ithtp) =  f8     (jvnew,1)
      f9     (jvnew,ithtp) =  f9     (jvnew,1)
      f10    (jvnew,ithtp) =  f10    (jvnew,1)
      f11    (jvnew,ithtp) =  f11    (jvnew,1)
      f12    (jvnew,ithtp) =  f12    (jvnew,1)
      f13    (jvnew,ithtp) =  f13    (jvnew,1)
      f14    (jvnew,ithtp) =  f14    (jvnew,1)
      f13    (jvnew,ithtp) =  f13    (jvnew,1)
      f14    (jvnew,ithtp) =  f14    (jvnew,1)
      f15    (jvnew,ithtp) =  f15    (jvnew,1)
      f16    (jvnew,ithtp) =  f16    (jvnew,1)
      f17    (jvnew,ithtp) =  f17    (jvnew,1)
      f18    (jvnew,ithtp) =  f18    (jvnew,1)
      f19    (jvnew,ithtp) =  f19    (jvnew,1)
      f20    (jvnew,ithtp) =  f20    (jvnew,1)
      f21    (jvnew,ithtp) =  f21    (jvnew,1)
      f22    (jvnew,ithtp) =  f22    (jvnew,1)
      f23    (jvnew,ithtp) =  f23    (jvnew,1)
      f24    (jvnew,ithtp) =  f24    (jvnew,1)
      f25    (jvnew,ithtp) =  f25    (jvnew,1)
      f26    (jvnew,ithtp) =  f26    (jvnew,1)
      f27    (jvnew,ithtp) =  f27    (jvnew,1)
      f28    (jvnew,ithtp) =  f28    (jvnew,1)
c
c
c
c 6.0 Return and end
c
      return
      end
      subroutine maparc(ktype,jval,psiv,fval,ithtm,srfint,nvnt)
c
c calculate arclength, the Pest and Hamiltonian coordinates, and the
c integrands st1, st2, sv0, sv1, sv2, sv3, sv4, and sv5.
c calculate integrals of st1, st2, sv0, sv1, sv2, sv3, and sv4 on the flux
c contour defined from (xp,zp)
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
      parameter (nlx=1441)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension srfint(nvnt)
      dimension ypi(1)
c
c
c     Input quantities:
c     psiv:            Psi value of the flux contour.
c     jval:            Index for the flux surface (jval > 0)
c                      jval = 0 corresponds to the plasma surface
c     fval:            Toroidal Field function value for the flux surface.
c     xp, zp:          Grid points defining the contour
c     npc:             Number of grid points defining the contour
c
c     Output quantities:
c     srfint(li):      Surface integrals:
c                        qpval:      Safety factor value on this flux surface
c                        fqval:      Value of fqpi on this flux surface
c     tp(i):           Arclength around the contour
c     st1(i):          Pest angle around the contour
c     st2(i):          Hamiltonian-like angle coordinate around the contour
c     st3(i):          Temporary storage
c     sv0(i):          r/grad(psi) on arc
c     sv1(i):          r*(1/(r**2)) / (grad(psi)) on arc
c     sv2(i):          r*(d/dpsi(log(grad(psi)**2)) / r**2) / (grad(psi) on arc
c     sv3(i):          r*(1/(grad(psi)**2)) / (grad(psi)) on arc
c     sv4(i):          r*(1/(r*grad(psi)**2)) / (grad(psi)) on arc
c     sv5(i):          r*(dlog(r**2)/dpsi) / (grad(psi)) on arc
c                         dlog(r**2)/dpsi = (2/r)dr/dpsi = (2/r)*dpsi/dr*(1/grad(psi))
c
c The mapping to the flux grid is done for each flux contour psiv as follows:
c
c 1.    Compute diagonal increments between the (xp,zp) from each ii to
c       ii+1 around the flux contour and store the incremented distances
c       in tp(ii).
c       Compute the diagonal increments on a rescaled approximately
c       circular surface.  The transformation from the real to rescaled
c       surface is a change in metric to
c                     dl  =  sqrt(dr*dr + gkappa*dz*dz)
c       where gkappa is the inverse elongation of the flux surface squared.
c       The incremented distances for the rescaled  surface are stored
c       in tpp(ii).
c 2.    Compute the arclengths between successive points (xp,zp)
c       for both the real and rescaled surfaces by integrating tp and
c       tpp using garc.  The arclengths are stored in arc and arcc
c       for ii = 1,npc respectively.
c 3.    Define a grid of arclength values around the surface as follows:
c       The odd points are computed from equal arclength around the
c       rescaled surface, stored in tpp, and mapped on to the real
c       surface in tp.  The total number of points, ntmsh is forced to
c       be odd to ensure the start and end points are included - ntmsh
c       is set equal to either ntmax=nlx or ntmax-1 to ensure maximum
c       accuracy.  The even points are then set halfway between the odd
c       points on the real contour to ensure equal spacing for three
c       point integrations.  These are then mapped to the rescaled surface
c       and stored in tpp.  The points should then be well distributed for
c       future interpolations.
c       Define the integrands st1 and st2 for the later calculation of
c       the PEST and Hamiltonian-like poloidal coordinates on this grid.
c 4.    Compute the cubic spline coefficients for the integrands for the
c       partial integrations which specify the PEST and Hamiltonian-like
c       coordinates and integrate around the real flux surface to compute
c       the normalizations corresponding to the q value (qpval) and fq (fqval).
c       Reset the interpolation coefficients for xp(arc) and zp(arc) in
c       csx and csz.
c 5.    Compute the PEST and Hamiltonian-like coordinates on the arclength
c       mesh tp by partial integration of st1 and st2 around the real
c       contour and store them back in st1 and st2.
c
c
c
c 1.0 Initialization.
c
c 1.1 Error flags and tolerances
c
      ier        = 0
      kercntr    = 0
      rndff      = roundff
      splndif    = tolspln*sqrt(xdim*xdim + zdim*zdim)
      delta0     = boxtnd
c
      ntdim      = nlx
      npcm1      = npc - 1
c
c
c 1.2 Constants
c
c 1.2.1 psi coordinate value for inverse mapping:
c
      if(ktype .ge. 1) then
        psivs      = defmesh(psiv,psimax,delpsir,peqpk0,rndff,
     &                       dpsds0,dpsdss0,ier)
        if(ier .ne. 0) call abortjob
     &        ('maparc  ',  1,   'Mesh construction error: defmesh    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
      endif
c
c 1.2.2 Toroidal field value
c
      fvsq       = fval*fval
c
c
c
c 2.0 Diagonal increments for successive (xp,zp) points on the contour
c
c 2.1 Define the box containing the surface and compute the elongation
c     for gkappa.  Use the box containing the appropriate flux surface
c
c 2.1.1 Find the box containing the flux surface
c
      xmn        = +bigno*abs(xdim)
      xmx        = -bigno*abs(xdim)
      zmn        = +bigno*abs(zdim)
      zmx        = -bigno*abs(zdim)
      delta1     = delta0/sqrt((ndim1-1.0)*(ndim2-1.0))
c
      do 40 ii   = 1,npc
      if(xp(ii) .le. xmn) xmn = xp(ii)
      if(xp(ii) .ge. xmx) xmx = xp(ii)
      if(zp(ii) .le. zmn) zmn = zp(ii)
      if(zp(ii) .ge. zmx) zmx = zp(ii)
  40  continue
c
c 2.1.2 Extend the extrema a little to ensure the box is finite and
c       check the box lies inside the full plasma box
      zboxx      = (xmx-xmn) + delta1*(xmx+xmn)
      zboxz      = (zmx-zmn) + delta1*(zmx+zmn)
      if(zboxx .gt. xdim  .or.  zboxx .le. 0.0) zboxx = xdim
      if(zboxz .gt. zdim  .or.  zboxz .le. 0.0) zboxz = zdim
c
      zratio     = zboxz/zboxx
      gkappa     = 1.0/(zratio*zratio)
c
c
c 2.2 Construct the arclength around the real contour
c
c 2.2.1 Construct the arclength and spline coefficients
c
      call arclng(xp,zp,npc,ntdim,1.0,   tp, arc, csx,csz,ierp0)
c
c 2.2.2 Error handling
c
      if(ierp0 .ne. 0) then
        write(kuout,1000) npc,ntdim
        write(kuout,1010) (ivv,xp(ivv),zp(ivv),tp (ivv),arc (ivv)
     &                        ,ivv=1,npc)
        if(ierp0 .gt. 0) then
          call abortjob
     &        ('maparc  ',  2,   'Arclength evaluation error: arc(x,z)' 
     &        ,'ierp0   ', ierp0,    'jval    ', jval,     +1)
        elseif(ierp0 .lt. 0) then
          call abortjob
     &        ('maparc  ',  3,   'Arclength evaluation error: arc(x,z)' 
     &        ,'ierp0   ', ierp0,    'jval    ', jval,     -1)
        endif
      endif
c
c
c 2.3 Construct the arclength around the rescaled contour
c
c 2.3.1 Construct the arclength and spline coefficients
c
      call arclng(xp,zp,npc,ntdim,gkappa,tpp,arcc,csx,csz,ierp1)
c
c 2.3.2 Error handling
c
      if(ierp1 .ne. 0) then
        write(kuout,1030) npc,ntdim,gkappa
        write(kuout,1040) (ivv,xp(ivv),zp(ivv),tpp(ivv),arcc(ivv)
     &                        ,ivv=1,npc)
        if(ierp1 .gt. 0) then
          call abortjob
     &        ('maparc  ',  4,   'Arclength evaluation error:arcc(x,z)' 
     &        ,'ierp1   ', ierp1,    'jval    ', jval,     +1)
        elseif(ierp1 .lt. 0) then
          call abortjob
     &        ('maparc  ',  5,   'Arclength evaluation error:arcc(x,z)' 
     &        ,'ierp1   ', ierp1,    'jval    ', jval,     -1)
        endif
      endif
c
c
c
c 3.0 Interpolate arclength values on the real flux contour
c     corresponding to equal arclength on the rescaled contour.
c
c 3.1 Spline coefficients of xp and zp with respect to arcc.
c     This is redundant if arclng is called last for arcc but is
c     redone here as a precaution against future coding changes.
c
c     The coefficients are stored in csx and csz respectively.
c     csx and csz are overwritten later before exiting with the
c     coefficients for xp and zp with respect to arc.
c
      bcd(1)     = 0.0
      bcd(2)     = 2.*f2s(npcm1,xp,arcc,ntmax)
      bcd(3)     = 0.0
      bcd(4)     = bcd(2)
      call icsici(arcc,xp,npc,bcd,csx,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('maparc  ',  6,   'Spline interpolation error:z_arc    '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
      bcd(2)     = 2.*f2s(npcm1,zp,arcc,ntmax)
      bcd(4)     = bcd(2)
      call icsici(arcc,zp,npc,bcd,csz,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('maparc  ',  7,   'Spline interpolation error:z_arc    '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c
c 3.2 Construct the arclength grids in tp and tpp such that the odd
c     points are at equal arclength on the rescaled contour and the
c     even points are midway between the odd points on the real contour.
c     The number of points is necessarily odd so as to include the start
c     and end points on the odd mesh.
c     The arclengths corresponding to arcc are stored in tpp
c     The corresponding arclengths on the real contour are stored in tp
c     The quantities st1 = (r/grad(psi)*(1/r**2)         and
c         st2 = (r/grad(psi)*(1/(r**nham1 *Bpol**nham2 * Btot**nham3))
c     are also computed for the calculation of the normalizations for
c     q and fqpi.
c     The coefficients csx and csz are the interpolation
c     coefficients from arcc to xp and zp
c
c 3.2.1 Initialize the mesh construction
c     Care is needed here for the interpolation between arc and arcc:
c     The interpolation can become unstable if arcc or arc are too
c     unevenly spaced.
c
      if(ntmax .eq. 2*(ntmax/2)) ntmsh   = ntmax-1
      if(ntmax .ne. 2*(ntmax/2)) ntmsh   = ntmax
c
      arctpp0    = 0.0
      arclmx     = arc (npc)
      arcclmx    = arcc(npc)
      if(arclmx  .le. 0.0) call abortjob
     &        ('maparc  ',  8,   'arc (npc) is negative               '
     &        ,'jval    ', jval,     'npc     ', npc,      +1)
c
      if(arcclmx .le. 0.0) call abortjob
     &        ('maparc  ',  9,   'arcc(npc) is negative               '
     &        ,'jval    ', jval,     'npc     ', npc,      +1)
c
      arnorm1    = charcmx/arclmx
c
      ntry       = 0
      ntorig     = ntmsh
   55 ntry       = ntry + 1
        missd      = 0
        ntmsh1     = ntmsh-1
        dlarcc     = arcclmx/(ntmsh-1.)
c
c 3.2.2 Construct the odd mesh points
c
c 3.2.2.1 Loop over even mesh points and interpolate the arclength
        kmis       = 0
        kmiss      = 0
        kmisiv     = 0
        kmissiv    = 0
        do 60 i    = 1,ntmsh,2
        ipv        = i
        dell       = arctpp0 + (ipv-1.0)*dlarcc
        if(dell .lt. arctpp0) dell   = arctpp0
        if(dell .gt. arcclmx) dell   = arcclmx
        arctp      = sintrp(dell,arcc,arc,npc,ypi,1,ypl,ypr,4,ier
     &                     ,endtol,kuout)
        if(iabs(ier) .eq. 1  .or.  iabs(ier) .ge. 3)
     &     call abortjob
     &        ('maparc  ', 10,   'Interpolation error: arcc(arc)      '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c 3.2.2.2 Interpolate to find r and z
        rvl0       = sterpl(dell,arcc,xp, csx,npc,nlx,1,rndff,ier)
        if(ier .ne. 0) call abortjob
     &        ('maparc  ', 11,   'Spline evaluation error: x(arcc)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
        zvl0       = sterpl(dell,arcc,zp, csz,npc,nlx,1,rndff,ier)
        if(ier .ne. 0) call abortjob
     &        ('maparc  ', 12,   'Spline evaluation error: z(arcc)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c
c 3.2.2.3 Compute the psi derivatives
c
c 3.2.2.3.1 Use the direct derivatives for ktype = 0
        if    (ktype .eq. 0) then
          call derivp(rvl0,zvl0,dpdx,dpdy,dpd2x,dpd2y,dpd2xy)
          gpsi2    =      dpdx*dpdx + dpdy*dpdy
          dgp2dpn  = 2.0*(dpdx*dpdx*dpd2x + 2.0*dpdx*dpdy*dpd2xy  +
     &                    dpdy*dpdy*dpd2y) / gpsi2
c
c 3.2.2.3.2 Use the inverse derivatives for ktype = 1
c           psivs is in the same units as peqmsh0
        elseif(ktype .eq. 1) then
          arctpn   = arnorm1*arctp
          rvl1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psivs,arctpn,pdsr,ier)
          if(ier .ne. 0) call abortjob
     &        ('maparc  ', 13,   'Spline error for rvl(psiv,arc)      '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
          zvl1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psivs,arctpn,pdsz,ier)
          if(ier .ne. 0) call abortjob
     &        ('maparc  ', 14,   'Spline error for zvl(psiv,arc)      '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
          rvldif   = rvl1 - rvl0
          zvldif   = zvl1 - zvl0
          if((abs(rvldif) .ge. splndif) .or.
     &       (abs(zvldif) .ge. splndif)) then
            kercntr   = kercntr + 1
            if    (kercntr .lt. nerstop) then
              call abortjob
     &        ('maparc  ', 15,   'Odd  mesh 1D / 2D Spline discrepancy'
     &        ,'jval    ', jval,     'ipv     ', ipv,       0)
              write(kuout,1100) dell,arctp,psiv,arctpn,arnorm1
     &                           ,splndif,rvldif,zvldif,rvl0,rvl1
     &                                                 ,zvl0,zvl1
            elseif(kercntr .eq. nerstop) then
              call abortjob
     &        ('maparc  ', 16,   'Maximum number spline errors reached'
     &        ,'jval    ', jval,     'nerstop ', nerstop,  -1)
            endif
          endif
c
          call derivpsi(pdsr,pdsz,dpsds0,dpsdss0,pdsp,pdsc,rndff,2,ier)
          if(ier .ne. 0) call abortjob
     &        ('maparc  ', 17,   'Error inverting dp/dr from dr/dp    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
          dpdx     = pdsp(2)
          dpdy     = pdsp(3)
          dbpoldp  = pdsp(5)
          dbpoldc  = pdsc(5)
          alpha    = pdsp(6)
c
c 3.2.2.3.3 Compute the normal derivative of grad(psi)**2
c           This obtains the derivatives in the equal arc coordinate system
c           and uses this to construct the normal derivative valid for any
c           poloidal angle
c
          gpsi2    = dpdx*dpdx + dpdy*dpdy
          dgp2dpn  = dbpoldp + alpha*dbpoldc
        endif
c
c 3.2.2.4 Construct the poloidal field
        btot2      = (fvsq + gpsi2) / (rvl0*rvl0)
        gpsi       =  sqrt(gpsi2)
        bpol       =  gpsi/rvl0
        btot       =  sqrt(btot2)
        djarc      =  rvl0/gpsi
        drdpsi     =  dpdx/(rvl0*gpsi2)
        dr2dpsi    =  2.0*drdpsi
c
c 3.2.2.5 Store the functions
        tp (ipv)   =  arctp
        tpp(ipv)   =  dell
        st1(ipv)   =  djarc/(rvl0*rvl0)
        st2(ipv)   =  djarc/((rvl0**nham1)*(bpol**nham2)*(btot**nham3))
c
c 3.2.2.6 Store the surface integrands
        sv0(ipv)   =  djarc
        sv1(ipv)   =  djarc/(rvl0*rvl0)
        sv2(ipv)   = (djarc*dgp2dpn)/(rvl0*rvl0*gpsi2)
        sv3(ipv)   =  djarc/(gpsi2)
        sv4(ipv)   =  djarc/(rvl0*rvl0*gpsi2)
        sv5(ipv)   =  djarc*dr2dpsi
   60   continue
c
c 3.2.3 Construct the even mesh points
c
c 3.2.3.1 Loop over even mesh points and interpolate the arclength
        do 65 i    = 2,ntmsh1,2
        ipv        = i
        arctp      = 0.5*(tp(ipv-1) + tp(ipv+1))
        dell       = sintrp(arctp,arc,arcc,npc,ypi,1,ypl,ypr,4,ier
     &                     ,endtol,kuout)
        if(iabs(ier) .eq. 1  .or.  iabs(ier) .ge. 3)
     &     call abortjob
     &        ('maparc  ', 18,   'Interpolation error: arc(arcc)      '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c 3.2.3.2 Interpolate to find r and z
        rvl0       = sterpl(dell,arcc,xp, csx,npc,nlx,1,rndff,ier)
        if(ier .ne. 0) call abortjob
     &        ('maparc  ', 19,   'Spline evaluation error: x(arcc)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
        zvl0       = sterpl(dell,arcc,zp, csz,npc,nlx,1,rndff,ier)
        if(ier .ne. 0) call abortjob
     &        ('maparc  ', 20,   'Spline evaluation error: z(arcc)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
c 3.2.3.3 Compute the psi derivatives
c
c 3.2.3.3.1 Use the direct derivatives for ktype = 0
        if    (ktype .eq. 0) then
          call derivp(rvl0,zvl0,dpdx,dpdy,dpd2x,dpd2y,dpd2xy)
          gpsi2    =      dpdx*dpdx + dpdy*dpdy
          dgp2dpn  = 2.0*(dpdx*dpdx*dpd2x + 2.0*dpdx*dpdy*dpd2xy  +
     &                    dpdy*dpdy*dpd2y) / gpsi2
c
c 3.2.3.3.2 Use the inverse derivatives for ktype = 1
        elseif(ktype .eq. 1) then
          arctpn   = arnorm1*arctp
          rvl1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,csrvl
     &                      ,psivs,arctpn,pdsr,ier)
          if(ier .ne. 0) call abortjob
     &        ('maparc  ', 21,   'Spline error for rvl(psiv,arc)      '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
          zvl1     = dspeval(peqmsh0,npsi,npp,thchi,nthet,ntt,cszvl
     &                      ,psivs,arctpn,pdsz,ier)
          if(ier .ne. 0) call abortjob
     &        ('maparc  ', 22,   'Spline error for zvl(psiv,arc)      '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
          rvldif   = rvl1 - rvl0
          zvldif   = zvl1 - zvl0
          if((abs(rvldif) .ge. splndif) .or.
     &       (abs(zvldif) .ge. splndif)) then
            kercntr   = kercntr + 1
            if    (kercntr .lt. nerstop) then
              call abortjob
     &        ('maparc  ', 23,   'Even mesh 1D / 2D Spline discrepancy'
     &        ,'jval    ', jval,     'ipv     ', ipv,       0)
              write(kuout,1110) dell,arctp,psiv,arctpn,arnorm1
     &                         ,splndif,rvldif,zvldif,rvl0,rvl1
     &                                               ,zvl0,zvl1
            elseif(kercntr .eq. nerstop) then
              call abortjob
     &        ('maparc  ', 24,   'Maximum number spline errors reached'
     &        ,'jval    ', jval,     'nerstop ', nerstop,  -1)
            endif
          endif
c
          call derivpsi(pdsr,pdsz,dpsds0,dpsdss0,pdsp,pdsc,rndff,2,ier)
          if(ier .ne. 0) call abortjob
     &        ('maparc  ', 25,   'Error inverting dp/dr from dr/dp    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
          dpdx     = pdsp(2)
          dpdy     = pdsp(3)
          dbpoldp  = pdsp(5)
          dbpoldc  = pdsc(5)
          alpha    = pdsp(6)
c
c 3.2.3.3.3 Compute the normal derivative of grad(psi)**2
c           This obtains the derivatives in the equal arc coordinate system
c           and uses this to construct the normal derivative valid for any
c           poloidal angle
c
          gpsi2    = dpdx*dpdx + dpdy*dpdy
          dgp2dpn  = dbpoldp + alpha*dbpoldc
        endif
c
c 3.2.3.4 Construct the poloidal field
        btot2      = (fvsq + gpsi2) / (rvl0*rvl0)
        gpsi       =  sqrt(gpsi2)
        bpol       =  gpsi/rvl0
        btot       =  sqrt(btot2)
        djarc      =  rvl0/gpsi
        drdpsi     =  dpdx/(rvl0*gpsi2)
        dr2dpsi    =  2.0*drdpsi
c
c 3.2.3.5 Store the functions
        tp (ipv)   =  arctp
        tpp(ipv)   =  dell
        st1(ipv)   =  djarc/(rvl0*rvl0)
        st2(ipv)   =  djarc/(rvl0**nham1 *bpol**nham2 *btot**nham3)
c
c 3.2.3.6 Store the surface integrands
        sv0(ipv)   =  djarc
        sv1(ipv)   =  djarc/(rvl0*rvl0)
        sv2(ipv)   = (djarc*dgp2dpn)/(rvl0*rvl0*gpsi2)
        sv3(ipv)   =  djarc/(gpsi2)
        sv4(ipv)   =  djarc/(rvl0*rvl0*gpsi2)
        sv5(ipv)   =  djarc*dr2dpsi
c
c 3.2.3.7 Check that the interpolated tp values are ordered correctly
        if(tp (ipv) .lt. tp (ipv-1)  .or.
     &     tp (ipv) .gt. tp (ipv+1)) then
          kmisiv     = ipv
          kmis       = kmis  + 1
        endif
        if(tpp(ipv) .lt. tpp(ipv-1)  .or.
     &     tpp(ipv) .gt. tpp(ipv+1)) then
          kmissiv    = ipv
          kmiss      = kmiss + 1
        endif
   65   continue
c
c 3.2.4 Print a warning if the maximum number of spline errors was reached
c
        if(kercntr .ge. nerstop) then
          call abortjob
     &        ('maparc  ', 26,   'Maximum spline errors exceeded      '
     &        ,'jval    ', jval,     'kercntr ', kercntr,  -1)
        endif
c
c
c 3.3 Check that the interpolation is correct
c
c 3.3.1 Check that the last point is correct
c
        ardiff     = tp(ntmsh) - arc(npc)
        arnorm     = endtol*abs(arc(npc))
        if(abs(ardiff) .ge. arnorm) call abortjob
     &        ('maparc  ', 27,   'tp(ntmsh) and arc(npc) not equal    '
     &        ,'jval    ', jval,     'npc     ', npc,      -1)
c
c 3.3.2 Check that the points are correctly ordered
c       If not return to 55 and try again
c
        if(kmis  .gt. 0  .or.  kmiss .gt. 0) then
c
c 3.3.2.1 Set a reduced number of mesh points
          ntmold    = ntmsh
          ntmshp    = ntmsh - 2*ntdecr
c
c 3.3.2.2 Print error message if the points are incorrectly ordered and
c         try again with fewer points
          if    (ntry .lt. ntrymx) then
            if    (ntmshp .ge. ntmmin) then
              ntmsh   = ntmshp
              if(kmis  .gt. 0  .and.  kmiss .gt. 0)
     &                         write(kuout,1500) jval,ntry,
     &                                           kmis, kmisiv,
     &                                           kmiss,kmissiv,
     &                                           npc,ntdecr,ntorig,
     &                                           ntmold,ntmsh
              if(kmis  .gt. 0  .and.  kmiss .eq. 0)
     &                         write(kuout,1510) jval,ntry,
     &                                           kmis, kmisiv,
     &                                           npc,ntdecr,ntorig,
     &                                           ntmold,ntmsh
              if(kmis  .eq. 0  .and.  kmiss .gt. 0)
     &                         write(kuout,1520) jval,ntry,
     &                                           kmiss,kmissiv,
     &                                           npc,ntdecr,ntorig,
     &                                           ntmold,ntmsh
              go to 55
c
c 3.3.2.3 Print error message if the points are incorrectly ordered and
c         quit retrying if the reduced mesh is too small
            elseif(ntmshp .lt. ntmmin) then
              call abortjob
     &        ('maparc  ', 28,   'Arc calculation failed:ntmsh<min    '
     &        ,'jval    ', jval,     'ntry    ', ntry,     -1)
              missd  = -1
            endif
c
c 3.3.2.4 Print error message if the points are incorrectly ordered and
c         quit retrying if the maximum number of tries is exceeded
          elseif(ntry .ge. ntrymx) then
            missd   = +1
            call abortjob
     &        ('maparc  ', 29,   'Arc calculation failed: ntry>max    '
     &        ,'jval    ', jval,     'ntry    ', ntry,     -1)
          endif
c
c 3.3.2.5 Print error message if the points are incorrectly ordered and
c         terminate if number of allowed tries is exceeded.
          if(missd .ne. 0) then
            if(kmis  .gt. 0  .and.  kmiss .gt. 0) then
              write(kuout,2000) jval,psiv,ntry,ntrymx,ntdecr,ntmmin,npc
     &                         ,ntorig,ntmold,ntmshp,ntmsh,kmis,kmisiv
     &                         ,kmiss,kmissiv
            elseif(kmis  .gt. 0  .and.  kmiss .eq. 0) then
              write(kuout,2010) jval,psiv,ntry,ntrymx,ntdecr,ntmmin,npc
     &                         ,ntorig,ntmold,ntmshp,ntmsh,kmis,kmisiv
     &                         ,kmiss,kmissiv
            elseif(kmis  .eq. 0  .and.  kmiss .gt. 0) then
              write(kuout,2020) jval,psiv,ntry,ntrymx,ntdecr,ntmmin,npc
     &                         ,ntorig,ntmold,ntmshp,ntmsh,kmis,kmisiv
     &                         ,kmiss,kmissiv
            elseif(kmis  .eq. 0  .and.  kmiss .eq. 0) then
              write(kuout,2030) jval,psiv,ntry,ntrymx,ntdecr,ntmmin,npc
     &                         ,ntorig,ntmold,ntmshp,ntmsh,kmis,kmisiv
     &                         ,kmiss,kmissiv
            endif
c
            write(kuout,2100)
            write(kuout,2110)  npc
            write(kuout,2115) (xp(ii),  ii=1,npc)
            write(kuout,2120)  npc
            write(kuout,2125) (zp(ii),  ii=1,npc)
            write(kuout,2130)  npc
            write(kuout,2135) (arc(ii), ii=1,npc)
            write(kuout,2140)  npc
            write(kuout,2145) (arcc(ii),ii=1,npc)
            write(kuout,2150)  ntmold
            write(kuout,2155) (tp(ii),  ii=1,ntmold)
            write(kuout,2160)  ntmold
            write(kuout,2165) (tpp(ii), ii=1,ntmold)
c
            if(kmiss .gt. 0) then
              km0     = max0(  1  ,kmissiv-4)
              km1     = min0(ntmold,  km0  +9)
              write(kuout,2170) kmissiv,km0,km1
              write(kuout,2175) (   kk  ,kk=km0,km1)
              write(kuout,2180) (tpp(kk),kk=km0,km1)
c
              if(missd .lt. 0) call abortjob
     &        ('maparc  ', 30,   'Misordered tpp points: missd < 0    '
     &        ,'jval    ', jval,     'kmiss   ', kmiss,    -1)
              if(missd .gt. 0) call abortjob
     &        ('maparc  ', 31,   'Misordered tpp points: missd > 0    '
     &        ,'jval    ', jval,     'kmiss   ', kmiss,    -1)
            endif
c
            if(kmis .gt. 0) then
              km0     = max0(  1  ,kmisiv -4)
              km1     = min0(ntmold,  km0  +9)
              write(kuout,2185) kmisiv,km0,km1
              write(kuout,2190) (   kk  ,kk=km0,km1)
              write(kuout,2195) (tp (kk),kk=km0,km1)
              if(missd .lt. 0) call abortjob
     &        ('maparc  ', 32,   'Misordered tp  points: missd < 0    '
     &        ,'jval    ', jval,     'kmiss   ', kmiss,    +1)
              if(missd .gt. 0) call abortjob
     &        ('maparc  ', 33,   'Misordered tp  points: missd > 0    '
     &        ,'jval    ', jval,     'kmiss   ', kmiss,    +1)
            endif
          endif
        endif
c
c
c 3.4 Print a warning if several attempts at getting ordered arclength points
c     were required
c
        if(ntry .gt. 1) then
              if(missd .eq. 0) call abortjob
     &        ('maparc  ', 34,   'Multiple tries: Points ordered      '
     &        ,'jval    ', jval,     'ntry    ', ntry,     -1)
              if(missd .ne. 0) call abortjob
     &        ('maparc  ', 35,   'Multiple tries: Still misordered    '
     &        ,'jval    ', jval,     'ntry    ', ntry,     -1)
        endif
c
c
c
c 4.0 Compute the normalizations for the PEST and Hamiltonian-like
c     poloidal coordinates, define and qp and fqpi, and compute
c     the interpolation coefficients for the later calculation
c     of the PEST and Hamiltonian coordinates from partial integration
c     of the integrands st1 and st2 around the contour.
c
c 4.1 Normalization for the PEST coordinate and safety factor from
c     integration of st1:
c               dchi = (f/(q*r**2) *(r/grad(psi)))*dl
c      q  =  (f/(2*pi)) * integral(1/(r**2) *(r/grad(psi)))*dl
c     Three separate estimates for the integration are used as
c     a check on the accuracy.
c
c 4.1.1 Integration from trapezoidal rule:
c
      wsumt      = 0.5*st1(  1  )*(tp(  2  )-tp(  1  ))  +
     &             0.5*st1(ntmsh)*(tp(ntmsh)-tp(ntmsh1))
      do 70 i    = 2,ntmsh1
      wsumt      = wsumt + 0.5*st1(i)*(tp(i+1)-tp(i-1))
  70  continue
c
c 4.1.2 Integration from Simpsons rule:
c
      wsums      = 0.0
      do 75 i    = 2,ntmsh1,2
      deltp      = (tp(i+1) - tp(i-1)) / 6.0
      wsums      = wsums + (st1(i-1) + 4.0*st1(i) + st1(i+1)) * deltp
  75  continue
c
c 4.1.3 Integration from gaussian formula with cubic spline interpolation
c       The interpolation coefficients in cseq1 are required later
c       for the calculation of the PEST coordinate by partial integration
c       around the contour.
c
      call surfint(tp,st1,cseq1,bcd,ntmsh,ntmax,ier,answer)
      wsumg      = answer
c
      if(ier .ne. 0) call abortjob
     &        ('maparc  ', 36,   'Spline error for st1 in surfint     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c 4.1.4 Compute and compare the estimates of the safety factor
c
c 4.1.4.1 Compute the three estimates and their differences.
      qptrap     = wsumt*fval/twopi
      qpsimp     = wsums*fval/twopi
      qpgaus     = wsumg*fval/twopi
      qdifts     = qptrap - qpsimp
      qdiftg     = qptrap - qpgaus
      qdifsg     = qpsimp - qpgaus
c
      qpave      = abs(qptrap + qpsimp + qpgaus) / 3.0
      epsqp      = qptol*qpave
c
      kqrule     = 0
      qestim     = qpsimp
c
c 4.1.4.2 Write out a warning if the differences are too great.
      if((abs(qdifts) .ge. epsqp) .or. (abs(qdiftg) .ge. epsqp) .or.
     &                                 (abs(qdifsg) .ge. epsqp)) then
c
c 4.1.4.2.1 For the case when all three estimates mutually differ
c           use the geometric average
        if    ((abs(qdifts) .ge. epsqp)  .and.
     &         (abs(qdiftg) .ge. epsqp)  .and.
     &         (abs(qdifsg) .ge. epsqp))   then
          kqrule   = 1
          qestim   = qpave
c
c 4.1.4.2.2 For the case when   simpson   and trapezoidal are within epsqp
c           but  gaussian   differs from both use   simpson
        elseif((abs(qdifts) .lt. epsqp)  .and.
     &         (abs(qdiftg) .ge. epsqp)  .and.
     &         (abs(qdifsg) .ge. epsqp))   then
          kqrule   = 2
          qestim   = qpsimp
c
c 4.1.4.2.3 For the case when trapezoidal and  gaussian   are within epsqp
c           but   simpson   differs from both use  gaussian
        elseif((abs(qdifts) .ge. epsqp)  .and.
     &         (abs(qdiftg) .lt. epsqp)  .and.
     &         (abs(qdifsg) .ge. epsqp))   then
          kqrule   = 3
          qestim   = qpgaus
c
c 4.1.4.2.4 For the case when   simpson   and  gaussian   are within epsqp
c           but trapezoidal differs from both use the average of simpson
c           and gaussian
        elseif((abs(qdifts) .ge. epsqp)  .and.
     &         (abs(qdiftg) .ge. epsqp)  .and.
     &         (abs(qdifsg) .lt. epsqp))   then
          kqrule   = 4
          qestim   = 0.5*(qpsimp + qpgaus)
c
c 4.1.4.2.5 For the case when   simpson   and trapezoidal are within epsqp
c           and trapezoidal and  gaussian   are within epsqp
c           but   simpson   differs from gaussian use the geometric average
        elseif((abs(qdifts) .lt. epsqp)  .and.
     &         (abs(qdiftg) .lt. epsqp)  .and.
     &         (abs(qdifsg) .ge. epsqp))   then
          kqrule   = 5
          qestim   = qpave
c
c 4.1.4.2.6 For the case when   simpson   and trapezoidal are within epsqp
c           and   simpson   and  gaussian   are within epsqp
c           but trapezoidal differs from gaussian use   simpson
        elseif((abs(qdifts) .lt. epsqp)  .and.
     &         (abs(qdiftg) .ge. epsqp)  .and.
     &         (abs(qdifsg) .lt. epsqp))   then
          kqrule   = 6
          qestim   = qpsimp
c
c 4.1.4.2.7 For the case when   simpson   and  gaussian   are within epsqp
c           and trapezoidal and  gaussian   are within epsqp
c           but   simpson   differs from trapezoidal use  gaussian
        elseif((abs(qdifts) .ge. epsqp)  .and.
     &         (abs(qdiftg) .lt. epsqp)  .and.
     &         (abs(qdifsg) .lt. epsqp))   then
          kqrule   = 7
          qestim   = qpgaus
c
c 4.1.4.2.8 For all other cases use the geometric mean
        else
          kqrule   = -1
          qestim   = qpave
        endif
c
c 4.1.4.2.5 Write the appropriate error message
        if(kqrule .eq. -1) call abortjob
     &        ('maparc  ', 37,   'Calculation for qpval in error      '
     &        ,'jval    ', jval,     'kqrule  ', kqrule,   -1)
        if(kqrule .eq. +1) call abortjob
     &        ('maparc  ', 38,   'qpsimp qptrap qpgaus all differ     '
     &        ,'jval    ', jval,     'kqrule  ', kqrule,   -1)
        if(kqrule .gt. +1) call abortjob
     &        ('maparc  ', 39,   'Calculations for qpval differ       '
     &        ,'jval    ', jval,     'kqrule  ', kqrule,    0)
        
        write(kuout,3000) psiv,qptrap,qpsimp,qpgaus
     &                        ,qdifts,qdiftg,qdifsg
      endif
c
c 4.1.4.3 Define the final estimate for qpval.
c         Use Simpsons estimate as a default except when it is diiferent
c         from both the trapezoidal and gaussian estimates.
c         If all three are different, use the geometric average
      qpval      = qestim
c
c 4.1.4.4 Error checking.
      if(qpval .lt. 0.0) call abortjob
     &        ('maparc  ', 40,   'qpval from integration is < 0.0     '
     &        ,'jval    ', jval,     'ntmsh   ', ntmsh,     0)
      if(qpval .eq. 0.0) call abortjob
     &        ('maparc  ', 41,   'qpval from integration is zero      '
     &        ,'jval    ', jval,     'ntmsh   ', ntmsh,    +1)
c
c
c 4.2 Normalization for the Hamiltonian-like coordinate and fqpi from
c     integration of st2:
c       dchi = (f/fqpi)*(r**a1 *Bpol**a2 *Btot**a3) *(r/grad(psi))*dl
c     fqpi =  (f/(2*pi))*integral((1/(r**a1*Bpol**a2*Btot**a3)*(r/grad(psi))*dl
c
c 4.2.1 Integration from gaussian formula of st2 with respect to tp with cubic spline interpolation
c       These are also required later for the calculation of the
c       Hamiltonian-like coordinate by partial integration around
c       the contour
c
      call surfint(tp,st2,cseq2,bcd,ntmsh,ntmax,ier,answer)
      wsumg      = answer
c
      if(ier .ne. 0) call abortjob
     &        ('maparc  ', 42,   'Spline error for st2 in surfint     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
      fqval      = wsumg*fval/twopi
c
c 4.2.2 Error checking.
c
      if(fqval .lt. 0.0) call abortjob
     &        ('maparc  ', 43,   'fqval from integration is < 0.0     '
     &        ,'jval    ', jval,     'ntmsh   ', ntmsh,     0)
      if(fqval .eq. 0.0) call abortjob
     &        ('maparc  ', 44,   'fqval from integration is zero      '
     &        ,'jval    ', jval,     'ntmsh   ', ntmsh,    -1)
c
c
c
c 5.0 Compute the surface integrals
c
c 5.1 Save qpval and fqval in srfint
c
      srfint(1)  = qpval
      srfint(2)  = fqval
c
c
c 5.2 Compute the auxiliary surface integrals
c
c 5.2.1 Loop over the integrals
c
      do 150 lnt = 3,nvnt
      lint       = lnt
      lint0      = lint - 3
c
c 5.2.2 Integrate dl over a full circuit and store integrand in st3
c
c 5.2.2.1 For the normalization
      if    (lint .eq. 3) then
         do 100 ival = 1,ntmsh
         st3(ival)   = sv0(ival)
 100     continue
c
c 5.2.2.2 For the integral of 1/(r**2)
      elseif(lint .eq. 4) then
         do 110 ival = 1,ntmsh
         st3(ival)   = sv1(ival)
 110     continue
c
c 5.2.2.3 For the integral of d/dpsi_norm(grad(psi)**2)/(r**2)
      elseif(lint .eq. 5) then
         do 120 ival = 1,ntmsh
         st3(ival)   = sv2(ival)
 120     continue
c
c 5.2.2.4 For the integral of 1/(grad(psi)**2)
      elseif(lint .eq. 6) then
         do 130 ival = 1,ntmsh
         st3(ival)   = sv3(ival)
 130     continue
c
c 5.2.2.5 For the integral of 1/(r*grad(psi)**2)
      elseif(lint .eq. 7) then
         do 140 ival = 1,ntmsh
         st3(ival)   = sv4(ival)
 140     continue
      endif
c
c 5.2.3 Integration from gaussian formula of sv0 with respect to tp with
c       cubic spline interpolation
c
      call surfint(tp,st3,csveq,bcd,ntmsh,ntmax,ier,answer)

c
c 5.2.4 Check for errors
c
      if(ier .ne. 0) call abortjob
     &        ('maparc  ', 45,   'Spline error for sv0 in surfint     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
      if(answer .eq.  0.0) then
         if    (lint .eq. 3)then
            call abortjob
     &        ('maparc  ', 46,   'Surface integral dl/Bp is zero      '
     &        ,'jval    ', jval,     'lint0   ', lint0,    +1)
         elseif(lint .gt. 3)then
            call abortjob
     &        ('maparc  ', 47,   'Surface integral from surfint =0    '
     &        ,'jval    ', jval,     'lint0   ', lint0,    -1)
         endif
      endif
c
      srfint(lint)   = answer
 150  continue
c
c
c
c 6.0 Set up the poloidal coordinates corresponding to the tp mesh values
c     for the arclength, PEST, and Hamiltonian-like coordinates.
c
c 6.1 Recompute the coefficients csx and csz of the functions xp(arc)
c     and zp(arc).

      bcd(1)     = 0.0
      bcd(2)     = 2.*f2s(npcm1,xp,arc,ntmax)
      bcd(3)     = 0.0
      bcd(4)     = bcd(2)
      call icsici(arc,xp,npc,bcd,csx,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('maparc  ', 48,   'Spline interpolation error:x(th)    '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)

      bcd(2)     = 2.*f2s(npcm1,zp,arc,ntmax)
      bcd(4)     = bcd(2)
      call icsici(arc,zp,npc,bcd,csz,nlx,ier)
      if(ier .ne. 0) call abortjob
     &        ('maparc  ', 49,   'Spline interpolation error:z(th)    '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c
c 6.2 Integration of st1 to find PEST chi.
c
c 6.2.1 Incremental integration around the contour.
c       The partial integrations are stored temporarily in st3.
c
      st3(1)     = 0.0
      do 200 i   = 2,ntmsh
      del1       = tp(i-1)
      del2       = tp(i)
      call garea(del1,del2,tp,st1,cseq1,ntmsh,nlx,3,ans)
      st3(i)     = st3(i-1) + ans
 200  continue
c
c 6.2.2 Place the partially integrated coordinate back in st1.
c       Normalize using qp from the complete integration of st1.
c
      st1nrm     = fval/qpval
      do 210 i   = 1,ntmsh
      st1(i)     = st1nrm*st3(i)
 210  continue
c
c
c 6.3 Integration of st2 to find the Hamiltonian-like chi.
c
c 6.3.1 Incremental integration around the contour.
c       The partial integrations are stored temporarily in st3.
c
      st3(1)     = 0.0
      do 220 i   = 2,ntmsh
      del1       = tp(i-1)
      del2       = tp(i)
      call garea(del1,del2,tp,st2,cseq2,ntmsh,nlx,3,ans)
      st3(i)     = st3(i-1) + ans
  220  continue
c
c 6.3.2 Place the partially integrated coordinate back in st2.
c       Normalize using fqpi from the complete integration of st2.
c
      st2nrm     = fval/fqval
      do 230 i   = 1,ntmsh
      st2(i)     = st2nrm*st3(i)
 230  continue
c
c
c
c 7.0 Return and end
c
      return
c
 1000 format(/,1x, 'Arclength values for real contour'
     &      ,/,1x, 'npc     = ',i5,4x,'ntdim   = ',i5
     &      ,/,4x, 'ip',6x,'xp',11x,'zp',11x,'tp',10x,'arc')
 1010 format(1x,i5,4(e13.6))
 1030 format(/,1x, 'Arclength values for rescaled contour'
     &      ,/,1x, 'npc     = ',i5,4x,'ntdim   = ',i5
     &        ,4x, 'gkappa  = ',e13.6
     &      ,/,4x, 'ip',6x,'xp',11x,'zp',11x,'tp',10x,'arc')
 1040 format(1x,i5,4(e13.6))

 1100 format(  1x, 'dell    = ',e16.9,2x, 'arctp   = ',e16.9
     &        ,1x, 'psiv    = ',e16.9,2x, 'arctpn  = ',e16.9,/
     &        ,1x, 'arnorm1 = ',e16.9,2x, 'splndif = ',e16.9
     &        ,1x, 'rvldif  = ',e16.9,2x, 'zvldif  = ',e16.9,/
     &        ,1x, 'rvl0    = ',e16.9,2x, 'rvl1    = ',e16.9
     &        ,1x, 'zvl0    = ',e16.9,2x, 'zvl1    = ',e16.9)
 1110 format(  1x, 'dell    = ',e16.9,2x, 'arctp   = ',e16.9
     &        ,1x, 'psiv    = ',e16.9,2x, 'arctpn  = ',e16.9,/
     &        ,1x, 'arnorm1 = ',e16.9,2x, 'splndif = ',e16.9
     &        ,1x, 'rvldif  = ',e16.9,2x, 'zvldif  = ',e16.9,/
     &        ,1x, 'rvl0    = ',e16.9,2x, 'rvl1    = ',e16.9
     &        ,1x, 'zvl0    = ',e16.9,2x, 'zvl1    = ',e16.9)
 1500 format(/,1x, 'Misordered points in both tp and tpp for'
     &        ,1x, 'surface jval =',1x, i5
     &        ,2x,': New attempt with decremented points'
     &      ,/,1x, 'ntry        = ',i5,2x, 'kmis        = ',i5
     &        ,2x, 'kmisiv      = ',i5
     &      ,/,1x,                     21x,'kmiss       = ',i5
     &        ,2x, 'kmissiv     = ',i5
     &      ,/,1x, 'npc         = ',i5,2x, 'ntdecr      = ',i5
     &        ,2x, 'ntmsh(orig) = ',i5,2x, 'ntmsh (old) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5)
 1510 format(/,1x, 'Misordered points in tp for surface jval ='
     &        ,1x,  i5,2x,': New attempt with decremented points'
     &      ,/,1x, 'ntry        = ',i5,2x, 'kmis        = ',i5
     &        ,2x, 'kmisiv      = ',i5
     &        ,2x, 'kmissiv     = ',i5
     &      ,/,1x, 'npc         = ',i5,2x, 'ntdecr      = ',i5
     &        ,2x, 'ntmsh(orig) = ',i5,2x, 'ntmsh (old) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5)
 1520 format(/,1x, 'Misordered points in tpp for surface jval ='
     &        ,1x, i5,2x,': New attempt with decremented points'
     &      ,/,1x, 'ntry        = ',i5,2x, 'kmiss       = ',i5
     &        ,2x, 'kmissiv     = ',i5
     &      ,/,1x, 'npc         = ',i5,2x, 'ntdecr      = ',i5
     &        ,2x, 'ntmsh(orig) = ',i5,2x, 'ntmsh (old) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5)
 2000 format(  1x, 'Mapping error:   The interpolation for both tp'
     &        ,1x, ' and tpp are incorrectly ordered for jval  =',i5
     &        ,2x, 'psiv  =',e14.7,/
     &        ,1x, 'ntry        = ',i5,2x, 'ntrymx      = ',i5
     &        ,2x, 'ntdecr      = ',i5,2x, 'ntmmin      = ',i5,/
     &        ,1x, 'npc         = ',i5,2x, 'ntmsh(orig) = ',i5
     &        ,2x, 'ntmsh (old) = ',i5,2x, 'ntmsh (dec) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5/
     &        ,1x, 'kmis        = ',i5,2x, 'kmisiv      = ',i5
     &        ,2x, 'kmiss       = ',i5,2x, 'kmissiv     = ',i5)
 2010 format(  1x, 'Mapping error:   The interpolation for tp  is'
     &        ,1x, 'incorrectly ordered for jval  =',i5
     &        ,2x, 'psiv  =',e14.7,/
     &        ,1x, 'ntry        = ',i5,2x, 'ntrymx      = ',i5
     &        ,2x, 'ntdecr      = ',i5,2x, 'ntmmin      = ',i5,/
     &        ,1x, 'npc         = ',i5,2x, 'ntmsh(orig) = ',i5
     &        ,2x, 'ntmsh (old) = ',i5,2x, 'ntmsh (dec) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5/
     &        ,1x, 'kmis        = ',i5,2x, 'kmisiv      = ',i5
     &        ,2x, 'kmiss       = ',i5,2x, 'kmissiv     = ',i5)
 2020 format(  1x, 'Mapping error:   The interpolation for tpp is'
     &        ,1x, 'incorrectly ordered for jval  =',i5
     &        ,2x, 'psiv  =',e14.7,/
     &        ,1x, 'ntry        = ',i5,2x, 'ntrymx      = ',i5
     &        ,2x, 'ntdecr      = ',i5,2x, 'ntmmin      = ',i5,/
     &        ,1x, 'npc         = ',i5,2x, 'ntmsh(orig) = ',i5
     &        ,2x, 'ntmsh (old) = ',i5,2x, 'ntmsh (dec) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5/
     &        ,1x, 'kmis        = ',i5,2x, 'kmisiv      = ',i5
     &        ,2x, 'kmiss       = ',i5,2x, 'kmissiv     = ',i5)
 2030 format(  1x, 'Mapping error:   The arc calculation failed even'
     &        ,1x, 'though the interpolation for both tp and tpp'
     &        ,1x, 'are correctly ordered for jval  =',i5
     &        ,2x, 'psiv  =',e14.7,/
     &        ,1x, 'ntry        = ',i5,2x, 'ntrymx      = ',i5
     &        ,2x, 'ntdecr      = ',i5,2x, 'ntmmin      = ',i5,/
     &        ,1x, 'npc         = ',i5,2x, 'ntmsh(orig) = ',i5
     &        ,2x, 'ntmsh (old) = ',i5,2x, 'ntmsh (dec) = ',i5
     &        ,2x, 'ntmsh (new) = ',i5/
     &        ,1x, 'kmis        = ',i5,2x, 'kmisiv      = ',i5
     &        ,2x, 'kmiss       = ',i5,2x, 'kmissiv     = ',i5)
 2100 format(5x,'Final arc array data used:')
 2110 format(5x,'xp    (npc = ',i6,'):')
 2115 format(10(1x,e12.5))
 2120 format(5x,'zp    (npc = ',i6,'):')
 2125 format(10(1x,e12.5))
 2130 format(5x,'arc   (npc = ',i6,'):')
 2135 format(10(1x,e12.5))
 2140 format(5x,'arcc  (npc = ',i6,'):')
 2145 format(10(1x,e12.5))
 2150 format(5x,'tp (ntmold = ',i6,'):')
 2155 format(10(1x,e12.5))
 2160 format(5x,'tpp(ntmold = ',i6,'):')
 2165 format(10(1x,e12.5))
 2170 format(/,5x,'tpp array near misordered point kmissiv  = ',i5
     &        ,5x,'from k = ',i6,1x,'to k = ',i6)
 2175 format(10(7x,i6))
 2180 format(10(1x,e12.5))
 2185 format(/,5x,'tp  array near misordered point kmisiv   = ',i5
     &        ,5x,'from k = ',i6,1x,'to k = ',i6)
 2190 format(10(7x,i6))
 2195 format(10(1x,e12.5))
 3000 format(1x,'q profile integration: psiv = ',e14.7
     &      ,/,1x,'qp(trap),  qp(simp),  qp(gaus) : ',3(1x,e16.9),/
     &      ,1x,'qp(t - s), qp(t - g), qp(s - g): ',3(1x,e16.9))
      end
      subroutine arclng(xp,zp,np,npdm,gk,tp,ac,csx,csz,ierp)
c
c  Compute the arclength along a curve defined by (xp,gk*zp) and spline
c  xp and zp with respect to the arclength
c
c  Input:
c         xp:      radial points of curve
c         zp:      axial  points of curve
c         np:      number of points on curve
c         npdm:    dimension for xp, zp, and second dimension of csx and csz
c         gk:      scale factor for zp
c
c  Output:
c         tp:      vector containing cumulative diagonal increments
c         ac:      vector containing arclengths
c         csx:     spline coefficients for xp(ac)
c         csz:     spline coefficients for zp(ac)
c         ierp:    error flag
c
      dimension xp(np),zp(np)
      dimension tp(np),ac(np)
      dimension csx(3,npdm),csz(3,npdm)
      dimension bcd(4)
c
c
c
c 1.0 Initialization
c
      ierp       = 0
      ierc       = 0
      ierd       = 0
      npm1       = np - 1
c
      if(np .gt. npdm) then
        call abortjob
     &        ('arclng  ',  1,   'Number of points exceeds dimension  '
     &        ,'np      ', np,       'npdm    ', npdm,     -1)
        ierp    = +1
        return
      endif
c
c
c
c 2.0 Diagonal increments for successive (xp,zp) points on the contour
c
      tp(1)      = 0.0
      do 50 i    = 2,np
      tp(i)      = tp(i-1) +
     &             sqrt((xp(i)-xp(i-1))**2 + gk*(zp(i)-zp(i-1))**2)
  50  continue
c
c
c
c 3.0 Compute arclengths for (xp,zp) points around the contour from splines
c
c 3.1 Spline coefficients for xp and zp as functions of tp
c     Boundary conditions for the spline are passed through vector bcd
c
c 3.1.1 Spline coefficients for xp(tp)
c
      bcd(1)     = 0.0
      bcd(2)     = 2.*f2s(npm1,xp,tp,np)
      bcd(3)     = 0.0
      bcd(4)     = bcd(2)
      call icsici(tp,xp,np,bcd,csx,npdm,ierc)
      if(ierc .ne. 0) then
        call abortjob
     &        ('arclng  ',  2,   'Spline interpolation error for x(tp)'
     &        ,'ierc    ', ierc,     'npdm    ', npdm,     -1)
        ierp    = +2
        return
      endif
c
c 3.1.2 Spline coefficients for zp(tp)
c
      bcd(2)     = 2.*f2s(npm1,zp,tp,np)
      bcd(4)     = bcd(2)
      call icsici(tp,zp,np,bcd,csz,npdm,ierc)
      if(ierc .ne. 0) then
        call abortjob
     &        ('arclng  ',  3,   'Spline interpolation error for z(tp)'
     &        ,'ierc    ', ierc,     'npdm    ', npdm,     -1)
        ierp    = +3
        return
      endif
c
c
c 3.2 Integration of spline fits for the real contour using garc
c     The arclength is stored in ac(i) for i = 1,np
c
      call garc(tp,xp,zp,csx,csz,ac,np,npdm,gk)
c
c
c
c 4.0 Respline coefficients of xp and zp with respect to ac.
c     The coefficients are stored in csx and csz respectively.
c
      bcd(2)     = 2.*f2s(npm1,xp,ac,np)
      bcd(4)     = bcd(2)
      call icsici(ac,xp,np,bcd,csx,npdm,ierd)
      if(ierd .ne. 0) then
        call abortjob
     &        ('arclng  ',  4,   'Spline interpolation error for x(ac)'
     &        ,'ierd    ', ierd,     'npdm    ', npdm,     -1)
        ierp    = -2
        return
      endif
c
      bcd(2)     = 2.*f2s(npm1,zp,ac,np)
      bcd(4)     = bcd(2)
      call icsici(ac,zp,np,bcd,csz,npdm,ierd)
      if(ierd .ne. 0) then
        call abortjob
     &        ('arclng  ',  5,   'Spline interpolation error for z(ac)'
     &        ,'ierd    ', ierd,     'npdm    ', npdm,     -1)
        ierp    = -3
        return
      endif
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine surfint(tparc,stint,cspln,bcnd,ntpmsh,ntpmax,ker,answr)
c
c    Integrate stint over a complete period of the variable tparc
c    using a  gaussian formula with cubic spline interpolation
c
c 
      dimension tparc(ntpmax),stint(ntpmax),cspln(3,ntpmax),bcnd(4)
c
c
c
c 1.0 Initialize
c
      ntpmsh1    = ntpmsh-1
c
c
c
c 2.0 Interpolation coefficients for stint with respect to tparc
c
      bcnd(1)    = 0.0
      bcnd(2)    = 2.*f2s(ntpmsh1,stint,tparc,ntpmax)
      bcnd(3)    = 0.0
      bcnd(4)    = bcnd(2)
c
      call icsici(tparc,stint,ntpmsh,bcnd,cspln,ntpmax,ker)
c
c
c
c 3.0 Integration around the contour to obtain the surface integral
c
c 3.1 Integrate around the contour
c
      call garcq(tparc,stint,cspln,ntpmsh,ntpmax,ans)
c
c
c 3.2 Set the result
c
      answr      = ans
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine mapangl(jval,ithtm)
c
c----------------------------------------------------------------
c calculate the arclength, Pest and Hamiltonian chi coordinates
c on the flux contour defined from (xp,zp)
c----------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nlx=1441)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/sarc/  ntmax,ntmsh,npcf,npcb,npc,xp(nlx),zp(nlx),gsq(nlx),
     &              arc(nlx),tp(nlx),arcc(nlx),tpp(nlx),bcd(4),
     &              csx(3,nlx),csz(3,nlx),cseq1(3,nlx),cseq2(3,nlx),
     &              st1(nlx),st2(nlx),st3(nlx),csveq(3,nlx),
     &              sv0(nlx),sv1(nlx),sv2(nlx),sv3(nlx),sv4(nlx),
     &              sv5(nlx)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/toq0/  npsi,nthet,ntht1,neqsym,axddxz,
     &              peqmsh0(npp),peqdsd0(npp),peqdss0(npp),
     &              peqmsh1(npp),peqmsh2(npp),
     &              sqvl(npp),sfqi(npp),csqvl(3,npp),csfqi(3,npp)
      common/toq1/  thchi(ntt), seqrps(npp,ntt), seqzps(npp,ntt),
     &              csrvl(npp,ntt,4), cszvl(npp,ntt,4),
     &              pdsa(6),pdsr(6),pdsz(6),pdsp(6),pdsc(6)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c     Input quantities:
c     jval:            Index for the flux surface (jval > 0)
c                      jval = 0 corresponds to the plasma surface
c     xp, zp:          Grid points defining the contour
c     tp:              Arclength on the contour for ntmsh points
c     st1:             PEST angle on the contour for ntmsh points
c     st2:             Hamiltonian angle on the contour for ntmsh points
c
c     Output quantities:
c     rs, zs:          Grid points (r,z) corresponding to the flux mesh
c                      For jval > 0: indexed with (i,jval) corresponding to the
c                      jval'th flux surface and i'th poloidal angle (i = 1,ithtm).
c                      For jval = 0: indexed with (i, 1  ) corresponding to the
c                      plasma surface and i'th poloidal angle (i = 1,ithtm).
c     arcsurf(i):      Arclength coordinate around the contour corresponding
c                      to the i'th poloidal coordinate.
c     pestchi(i):      Pest angle coordinate around the contour corresponding
c                      to the i'th poloidal coordinate.
c     hamlchi(i):      Hamiltonian-like angle coordinate around the contour
c                      corresponding to the i'th poloidal coordinate.
c
c The construction of the poloidal coordinate angle is done as follows:
c 1.    Construct the interpolation coefficients:
c                   for st1(tp)  and st2(tp)     (igrid=0)   or
c                   for tp (st1) and st2(st1)    (igrid=1).
c 2.    Compute the poloidal mesh points around the surface using:
c             Equal arclength around the real surface       (igrid =  0)
c             Equidistant PEST chi coordinates              (igrid = +1)
c       The points (rs(i,j),zs(i,j)), arclength, arcsurf(i), and
c       the PEST and Hamiltonian-like coordinates, pestchi(i) and hamlchi(i),
c       are stored for i = 1,ithtm corresponding to the chi(i) grid
c       for j = 1 (jval = 0) or j = jval (jval > 0).
c 3.    Adjust boundary and symmetry conditions for rs, zs, arcsurf,
c       pestchi and hamlchi.
c
c
c
c 1.0 Initialization.
c
      ier        = 0
      ntmsh1     = ntmsh-1
      rndff      = roundff
c
      if(jval .eq. 0) jvsf  = 1
      if(jval .gt. 0) jvsf  = jval
c
c
c
c 2.0 Set up interpolation coefficients for st1(tp) and st2(tp), or
c     set up interpolation coefficients for tp(st1) and st2(st1),
c     for igrid = 0 or igrid = 1 respectively.
c
c
c 2.1 For igrid = 0, use st1(tp) and st2(tp).
c
      if(igrid .eq. 0) then
         bcd(2)    = 2.*f2s(ntmsh1,st1,tp, ntmax)
         bcd(4)    = bcd(2)
         call icsici(tp, st1,ntmsh,bcd,cseq1,nlx,ier)
         if(ier .ne. 0) call abortjob
     &        ('mapangl ',  1,   'Spline interpolation error: st1     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
         bcd(2)    = 2.*f2s(ntmsh1,st2,tp, ntmax)
         bcd(4)    = bcd(2)
         call icsici(tp, st2,ntmsh,bcd,cseq2,nlx,ier)
         if(ier .ne. 0) call abortjob
     &        ('mapangl ',  2,   'Spline interpolation error: st2     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
c
c 2.2 For igrid = 1, use tp(st1) and st2(st1).
c
      else
         bcd(2)    = 2.*f2s(ntmsh1,tp,st1,ntmax)
         bcd(4)    = bcd(2)
         call icsici(st1,tp,ntmsh,bcd,cseq1,nlx,ier)
         if(ier .ne. 0) call abortjob
     &        ('mapangl ',  3,   'Spline interpolation error: st1     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
c
         bcd(2)    = 2.*f2s(ntmsh1,st2,st1,ntmax)
         bcd(4)    = bcd(2)
         call icsici(st1,st2,ntmsh,bcd,cseq2,nlx,ier)
         if(ier .ne. 0) call abortjob
     &        ('mapangl ',  4,   'Spline interpolation error: st2     '
     &        ,'ier     ', ier,      'jval    ', jval,     +1)
      endif
c
c
c
c 3.0 Compute the points (rs(i,jvsf), zs(i,jvsf)) around the contour psiv,
c     corresponding to equal arclength of the real contour (igrid = 0)
c     or equal PEST chi coordinates (igrid = +1).
c     The first point is taken at the cell centre.
c     rs and zs are interpolated using the coefficients of xp and zp with
c     respect to arc corresponding to the real contour (csx and csz).
c
c
      arcnrm0    = arc(npc)
      pstnrm0    = st1(ntmsh)
      hamnrm0    = st2(ntmsh)
      if(arcnrm0 .le. 0.0) call abortjob
     &        ('mapangl ',  5,   'arcnrm0 = arc(npc)   .le. zero      '
     &        ,'jval    ', jval,     'npc     ', npc,      +1)
      if(pstnrm0 .le. 0.0) call abortjob
     &        ('mapangl ',  6,   'pstnrm0 = st1(ntmsh) .le. zero      '
     &        ,'jval    ', jval,     'npc     ', npc,      +1)
      if(hamnrm0 .le. 0.0) call abortjob
     &        ('mapangl ',  7,   'hamnrm0 = st2(ntmsh) .le. zero      '
     &        ,'jval    ', jval,     'npc     ', npc,      +1)
c
      ardiff     = tp(ntmsh) - arc(npc)
      arnorm     = endtol*abs(arc(npc))
      if(abs(ardiff) .gt. arnorm) then
         call abortjob
     &        ('mapangl ',  8,   'tp(ntmsh) and arc(npc) different    '
     &        ,'jval    ', jval,     'npc     ', npc,      -1)
      endif
c
      dsarcl     = arcnrm0/ithtm
      dspest     = pstnrm0/ithtm
      dshaml     = hamnrm0/ithtm
c
      do 100 i   = 1,ithtm
      if(igrid .eq. 0) then
         dlgrid    = (i-0.5)*dsarcl
         dlarcl    = dlgrid
c
         dlpest    = sterpl(dlgrid,tp, st1,cseq1,ntmsh,nlx,1,rndff,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('mapangl ',  9,   'Spline evaluation error: st1(tp)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
         endif
c
         dlhaml    = sterpl(dlgrid,tp, st2,cseq2,ntmsh,nlx,1,rndff,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('mapangl ', 10,   'Spline evaluation error: st2(tp)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
         endif
c
      else
         dlgrid    = (i-0.5)*dspest
         dlpest    = dlgrid
c
         dlarcl    = sterpl(dlgrid,st1,tp, cseq1,ntmsh,nlx,1,rndff,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('mapangl ', 11,   'Spline evaluation error: st1(tp)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
         endif
c
         dlhaml    = sterpl(dlgrid,st1,st2,cseq2,ntmsh,nlx,1,rndff,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('mapangl ', 12,   'Spline evaluation error:st1(st2)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
         endif
      endif
c
      dl              = dlarcl
c
      rs(i,jvsf)      = sterpl(dl,arc,xp,csx,npc,nlx,1,rndff,ier)
      if(ier .ne. 0) call abortjob
     &        ('mapangl ', 13,   'Spline evaluation error: xp(arc)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
c
      zs(i,jvsf)      = sterpl(dl,arc,zp,csz,npc,nlx,1,rndff,ier)
      if(ier .ne. 0) call abortjob
     &        ('mapangl ', 14,   'Spline evaluation error: zp(arc)    '
     &        ,'ier     ', ier,      'jval    ', jval,     -1)
      arcsurf(i)      = dlarcl
      pestchi(i)      = dlpest
      hamlchi(i)      = dlhaml
 100  continue
c
c
c
c 4.0 Boundary and symmetry conditions.
c
c 4.1 Boundary (periodicity) conditions
c     rs and zs are set for complete periodicity.  The last values of
c     arcsurf, pestchi, and hamlchi are set at the integrated value
c     for one poloidal circuit.
c
      rs(ithtp,jvsf)  = rs(1,jvsf)
      zs(ithtp,jvsf)  = zs(1,jvsf)
c
      arcsurf(ithtp)  = arcnrm0
      pestchi(ithtp)  = pstnrm0
      hamlchi(ithtp)  = hamnrm0
c
c
c 4.2 Impose symmetry conditions if required.
c
c 4.2.1 Symmetry conditions for rs, zs, arcsurf, pestchi, and hamlchi.
      if(isym .ne. 0) then
         ithtd2         = itht/2
         ithtmd         = ithtd2 + 1
         do 110 i       = ithtmd,itht
         ll             = ithtp-i
         rs(i,jvsf)     = +rs(ll,jvsf)
         zs(i,jvsf)     = -zs(ll,jvsf)
         arcsurf(i)     = arcsurf(ithtp) - arcsurf(ll)
         pestchi(i)     = pestchi(ithtp) - pestchi(ll)
         hamlchi(i)     = hamlchi(ithtp) - hamlchi(ll)
  110    continue
      endif
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine restart(x,nw,y,nh,cs1,nw1,nh1,xs0,ys0,psv0,xs1,ys1)
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/cntd/  nbpmx,nwtmx,nslmx,nhfmx,bperr,dang,arcl,
     &              serrs,serrt,delgp,stfrac,rnderr,
     &              xaxd,yaxd,xmin,xmax,ymin,ymax
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension pds(6),x(nw),y(nh),cs1(2,nw1,2*nh1)
c
c     This routine takes an initial guess for a point (xs0,ys0) on
c     a psi contour at value psi0 and converges to an accurate
c     value for (xs1,ys1), along a ray between an interior point and
c     the input (xs0,ys0), using a Newtons Method iteration to match
c     the accuracy obtained in cntour.
c
c     The new starting point is determined by defining a ray from
c     (xaxd,yaxd) to the input point (xs0,ys0).
c     The ray is defined by an equation y = a*x + b  or  x = a*y + b,
c     depending on whether the angle is in the left or right quadrants
c     or in the top or bottom quadrants respectively.
c     Newtons Method is then used to converge to the correct intersection
c     point with the contour.
c
c     Input parameters :
c     x,y :        Vectors containing the rectangular grid point values on
c                  which the contoured function is defined.
c     nw,nh :      Respective dimensions of the vectors x and y.
c     cs1 :        Spline coefficients for the contoured function.
c     nw1 :        Second dimension of cs1.
c     nh1 :        Third dimension of  cs1 (2*nh1)
c     xs0,ys0 :    Initial contour point.
c     psv0 :       Value of the contour to be mapped.
c
c     Input paramaters passed through common/cntd/ :
c     xaxd,yaxd :  Interior point for the contour.  The rays intersecting
c                  the contour emmanate from the point (xaxd,yaxd).
c     xmin,xmax :  The search for intersection points is limited
c                  horizontally to (xmin,xmax).
c     ymin,ymax :  The search for intersection points is limited vertically
c                  to (ymin,ymax).
c     serrs :      Absolute error convergence criterion for Newtons Method
c                  for warning if exceeded.
c     serrt :      Absolute error convergence criterion for Newtons Method
c                  for termination if exceeded.
c     rnderr :     roundoff error for checking for division by zero.
c     nwtmx :      Maximum number of Newtons iterations allowed in the
c                  search for the intersection of the ray with the contour.
c
c     Output parameters :
c     xs1,ys1:     Contour points generated at intersection of the
c                  contour and the ray between (xaxd,yaxd) and
c                  the initial point (xs0,ys0).
c
c     Output parameters passed through common/cntd/ :
c     xemin,xemax :  Minimum and maximum x values of the contour.
c     yemin,yemax :  Minimum and maximum y values of the contour.
c     xymin,xymax :  x values at y=yemin and y=yemax respectively.
c     yxmin,yxmax :  y values at x=xemin and x=xemax respectively.
c
c
c
c 1.0 Initialization
c
      xemin     = +bigno
      xemax     = -bigno
      yemin     = +bigno
      yemax     = -bigno
      xymin     =  0.0
      xymax     =  0.0
      yxmin     =  0.0
      yxmax     =  0.0
c
c
c
c 2.0 Set up the ray from the axis to the starting point.
c
c 2.1 Get psi at (xaxd,yaxd) and check that (xaxd,yaxd) is inside psv0.
c
      call dbcevl(x,nw,y,nh,cs1,nw1,nh1,xaxd,yaxd,pds,ier)
      if(ier .ne. 0) call abortjob
     &        ('restart ',  1,   'Spline evaluation error:psi(axe)    '
     &        ,'ier     ', ier,      'nw      ', nw,       +1)
c
      psiaxd    = pds(1)
      if(psiaxd .gt. psv0) call abortjob
     &        ('restart ',  2,   'Spline psi axis value > psv0        '
     &        ,'nw      ', nw,       'nh      ', nh,       -1)
c
c
c 2.2 Define the ray between (xaxd,yaxd) and the initial point.
c
      hyptn2    = (xs0-xaxd)*(xs0-xaxd) + (ys0-yaxd)*(ys0-yaxd)
      hypotn    = sqrt(hyptn2)
      if(hypotn .eq.  0.0) then
        call abortjob
     &        ('restart ',  3,   'Initial restart point is on axis    '
     &        ,'nw      ', nw,       'nh      ', nh,       -1)
        hypotn    = 1.0
      endif
c
      sinv      = (ys0-yaxd)/hypotn
      cosv      = (xs0-xaxd)/hypotn
c
c
c 2.3 Initialize the Newton-Raphson iteration.
c
      xnorm     = sqrt(xmax*xmax+xmin*xmin + ymax*ymax+ymin*ymin)
      pnorm     = abs(psiaxd)
      rnderr1   = rnderr*(pnorm/xnorm)
      xn        = xs0
      yn        = ys0
c
c
c
c 3.0 Converge to the intersection point using Newton-Raphson iteration.
c
c 3.1 Newton-Raphson iteration on (xn,yn).
c
      newti     = 0
  10  newti     = newti + 1
        call dbcevl(x,nw,y,nh,cs1,nw1,nh1,xn,yn,pds,ier)
        if(ier .ne. 0) call abortjob
     &        ('restart ',  4,   'Newton iteration spline error       '
     &        ,'ier     ', ier,      'newti   ', newti,    +1)
c
        dpsids    = pds(2)*cosv + pds(3)*sinv
        dpsi      = pds(1) - psv0
c
        if    (abs(dpsids) .gt. rnderr1) then
          serr      = -dpsi/dpsids
c
        elseif(abs(dpsids) .le. rnderr1) then
          call abortjob
     &        ('restart ',  5,   'Newton iteration gradient small     '
     &        ,'newti   ', newti,    'nw      ', nw,        0)
          serr      = -dpsi/rnderr1
        endif
c
c
c 3.2 Error convergence test.
c
c 3.2.1 Check the error and iterate again if needed.
c
        if    (abs(serr) .ge. serrs  .and.  newti .lt. nwtmx) then
          delx    = serr*cosv
          dely    = serr*sinv
          xn      = xn + delx
          yn      = yn + dely
          go to 10
c
c 3.2.2 Error if the maximum number of iterations is exceeded.
c       If the maximum is exceeded and abs(serr) is still greater than
c       serrt the routine aborts, otherwise a warning is
c       printed and the mapping is continued.
c
        elseif(abs(serr) .ge. serrs  .and.  newti .ge. nwtmx) then
           if    (abs(serr) .lt. serrt) then
              call abortjob
     &        ('restart ',  6,   'Newton iterations exceeded nwtmx    '
     &        ,'newti   ', newti,    'nwtmx   ', nwtmx,    -1)
              write(kuout,1000) newti,psv0,serr,serrs,serrt
c
           elseif(abs(serr) .ge. serrt) then
              call abortjob
     &        ('restart ',  7,   'Newton iterations not converged     '
     &        ,'newti   ', newti,    'nwtmx   ', nwtmx,    +1)
              write(kuout,1010) newti,psv0,serr,serrs,serrt
           endif
        endif
c
c
c
c 4.0 Reset the converged point (xs1,ys1).
c
c 4.1 Define the extrema for the contour.
c
      xemin     = amin1(xn,xemin)
      xemax     = amax1(xn,xemax)
      yemin     = amin1(yn,yemin)
      yemax     = amax1(yn,yemax)
      if(xn .eq. xemax) yxmax     = yn
      if(xn .eq. xemin) yxmin     = yn
      if(yn .eq. yemax) xymax     = xn
      if(yn .eq. yemin) xymin     = xn
c
c
c 4.2 Define the new initial contour starting point.
c
      xs1       = xn
      ys1       = yn
c
c
c
c 5.0 Return and end
c
      return
c
 1000    format(10x,'Warning: Newtons iteration in restart is not fully'
     &         ,1x,'converged:  newti =',i5,4x,'psv0 =',e12.5,/
     &         ,1x,'serr  =',e12.5,4x,'serrs =',e12.5
     &         ,4x,'serrt =',e12.5)
 1010    format(10x,'Fatal error: Newtons iteration in restart did not'
     &         ,1x,'converge :  newti =',i5,4x,'psv0 =',e12.5,/
     &         ,1x,'serr  =',e12.5,4x,'serrs =',e12.5
     &         ,4x,'serrt =',e12.5)
      end
      subroutine cntour(x,nw,y,nh,cs1,nw1,nh1,xc,yc,gc,npt,dx,dy
     &                 ,ntmx,jsurf,psvl,kerr)
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/cntd/  nbpmx,nwtmx,nslmx,nhfmx,bperr,dang,arcl,
     &              serrs,serrt,delgp,stfrac,rnderr,
     &              xaxd,yaxd,xmin,xmax,ymin,ymax
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension pds(6),x(nw),y(nh),cs1(2,nw1,2*nh1)
      dimension xc(ntmx),yc(ntmx),gc(ntmx)
c
c
c     cntour generates a contour of ordered points (xc(i),yc(i)) for
c     i = 1,ipts along a contour psvl of a function psi = psarray(x,y).
c     The function values psi(x,y) are defined from the spline coefficients
c     in cs1.
c     The contour psvl must fully encircle a given point (xaxd,yaxd).
c
c     The contour is determined by defining a series of rays from
c     (xaxd,yaxd) intersecting with the contour.
c     Each ray is defined by an equation y = a*x + b  or  x = a*y + b,
c     depending on whether the angle is in the left or right quadrants
c     or in the top or bottom quadrants respectively.
c
c     For a given ray, the intersection is first bounded by a coarse sliding
c     interval search along the ray to find two points on the ray bounding
c     the intersection.  The search is limited to a rectangle specified by
c     xmin,xmax,ymin,ymax.  A sliding interval search, rather than a
c     binary search, is used for the coarse grid so that non-monotonic
c     psi can be handled.  Newtons Method is then used to converge to the
c     intersection point and the coordinates are stored as (xc(i),yc(i)).
c
c     The ray angular spacing is controlled dynamically and so the total
c     number of contour points (xc(i),yc(i)) is determined by the routine.
c     Normally, the increment is defined as the minimum of arcl/rad and
c     2pi*dang*(rad0/rad), where dang is an angle fraction of 2pi and
c     arcl is an arclength spacing between successive points, both input
c     through common/cntd/, and rad and rad0 are the computed radii at the
c     respective and first (i.e. theta = 0) contour points respectively.
c     After each point on the contour is found, the relative change in the
c     poloidal field from the previous point is checked to ensure that it
c     is less than bpers.  If the change in poloidal field exceeds bpers,
c     the angular increment is successively reduced, up to nhfmx times,
c     and the point is recalculated.
c     If the number of contour points exceeds the maximum allowed dimension
c     ntmx, the mapping for this contour is restarted with bpers increased
c     and appropriate warnings are printed.  The mapping can restart
c     up to nbpmx tries, after which, the routine aborts.
c
c     Input parameters :
c     x,y :        Vectors containing the rectangular grid point values on
c                  which the contoured function is defined.
c     nw,nh :      Respective dimensions of the vectors x and y.
c     cs1 :        Spline coefficients for the contoured function.
c     nw1 :        Second dimension of cs1.
c     nh1 :        Third  dimension of cs1 (2*nh1).
c     dx,dy :      Increment (in metres) for the coarse grid search of
c                  the intersection between the contour and rays.
c                  dx and dy should normally be chosen so that, over the
c                  distance dx or dy, psi is single valued.  This can
c                  usually be ensured by setting dx and dy to the x and y
c                  grid increments.
c     ntmx :       Maximum dimension for the vector containing the contour
c                  points.
c     jsurf :      Surface index.
c     psvl :       Value of the contour to be mapped.
c     kerr :       Error flag
c
c     Input paramaters passed through common/cntd/ :
c     xaxd,yaxd :  Interior point for the contour.  The rays intersecting
c                  the contour emmanate from the point (xaxd,yaxd).
c     xmin,xmax :  The search for intersection points is limited
c                  horizontally to (xmin,xmax).
c     ymin,ymax :  The search for intersection points is limited vertically
c                  to (ymin,ymax).
c     dang :       The maximum angular increment allowed for the generated
c                  contour points is limited to
c                       2pi*dang*(rad(theta=0)/rad(theta)).
c                  In general, dang should be set according to shape of the
c                  equilibrium.  If dang is too small, many unnecessary
c                  points will be generated.  If dang is too large for
c                  bperr (defined below),  the routine wastes computation
c                  time in cutting the step angle down to size.
c                  dang = 0.03 near psilim and dang = 0.10 near psimax
c                  is usually satisfactory.
c     arcl :       The maximum arclength allowed between generated contour
c                  points is limited to arcl.  For highly elongated plasmas
c                  control with dang is difficult to set for all contours.
c                  For such cases, arcl should be used instead to set the
c                  angular increment.  arcl can be set to a large number to
c                  overide this option so that dang is always used.
c     bpers :      Relative change in poloidal b field between (xc(i),yc(i))
c                  and (xc(i+1),yc(i+1)).  If dang yields a relative change
c                  in poloidal b less than bperr, then the the computed
c                  point is retained.  Otherwise, dang is successively
c                  reduced by stfrac until this condition is met.  bpers
c                  is started at bperr (set in eqdmap).  After each failure
c                  (i.e. if ipts gets too large), then the calculation is
c                  restarted with larger bpers, up to a maximum of nbpmx
c                  tries.
c     serrs :      Absolute error convergence criterion for Newtons Method
c                  for warning if exceeded.
c     serrt :      Absolute error convergence criterion for Newtons Method
c                  for termination if exceeded.
c     delgp :      Gap in closing the contour.
c     stfrac :     Fractional reduction in step size imposed when the
c                  test for the poloidal field fails.
c     rnderr :     Roundoff error for checking for division by zero.
c     nbpmx :      Maximum number of restarts allowed.
c     nwtmx :      Maximum number of Newtons iterations allowed in the
c                  search for intersections of a given ray with the contour.
c     nslmx:       Limit to the number of sliding interval coarse searches
c                  allowed for the intersection points.
c                  The number of searches is limited to:
c                  nslmx*sqrt(((xmax-xmin)**2+(ymax-ymin)**2) / (dx**2+dy**2)).
c     nhfmx :      Maximum number of increment halvings allowed for
c                  each contour point calculation.
c
c     Output parameters :
c     xc,yc :      Contour points generated at intersections of the
c                  psvl contour and the rays emmanating from (xaxd,yaxd).
c     gc :         Gradient of psi squared at (xc,yc).
c     npt  :       Number of contour points generated.  npt = ipts must be
c                  less than or equal to ntmx.
c
c
c
c 1.0 Initialization
c
      kerr      = 0
c
      piov2     = hlfpi
      piov4     = 0.25*pi
      tpiov2    = 3.00*piov2
      tpiov4    = 3.00*piov4
      fpiov4    = 5.00*piov4
      spiov4    = 7.00*piov4
c
      xnorm     = sqrt(xmax*xmax+xmin*xmin + ymax*ymax+ymin*ymin)
      dmaxsq    = (xmax-xmin)*(xmax-xmin) + (ymax-ymin)*(ymax-ymin)
      dmax      = sqrt(dmaxsq/(dx*dx + dy*dy))
      kdmax     = dmax + 1
      ksmax     = nslmx*kdmax
c
      ntmx1     = ntmx - 1
      dthet0    = dang*twopi
      delgpsq   = delgp*delgp
c
c
c
c 2.0 Initialize the search
c
c 2.1 Get psi at (xaxd,yaxd) and check that (xaxd,yaxd) is inside psvl
c
      call dbcevl(x,nw,y,nh,cs1,nw1,nh1,xaxd,yaxd,pds,ier)
      if(ier .ne. 0) then
        call abortjob
     &        ('cntour  ',  1,   'Spline evaluation error for psi(axe)'
     &        ,'ier     ', ier,      'nw      ', nw,       -1)
        kerr  = +1
        return
      endif
c
      psiaxd    = pds(1)
      if(psiaxd .gt. psvl) then
         call abortjob
     &        ('cntour  ',  2,   'Spline psi axis value exceeds psvl  '
     &        ,'nw      ', nw,       'nh      ', nh,       -1)
        kerr  = -1
      endif
c
c
c 2.2 Set up the loop and counter for retrying the search if too many
c     points are found
c
      jcount    = 0
  5   jcount    = jcount + 1
      bpers     = bperr*jcount
c
c
c 2.3 Set up the loop over theta from zero to twopi
c     Exit when theta exceeds twopi
c
      ipts      = 0
      ihalf     = 0
      thet      = 0.0
      dthet     = 0.0
      theta0    = thet
  10  continue
c
c
c
c 3.0 Search for the point on the surface
c     Return here to recompute the ray if the increment in bpol was
c     too large
c
c 3.1 Get the equation of the ray emanating from (xaxd,yaxd)
c
c 3.1.1 y as a function of x:           y=aincp*x + bincp
c
      if((thet .lt.  piov4  .and.  thet .ge.  0.0  )  .or.
     &   (thet .gt. tpiov4  .and.  thet .lt. fpiov4)  .or.
     &   (thet .gt. spiov4  .and.  thet .le. twopi)) then
        iflg      = 0
        if((thet .lt.  piov4)  .or.   (thet .gt. spiov4)) isgn = +1
        if((thet .gt. tpiov4)  .and.  (thet .lt. fpiov4)) isgn = -1
        aincp     = sin(thet)/cos(thet)
        bincp     = yaxd - aincp*xaxd
      endif
c
c 3.1.2 x as a function of y:           x=aincp*y+bincp
c
      if((thet .ge.  piov4)  .and.  (thet .le. tpiov4)  .or.
     &   (thet .ge. fpiov4)  .and.  (thet .le. spiov4)) then
        iflg      = 1
        if(thet .lt. pi) isgn = +1
        if(thet .gt. pi) isgn = -1
c
        if    (isgn .eq. +1) then
          thet1     = piov2 - thet
          if(thet .gt.  piov2) thet1 = twopi - abs(thet1)
        elseif(isgn .eq. -1) then
          thet1     = tpiov2 - thet
          if(thet .gt. tpiov2) thet1 = pi    - abs(thet1)
        endif
c
        aincp     = sin(thet1)/cos(thet1)
        bincp     = xaxd - aincp*yaxd
      endif
c
c
c 3.2 Sliding interval search for the intersection point.
c     Bracket psvl between psi1 and psi2 at (x1,y1) and (x2,y2)
c     along the ray.
c     The equation of the ray is:  y = aincp*x + bincp  (if iflg = 0)
c                            or    x = aincp*y + bincp  (if iflg = 1)
c
c 3.2.1 Initialize the search starting point and direction and
c       start the binary search iteration
c
      x1        = xaxd
      y1        = yaxd
      cosv      = cos(thet)
      sinv      = sin(thet)
      psi1      = psiaxd
c
      psnrm     = abs(psiaxd) + abs(psvl)
      prndff    = rnderr*((psnrm*psnrm)/(xnorm*xnorm))
c
c
      kslide    = 0
      kountr    = 0
  40  kountr    = kountr + 1
c
c 3.2.2 Search in the x direction:
c
         if    (iflg .eq. 0) then
           x2     = x1 + isgn*dx
           y2     = aincp*x2 + bincp
c
c 3.2.3 Search in the y direction:
c
         elseif(iflg .eq. 1) then
           y2     =       y1 + isgn*dy
           x2     = aincp*y2 + bincp
         endif
c
c 3.2.4 Check for coordinates out of range.  Abort if the search has
c       gone out of range or if the number of searches has exceeded
c       ksmax
c
         if((x2 .lt. xmin)  .or.  (x2 .gt. xmax)  .or.
     &      (y2 .lt. ymin)  .or.  (y2 .gt. ymax)) then
           if(x2 .lt. xmin) call abortjob
     &        ('cntour  ',  3,   'Ray search out of range: x2 < xmin  '
     &        ,'kountr  ', kountr,   'iflg    ', iflg,     -1)
           if(x2 .gt. xmax) call abortjob
     &        ('cntour  ',  4,   'Ray search out of range: x2 > xmax  '
     &        ,'kountr  ', kountr,   'iflg    ', iflg,     -1)
           if(y2 .lt. ymin) call abortjob
     &        ('cntour  ',  5,   'Ray search out of range: y2 < ymin  '
     &        ,'kountr  ', kountr,   'iflg    ', iflg,     -1)
           if(y2 .gt. ymax) call abortjob
     &        ('cntour  ',  6,   'Ray search out of range: y2 > ymax  '
     &        ,'kountr  ', kountr,   'iflg    ', iflg,     -1)
           write(kuout,1000) x(1),x(nw),x2,y(1),y(nh),y2
           kerr   = +2
           return
         endif
c
         if(kountr .gt. ksmax) then
            call abortjob
     &        ('cntour  ',  7,   'Slide search iterations exceed ksmax'
     &        ,'kountr  ', kountr,   'ksmax   ', ksmax,    -1)
           kerr   = +3
           return
         endif
c
c 3.2.5 Check if psvl is bracketed by psi1 and psi2 and continue
c       searching if not
c
c 3.2.5.1 Find the new psi value for the point (x2,y2)
         call dbcevl(x,nw,y,nh,cs1,nw1,nh1,x2,y2,pds,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('cntour  ',  8,   'Spline error in slide search on ray '
     &        ,'ier     ', ier,      'kountr  ', kountr,   -1)
           kerr   = +4
           return
         endif
c
         psi2     = pds(1)
         dpsi     = (psvl-psi1)*(psvl-psi2)
c
c 3.2.5.2 If psvl is not bracketed by psi1 and psi2 continue iterating
c         If psi1 and psi2 are close to psvl set a marker
         if    (dpsi .gt. 0.0  .and.  kslide .eq. 0) then
            if(abs(dpsi) .le. prndff) then
               kslide   = kslide + 1
               xkeep    = x1
               ykeep    = y1
               pkeep    = psi1
            endif
            x1      = x2
            y1      = y2
            psi1    = psi2
            go to 40
c
c 3.2.5.3 If psvl is not bracketed by psi1 and psi2 and the marker was set
c         from the previous iteration, print a warning, set the point back
c         to that from the previous iteration and proceed to the Newtons
c         iteration search
         elseif(dpsi .gt. 0.0  .and.  kslide .ne. 0) then
            call abortjob
     &        ('cntour  ',  9,   'Slide search passed target surface  '
     &        ,'kslide  ', kslide,   'kountr  ', kountr,   -1)
            write(kuout,1010) xkeep,ykeep,pkeep,x1,y1,psi1,x2,y2,psi2,
     &                        psvl,dpsi,prndff
            scmid   = 0.0
            x1      = xkeep
            y1      = ykeep
            psi1    = pkeep
c
         elseif(dpsi .le. 0.0) then
c 3.2.5.4 If psvl is bracketed by psi1 and psi2 proceed to the Newtons
c         iteration search
            scmid   = 0.5
         endif
c
c
c 3.3 Converge to the intersection point using Newton-Raphson iteration
c
c 3.3.1 Start iteration from the centre of the bracketed interval
c
      pnorm     = abs(psi2) + abs(psi1)
      rnderr1   = rnderr*(pnorm/xnorm)
c
      if    (iflg .eq. 0) then
        xn        =       x1 + scmid*isgn*dx
        yn        = aincp*xn + bincp
c
      elseif(iflg .eq. 1) then
        yn        =       y1 + scmid*isgn*dy
        xn        = aincp*yn + bincp
      endif
c
c 3.3.2 Newton-Raphson iteration on (xn,yn).
c
      newti     = 0
  80  newti     = newti + 1
c
c 3.3.2.1 Compute the new estimate
         call dbcevl(x,nw,y,nh,cs1,nw1,nh1,xn,yn,pds,ier)
         if(ier .ne. 0) then
            call abortjob
     &        ('cntour  ', 10,   'Spline error in Newton iteration    '
     &        ,'ier     ', ier,      'newti   ', newti,    -1)
           kerr   = +5
           return
         endif
c
         dpsids   = pds(2)*cosv + pds(3)*sinv
         dpsi     = pds(1) - psvl
c
         if    (abs(dpsids) .gt. rnderr1) then
            serr    = -dpsi/dpsids
c
         elseif(abs(dpsids) .le. rnderr1) then
            call abortjob
     &        ('cntour  ', 11,   'Newton iteration gradient is small  '
     &        ,'newti   ', newti,    'kslide  ', kslide,    0)
            serr    = -dpsi/rnderr1
         endif
c
c 3.3.2.2 Error convergence test.
         if(abs(serr) .ge. serrs  .and.  newti .lt. nwtmx) then
            delx    = serr*cosv
            dely    = serr*sinv
            xn      = xn + delx
            yn      = yn + dely
            go to 80
         endif
c
c 3.3.3 Error if the maximum number of iterations is exceeded.
c       If the maximum is exceeded and abs(serr) is still greater than
c       serrt the routine aborts, otherwise a warning is
c       printed and the mapping is continued.
c
        if(abs(serr) .ge. serrs  .and.  newti .ge. nwtmx) then
           if    (abs(serr) .lt. serrt) then
              call abortjob
     &        ('cntour  ', 12,   'Newton iterations exceeded nwtmx    '
     &        ,'newti   ', newti,    'nwtmx   ', nwtmx,    -1)
              write(kuout,2000) newti,psvl,serr,serrs,serrt

           elseif(abs(serr) .ge. serrt) then
              call abortjob
     &        ('cntour  ', 13,   'Newton iterations did not converge  '
     &        ,'newti   ', newti,    'nwtmx   ', nwtmx,    -1)
              write(kuout,2010) newti,psvl,serr,serrs,serrt
              kerr   = +6
              return
           endif
        endif
c
c
c 3.4 Check for sufficient accuracy in the point spacing for theta
c     The accuracy test is based on a relative error in the poloidal
c     magnetic field of bpers.  If the spacing is too large, set theta
c     back to its previous value theta0, decrease dtheta, and recalculate
c     the point.  The spacing can be repeatedly reduced nhfmx times.
c     Excessive accumulation near the x points is avoided by keeping
c     nhfmx small; if nhfmx is exceeded, the mapping simply continues
c     to the next point
c
c 3.4.1 Find the local poloidal field
c
      gpsi      = pds(2)*pds(2) + pds(3)*pds(3)
      bp2       = sqrt(gpsi)/xn
c
c 3.4.2 Test the change in local poloidal field from the previous point
c
      if(thet .gt. 0.0) then
        bpdiff    = abs(bp2-bp1)/amax1(bp2,bp1)
        if(bpdiff .ge. bpers) then
          ihalf      = ihalf + 1
c
c 3.4.3 Reset the angle for this point and start again if the field
c       has changed too much
c
          if(ihalf .le. nhfmx) then
            thet     = theta0
            dthet    = stfrac*dthet
            thet     = thet + dthet
            go to 10
          endif
        endif
      endif
c
c
c 3.5 Increment ipts and check if it has exceeded the dimensions
c     Fill in the new point (xc,zc) and continue
c
      ipts      = ipts + 1
      if(ipts .gt. ntmx1  .and.  jcount .lt. nbpmx) go to 5
      if(ipts .gt. ntmx1  .and.  jcount .ge. nbpmx) then
         call abortjob
     &        ('cntour  ', 14,   'Number of surface points exceeds Max'
     &        ,'ipts    ', ipts,     'jcount  ', jcount,   -1)
         write(kuout,3000) jsurf,psvl
         kerr  = +7
         return
      endif
c
      bp1       = bp2
      ihalf     = 0
c
      xc(ipts)  = xn
      yc(ipts)  = yn
      gc(ipts)  = gpsi
c
c
c 3.6 Redefine the increment dthet for the next point.
c     The angle increment is limited to dang*2pi*(rad0/rad) and to an
c     arclength of arcl metres
c
      rad       = sqrt((xn-xaxd)**2 + (yn-yaxd)**2)
      if(ipts .eq. 1) rad0  = rad
c
      dthet1    = dthet0*(rad0/rad)
      dthet2    = arcl/rad
      dthet     = amin1(dthet1,dthet2)
c
c
c
c 3.0 Increment theta and close the contour if theta has exceeded twopi
c
c 3.1 Increment theta and continue for the next point.
c
      theta0    = thet
      thet      = thet + dthet
      if(thet .lt. twopi) go to 10
c
c
c 3.2 Close the contour at theta = twopi
c
c 3.2.1 Eliminate the last calculated point if it is too close to the
c       closure point
c
      if(ipts .gt. 1) then
        ipt1      = ipts - 1
        xcfn      = xc(1)
        ycfn      = yc(1)
        deli2     = (xc( 2  )-xc( 1  ))*(xc( 2  )-xc( 1  ))  +
     &              (yc( 2  )-yc( 1  ))*(yc( 2  )-yc( 1  ))
        deln2     = (xc(ipts)-xc(ipt1))*(xc(ipts)-xc(ipt1))  +
     &              (yc(ipts)-yc(ipt1))*(yc(ipts)-yc(ipt1))
        delfn2    = (xcfn    -xc(ipts))*(xcfn    -xc(ipts))  +
     &              (ycfn    -yc(ipts))*(ycfn    -yc(ipts))
        delti2    = deli2*delgpsq
        deltn2    = deln2*delgpsq
        if((delfn2 .lt. delti2) .or. (delfn2 .lt. deltn2)) ipts = ipt1
      endif
c
c 3.2.2 Close the contour by setting the last point equal to the
c       starting point
c
      ipts      = ipts + 1
      npt       = ipts
      thet      = twopi
      xc(ipts)  = xc(1)
      yc(ipts)  = yc(1)
      gc(ipts)  = gc(1)
c
c
c
c 4.0 Write error messages if bpers needed to be increased.
c
      if(jcount .gt. 1) then
         call abortjob
     &        ('cntour  ', 15,   'Contour restarted with new bpers    '
     &        ,'jcount  ', jcount,   'npt     ', npt,      -1)
         write(kuout,4000) jsurf,psvl,jcount,nbpmx,bperr,bpers,ipts
c
         if(jcount .ge. (nbpmx-1)) then
            write(kuout,4010) xaxd,yaxd,psiaxd,psvl
            write(kuout,4011) ipts,(xc(ik),ik=1,ipts)
            write(kuout,4012) ipts,(yc(ik),ik=1,ipts)
         endif
      endif
c
c
c
c 5.0 Return and end
c
      return
c
 1000 format(1x,'Error in cntour',/,'x(1),x(nw),x = '
     &      ,3(2x,e16.8),/,1x,'y(1),y(nh),y = ',3(2x,e16.8))
 1010 format(  4x,'Quitting sliding bracket search',/
     &        ,4x,'xkeep  = ',e12.5,2x,'ykeep  = ',e12.5
     &        ,4x,'pkeep  = ',e12.5,/
     &        ,4x,'x1     = ',e12.5,2x,'y1     = ',e12.5
     &        ,4x,'psi1   = ',e12.5,/
     &        ,4x,'x2     = ',e12.5,2x,'y2     = ',e12.5
     &        ,4x,'psi2   = ',e12.5,/
     &        ,4x,'psvl   = ',e12.5,2x,'dpsi   = ',e12.5
     &        ,4x,'prndff = ',e12.5,/)
 2000 format(  4x,'Newtons iteration in cntour is not fully'
     &        ,1x,'converged:  newti =',i5,4x,'psvl =',e12.5,/
     &        ,4x,'serr  =',e12.5,4x,'serrs =',e12.5
     &        ,4x,'serrt =',e12.5,/)
 2010 format(  4x,'Newtons iteration in cntour did not converge :'
     &        ,1x,'newti =',i5,4x,'psvl =',e12.5,/
     &        ,4x,'serr  =',e12.5,4x,'serrs =',e12.5
     &        ,4x,'serrt =',e12.5,/)
 3000 format(  4x,'Contour could not be closed for psi(',i5,') = '
     &        ,e12.5,/)
 4000 format(  4x,'Needed to increment bpers for psi(',i5,') = '
     &        ,e12.5,/
     &        ,4x,'jcount  = ',i5,12x,  'nbpmx   = ',i5,/
     &        ,4x,'bperr   = ',e12.5,5x,'bpers   = ',e12.5,/
     &        ,4x,'ipts    = ',i5)
 4010 format(  4x,'xaxd    = ',e12.5,5x,'yaxd    = ',e12.5,/
     &        ,4x,'psiaxd  = ',e12.5,5x,'psvl    = ',e12.5,/)
 4011 format(/,1x,'(xc(i),i=1,',i5,')',/,(10(1x,e11.4)))
 4012 format(/,1x,'(yc(i),i=1,',i5,')',/,(10(1x,e11.4)))
      end
      function sintrp(x0,x,y,nx,ypi,npi,ypl,ypr,ibd0,ier,tol,kunit)
c
      parameter (nd=4 , iudflt=6 , iumax=60)
      dimension am(nd,nd),dm(nd)
      dimension x(nx),y(nx),ypi(npi)
c
c |-----------------------------------------------------------------------|
c |   Interpolation of a function y(x) to point x0                        |
c |                                                                       |
c |   The interpolatory polynomial is a cubic in x fitted to two          |
c |   points yl = y(xl) and yr = y(xr) and the corresponding two          |
c |   first derivatives ypl and ypr, where xl and xr are the left         |
c |   and right grid points x(i0) and x(i0+1) nearest x0                  |
c |                                                                       |
c |   Input:                                                              |
c |           x0:    interpolation point                                  |
c |           x:     vector of length nx containing the ordered abscissae |
c |           y:     vector of length nx containing the function values   |
c |           nx:    number of grid points and function values in x and y |
c |           ypi:   vector containing the derivative values at the       |
c |                  internal grid points                                 |
c |           npi:   dimension of ypi                                     |
c |                  If npi .lt. nx-2 the derivatives at internal points  |
c |                  are computed numerically                             |
c |                  If npi .ge. nx-2 the derivatives at internal points  |
c |                  ik are taken from ypi(ik-1) for ik = 2,nx-1          |
c |           ypl:   left endpoint derivative value                       |
c |           ypr:   right endpoint derivative value                      |
c |                  the endpoints                                        |
c |           ibd0:  defines the boundary conditions                      |
c |                  If ibd0 = 0 the derivatives at the endpoints are not |
c |                  used                                                 |
c |                  If ibd0 = 1 the left endpoint derivative is ypl and  |
c |                  the right boundary derivative (ypr) is not used      |
c |                  If ibd0 = 2 the right endpoint derivative is ypr and |
c |                  the left boundary derivative (ypl) is not used       |
c |                  If ibd0 = 3 ypl and ypr are used for the left and    |
c |                  right boundary derivatives                           |
c |                  If ibd0 = 4 periodic boundary conditions assuming    |
c |                  y(x+t) = y(x) + c are used                           |
c |           ier:   error parameter:                                     |
c |                  ier =  0       if no error                           |
c |                  ier =  1       if there are too few grid points      |
c |                  ier = -2 or +2 if x0 is out of range but within      |
c |                                 a tolerance (determined by ibd0)      |
c |                                 of the endpoint  (- for left          |
c |                                 endpoint, + for right endpoint)       |
c |                  ier = -3 or +3 if x0 is out of range (- for left     |
c |                                 endpoint, + for right endpoint)       |
c |                  ier = 4 - 8    if the abscissae x(i) are out of      |
c |                                 order                                 |
c |                  The value is determined by the place the error is    |
c |                  detected:                                            |
c |                  for the interval containing x0;       ier = 4        |
c |                  for the interval to the left of x0                   |
c |                  with x0 at a periodic endpoint;       ier = 5        |
c |                  for the interval to the left of x0                   |
c |                  with x0 at an internal point;         ier = 6        |
c |                  for the interval to the right of x0                  |
c |                  with x0 at a periodic endpoint;       ier = 7        |
c |                  for the interval to the right of x0                  |
c |                  with x0 at an internal point;         ier = 8        |
c |           tol:   tolerance allowed for extrapolation beyond the       |
c |                  endpoints for boundary conditions in which           |
c |                  the endpoint derivative is not defined               |
c |           kunit: output unit for error messages                       |
c |                                                                       |
c |   Restrictions:                                                       |
c |    1.  x(i), i = 1,nx must be ordered in increasing order             |
c |    2.  x0 must lie within the range of x(i).  For boundary conditions |
c |        in which an endpoint derivative is not defined either from     |
c |        input or by periodicity, extrapolation to within tol only is   |
c |        permitted.                                                     |
c |        For boundary conditions in which the endpoint derivative       |
c |        is defined by either periodicity (ibd0 = 4) or by ypl or       |
c |        ypr, extrapolation up to one full grid space is permitted      |
c |    3.  npi can be 1 or nx-2 only.  Any value less than nx-2 will      |
c |        default to 1 and any value greater than nx-2 will              |
c |        default to nx-2                                                |
c |    4.  If ibd0 is out of the range given above it defaults to 0       |
c |                                                                       |
c |   Several options are available for the derivative fitting:           |
c |    1.  If npi = 1,    the internal interval derivatives are computed  |
c |                       numerically from a quadratic fit about the      |
c |                       three points including and neighbouring the     |
c |                       desired grid point                              |
c |    2.  If npi = nx-2, the derivatives are defined at every internal   |
c |                       point from:                                     |
c |                           ypl = ypi(i0-1)    and   ypr = ypi(i0)      |
c |    3.  If ibd0 = 0,   the derivatives of the endpoints are not used   |
c |                       and the degree of the interpolation is reduced  |
c |                       to a quadratic at each end                      |
c |    5.  If ibd0 = 1,   the derivative for the left endpoint is taken   |
c |                       from ypl and the derivative at the right        |
c |                       endpoint (ypr) is not used                      |
c |    6.  If ibd0 = 2,   the derivative for the right endpoint is taken  |
c |                       from ypr and the derivative at the left         |
c |                       endpoint (ypl) is not used                      |
c |    7.  If ibd0 = 3,   the derivatives for the left and right endpoints|
c |                       are taken from ypl and ypr respectively         |
c |    4.  If ibd0 = 4,   the derivatives of the endpoints are computed   |
c |                       assuming periodicity in the sense:              |
c |                       y(x+t) = y(x) + (y(nx)-y(1)) where the period t |
c |                       is x(nx) - x(1)                                 |
c |                                                                       |
c |-----------------------------------------------------------------------|
c
c
c
c 1.0 Initialization
c
c 1.1 Set up output unit
c
      if(kunit .ge. 1  .and.  kunit .le. iumax) iunit = kunit
      if(kunit .lt. 1  .or.   kunit .gt. iumax) iunit = iudflt
c
c
c 1.2 Initialize parameters
c
c 1.2.1 Initialize error parameter
c
      ier    = 0
      if(nx  .le. 1) ier   = +1
      if(nx  .le. 1) return
c
c 1.2.2 Set up boundary parameters
c
      ibdy  = ibd0
      if(ibdy  .lt. 0  .or.   ibdy  .gt.   4  ) then
         ier   = -1
         ibdy  =  0
      endif
c
      if(npi .lt. nx-2) npint = 0
      if(npi .ge. nx-2) npint = 1
c
c 1.2.3 Set tolerances
c
      xmin   = x(1)
      xmax   = x(nx)
      if(ibdy .eq. 0) then
         tolxl = abs(x(nx) - x(1))*abs(tol)
         tolxr = tolxl
      elseif(ibdy .eq. 1) then
         tolxl = abs(x(nx) - x(nx-1))
         tolxr = abs(x(nx) - x(1))*abs(tol)
      elseif(ibdy .eq. 2) then
         tolxl = abs(x(nx) - x(1))*abs(tol)
         tolxr = abs(x( 2) - x(  1 ))
      elseif(ibdy .eq. 3) then
         tolxl = abs(x(nx) - x(nx-1))
         tolxr = abs(x( 2) - x(  1 ))
      elseif(ibdy .eq. 4) then
         tolxl = abs(x(nx) - x(nx-1))
         tolxr = abs(x( 2) - x(  1 ))
      endif
c
c
c
c 2.0 Find the interval containing x0
c
c 2.1 First test if x0 is out of range
c
      kend   = 0
      if(x0 .lt. xmin) then
         kend   = -1
         if(abs(x0-xmin) .le. tolxl) ier = -2
         if(abs(x0-xmin) .gt. tolxl) ier = -3
      endif
      if(x0 .gt. xmax) then
         kend   = +1
         if(abs(x0-xmax) .le. tolxr) ier = +2
         if(abs(x0-xmax) .gt. tolxr) ier = +3
      endif
c
c
c 2.2 Return or give a warning if x0 is out of range
c
      if(iabs(ier) .eq. 3) then
         write(iunit,1001) x0,xmin,xmax,ier,(x(ii),ii=1,nx)
         return
      endif
c
c
c 2.3 Now search through the range
c
      if(kend .lt. 0) then
         i0   = 1
      else if(kend .gt. 0) then
         i0   = nx-1
      else if(kend .eq. 0) then
         i0   = 1
         do 10 i = 2,nx
         if(x0 .le. x(i)) then
            i0   = i-1
            go to 15
         endif
 10      continue
      endif
c
c
c 2.4 Set up interval quantities
c
 15   continue
      xl     = x(i0)
      xr     = x(i0+1)
      yl     = y(i0)
      yr     = y(i0+1)
      xl2    = xl*xl
      xr2    = xr*xr
      xlr    = xl*xr
      sumx   = xr + xl
      deltax = xr - xl
      delta2 = deltax*deltax
      if(deltax .le. 0.0) then
         ier = 4
         write(iunit,2001) x0,i0,xl,xr,ier,(x(ii),ii=1,nx)
         return
      endif
c
c
c
c 3.0 Define the derivatives at xl and xr
c
c 3.1 Left hand derivative at i0
c
c 3.1.1 Left side end point:
c
      if(i0 .eq. 1) then
c
c 3.1.1.1 Left side end point; derivative not defined:
         if(ibdy .eq. 0  .or.  ibdy .eq. 2) ypleft   = 0.0
c
c 3.1.1.2 Left side end point; derivative given:
         if(ibdy .eq. 1  .or.  ibdy .eq. 3) ypleft   = ypl
c
c 3.1.1.3 Left side endpoint; periodic boundary condition:
         if(ibdy .eq. 4) then
            deltap  = x(nx) - x(nx-1)
            if(deltap .le. 0.0) then
               ier    = 5
               write(iunit,2001) x0,i0,x(nx-1),x(nx),ier
     &                         ,(x(ii),ii=1,nx)
               return
            endif
            yll     = y(nx-1) - (y(nx)-y(1))
            deltas  = deltax + deltap
            deltar  = deltap/deltax
            deltad  = deltax - deltap
            ypleft  = (yr*deltar - yll/deltar)/deltas
     &              + deltad*yl/(deltax*deltap)
         endif
c
c 3.1.2 Left side internal point:
c
      else if(i0 .gt. 1) then
c
c 3.1.2.1 Left side internal point; derivative computed numerically:
         if(npint .eq. 0) then
            deltap  = x(i0) - x(i0-1)
            if(deltap .le. 0.0) then
               ier    = 6
               write(iunit,2001) x0,i0,x(i0-1),x(i0),ier
     &                         ,(x(ii),ii=1,nx)
               return
            endif
c
            yll     = y(i0-1)
            deltas  = deltax + deltap
            deltar  = deltap/deltax
            deltad  = deltax - deltap
            ypleft  = (yr*deltar - yll/deltar)/deltas
     &              + deltad*yl/(deltax*deltap)
         endif
c
c 3.1.2.2 Left side internal point; derivative given:
         if(npint .eq. 1) ypleft   = ypi(i0-1)
      endif
c
c
c 3.2 Right hand derivative at i0+1
c
c 3.2.1 Right side end point:
c
      if(i0 .eq. nx-1) then
c
c 3.2.1.1 Right side end point; derivative not defined:
         if(ibdy .eq. 0  .or.  ibdy .eq. 1) yprite   = 0.0
c
c 3.2.1.2 Right side end point; derivative given:
         if(ibdy .eq. 2  .or.  ibdy .eq. 3) yprite   = ypr
c
c 3.2.1.3 Right side endpoint; periodic boundary conditions:
         if(ibdy .eq. 4) then
            deltap  = x(2) - x(1)
            if(deltap .le. 0.0) then
               ier    = 7
               write(iunit,2001) x0,i0,x(i0+1),x(i0+2),ier
     &                         ,(x(ii),ii=1,nx)
               return
            endif
            yrr     = y(2) + (y(nx)-y(1))
            deltas  = deltax + deltap
            deltar  = deltax/deltap
            deltad  = deltap - deltax
            yprite  = (yrr*deltar - yl/deltar)/deltas
     &              + deltad*yr/(deltax*deltap)
         endif
c
c 3.2.2 Right side internal point:
c
      else if(i0 .lt. nx-1) then
c
c 3.2.2.1 Right side internal point; derivative computed numerically:
         if(npint .eq. 0) then
            deltap  = x(i0+2) - x(i0+1)
            if(deltap .le. 0.0) then
               ier    = 8
               write(iunit,2001) x0,i0,x(i0+1),x(i0+2),ier
     &                           ,(x(ii),ii=1,nx)
               return
            endif
            yrr     = y(i0+2)
            deltas  = deltax + deltap
            deltar  = deltax/deltap
            deltad  = deltap - deltax
            yprite  = (yrr*deltar - yl/deltar)/deltas
     &              + deltad*yr/(deltax*deltap)
         endif
c
c 3.2.2.2 Right side internal point; derivative given:
         if(npint .eq. 1) yprite   = ypi(i0)
      endif
c
c
c
c 4.0 Matrix coefficients for interpolation polynomial coefficients
c
c 4.1 Left side endpoint with no derivative defined
c     For this case the coefficient of the cubic term is forced to zero
c
      if    (i0 .eq.    1   .and. (ibdy .eq. 0  .or.  ibdy .eq. 2)) then
         am(1,1) = +xr2
         am(1,2) = +delta2 - xr2
         am(1,3) = +deltax*xlr
         am(1,4) =  0.0
         am(2,1) = -2.*xr
         am(2,2) = +2.*xr
         am(2,3) = -deltax*sumx
         am(2,4) =  0.0
         am(3,1) = +1.0
         am(3,2) = -1.0
         am(3,3) = +deltax
         am(3,4) =  0.0
         am(4,1) =  0.0
         am(4,2) =  0.0
         am(4,3) =  0.0
         am(4,4) =  0.0
c
         dm(1)   = yl
         dm(2)   = yr
         dm(3)   = yprite
         dm(4)   = 0.0
         fnorm   = delta2
c
c
c 4.2 Right side endpoint with no derivative defined
c     For this case the coefficient of the cubic term is forced to zero
c
      elseif(i0 .eq. (nx-1) .and. (ibdy .eq. 0  .or.  ibdy .eq. 1)) then
         am(1,1) = +delta2 - xl2
         am(1,2) = +xl2
         am(1,3) = -deltax*xlr
         am(1,4) =  0.0
         am(2,1) = +2.*xl
         am(2,2) = -2.*xl
         am(2,3) = +deltax*sumx
         am(2,4) =  0.0
         am(3,1) = -1.0
         am(3,2) = +1.0
         am(3,3) = -deltax
         am(3,4) =  0.0
         am(4,1) =  0.0
         am(4,2) =  0.0
         am(4,3) =  0.0
         am(4,4) =  0.0
c
         dm(1)   = yl
         dm(2)   = yr
         dm(3)   = ypleft
         dm(4)   = 0.0
         fnorm   = delta2
c
c
c 4.3 Cubic interpolation for all remaining cases in which the
c     derivatives are defined on both sides of the interval (i0,i0+1)
c
      else
         url     =    xr + 2.*xl
         vrl     = 2.*xr +    xl
         prl     =    xr - 3.*xl
         qrl     = 3.*xr -    xl
c
         am(1,1) = +prl*xr*xr
         am(1,2) = +qrl*xl2
         am(1,3) = -xr*xlr*deltax
         am(1,4) = -xl*xlr*deltax
         am(2,1) = +6.*xlr
         am(2,2) = -6.*xlr
         am(2,3) = +xr*url*deltax
         am(2,4) = +xl*vrl*deltax
         am(3,1) = -3.*sumx
         am(3,2) = +3.*sumx
         am(3,3) = -vrl*deltax
         am(3,4) = -url*deltax
         am(4,1) = +2.0
         am(4,2) = -2.0
         am(4,3) = +deltax
         am(4,4) = +deltax
c
         dm(1)   = yl
         dm(2)   = yr
         dm(3)   = ypleft
         dm(4)   = yprite
         fnorm   = delta2*deltax
      endif
c
c
c
c 5.0 Construct interpolation coefficients and interpolate
c
c 5.1 Sum the interpolation polynomial
c
      sumck    = 0.0
      do 30 ki = 1,nd
      kin      = nd - ki + 1
      cmkin    = 0.0
      do 25 kj = 1,nd
      cmkin    = cmkin + am(kin,kj)*dm(kj)
 25   continue
      sumck    = sumck*x0 + cmkin
 30   continue
c
c
c 5.2 Define the interpolated value
c
      sintrp = sumck/fnorm
c
c
c
c 6.0 Return and end
c
      return
c
 1001 format(/10x,'fatal error: x0 =',e12.5,' is out of range:'
     & ,' xmin =',e12.5,2x,'xmax =',e12.5,4x,'ier =',i2,/
     & ,10x,'x(i):',/,(10(1x,e12.5)))
 2001 format(/,10x,'fatal error: x is not ordered near x0 ='
     & ,e12.5,2x,'for i0 =',i4,2x,'xl =',e12.5,2x,'xr =',e12.5
     & ,4x,'ier =',i2,/,10x,'x(i):',/,(10(1x,e12.5)))
      end
      subroutine compar(pb,knb,pint,kint)
c
      dimension pb(knb)
c
c
c
c 1.0 Set kint
c
      do 100 j = 1,knb
      kint     = j
      if(pint .le. pb(j)) return
  100 continue
c
c
c
c 2.0 Return and end
c
      return
      end
      subroutine cuschk(npnts,npmx,cscf,pfun,pmesh,pfact,ker)
c
      dimension cscf(3,npmx),pfun(npnts),pmesh(npnts)
c
c
c
c 1.0 Check coefficients to ensure pfun .gt. pfact*min(pfun(k),pfun(k+1))
c
c 1.1 Loop over points
c
      ker      = 0
      do 500 k = 1,npnts-1
      kskip    = 0
c
c 1.1.1 Check cubic term is non zero
c
      if(cscf(3,k) .ne. 0.0) then
         ws       = cscf(2,k)**2 - 3.0*cscf(3,k)*cscf(1,k)
         if(ws .ge. 0.) pe = (-cscf(2,k) + sqrt(ws)) / (3.0*cscf(3,k))
         if(ws .lt. 0.0) kskip  = +1
c
c 1.1.2 If cubic term is zero check quadratic term is nonzero
c
      elseif(cscf(3,k) .eq. 0.0) then
         if(cscf(2,k) .ne. 0.0) pe = -cscf(1,k)/(2.0*cscf(2,k))
         if(cscf(2,k) .eq. 0.0) kskip  = +2
      endif
c
c
c 1.2 Reset spline coefficients for a linear fit
c
c 1.2.1 Check that the estimate pe is in the range
c
      if(kskip .eq. 0) then
         pmspace  =  pmesh(k+1) - pmesh(k)
c
         if(pe .ge. 0.0  .and.  pe  .le. pmspace) then
c
c 1.2.2 Check the function estimate at pe
c
            pfestm   =  pfun(k)    +  
     &                ((cscf(3,k)*pe + cscf(2,k))*pe  +  cscf(1,k))*pe
            pfminm   =  pfact*amin1(pfun(k) , pfun(k+1))
c
c 1.2.3 Reset for linear fit if pe is in range and the function estimate
c       is too small
            if(pfestm .lt. pfminm) then
               if(ker .eq. 0) ker   = +k
               if(ker .ne. 0) ker   = -k
               cscf(3,k)  = 0.0
               cscf(2,k)  = 0.0
               cscf(1,k)  = (pfun (k+1) - pfun (k))  /
     &                      (pmesh(k+1) - pmesh(k))
            endif
         endif
      endif
  500 continue
c
c
c
c 2.0 Return and end
c
      return
      end
      subroutine cvcal(curav,nf,psivol,rzero,curint,vhalf)
c
c-------------------------------------------------------------------
c  this routine calculates curint, the integrated current profile,
c  and vhalf, the fractional volume containing half the current.
c-------------------------------------------------------------------
c
      dimension curav(nf), psivol(nf), curint(nf)
c
c
c
c 1.0 Initialization
c
      pii        = 3.14159265358979
      if(rzero .gt. 0.0) twopir  = 2.0*pii*rzero
      if(rzero .le. 0.0) twopir  = 2.0*pii
c
c
c
c 2.0 Calculate curint using trapezoidal rule
c
      vtot       = 0.0
      curint(nf) = 0.0
      do 10 j    = nf-1,1,-1
      curint(j)  =    curint(j+1)  +  0.5*psivol(j)
     &             * (curav ( j )  + curav(j+1)) / twopir
      vtot       = vtot + psivol(j)
   10 continue
c
      if(  vtot    .eq. 0.0) vtot       = 1.0
      if(curint(1) .eq. 0.0) curint(1)  = 1.0
c
c
c
c 3.0 Calculate vhalf
c
c 3.1 Find the coordinate closest to the half current value
c     and integrate the coordinate to obtain the volume
c
      vsum       = 0.0
      do 30 j    = nf-1,1,-1
      jvl        = j
      if((curint(jvl)/curint(1)) .gt. 0.5) go to 40
      vsum       = vsum + psivol(jvl)
   30 continue
c
c
c 3.2 Find the interpolated coordinate between the two bounding
c     grid points
c
  40  continue
      v1         =  vsum               /vtot
      v2         = (vsum + psivol(jvl))/vtot
c
      cdiff      =      curint(jvl) - curint(jvl+1)
      if(cdiff .eq. 0.0) cdiff  = 1.0
c
      del        = (0.5*curint( 1 ) - curint(jvl+1)) / cdiff
      vhalf      = (1.0 - del)*v1  +  del*v2
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine derivp(r1,z1,dpdx,dpdy,dpd2x,dpd2y,dpd2xy)
c
c-------------------------------
c calculate derivatives of psi
c-------------------------------
c
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
c
c
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      dimension pds(6)
c
      call dbcevl(x,nx,z,nz,cspl1,nxd,nzd,r1,z1,pds,ier)
      if(ier .ne. 0) call abortjob
     &        ('derivp  ',  1,   'Spline evaluation error:psi(r,z)    '
     &        ,'ier     ', ier,      'nx      ', nx,       +1)
c
      dpdx     = pds(2)
      dpdy     = pds(3)
      dpd2x    = pds(5)
      dpd2y    = pds(6)
      dpd2xy   = pds(4)
      return
      end
      subroutine derivpsi(xval,yval,dpds,dpdss,pval,tval,rndff,k,ier)
c
      dimension xval(6),yval(6),pval(6),tval(6)
c
c
c
c 1.0 Initialize
c
      ier      = 0
c
c
c
c 2.0 Set x and y derivatives with respect to p and t
c
      xvalu    = xval(1)
      dxds     = xval(2)
      dxdt     = xval(3)
      dxdss    = xval(4)
      dxdst    = xval(5)
      dxdtt    = xval(6)
c
      yvalu    = yval(1)
      dyds     = yval(2)
      dydt     = yval(3)
      dydss    = yval(4)
      dydst    = yval(5)
      dydtt    = yval(6)
c
c
c
c 3.0 Define the transformation coefficients
c
c 3.1 Set the determinant and Jacobian
c
      rndoff   = rndff*(abs(dxds*dydt) + abs(dxdt*dyds))
c
      dterms   = dxds*dydt - dxdt*dyds
c
      if    (abs(dpds) .ge. rndoff) then
        dpsids   = dpds
      elseif(abs(dpds) .lt. rndoff) then
        ier      = 1
        dpsids   = rndoff
      endif
c
      dtermp   = dterms/dpsids
      xjacb    = xvalu*dtermp
c
c
c 3.2 Check for zero division and define the inverse determinant
c
c 3.2.1 Determinant with s
c
      rndofs   = rndoff
      rndofp   = rndoff/dpsids
      if    (abs(dterms) .ge. rndofs) then
        denoms   = 1.0/dterms
      elseif(abs(dterms) .lt. rndofs) then
        if    (rndofs .gt. 0.0) then
          ier      = 2
          denoms   =   1.0 /rndofs
        elseif(rndofs .le. 0.0) then
          ier      = 3
          return
        endif
      endif
c
c 3.2.2 Determinant with psi
c
      if    (abs(dtermp) .ge. rndofp) then
        denomp   = 1.0/dtermp
c
      elseif(abs(dtermp) .lt. rndofp) then
        if    (rndofp .gt. 0.0  .and.  abs(dpds) .gt. rndoff) then
          ier      = 4
          denomp   = dpsids/rndofp
        elseif(rndofp .le. 0.0) then
          ier      = 5
          return
        elseif(abs(dpds) .le. rndoff) then
          ier      = 6
          return
        endif
      endif
c
c
c 3.3 Pass the Jacobian
c
      pval(1)  = 1.0*xjacb
      tval(1)  = 1.0/xjacb
c
c
c 3.4 Return if no derivatives are needed
c
      if(k .le. 0) return
c
c
c
c 4.0 Set the derivatives of p and t with respect to x and y
c
c 4.1 Set the first derivatives
c
      dpdx     = +dydt*denomp
      dpdy     = -dxdt*denomp
      dtdx     = -dyds*denoms
      dtdy     = +dxds*denoms
c
c
c 4.2 Pass the First derivatives
c
      pval(2)  = dpdx
      pval(3)  = dpdy
      tval(2)  = dtdx
      tval(3)  = dtdy
c
c
c 4.3 Return if no further derivatives are needed
c
      if(k .le. 1) return
c
c
c
c 5.0 Set the second derivatives of p and t
c
c 5.1 Compute the derivatives of the Jacobian and poloidal field
c
      dnomp2   = denomp*denomp
      dpsidss  = dpdss/dpsids
      dpsid2   = dpsids*dpsids
      dxydss   = dxds*dxds  + dyds*dyds
      dxydpp   = dxydss/dpsid2
      dxydtt   = dxdt*dxdt  + dydt*dydt
c
      djds     = +((dydt*dxdss - dxdt*dydss) +
     &             (dxds*dydst - dyds*dxdst))
      djdp     = +((djds  - dpsidss*dterms) / dpsid2)
c
      djdt     = +((dxds*dydtt - dyds*dxdtt) +
     &             (dydt*dxdst - dxdt*dydst)) / dpsids
c
      djbdp    =   xvalu*djdp + dtermp*dxds/dpsids
      dbpdp    = +(2.0*dnomp2)*((dxdt*dxdst + dydt*dydst)/dpsids
     &                        -  dxydtt*djdp*denomp)
c
c
      djbdt    =   xvalu*djdt + dtermp*dxdt
      dbpdt    = +(2.0*dnomp2)*((dxdt*dxdtt + dydt*dydtt)
     &                        -  dxydtt*djdt*denomp)
c
c
c 5.2 Compute the nonorthogonality
c
      alpha    = -((dxds*dxdt + dyds*dydt)/dxydtt) / dpsids
      beta     = -((dxds*dxdt + dyds*dydt)/dxydss) * dpsids
c
c
c 5.2 Pass the derivatives
c
      pval(4)  = djbdp
      pval(5)  = dbpdp
      pval(6)  = alpha
      tval(4)  = djbdt
      tval(5)  = dbpdt
      tval(6)  = beta
c
c
c
c 6.0 Return and end
c
      return
      end
      function f2s(iv,f,x,n)
c
c ----------------------------------------------------------------------
c  compute the second derivative of f with respect to x
c  at the periodic point
c ----------------------------------------------------------------------
c
      dimension f(n),x(n)
c
      nm1   = n-1
      if(iv .le. nm1) i0  = iv
      if(iv .gt. nm1) i0  = nm1
      z     = f(i0) - f(i0+1) + f(1)
      y     = x(i0) - x(i0+1) + x(1)
      f2s   = 2.0*(z-f(2)-(y-x(2)) / (x(1)-x(2)) * (f(1)-f(2)))  /
     &                              ((y-x(2))*(y-x(1)))
      return
      end
      function f2sx(iv,f,x,n)
c
c ----------------------------------------------------------------------
c  compute the second derivative of f with respect to x
c ----------------------------------------------------------------------
c
      dimension f(n),x(n)
c
      nm1    = n-1
      if(iv .lt.  2 ) i0  = 2
      if(iv .ge.  2  .and.  iv .le. nm1) i0  = iv
      if(iv .gt. nm1) i0  = nm1
c
      x0     = x(i0-1)
      x1     = x(i0)
      x2     = x(i0+1)
c
      f0     = f(i0-1)
      f1     = f(i0)
      f2     = f(i0+1)
c
      dx01   = x1 - x0
      dx12   = x2 - x1
      dx02   = x2 - x0
      dx012  = dx01*dx12*dx02
c
      f2sx   = 2.0*(dx01*f2 - dx02*f1 + dx12*f0) / dx012
c
      return
      end
      function fcn(gp,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                   ,a2,a3,a4,a5,ier)
c
      dimension gp(nwd,nhd)
c
c
c Check input
c
      ier    = 0
      if(is .le. 1   .or.  js .le.  1) then
         if(is .le.   1 ) ier   = -1
         if(js .le.   1 ) ier   = -2
         if(is .le.   1   .and.  js .le.   1 ) ier   = -3
         return
      endif
c
      if(is .ge. nw  .or.  js .ge. nh) then
         if(is .ge. nw-1) ier   = +1
         if(js .ge. nh-1) ier   = +2
         if(is .ge. nw-1  .and.  js .ge. nh-1) ier   = +3
         return
      endif
c
      fcn  = a1*(a2*gp(is-1,js-1) - a3*gp( is ,js-1) -
     &           a4*gp(is+1,js-1) - a5*gp(is+2,js-1))   -
     &       b1*(a2*gp(is-1, js ) - a3*gp( is , js ) -
     &           a4*gp(is+1, js ) - a5*gp(is+2, js ))   -
     &       c1*(a2*gp(is-1,js+1) - a3*gp( is ,js+1) -
     &           a4*gp(is+1,js+1) - a5*gp(is+2,js+1))   -
     &       d1*(a2*gp(is-1,js+2) - a3*gp( is ,js+2) -
     &           a4*gp(is+1,js+2) - a5*gp(is+2,js+2))
      return
      end
      subroutine furplm(pvl,grsq,x,y,vp,xp,yp,gsq,np,nx,ny,npmax,nw,nh
     &                 ,is0,js0,isp,jsp,jvl,mxcut,newtmxp,newtmxm,rslv
     &                 ,clcv,xshf,tolnwfp,tolnwfm,rndf,kunit,norient
     &                 ,mtrack,ninit,ker)
c
c  Given an x-y grid with a variable pvl defined on the grid this routine
c      finds the contour curves of value vp.  that is, it finds np points
c      (xp(k),yp(k)) such that pvl(xp(k),yp(k)) is close to vp.
c
c  Input variables:
c    pvl     : array to be contoured
c    grsq    : abs(grad(pvl))**2 array
c    x       : horizontal grid array
c    y       : vertical   grid array
c    vp      : value of pvl to be contoured
c    nx      : number of values in x grid
c    ny      : number of values in y grid
c    npmax   : maximum number of contour points
c    nw      : actual dimension of x grid
c    nh      : actual dimension of y grid
c    is0     : starting index in x for search
c    js0     : starting index in y for search
c    jvl     : index label for the contour vp
c    mxcut   : maximum number of points allowed to be excised if contour
c              retraces itself
c    newtmxp : maximum number of bisection iteration before initiating
c              Newton iteration in r(z) or z(r) fitting
c    newtmxm : maximum number of Newton iteration fitting routine for
c            : r(z) and z(r)
c    rslv    : parameter determining whether the contour passes through
c              grid points
c    clcv    : parameter determining whether the curve is closed
c    xshf    : shift in xp or yp into grid range
c    tolnwfp : tolerance criterion for bisection iteration before initiating
c              Newton iteration in r(z) or z(r) fitting
c    tolnwfm : tolerance criterion for Newton iteration fitting routine for
c            : r(z) and z(r)
c    rndf    : roundoff parameter passed to cubic interpolation
c    kunit   : output unit number
c    norient : parameter to determine orientation priority of search for
c              multiple exits
c    mtrack  : parameter set for diagnostic print whenever mtrack .ne. 0
c
c  Output variables:
c    ist     : actual starting index in x for search
c    jst     : actual starting index in y for search
c    xp      : vector containing x coordinates of contour
c    yp      : vector containing y coordinates of contour
c    gsq     : vector containing abs(grad(pvl))**2 along contour
c    np      : number of points found on contour
c    ninit   : number of initial search iterations to find starting point
c    ker     : error and warning flag
c
c  Search identification variables:
c                                                            (icurve  = 1).
c    idnti is an integer between 0 and 12 that identifies the option
c      used to find the entry point to a cell:
c        idnti  =  0 at initialization.
c        idnti  =  1 if kdir = -1 (ilfrt = 0) and the curve entered through
c                                           the grid point at ( i , j ).
c        idnti  =  2 if kdir = -1 (ilfrt = 0) and the curve entered through
c                                           the grid point at ( i ,j+1).
c        idnti  =  3 if kdir = -1 (ilfrt = 0) and the curve entered between
c                                           ( i , j ) and ( i ,j+1).
c        idnti  =  4 if kdir = +1 (ilfrt = 1) and the curve entered through
c                                           the grid point at ( i , j ).
c        idnti  =  5 if kdir = +1 (ilfrt = 1) and the curve entered through
c                                           the grid point at ( i ,j+1).
c        idnti  =  6 if kdir = +1 (ilfrt = 1) and the curve entered between
c                                           ( i , j ) and ( i ,j+1).
c        idnti  =  7 if kdir = -2 (iupdn = 0) and the curve entered through
c                                           the grid point at ( i , j ).
c        idnti  =  8 if kdir = -2 (iupdn = 0) and the curve entered through
c                                           the grid point at (i+1, j ).
c        idnti  =  9 if kdir = -2 (iupdn = 0) and the curve entered between
c                                           ( i , j ) and (i+1, j ).
c        idnti  = 10 if kdir = +2 (iupdn = 1) and the curve entered through
c                                           the grid point at ( i , j ).
c        idnti  = 11 if kdir = +2 (iupdn = 1) and the curve entered through
c                                           the grid point at (i+1, j ).
c        idnti  = 12 if kdir = +2 (iupdn = 1) and the curve entered between
c                                           ( i , j ) and (i+1, j ).
c
c    idntt is an integer between 0 and 20 or 25 that identifies the option
c      used to find the point:
c        idntt  =  0 at initialization unless the first point is a grid point.
c        idntt  =  1 if kdir = -1 (ilfrt = 0) and curve exited between i   and i+1
c                                           on grid line j   (icurve  = 2).
c        idntt  =  2 if kdir = -1 (ilfrt = 0) and curve exited between j   and j+1
c                                           on grid line i   (icurve  = 3).
c        idntt  =  3 if kdir = -1 (ilfrt = 0) and curve exited between i   and i+1
c                                           on grid line j+1 (icurve  = 2).
c        idntt  =  4 if kdir = +1 (ilfrt = 1) and curve exited between i-1 and i
c                                           on grid line j   (icurve  = 2).
c        idntt  =  5 if kdir = +1 (ilfrt = 1) and curve exited between j   and j+1
c                                           on grid line i-1 (icurve  = 3).
c        idntt  =  6 if kdir = +1 (ilfrt = 1) and curve exited between i-1 and i
c                                           on grid line j+1 (icurve  = 2).
c        idntt  =  7 if kdir = -2 (iupdn = 0) and curve exited between j-1 and j
c                                           on grid line i   (icurve  = 3).
c        idntt  =  8 if kdir = -2 (iupdn = 0) and curve exited between i   and i+1
c                                           on grid line j-1 (icurve  = 2).
c        idntt  =  9 if kdir = -2 (iupdn = 0) and curve exited between j-1 and j
c                                           on grid line i+1 (icurve  = 3).
c        idntt  = 10 if kdir = +2 (iupdn = 1) and curve exited between j   and j+1
c                                           on grid line i   (icurve  = 3).
c        idntt  = 11 if kdir = +2 (iupdn = 1) and curve exited between i   and i+1
c                                           on grid line j+1 (icurve  = 2).
c        idntt  = 12 if kdir = +2 (iupdn = 1) and curve exited between j   and j+1
c                                           on grid line i+1 (icurve  = 3).
c        idntt  = 13 to 20 or 25 if the point was actually a grid point
c
c    igpopt is an integer that identifies the grid point option used to find
c      the previous point when that point is a grid point.
c
c  Search direction variables:
c    iupdn sets the  vertical  direction of the curve:
c      if iupdn = 0 the curve is moving down.
c      if iupdn = 1 the curve is moving up.
c    ilfrt sets the horizontal direction of the curve:
c      if ilfrt = 0 the curve is moving to the right.
c      if ilfrt = 1 the curve is moving to the left.
c    kdir is a direction parameter used to decide the subsequent search direction:
c      kdir  = -1  Search right for intersections with lower, upper, and left  grid.
c      kdir  = +1  Search left  for intersections with lower, upper, and right grid.
c      kdir  = -2  Search down  for intersections with left,  right, and lower grid.
c      kdir  = +2  Search  up   for intersections with left,  right, and upper grid.
c
c  Grid line interpolation variables:
c    icurve is an indicator for setting the type of interpolation used to
c      obtain the next grid point, depending on whether the curve cut through:
c        a point           (icurve = 1) or
c        a horizontal line (icurve = 2) or
c        a vertical   line (icurve = 3)
c
c
      dimension xp(npmax),yp(npmax),gsq(npmax)
      dimension x (nw),y (nw),pvl(nw,nh),grsq(nw,nh)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize fixed constants
c
      ktrial     = 0
      jsurf      = jvl
      ezero      = rndf
c
      imax       = newtmxm
      imaxp      = newtmxp
      crit       = tolnwfm
      critp      = tolnwfp
c
      nx2        = nx/2
      ny2        = ny/2
      dx         = x(2)-x(1)
      dy         = y(2)-y(1)
      dp         = abs(pvl(nx2,ny2))
      nkount     = iabs(nx) + iabs(ny)
c
      dconvg     = rslv*dp
      econvg     = clcv*dx
      xinc0      = xshf*dx
      xinc1      =      dx
      yinc0      = xshf*dy
      yinc1      =      dy
      kutmax     = mxcut
c
c
c 1.2 Initialize start and direction parameters
c
c 1.2.1 Set the start parameters
c
c     If is0 .gt. 0, the search for the first point starts from is0.
c     If is0 .le. 0, the search for the first point starts from the left side.
c     If js0 .gt. 0, the search for the first point starts from js0.
c     If js0 .eq. 0, the search for the first point starts in the center of the grid.
c     If js0 .lt. 0, the search for the first point starts from the top of the grid.
c
      if    (is0 .gt. 0) ist    = is0
      if    (is0 .le. 0) ist    =  1
c
      if    (js0 .gt. 0) then
        jst        =  js0
        jdec       = +1
      elseif(js0 .eq. 0) then
        jst        =  1 + ny2
        jdec       = +1
      elseif(js0 .lt. 0) then
        jst        =  ny-1
        jdec       = -1
      endif
c
      ist        = min0(ist,nx-1)
      ist        = max0(ist, 1  )
      jst        = min0(jst,ny-1)
      jst        = max0(jst, 1  )
c
c 1.2.2 Set the default direction parameter:
c       ncycle0 < 0 means clockwise
c       ncycle0 > 0 means counterclockwise
c
c 1.2.2.1 Use the default if norient = 0
      if    (norient .eq. 0) then
        if(ist .le. nx2) ncycle0   = -1
        if(ist .gt. nx2) ncycle0   = +1
c
c 1.2.2.2 Force counterclockwise searching if norient > 0
      elseif(norient .gt. 0) then
        ncycle0    = +1
c
c 1.2.2.3 Force     clockwise    searching if norient < 0
      elseif(norient .lt. 0) then
        ncycle0    = -1
      endif
c
c 1.2.2.4 Set  the current orientation at the initial orientation
      ncycle1    = ncycle0
c
c
c 1.3 Initialize search parameters
c     Return here if search failed and try again with either diagnostic
c     output set (ktrial = -1) or
c     reverse priority for multiple exits (ktrial = +1)
c
 100  continue
c
c 1.3.1 Set the priority for choosing which branch to follow and
c       print a heading if this is a diagnostic rerun
c       When ktrial = 0 the priority is the default priority ncycle0
c       When ktrial > 0 the priority is reset for the reverse from the default
c                       priority ncycle0
c       When ktrial < 0 the priority is left unchanged from that set in ncycle1
c
c 1.3.1.1 Reset the priority
      if    (ktrial .lt. 0) then
        ncycle     = +ncycle1
      elseif(ktrial .eq. 0) then
        ncycle     = +ncycle0
      elseif(ktrial .gt. 0) then
        ncycle     = -ncycle0
      endif
c
c 1.3.1.2 Print the diagnostic data if requested for this surface or if this
c         is a diagnostic rerun
      if    (ktrial .lt. 0  .or.  mtrack .eq. 1) then
        write(kunit,1000) jsurf,vp
      endif
c
c 1.3.1.3 Reset the current orientation priority and the counter for
c         multiple exits
      ncycle1    = ncycle
      kountex    =   0
c
c 1.3.2 Initialize the error and fit parameters
c
c 1.3.2.1 Reset the error flags
      ker        =   0
      ker1       =   0
      ker2       =   0
      kmtype     =   0
c
c 1.3.2.2 Reset the fit parameters
      acf        = 0.0
      bcf        = 0.0
      ccf        = 0.0
      dcf        = 0.0
      yq         = 0.0
c
c 1.3.3 Initialize the counter and direction parameters
c
      k          =  0
      kut        =  0
c
      kdir       =  0
      ilfrt      = -1
      iupdn      = -1
      igpopt     = -1
      icurve     = -1
c
c
c
c 2.0 Find the first point
c
c 2.1 Initialize the starting grid points and loop to find
c     the nearest grid intersection 
c
      i          =  ist
      j          =  jst
c
      do 110 kl  = 1,nkount
      kinit      = kl
c
c
c 2.2 If the point is not between (i,j) and (i+1,j) check if it is
c     close to the point (i,j) and if not, keep searching
c
      if    ((vp-pvl(i,j))*(vp-pvl(i+1,j)) .ge. 0.0) then
c
c 2.2.1 If the point is within dconvg of the (i,j) grid point set icurve
c       for the case where the curve hit the grid point
c
        if    (abs(vp-pvl(i,j)) .lt. dconvg) then
          idnti      =  0
          idntt      =  25
          icurve     =  1
          go to 120
c
c 2.2.2 If the point is not right at the grid point increment i and
c       continue searching
c
        elseif(abs(vp-pvl(i,j)) .ge. dconvg) then
c
c 2.2.2.1 Increment i until the right edge is reached
          if    (i .lt. nx-1) then
            i   = i+1
c
c 2.2.2.2 Increment j if the right edge was reached and reset i to start
c         again and continue searching
          elseif(i .eq. nx-1) then
            i      = 1
            j      = j+jdec
c
c 2.2.2.3 Return if search reached the right edge and the top or bottom
            if((jdec .lt. 0  .and.  j .lt. 1 )  .or.
     &         (jdec .gt. 0  .and.  j .gt. ny)) then
              ker      = -1
              np       =  1
              if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,1010)
     &                             k,pvl(i,j),i,j,i,j,i,j,idnti
     &                            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt
              call abortjob
     &        ('furplm  ',  1,   'Surface could not be initialized    '
     &        ,'jsurf   ', jsurf,    'j       ', j,        -1)
              return
            endif
          endif
        endif
c
c
c 2.3 The point is located between the grid points (i,j) and (i+1,j)
c     Quit searching and set icurve for the case where the curve cuts
c     the horizontal j'th grid line between i and i+1
c
      elseif((vp-pvl(i,j))*(vp-pvl(i+1,j)) .lt. 0.0) then
c
c 2.3.1 If the point is within dconvg of the (i,j) grid point set icurve
c       for the case where the curve hit the grid point
c
        if    (abs(vp-pvl(i,j)) .lt. dconvg) then
          idnti      =  0
          idntt      =  25
          icurve     =  1
          go to 120
c
c 2.3.2 If the point is not right at the grid point set icurve for the
c       case where the curve cut a horizontal grid line
c
        elseif(abs(vp-pvl(i,j)) .ge. dconvg) then
          idnti      =  0
          idntt      =  0
          icurve     =  2
          go to 120
        endif
      endif
 110  continue
c
c
c 2.4 Return with error if the maximum number of searches was reached
c     without finding the initial point
c
      ker        = +1
      np         =  1
      ninit      = kinit
      if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,1010)
     &                             k,pvl(i,j),i,j,i,j,i,j,idnti
     &                            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt
      call abortjob
     &        ('furplm  ',  2,   'Exceeded initial search maximum     '
     &        ,'jsurf   ', jsurf,    'ninit   ', ninit,    -1)
      return
c
c
c 2.5 Set parameters to add the first point for a curve moving up and
c     cutting through a horizontal grid line or cutting the grid point
c
 120  continue
c
c 2.5.1 Set the initialization parameters for passing back
c
      ninit      =  kinit
      isp        =  i
      jsp        =  j
c
c 2.5.2 Set the initial parameters for the rest of the search
c
      ip0        =  i
      jp0        =  j
      ix         =  i
      jy         =  j
      iupdn      =  1
      kdir       = +2
c
c
c
c 3.0 Check if search has exceeded the bounds
c     Search returns here to find the next point
c     Skip this for the first point which was found above
c
 200  continue
      if(k .gt. 0) then
c
c
c 3.1 Check i and j are within bounds
c
c 3.1.1 Check the indices
c
        if(( i .le.  1)  .or.  ( i .ge. nx)  .or.
     &     ( j .le.  1)  .or.  ( j .ge. ny)) then
          if(i .le.  1) ker1    = -2
          if(i .ge. nx) ker1    = +2
          if(j .le.  1) ker1    = -3
          if(j .ge. ny) ker1    = +3
        endif
c
c 3.1.2 Set the error flag and print a warning if the boundary was exceeded
c
        if(ker1 .ne. 0) then
          np       = k
          if(iabs(ker1) .eq. 2) call abortjob
     &        ('furplm  ',  3,   'Search exceeded  vertical  bound    '
     &        ,'ker1    ', ker1,     'np      ', np,        0)
c
          if(iabs(ker1) .eq. 3) call abortjob
     &        ('furplm  ',  4,   'Search exceeded horizontal bound    '
     &        ,'ker1    ', ker1,     'np      ', np,        0)
        endif
c
c
c 3.2 Check for ix and jy
c
c 3.2.1 Check ix for curves cutting a vertical grid line (icurve = 3)
c
        if(ix .eq. 1    .and.   ((idntt .eq.  5)  .or.
     &                           (idntt .eq.  9)  .or.
     &                           (idntt .eq. 10))) then
          ker2     = -4
        endif
c
        if(ix .eq. nx   .and.   ((idntt .eq.  2)  .or.
     &                           (idntt .eq.  9)  .or.
     &                           (idntt .eq. 12))) then
          ker2     = +4
        endif
c
c 3.2.2 Check jy for curves cutting a horizontal grid line (icurve = 2)
c
        if(jy .eq. 1    .and.   ((idntt .eq.  1)  .or.
     &                           (idntt .eq.  4)  .or.
     &                           (idntt .eq.  8))) then
          ker2     = -5
        endif
c
        if(jy .eq. ny   .and.   ((idntt .eq.  3)  .or.
     &                           (idntt .eq.  6)  .or.
     &                           (idntt .eq. 11))) then
          ker2     = +5
        endif
c
c 3.2.3 Set the error flag and print a warning if the base index exceeded
c       the boundary
c
        if(ker2 .ne. 0) then
          np       = k
          if(iabs(ker2) .eq. 4) call abortjob
     &        ('furplm  ',  5,   'Base index ix exceeded  border      '
     &        ,'ker2    ', ker2,     'np      ', np,        0)
c
          if(iabs(ker2) .eq. 5) call abortjob
     &        ('furplm  ',  6,   'Base index jy exceeded  border      '
     &        ,'ker2    ', ker2,     'np      ', np,        0)
        endif
c
c
c 3.3 If boundary was exceeded switch orientation priority and repeat
c     calculation for first time through or 
c     return with error if this is not the first time through
c
        if(ker1 .ne. 0  .or.  ker2 .ne. 0) then
c
c 3.3.1 For the first run through, try switching orientation priority
c       if there were multiple cell exits and rerun.
c       Otherwise, return if there were no other choices possible
c
          if    (ktrial .eq. 0) then
            if    (kountex .gt. 0) then
              call abortjob
     &        ('furplm  ',  7,   'Switching orientation priority      '
     &        ,'kountex ', kountex,  'ktrial  ', ktrial,    0)
              ktrial   = +1
              go to 100
            elseif(kountex .le. 0) then
              if(ker1 .ne. 0) ker  = ker1
              if(ker1 .eq. 0) ker  = ker2
              if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,1020)
     &                          k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &                          ,idntt,ilfrt,iupdn,kdir,icurve,igpopt
              call abortjob
     &        ('furplm  ',  8,   'Boundary reached: no exit options   '
     &        ,'kountex ', kountex,  'ker     ', ker,      -1)
              return
            endif
c
c 3.3.2 Print a warning and return if this is the second pass through
c       with orientation priority switched
c
          elseif(ktrial .gt. 0) then
            if(ker1 .ne. 0) ker  = ker1
            if(ker1 .eq. 0) ker  = ker2
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,1020)
     &                          k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &                          ,idntt,ilfrt,iupdn,kdir,icurve,igpopt
            call abortjob
     &        ('furplm  ',  9,   'Return: All exit choices tried      '
     &        ,'ktrial  ', ktrial,   'ker     ', ker,      -1)
            return
c
c 3.3.3 Print a warning and return if this was a diagnostic rerun
c
          elseif(ktrial .lt. 0) then
            if(ker1 .ne. 0) ker  = ker1
            if(ker1 .eq. 0) ker  = ker2
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,1020)
     &                          k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &                          ,idntt,ilfrt,iupdn,kdir,icurve,igpopt
            call abortjob
     &        ('furplm  ', 10,   'Return from diagnostic rerun        '
     &        ,'ktrial  ', ktrial,   'ker     ', ker,      -1)
            return
          endif
        endif
c
c
c
c 4.0 Set up for the search for the next grid intersection
c     Skip this for the first point
c
c 4.1 Initialize the cell entry and exit counters
c
c 4.1.1 Entry flags
c
        kentrp1    = 0
        kentrp2    = 0
        kentrg1    = 0
        ktotent    = 0
c
c 4.1.2 Exit flags
c
        kexitp1    = 0
        kexitp2    = 0
        kexitg1    = 0
        kexitg2    = 0
        kexitg3    = 0
        ktotxit    = 0
c
c
c 4.2 Set the indices for the four cell corners
c
        ip0        =  i
        jp0        =  j
c
        if    (kdir .eq. -1  .or.  kdir .eq. +2) then
          ip1        = ip0 + 1
          jp1        = jp0 + 1
        elseif(kdir .eq. +1) then
          ip1        = ip0 - 1
          jp1        = jp0 + 1
        elseif(kdir .eq. -2) then
          ip1        = ip0 + 1
          jp1        = jp0 - 1
        endif
c
c
c 4.3 Set the entry and exit options for curves moving left or right
c     If ilfrt = 0, the curve is moving to the right
c     If ilfrt = 1, the curve is moving to the left
c         
        if    (iabs(kdir) .eq. +1) then
c
c 4.3.1 Check each entry possibility
c       kentrp1 refers to the base point of the grid entry line
c       kentrp2 refers to the other end point of the grid entry line
c       kentrg1 refers to the grid entry line
c
          if(abs(vp-pvl(ip0,jp0)) .lt. dconvg)             kentrp1  = 1
          if(abs(vp-pvl(ip0,jp1)) .lt. dconvg)             kentrp2  = 1
          if((vp-pvl(ip0,jp0))*(vp-pvl(ip0,jp1)) .lt. 0.0) kentrg1  = 1
c
c 4.3.2 Check for multiple entries
c
c 4.3.2.1 Count and save the entry flags
          kentrp1a   = kentrp1
          kentrp2a   = kentrp2
          kentrg1a   = kentrg1
          ktotent    = kentrp1 + kentrp2 + kentrg1
c
c 4.3.2.2 Print a warning if multiple entry points exist
          if(ktotent .ne. 1) then
            if(ktotent .eq. 0) call abortjob
     &        ('furplm  ', 11,   'Horizontal curve: No entry point    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
            if(ktotent .gt. 1) call abortjob
     &        ('furplm  ', 12,   'Horizontal curve: Multiple entry    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
c
c 4.3.2.3 Reset the entry points if counted both a point and line crossing
            if(kentrp1 .eq. 1  .and.  kentrg1 .eq. 1  .and.
     &         kentrp2 .eq. 0) kentrg1  = 0
            if(kentrp2 .eq. 1  .and.  kentrg1 .eq. 1  .and.
     &         kentrp1 .eq. 0) kentrg1  = 0
c
c 4.3.2.4 Print the entry data
            write(kunit,2000) ilfrt,kdir,jsurf,vp,
     &                        kentrp2a,kentrp2,ip0,jp1,pvl(ip0,jp1),
     &                        kentrg1a,kentrg1,
     &                        kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0)
          endif
c
c 4.3.3 Check each exit possibility
c       kexitp1 refers to the lower point opposite the entry grid line
c       kexitp2 refers to the upper point opposite the entry grid line
c       kexitg1 refers to the lower grid line
c       kexitg2 refers to the grid line opposite the entry grid line
c       kexitg3 refers to the upper grid line
c
          if(abs(vp-pvl(ip1,jp0)) .lt. dconvg)             kexitp1  = 1
          if(abs(vp-pvl(ip1,jp1)) .lt. dconvg)             kexitp2  = 1
          if((vp-pvl(ip0,jp0))*(vp-pvl(ip1,jp0)) .lt. 0.0) kexitg1  = 1
          if((vp-pvl(ip1,jp0))*(vp-pvl(ip1,jp1)) .lt. 0.0) kexitg2  = 1
          if((vp-pvl(ip0,jp1))*(vp-pvl(ip1,jp1)) .lt. 0.0) kexitg3  = 1
c
c 4.3.4 Count and save the exit flags
c
          kexitp1a   = kexitp1
          kexitp2a   = kexitp2
          kexitg1a   = kexitg1
          kexitg2a   = kexitg2
          kexitg3a   = kexitg3
          ktotxit    = kexitp1 + kexitp2 + kexitg1 + kexitg2 + kexitg3
c
c 4.3.5 Return if there are no exits from this grid cell
c
          if    (ktotxit .lt. 1) then
            call abortjob
     &        ('furplm  ', 13,   'Horizontal curve:   No grid exit    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
            write(kunit,2020) ilfrt,kdir,jsurf,vp,
     &                        kentrp2a,ip0,jp1,pvl(ip0,jp1),kentrg1a,
     &                        kentrp1a,ip0,jp0,pvl(ip0,jp0),kexitg1a,
     &                        kexitp1a,ip1,jp0,pvl(ip1,jp0),kexitg2a,
     &                        kexitp2a,ip1,jp1,pvl(ip1,jp1),kexitg3a
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,2010)
     &             k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            ker        = -6
            return
c
c 4.3.6 Reset exit flags for multiple exits
c
          elseif(ktotxit .gt. 1) then
c
c 4.3.6.1 Reset for multiple exits according to priority for either
c         curves moving left to right with counterclockwise (default) priority or
c         curves moving right to left with    clockwise     (reverse) priority
            if    (kdir*ncycle .le. 0) then
              if    (kexitg3 .eq. 1) then
                kmtype    = +1
                kexitp1   =  0
                kexitp2   =  0
                kexitg1   =  0
                kexitg2   =  0
              elseif(kexitg3 .eq. 0  .and.  kexitp2 .eq. 1)   then
                kmtype    = +2
                kexitp1   =  0
                kexitg1   =  0
                kexitg2   =  0
              elseif(kexitg3 .eq. 0  .and.  kexitp2 .eq. 0  .and.
     &                                      kexitg2 .eq. 1)   then
                kmtype    = +3
                kexitp1   =  0
                kexitg1   =  0
              elseif(kexitg3 .eq. 0  .and.  kexitp2 .eq. 0  .and.
     &               kexitg2 .eq. 0  .and.  kexitp1 .eq. 1)   then
                kmtype    = +4
                kexitg1   =  0
              endif
c
c 4.3.6.2 Reset for multiple exits according to priority for either
c         curves moving right to left with counterclockwise (default) priority or
c         curves moving left to right with    clockwise     (reverse) priority
            elseif(kdir*ncycle .gt. 0) then
              if    (kexitg1 .eq. 1) then
                kmtype    = -1
                kexitp1   =  0
                kexitp2   =  0
                kexitg2   =  0
                kexitg3   =  0
              elseif(kexitg1 .eq. 0  .and.  kexitp1 .eq. 1)   then
                kmtype    = -2
                kexitp2   =  0
                kexitg2   =  0
                kexitg3   =  0
              elseif(kexitg1 .eq. 0  .and.  kexitp1 .eq. 0  .and.
     &                                      kexitg2 .eq. 1)   then
                kmtype    = -3
                kexitp2   =  0
                kexitg3   =  0
              elseif(kexitg1 .eq. 0  .and.  kexitp1 .eq. 0  .and.
     &               kexitg2 .eq. 0  .and.  kexitp2 .eq. 1)   then
                kmtype    = -4
                kexitg3   =  0
              endif
            endif
c
c 4.3.7 Set the multiple exit counter flag and print a warning if
c       there were multiple exits
c
            kountex    = kountex + 1
            call abortjob
     &        ('furplm  ', 14,   'Horizontal curve: Multiple exits    '
     &        ,'jsurf   ', jsurf,    'k       ', k,         0)
            if(ktotxit .ne. 3) then
              call abortjob
     &        ('furplm  ', 15,   'Number of multiple exits .ne. 3     '
     &        ,'ktotxit ', ktotxit,  'kountex ', kountex,  -1)
              write(kunit,2030) ilfrt,kdir,kmtype,jsurf,vp,
     &                          kentrp2a,kentrp2,ip0,jp1,pvl(ip0,jp1),
     &                          kentrg1a,kentrg1,
     &                          kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0),
     &                          kexitg1a,kexitg1,
     &                          kexitp1a,kexitp1,ip1,jp0,pvl(ip1,jp0),
     &                          kexitg2a,kexitg2,
     &                          kexitp2a,kexitp2,ip1,jp1,pvl(ip1,jp1),
     &                          kexitg3a,kexitg3
            endif
          endif
c
c
c 4.4 Set the entry and exit options for curves moving up or down
c     If iupdn = 0, the curve is moving downwards
c     If iupdn = 1, the curve is moving upwards
c
        elseif(iabs(kdir) .eq. +2) then
c
c 4.4.1 Check each entry possibility
c       kentrp1 refers to the base point of the grid entry line
c       kentrp2 refers to the other end point of the grid entry line
c       kentrg1 refers to the grid entry line
c
          if(abs(vp-pvl(ip0,jp0)) .lt. dconvg)             kentrp1  = 1
          if(abs(vp-pvl(ip1,jp0)) .lt. dconvg)             kentrp2  = 1
          if((vp-pvl(ip0,jp0))*(vp-pvl(ip1,jp0)) .lt. 0.0) kentrg1  = 1
c
c 4.4.2 Check for multiple entries
c
c 4.4.2.1 Count and save the entry flags
          kentrp1a   = kentrp1
          kentrp2a   = kentrp2
          kentrg1a   = kentrg1
          ktotent    = kentrp1 + kentrp2 + kentrg1
c
c 4.4.2.2 Print a warning if multiple entry points exist
          if(ktotent .ne. 1) then
            if(ktotent .eq. 0) call abortjob
     &        ('furplm  ', 16,   'Vertical  curve:  No entry point    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
            if(ktotent .gt. 1)call abortjob
     &        ('furplm  ', 17,   'Vertical  curve:  Multiple entry    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
c
c 4.4.2.3 Reset the entry points if counted both a point and line crossing
            if(kentrp1 .eq. 1  .and.  kentrg1 .eq. 1  .and.
     &         kentrp2 .eq. 0) kentrg1  = 0
            if(kentrp2 .eq. 1  .and.  kentrg1 .eq. 1  .and.
     &         kentrp1 .eq. 0) kentrg1  = 0
c
c 4.4.2.4 Print the entry data
            write(kunit,2100) iupdn,kdir,jsurf,vp,
     &                        kentrp2a,kentrp2,ip1,jp0,pvl(ip1,jp0),
     &                        kentrg1a,kentrg1,
     &                        kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0)
          endif
c
c 4.4.3 Check each exit possibility
c       kexitp1 refers to the left  point opposite the entry grid line
c       kexitp2 refers to the right point opposite the entry grid line
c       kexitg1 refers to the left  grid line
c       kexitg2 refers to the upper or lower grid line opposite the entry
c       kexitg3 refers to the right grid line
c
          if(abs(vp-pvl(ip0,jp1)) .lt. dconvg)             kexitp1  = 1
          if(abs(vp-pvl(ip1,jp1)) .lt. dconvg)             kexitp2  = 1
          if((vp-pvl(ip0,jp0))*(vp-pvl(ip0,jp1)) .lt. 0.0) kexitg1  = 1
          if((vp-pvl(ip0,jp1))*(vp-pvl(ip1,jp1)) .lt. 0.0) kexitg2  = 1
          if((vp-pvl(ip1,jp0))*(vp-pvl(ip1,jp1)) .lt. 0.0) kexitg3  = 1
c
c 4.4.4 Count and save the exit flags
c
          kexitp1a   = kexitp1
          kexitp2a   = kexitp2
          kexitg1a   = kexitg1
          kexitg2a   = kexitg2
          kexitg3a   = kexitg3
          ktotxit    = kexitp1 + kexitp2 + kexitg1 + kexitg2 + kexitg3
c
c 4.4.5 Return if there are no exits from this grid cell
c
          if    (ktotxit .lt. 1) then
            call abortjob
     &        ('furplm  ', 18,   'Vertical  curve:    No grid exit    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
            write(kunit,2120) iupdn,kdir,jsurf,vp,
     &                        kentrp2a,ip1,jp0,pvl(ip1,jp0),kentrg1a,
     &                        kentrp1a,ip0,jp0,pvl(ip0,jp0),kexitg1a,
     &                        kexitp1a,ip0,jp1,pvl(ip0,jp1),kexitg2a,
     &                        kexitp2a,ip1,jp1,pvl(ip1,jp1),kexitg3a
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,2110)
     &             k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            ker   = +6
            return
c
c 4.4.6 Reset exit flags for multiple exits
c
          elseif(ktotxit .gt. 1) then
c
c 4.4.6.1 Reset for multiple exits according to priority for either
c         curves moving down  with counterclockwise (default) priority or
c         curves moving  up   with    clockwise     (reverse) priority
            if    (kdir*ncycle .le. 0) then
              if    (kexitg3 .eq. 1) then
                kmtype    = +1
                kexitp1   =  0
                kexitp2   =  0
                kexitg1   =  0
                kexitg2   =  0
              elseif(kexitg3 .eq. 0  .and.  kexitp2 .eq. 1)   then
                kmtype    = +2
                kexitp1   =  0
                kexitg1   =  0
                kexitg2   =  0
              elseif(kexitg3 .eq. 0  .and.  kexitp2 .eq. 0  .and.
     &                                      kexitg2 .eq. 1)   then
                kmtype    = +3
                kexitp1   =  0
                kexitg1   =  0
              elseif(kexitg3 .eq. 0  .and.  kexitp2 .eq. 0  .and.
     &               kexitg2 .eq. 0  .and.  kexitp1 .eq. 1)   then
                kmtype    = +4
                kexitg1   =  0
              endif
c
c 4.4.6.2 Reset for multiple exits according to priority for either
c         curves moving  up  with counterclockwise (default) priority or
c         curves moving down with    clockwise     (reverse) priority
            elseif(kdir*ncycle .gt. 0) then
              if    (kexitg1 .eq. 1) then
                kmtype    = -1
                kexitp1   =  0
                kexitp2   =  0
                kexitg2   =  0
                kexitg3   =  0
              elseif(kexitg1 .eq. 0  .and.  kexitp1 .eq. 1)   then
                kmtype    = -2
                kexitp2   =  0
                kexitg2   =  0
                kexitg3   =  0
              elseif(kexitg1 .eq. 0  .and.  kexitp1 .eq. 0  .and.
     &                                      kexitg2 .eq. 1)   then
                kmtype    = -3
                kexitp2   =  0
                kexitg3   =  0
              elseif(kexitg1 .eq. 0  .and.  kexitp1 .eq. 0  .and.
     &               kexitg2 .eq. 0  .and.  kexitp2 .eq. 1)   then
                kmtype    = -4
                kexitg3   =  0
              endif
            endif
c
c 4.4.7 Set the multiple exit counter flag and print a warning if
c       there were multiple exits
c
            kountex   = kountex + 1
c
            call abortjob
     &        ('furplm  ', 19,   'Vertical  curve:  Multiple exits    '
     &        ,'jsurf   ', jsurf,    'k       ', k,         0)
            if(ktotxit .ne. 3) then
              call abortjob
     &        ('furplm  ', 20,   'Number of multiple exits .ne. 3     '
     &        ,'ktotxit ', ktotxit,  'kountex ', kountex,  -1)
              write(kunit,2130) iupdn,kdir,kmtype,jsurf,vp,
     &                          kentrp2a,kentrp2,ip1,jp0,pvl(ip1,jp0),
     &                          kentrg1a,kentrg1,
     &                          kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0),
     &                          kexitg1a,kexitg1,
     &                          kexitp1a,kexitp1,ip0,jp1,pvl(ip0,jp1),
     &                          kexitg2a,kexitg2,
     &                          kexitp2a,kexitp2,ip1,jp1,pvl(ip1,jp1),
     &                          kexitg3a,kexitg3
            endif
          endif
        endif
c
c
c
c 5.0 Determine where the next point is located
c     Skip this for the first point
c
c 5.1 For curves entering from the left and moving to the right
c
        if    (   kdir  .eq. -1) then
          if      (kentrp1 .eq. 1) idnti  = 1
          if      (kentrp2 .eq. 1) idnti  = 2
          if      (kentrg1 .eq. 1) idnti  = 3
c
c 5.1.1 Check if the curve cuts through the lower right grid point (i+1,j)
          if      ( kexitp1 .eq.  1 )   then
            igpopt    =  1
            i         = ip1
            ix        = ip1
            jy        = jp0
            idntt     = 13
            icurve    =  1
c
c 5.1.2 Check if the curve cuts through the upper right grid point (i+1,j+1)
c
          elseif  ( kexitp2 .eq.  1 )   then
            igpopt    =  2
            i         = ip1
            j         = jp1
            ix        = ip1
            jy        = jp1
            idntt     = 14
            icurve    =  1
c
c 5.1.3 Check if the curve cuts the lower grid line between grid
c       points (i,j) and (i+1,j)
c
          elseif  ( kexitg1 .eq.  1 )   then
            ix        = ip0
            jy        = jp0
            idntt     =  1
            icurve    =  2
c
c 5.1.4 Check if the curve cuts the right grid line between grid
c       points (i+1,j) and (i+1,j+1)
c
          elseif  ( kexitg2 .eq.  1 )   then
            ix        = ip1
            jy        = jp0
            idntt     =  2
            icurve    =  3
c
c 5.1.5 Check if the curve cuts the upper grid line between grid
c       points (i,j+1) and (i+1,j+1)
c
          elseif  ( kexitg3 .eq.  1 )   then
            ix        = ip0
            jy        = jp1
            idntt     =  3
            icurve    =  2
c
c 5.1.6 Print a warning and return if none of the conditions were satisfied
c       This may occur if the curve reenters back through the left
c       grid line through the upper or lower grid point
c
          else
            ker       = -7
            np        =  k
            ijt       =  i + (j-1)*nx
            call abortjob
     &        ('furplm  ', 21,   'Unable to find an exit from cell    '
     &        ,'np      ', np,       'ijt     ', ijt,      -1)
            write(kunit,3100) ilfrt,kdir,kmtype,jsurf,vp,
     &                        kentrp2a,kentrp2,ip0,jp1,pvl(ip0,jp1),
     &                        kentrg1a,kentrg1,
     &                        kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0),
     &                        kexitg1a,kexitg1,
     &                        kexitp1a,kexitp1,ip1,jp0,pvl(ip1,jp0),
     &                        kexitg2a,kexitg2,
     &                        kexitp2a,kexitp2,ip1,jp1,pvl(ip1,jp1),
     &                        kexitg3a,kexitg3
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,3000)
     &             k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            return
          endif
c
c
c 5.2 For curves entering from the right and moving to the left
c
        elseif(   kdir  .eq. +1) then
          if      (kentrp1 .eq. 1) idnti  = 4
          if      (kentrp2 .eq. 1) idnti  = 5
          if      (kentrg1 .eq. 1) idnti  = 6
c
c 5.2.1 Check if the curve cuts through the lower left grid point (i-1,j)
c
          if      ( kexitp1 .eq.  1 )   then
            igpopt    =  3
            i         = ip1
            ix        = ip1
            jy        = jp0
            idntt     = 15
            icurve    =  1
c
c 5.2.2 Check if the curve cuts through the upper left grid point (i-1,j+1)
c
          elseif  ( kexitp2 .eq.  1 )   then
            igpopt    =  4
            i         = ip1
            j         = jp1
            ix        = ip1
            jy        = jp1
            idntt     = 16
            icurve    =  1
c
c 5.2.3 Check if the curve cuts the lower grid line between grid
c       points (i-1,j) and (i,j)
c
          elseif  ( kexitg1 .eq.  1 )   then
            ix        = ip1
            jy        = jp0
            idntt     =  4
            icurve    =  2
c
c 5.2.4 Check if the curve cuts the left grid line between grid
c       points (i-1,j) and (i-1,j+1)
c
          elseif  ( kexitg2 .eq.  1 )   then
            ix        = ip1
            jy        = jp0
            idntt     =  5
            icurve    =  3
c
c 5.2.5 Check if the curve cuts the upper grid line between grid
c       points (i-1,j+1) and (i,j+1)
c
          elseif  ( kexitg3 .eq.  1 )   then
            ix        = ip1
            jy        = jp1
            idntt     =  6
            icurve    =  2
c
c 5.2.6 Print a warning and return if none of the conditions were satisfied
c       This may occur if the curve reenters back through the right
c       grid line through the upper or lower grid point
c
          else
            ker       = +7
            np        =  k
            ijt       =  i + (j-1)*nx
            call abortjob
     &        ('furplm  ', 22,   'Unable to find an exit from cell    '
     &        ,'np      ', np,       'ijt     ', ijt,      -1)
            write(kunit,3100) ilfrt,kdir,kmtype,jsurf,vp,
     &                        kentrp2a,kentrp2,ip0,jp1,pvl(ip0,jp1),
     &                        kentrg1a,kentrg1,
     &                        kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0),
     &                        kexitg1a,kexitg1,
     &                        kexitp1a,kexitp1,ip1,jp0,pvl(ip1,jp0),
     &                        kexitg2a,kexitg2,
     &                        kexitp2a,kexitp2,ip1,jp1,pvl(ip1,jp1),
     &                        kexitg3a,kexitg3
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,3000)
     &             k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            return
          endif
c
c
c 5.3 For curves entering from the top and moving down
c
        elseif(   kdir  .eq. -2) then
          if      (kentrp1 .eq. 1) idnti  = 7
          if      (kentrp2 .eq. 1) idnti  = 8
          if      (kentrg1 .eq. 1) idnti  = 9
c
c 5.3.1 Check if the curve cuts through the lower left grid point (i,j-1)
c
          if      ( kexitp1 .eq.  1 )   then
            igpopt    =  5
            j         = jp1
            ix        = ip0
            jy        = jp1
            idntt     = 17
            icurve    =  1
c
c 5.3.2 Check if the curve cuts through the lower right grid point (i+1,j-1)
c
          elseif  ( kexitp2 .eq.  1 )   then
            igpopt    =  6
            i         = ip1
            j         = jp1
            ix        = ip1
            jy        = jp1
            idntt     = 18
            icurve    =  1
c
c 5.3.3 Check if the curve cuts the left grid line between grid
c       points (i,j) and (i,j-1)
c
          elseif   (kexitg1 .eq.  1)    then
            ix        = ip0
            jy        = jp1
            idntt     =  7
            icurve    =  3
c
c 5.3.4 Check if the curve cuts the lower grid line between grid
c       points (i,j-1) and (i+1,j-1)
c
          elseif  ( kexitg2 .eq.  1 )   then
            ix        = ip0
            jy        = jp1
            idntt     =  8
            icurve    =  2
c
c 5.3.5 Check if the curve cuts the right grid line between grid
c       points (i+1,j) and (i+1,j-1)
c
          elseif   (kexitg3 .eq.  1)    then
            ix        = ip1
            jy        = jp1
            idntt     =  9
            icurve    =  3
c
c 5.3.6 Print a warning and return if none of the conditions were satisfied
c
          else
            ker       = -8
            np        =  k
            ijt       =  i + (j-1)*nx
            call abortjob
     &        ('furplm  ', 23,   'Unable to find an exit from cell    '
     &        ,'np      ', np,       'ijt     ', ijt,      -1)
            write(kunit,3110) iupdn,kdir,kmtype,jsurf,vp,
     &                        kentrp2a,kentrp2,ip1,jp0,pvl(ip1,jp0),
     &                        kentrg1a,kentrg1,
     &                        kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0),
     &                        kexitg1a,kexitg1,
     &                        kexitp1a,kexitp1,ip0,jp1,pvl(ip0,jp1),
     &                        kexitg2a,kexitg2,
     &                        kexitp2a,kexitp2,ip1,jp1,pvl(ip1,jp1),
     &                        kexitg3a,kexitg3
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,3000)
     &             k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti,idntt
     &            ,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            return
          endif
c
c
c 5.4 For curves entering from the bottom and moving up
c
        elseif(   kdir  .eq. +2) then
          if      (kentrp1 .eq. 1) idnti  = 10
          if      (kentrp2 .eq. 1) idnti  = 11
          if      (kentrg1 .eq. 1) idnti  = 12
c
c 5.4.1 Check if the curve cuts through the upper left grid point (i,j+1)
c
          if      ( kexitp1 .eq.  1 )   then
            igpopt    =  7
            j         = jp1
            ix        = ip0
            jy        = jp1
            idntt     = 19
            icurve    =  1
c
c 5.4.2 Check if the curve cuts through the upper right grid point (i+1,j+1)
c
          elseif  ( kexitp2 .eq.  1 )   then
            igpopt    =  8
            i         = ip1
            j         = jp1
            ix        = ip1
            jy        = jp1
            idntt     = 20
            icurve    =  1
c
c 5.4.3 Check if the curve cuts the left grid line between grid
c       points (i,j+1) and (i,j)
c
          elseif   (kexitg1 .eq.  1)    then
            ix        = ip0
            jy        = jp0
            idntt     = 10
            icurve    =  3
c
c 5.4.4 Check if the curve cuts the upper grid line between grid
c       points (i,j+1) and (i+1,j+1)
c
          elseif  ( kexitg2 .eq.  1 )   then
            ix        = ip0
            jy        = jp1
            idntt     = 11
            icurve    =  2
c
c 5.4.5 Check if the curve cuts the right grid line between grid
c       points (i+1,j) and (i+1,j+1)
c
          elseif   (kexitg3 .eq.  1)    then
            ix        = ip1
            jy        = jp0
            idntt     = 12
            icurve    =  3
c
c 5.4.6 Print a warning and return if none of the conditions were satisfied
c
          else
            ker       = +8
            np        =  k
            ijt       =  i + (j-1)*nx
            call abortjob
     &        ('furplm  ', 24,   'Unable to find an exit from cell    '
     &        ,'np      ', np,       'ijt     ', ijt,      -1)
            write(kunit,3110) iupdn,kdir,kmtype,jsurf,vp,
     &                        kentrp2a,kentrp2,ip1,jp0,pvl(ip1,jp0),
     &                        kentrg1a,kentrg1,
     &                        kentrp1a,kentrp1,ip0,jp0,pvl(ip0,jp0),
     &                        kexitg1a,kexitg1,
     &                        kexitp1a,kexitp1,ip0,jp1,pvl(ip0,jp1),
     &                        kexitg2a,kexitg2,
     &                        kexitp2a,kexitp2,ip1,jp1,pvl(ip1,jp1),
     &                        kexitg3a,kexitg3
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,3000)
     &             k,pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti,idntt
     &            ,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            return
          endif
        endif
      endif
c
c
c
c 6.0 Add the new point to (xp,yp)
c
c 6.1 Increment the counter and check that the number of points has
c     not exceeded the maximum
c
      k          = k + 1
      if    (k .lt. npmax) then
c
c 6.2 Add the point if the curve has cut through a grid point
c 
        if    (icurve .eq. 1) then
c
c 6.2.1 Set the point on the curve at the grid point
c
          kp0      = k
          ix0      = ix
          jy0      = jy
c
          xp(k)    = x(ix0)
          yp(k)    = y(jy0)
c
c 6.2.2 Set gsq from grsq at the grid point
c
          gsq(k)   = grsq(ix0,jy0)
c
c 6.2.3 Set the directional parameters
c
          if(xp(k) .gt. xp(k-1)) ilfrt   = 0
          if(xp(k) .le. xp(k-1)) ilfrt   = 1
          if(yp(k) .lt. yp(k-1)) iupdn   = 0
          if(yp(k) .ge. yp(k-1)) iupdn   = 1
c
          if(ilfrt .eq. 1) i = i-1
c
c 6.2.4 Set up next search iteration
c
          if(iupdn .eq. 0) kdir   = -2
          if(iupdn .eq. 1) kdir   = +2
c
c 6.2.5 Print a warning when curves cut exactly through a grid point
c
              call abortjob
     &        ('furplm  ', 25,   'Saved curve point on grid point     '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
c
c
c 6.3 For a curve moving up or down, intersecting a constant y line
c
        elseif(icurve .eq. 2) then
c
c 6.3.1 Compute xp(k) from interpolation between grid points
c       (ix,jy) and (ix+1,jy)
c
c 6.3.1.1 Set up the interpolation
          if    (ix .eq. 1) then
            ix0    = 2
          elseif(ix .gt.  1   .and.  ix .lt. nx-1) then
            ix0    = ix
          elseif(ix .ge. nx-1) then
            ix0    = nx-2
          endif
c
          ixm1     = ix0 - 1
          ixp1     = ix0 + 1
          ixp2     = ix0 + 2
          jy0      = jy
c
c 6.3.1.2 Compute xp from fitting
          kp0      = k
          xg1      = x  (ixm1)
          xg2      = x  (ix0 )
          xg3      = x  (ixp1)
          xg4      = x  (ixp2)
          p1y0     = pvl(ixm1,jy0)
          p2y0     = pvl(ix0, jy0)
          p3y0     = pvl(ixp1,jy0)
          p4y0     = pvl(ixp2,jy0)
          xinp     = x(ix0)
          pinp     = vp
          call fit(2,xg1,xg2,xg3,xg4,p1y0,p2y0,p3y0,p4y0,xinp,pinp,
     &               xs,ps,pq,imaxp,imax,critp,crit,kunit,iwn0,ier0,
     &                                                         icflg)
c
          xp(kp0)  = xs
          pdif     = ps - pinp
          psumg    = abs(p1y0) + abs(p2y0) + abs(p3y0) + abs(p4y0)
     &                                                 + abs(pinp)
          compr    = crit*psumg
          if(iwn0 .ne. 0) then
            if(iabs(iwn0) .le. +3) call abortjob
     &        ('furplm  ', 26,   'x mesh misordered in fit routine    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            if(iabs(iwn0) .gt. +3  .and.  iabs(iwn0) .le. +5)
     &        call abortjob
     &        ('furplm  ', 27,   'Poor initial guess for x in fit     '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            if(iwn0 .ge. +6  .or.  iwn0 .lt. 0) call abortjob
     &        ('furplm  ', 28,   'fit bisection iteration failed      '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            if(iwn0 .ne. +5) then
              write(kunit,4000) iwn0,ier0,icflg,pdif,compr
            endif
          endif
c
          if(ier0 .ne. 0  .or.  abs(pdif) .ge. compr) then
            if    (ier0 .eq. 0) then
               call abortjob
     &        ('furplm  ', 29,   'Newton iteration inaccurate in x    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            elseif(ier0 .ne. 0) then
               if(ier0 .lt. 0) call abortjob
     &        ('furplm  ', 30,   'x interval in fit coordinate = 0    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -2)
               if(ier0 .lt. 0) call abortjob
     &        ('furplm  ', 31,   'Newton iteration failure: x(psi)    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            endif
            write(kunit,4010) iwn0,ier0,icflg
     &                       ,xg1, xg2, xg3, xg4, xinp,xs
     &                       ,p1y0,p2y0,p3y0,p4y0,pinp,ps,pq
     &                       ,pdif,compr
          endif
c
c 6.3.2 Compute gsq from cubic interpolation of grsq
c
          ws       = xp(kp0)
          call cubic(x(ixm1),x(ix0),x(ixp1),x(ixp2),ws,acf,bcf,ccf,dcf
     &                                                ,ezero,ierc,kerc)
          if(ierc .ne. 0) then
             if(ierc .lt. 0) call abortjob
     &        ('furplm  ', 32,   'Points are misordered in cubic fit  '
     &        ,'jsurf   ', jsurf,    'ierc    ', ierc,     -1)
             if(ierc .gt. 0) call abortjob
     &        ('furplm  ', 33,   'Cubic fit reduced to lower order    '
     &        ,'jsurf   ', jsurf,    'ierc    ', ierc,      0)
          endif
c
          gsq(kp0) = acf*grsq(ixm1,jy0)  +  bcf*grsq(ix0, jy0)  +
     &               ccf*grsq(ixp1,jy0)  +  dcf*grsq(ixp2,jy0)
c
c 6.3.3 Set yp and adjust xp if it lies outside the range
c       Shift inside a distance xinc0 to keep it away from the grid point
c
          ixm      = ix0
          ixp      = ix0 + 1
          if(ixm .gt.  1) ixmm = ix0 - 1
          if(ixm .le.  1) ixmm = ix0
          if(ixp .lt. nx) ixpp = ix0 + 2
          if(ixp .ge. nx) ixpp = ix0 + 1
          xp00     = xp(kp0)
          yp00     = y (jy0)
          yp(kp0)  = yp00
          if(xp00 .le. x(ixm)) then
            if    (abs(xp00-x(ixm)) .le. xinc0) then
              call abortjob
     &        ('furplm  ', 34,   'Point xp is slightly left of range  '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            elseif(abs(xp00-x(ixm)) .gt. xinc0  .and.
     &             abs(xp00-x(ixm)) .le. xinc1) then
              call abortjob
     &        ('furplm  ', 35,   'Point xp in neighboring left cell   '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            elseif(abs(xp00-x(ixm)) .gt. xinc1) then
              call abortjob
     &        ('furplm  ', 36,   'New point xp is well left of range  '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            endif
            xp(kp0) = x(ixm) + xinc0
            write(kunit,4100) xp00,yp00,kp0, xp(kp0), kp0, yp(kp0)
     &                                 ,ixmm,x (ixmm),ixm, x (ixm )
     &                                 ,ixp, x (ixp ),ixpp,x (ixpp)
          endif
c
          xp11     = xp(kp0)
          yp11     = yp00
          if(xp11 .ge. x(ixp)) then
            if    (abs(xp11-x(ixp)) .le. xinc0) then
              call abortjob
     &        ('furplm  ', 37,   'Point xp is slightly right of range '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            elseif(abs(xp11-x(ixp)) .gt. xinc0  .and.
     &             abs(xp11-x(ixp)) .le. xinc1) then
              call abortjob
     &        ('furplm  ', 38,   'Point xp in neighboring right cell  '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            elseif(abs(xp11-x(ixp)) .gt. xinc1) then
              call abortjob
     &        ('furplm  ', 39,   'New point xp is well right of range '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            endif
            xp(kp0) = x(ixp) - xinc0
            write(kunit,4110) xp11,yp11,kp0, xp(kp0), kp0, yp(kp0)
     &                                 ,ixmm,x (ixmm),ixm, x (ixm )
     &                                 ,ixp, x (ixp ),ixpp,x (ixpp)
          endif
c
c 6.3.4 Set directional parameters
c
c 6.3.4.1 For k = 1 set ilfrt
          if    (kp0 .eq. 1) then
            if(jdec .lt. 0) ilfrt  = 0
            if(jdec .gt. 0) ilfrt  = 1
c
c 6.3.4.2 For k .gt. 1 reset i and j and the direction parameters
          elseif(kp0 .gt. 1) then
            if     ((idntt .eq.  4)  .or.  (idntt .eq.  6)) i   = i-1
c
            if    (((idntt .eq.  3)  .or.  (idntt .eq.  6))  .or.
     &                                     (idntt .eq. 11))    then
              j   = j+1
            elseif(  idntt .eq.  8)                            then
              j   = j-1
            endif
c
            if(xp(kp0) .gt. xp(kp0-1)) ilfrt  = 0
            if(xp(kp0) .le. xp(kp0-1)) ilfrt  = 1
            if(yp(kp0) .lt. yp(kp0-1)) iupdn  = 0
            if(yp(kp0) .ge. yp(kp0-1)) iupdn  = 1
          endif
c
c 6.3.5 Set up next search iteration
c
          if(iupdn .eq. 0) kdir   = -2
          if(iupdn .eq. 1) kdir   = +2
c
c
c 6.4 For a curve moving left or right, intersecting a constant x line
c
        elseif(icurve .eq. 3) then
c
c 6.4.1 Compute yp(k) from interpolation between grid points
c       (ix,jy) and (ix,jy+1)
c
c 6.4.1.1 Set up the interpolation
          if(jy .eq. 1) then
            jy0    = 2
          elseif(jy .gt.  1   .and.  jy .le. ny-2) then
            jy0    = jy
          elseif(jy .gt. ny-2) then
            jy0    = ny-2
          endif
c
          jym1     = jy0-1
          jyp1     = jy0+1
          jyp2     = jy0+2
          ix0      = ix
c
c 6.4.1.2 Compute yp from fitting
c
c 6.3.1.2 Compute xp from fitting
          kp0      = k
          yg1      = y  (jym1)
          yg2      = y  (jy0 )
          yg3      = y  (jyp1)
          yg4      = y  (jyp2)
          p1x0     = pvl(ix0,jym1)
          p2x0     = pvl(ix0,jy0 )
          p3x0     = pvl(ix0,jyp1)
          p4x0     = pvl(ix0,jyp2)
          yinp     = y(jy0)
          pinp     = vp
          call fit(2,yg1,yg2,yg3,yg4,p1x0,p2x0,p3x0,p4x0,yinp,pinp,
     &               ys,ps,pq,imaxp,imax,critp,crit,kunit,iwn0,ier0,
     &                                                         icflg)
c
          yp(kp0)  = ys
          pdif     = ps - pinp
          psumg    = abs(p1x0) + abs(p2x0) + abs(p3x0) + abs(p4x0)
     &                                                 + abs(pinp)
          compr    = crit*psumg
          if(iwn0 .ne. 0) then
            if(iabs(iwn0) .le. +3) call abortjob
     &        ('furplm  ', 40,   'y mesh misordered in fit routine    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            if(iabs(iwn0) .gt. +3  .and.  iabs(iwn0) .le. +5)
     &        call abortjob
     &        ('furplm  ', 41,   'Poor initial guess for y in fit     '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            if(iwn0 .ge. +6  .or.  iwn0 .lt. 0) call abortjob
     &        ('furplm  ', 42,   'fit bisection iteration failed      '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            if(iwn0 .ne. +5) then
              write(kunit,4020) iwn0,ier0,icflg,pdif,compr
            endif
          endif
c
          if(ier0 .ne. 0  .or.  abs(pdif) .ge. compr) then
            if    (ier0 .eq. 0) then
               call abortjob
     &        ('furplm  ', 43,   'Newton iteration inaccurate in y    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            elseif(ier0 .ne. 0) then
               if(ier0 .lt. 0) call abortjob
     &        ('furplm  ', 44,   'y interval in fit coordinate = 0    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -2)
               if(ier0 .lt. 0) call abortjob
     &        ('furplm  ', 45,   'Newton iteration failure: y(psi)    '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            endif
            write(kunit,4030) iwn0,ier0,icflg
     &                       ,yg1, yg2, yg3, yg4, yinp,ys
     &                       ,p1x0,p2x0,p3x0,p4x0,pinp,ps,pq
     &                       ,pdif,compr
          endif
c
c 6.4.2 Compute gsq from cubic interpolation of grsq
c
          ws       = yp(kp0)
          call cubic(y(jym1),y(jy0),y(jyp1),y(jyp2),ws,acf,bcf,ccf,dcf
     &                                                ,ezero,ierc,kerc)
          if(ierc .ne. 0) then
             if(ierc .lt. 0) call abortjob
     &        ('furplm  ', 46,   'Points misordered in cubic fit      '
     &        ,'jsurf   ', jsurf,    'ierc    ', ierc,     -1)
             if(ierc .gt. 0) call abortjob
     &        ('furplm  ', 47,   'Cubic fit reduced to low order      '
     &        ,'jsurf   ', jsurf,    'ierc    ', ierc,      0)
          endif
c
          gsq(kp0) = acf*grsq(ix0,jym1)  +  bcf*grsq(ix0, jy0)  +
     &               ccf*grsq(ix0,jyp1)  +  dcf*grsq(ix0,jyp2)
c
c 6.4.3 Set xp and adjust yp if it lies outside the range
c       Shift inside a distance yinc0 to keep it away from the grid point
c
          jym      = jy0
          jyp      = jy0 + 1
          if(jym .gt.  1) jymm = jy0 - 1
          if(jym .le.  1) jymm = jy0
          if(jyp .lt. ny) jypp = jy0 + 2
          if(jyp .ge. ny) jypp = jy0 + 1
          xp00     = x (ix0)
          yp00     = yp(kp0)
          xp(kp0)  = xp00
          if(yp00 .le. y(jym)) then
            if    (abs(yp00-y(jym)) .le. yinc0) then
              call abortjob
     &        ('furplm  ', 48,   'Point yp slightly below range       '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            elseif(abs(yp00-y(jym)) .gt. yinc0  .and.
     &             abs(yp00-y(jym)) .le. yinc1) then
              call abortjob
     &        ('furplm  ', 49,   'Point yp in neighbor cell below     '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,       0)
            elseif(abs(yp00-y(jym)) .gt. yinc1) then
              call abortjob
     &        ('furplm  ', 50,   'New point yp well below range       '
     &        ,'jsurf   ', jsurf,    'kp0     ', kp0,      -1)
            endif
            yp(kp0)  = y(jym) + yinc0
            write(kunit,4120) xp00,yp00,kp0, xp(kp0), kp0, yp(kp0)
     &                                 ,jymm,y (jymm),jym, y (jym )
     &                                 ,jyp, y (jyp ),jypp,y (jypp)
          endif
c
          xp11     = xp(kp0)
          yp11     = yp(kp0)
          if(yp11 .ge. y(jyp)) then
            if    (abs(yp11-y(jyp)) .le. yinc0) then
              call abortjob
     &        ('furplm  ', 51,   'Point yp slightly above range       '
     &        ,'kp0     ', kp0,      'jyp     ', jyp,       0)
            elseif(abs(yp11-y(jyp)) .gt. yinc0  .and.
     &             abs(yp11-y(jyp)) .le. yinc1) then
              call abortjob
     &        ('furplm  ', 52,   'Point yp in neighbor cell above     '
     &        ,'kp0     ', kp0,      'jyp     ', jyp,       0)
            elseif(abs(yp11-y(jyp)) .gt. yinc1) then
              call abortjob
     &        ('furplm  ', 53,   'New point yp well above range       '
     &        ,'kp0     ', kp0,      'jyp     ', jyp,      -1)
            endif
            yp(kp0)  = y(jyp) - yinc0
            write(kunit,4130) xp11,yp11,kp0, xp(kp0), kp0, yp(kp0)
     &                                 ,jymm,y (jymm),jym, y (jym )
     &                                 ,jyp, y (jyp ),jypp,y (jypp)
          endif
c
c 6.4.4 Set directional parameters
c
          if( idntt .eq. 5                        ) i   = i-1
          if((idntt .eq. 7)  .or.  (idntt .eq. 9 )) j   = j-1
c
          if(xp(kp0) .gt. xp(kp0-1)) ilfrt  = 0
          if(xp(kp0) .le. xp(kp0-1)) ilfrt  = 1
          if(yp(kp0) .lt. yp(kp0-1)) iupdn  = 0
          if(yp(kp0) .ge. yp(kp0-1)) iupdn  = 1
c
          if((idntt .eq.  2                     )   .or.
     &       (idntt .eq.  9  .and.  ilfrt .eq. 0)   .or.
     &       (idntt .eq. 12  .and.  ilfrt .eq. 0))   i   = i+1
c
c 6.4.5 Set up next search iteration
c
          if(ilfrt .eq. 0) kdir   = -1
          if(ilfrt .eq. 1) kdir   = +1
        endif
c
c
c 6.5 Error tracing if ktrial < 0
c
        if(ktrial .lt. 0  .or.  mtrack .eq. 1) then
          write(kunit,4200) k,xp(k),yp(k),pvl(ip0,jp0)
     &             ,ip0,jp0,ix,jy,i,j,idnti,idntt,ilfrt,iupdn,kdir
     &             ,icurve,igpopt,ktotent,ktotxit
        endif
c
c
c 6.6 Return to iterate again if the curve is not finished
c
        if    (k .le. 3   .or.    ((abs(xp(k)-xp(1)) .ge. econvg)  .or.
     &                             (abs(yp(k)-yp(1)) .ge. econvg))) then
c
c 6.6.1 Check the curve has not retraced itself before returning
c
          if(k .ge. 3) then
            if((abs(xp(k)-xp(k-2)) .lt.econvg)  .and.
     &         (abs(yp(k)-yp(k-2)) .lt.econvg))  then
c
c 6.6.1.1 Excise the last two points if the curve has retraced itself
              kp       = k
              k        = kp  - 2
              kut      = kut + 1
c
              call abortjob
     &        ('furplm  ', 54,   'Curve retraced itself: excising     '
     &        ,'jsurf   ', jsurf,    'kp      ', kp,        0)
c
c 6.6.1.2 Return if too many points have been excised
              if    (kut .gt. kutmax) then
                ker      = +9
                np       =  k
                call abortjob
     &        ('furplm  ', 55,   'Number points excised > kutmax      '
     &        ,'jsurf   ', jsurf,    'np      ', np,       -1)
                if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,4210)
     &             k,xp(k),yp(k),pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
                return
c
c 6.6.1.3 Reverse search directions if kut is even before returning to
c         search again
              elseif(kut  .le. kutmax) then
                if(kut .eq. 2*(kut/2)) then
                  if    (ilfrt .eq. 0) then
                    ilfrt   = 1
                  elseif(ilfrt .eq. 1) then
                    ilfrt   = 0
                  endif
c
                  if    (iupdn .eq. 0) then
                    iupdn   = 1
                  elseif(iupdn .eq. 1) then
                    iupdn   = 0
                  endif
                  kdir   = -kdir
                endif
              endif
            endif
          endif
c
c 6.6.2 Return to search for the next intersection
c
          go to 200
        endif
c
c
c 6.7 Exit if the number of points exceeds the dimension
c
      elseif(k .ge. npmax) then
c
c 6.7.1 Print a warning and return if k .ge. npmax and npmax = 1
c
        if    (npmax .le. 1) then
          ker      = +10
          np       =  1
          call abortjob
     &        ('furplm  ', 56,   'npmax is set less than one          '
     &        ,'jsurf   ', jsurf,    'npmax   ', npmax,    -1)
          if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,4210)
     &             k,xp(k),yp(k),pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
          return
c
c 6.7.2 Test if curve is looping on separatrix
c
        elseif(npmax .gt. 1) then
c
c 6.7.2.1 Print a warning
          call abortjob
     &        ('furplm  ', 57,   'Number points has exceeded npmax    '
     &        ,'jsurf   ', jsurf,    'k       ', k,        -1)
c
c 6.7.2.2 Check for a pair of points crossing
          krosspt   = 0
          kold      = k
          do 350 k0 = 1,kold - 1
          k0p       = k0
          x1p       = xp(k0p)
          y1p       = yp(k0p)
c
          do 300 k1 = k0p + 1,kold
          k1p       = k1
          if((abs(xp(k1p) - x1p) .le. econvg)  .and.
     &       (abs(yp(k1p) - y1p) .le. econvg))    then
            krosspt  = k1p
            go to 400
          endif
 300      continue
 350      continue
c
 400      continue
c
c 6.7.3 Rerun with diagnostic or return if no crossing point could be found
c 
c 6.7.3.1 Print a message and redo calculation with diagnostic printout
          if    (krosspt .eq. 0) then
            if    (ktrial .ge. 0  .and.  mtrack .eq. 0) then
              call abortjob
     &        ('furplm  ', 58,   'Rerunning search with diagnostic    '
     &        ,'jsurf   ', jsurf,    'kold    ', kold,     -1)
              ktrial  = -1
              go to 100
c
c 6.7.3.2 Return if run was already done with diagnostic output requested
            elseif(ktrial .ge. 0  .and.  mtrack .eq. 1) then
              call abortjob
     &        ('furplm  ', 59,   'Search was run with diagnostic      '
     &        ,'jsurf   ', jsurf,    'kold    ', kold,     -1)
              write(kunit,4210) k,xp(k),yp(k),pvl(ip0,jp0),ip0,jp0
     &             ,ix,jy,i,j,idnti,idntt,ilfrt,iupdn,kdir
     &             ,icurve,igpopt,ktotent,ktotxit
              return
c
c 6.7.3.3 Return if diagnostic was already run
            elseif(ktrial .lt. 0) then
              ker      = +11
              np       =  k
              call abortjob
     &        ('furplm  ', 60,   'Completed diagnostic: returning     '
     &        ,'jsurf   ', jsurf,    'np      ', np,       -1)
              write(kunit,4210) k,xp(k),yp(k),pvl(ip0,jp0),ip0,jp0
     &            ,ix,jy,i,j,idnti,idntt,ilfrt,iupdn,kdir
     &            ,icurve,igpopt,ktotent,ktotxit
              return
            endif
c
c 6.7.4 Remove excess points after curve crossing
c
          elseif(krosspt .ne. 0) then
c
c 6.7.4.1 Remove the excess points
            knew       = k1p - k0p + 1
            do 450 kp  = 1,knew
            kq         = k0p + kp - 1
            gsq(kp)    = gsq(kq)
            xp(kp)     = xp(kq)
            yp(kp)     = yp(kq)
 450        continue
c
c 6.7.4.2 Return with a warning if k .ge. npmax and npmax .ge. 1 and points were
c         successfully excised to close the curve
            ker      = -12
            npold    =  kold
            np       =  knew
            call abortjob
     &        ('furplm  ', 61,   'Excised points after  crossing      '
     &        ,'npold   ', npold,    'np      ', np,       -1)
            if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,4210)
     &             k,xp(k),yp(k),pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
            return
          endif
        endif
      endif
c
c
c
c 7.0 Return and end
c
c 7.1 Return with no error if the curve has finished
c
      if(k .gt. 3   .and.   ((abs(xp(k)-xp(1)) .lt. econvg)  .and.
     &                       (abs(yp(k)-yp(1)) .lt. econvg))) then
        np      = k
c
c
c 7.2 Print a warning before returning if the curve is not converged
c
      else
        ker      = +12
        np       =  k
        call abortjob
     &        ('furplm  ', 62,   'Curve has not completed properly    '
     &        ,'jsurf   ', jsurf,    'np      ', np,       -1)
        if(ktrial .lt. 0  .or.  mtrack .eq. 1) write(kunit,4210)
     &             k,xp(k),yp(k),pvl(ip0,jp0),ip0,jp0,ix,jy,i,j,idnti
     &            ,idntt,ilfrt,iupdn,kdir,icurve,igpopt,ktotent,ktotxit
      endif
c
c
c 7.3 Return
c
      return
c
 1000 format(//,10x,'Furplm Diagnostic run for surface psiv('
     &         ,1x,i6,') = ',e13.6/
     &         ,4x,'k',7x,'xp',12x,'yp',10x,'pvl(ip0,jp0)'
     &         ,3x,'ip0',3x,'jp0',3x,'ix',4x,'jy',5x,'i',5x,'j'
     &         ,3x,'idnti',1x,'idntt',1x,'ilfrt',1x,'iupdn'
     &         ,1x,'kdir',1x,'curve',1x,'igpopt',1x,'totent'
     &         ,1x,'totxit')
 1010 format(/ ,1x,i5,4x,'Exit in initialization:'1x,e13.6,13(1x,i5)
     &         ,7x,'<- Last point',/)
 1020 format(/ ,1x,i5,4x,'Exit in bound checking:'1x,e13.6,13(1x,i5)
     &         ,7x,'<- Last point',/)
 2000 format(   2x,'Moving left-right: ilfrt = ',i2,2x,'kdir  = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2(orig) = ',i1
     &         ,1x,'kentrp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1(orig) = ',i1
     &         ,1x,'kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1(orig) = ',i1
     &         ,1x,'kentrp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6)
 2010 format(/ ,1x,i5,4x,'Exit in point search  :'1x,e13.6,15(1x,i5)
     &         ,1x,'<- Last point',/)
 2020 format(   2x,'Moving left-right: ilfrt = ',i2,2x,'kdir  = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg1 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp1 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg2 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp2 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg3 = ',i1)
 2030 format(   2x,'Moving left-right: ilfrt = ',i2,2x,'kdir  = ',i2
     &         ,2x,'kmtype = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2(orig) = ',i1
     &         ,1x,'kentrp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1(orig) = ',i1
     &         ,1x,'kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1(orig) = ',i1
     &         ,1x,'kentrp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg1(orig) = ',i1
     &         ,1x,'kexitg1 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp1(orig) = ',i1
     &         ,1x,'kexitp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg2(orig) = ',i1
     &         ,1x,'kexitg2 = ',i1
     &       ,/,2x,'Other exit  point flag: kexitp2(orig) = ',i1
     &         ,1x,'kexitp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg3(orig) = ',i1
     &         ,1x,'kexitg3 = ',i1)
 2100 format(   2x,'Moving   up-down : iupdn = ',i2,2x,'kdir  = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2(orig) = ',i1
     &         ,1x,'kentrp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1(orig) = ',i1
     &         ,1x,'kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1(orig) = ',i1
     &         ,1x,'kentrp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6)
 2110 format(/ ,1x,i5,4x,'Exit in point location:'1x,e13.6,15(1x,i5)
     &         ,1x,'<- Last point',/)
 2120 format(   2x,'Moving   up-down : iupdn = ',i2,2x,'kdir  = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg1 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp1 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg2 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp2 = ',i1,':'
     &         ,2x,'psarray(',i5,',',i5,') = ',e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg3 = ',i1)
 2130 format(   2x,'Moving   up-down : iupdn = ',i2,2x,'kdir  = ',i2
     &         ,2x,'kmtype = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2(orig) = ',i1
     &         ,1x,'kentrp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1(orig) = ',i1
     &         ,1x,'kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1(orig) = ',i1
     &         ,1x,'kentrp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg1(orig) = ',i1
     &         ,1x,'kexitg1 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp1(orig) = ',i1
     &         ,1x,'kexitp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg2(orig) = ',i1
     &         ,1x,'kexitg2 = ',i1
     &       ,/,2x,'Other exit  point flag: kexitp2(orig) = ',i1
     &         ,1x,'kexitp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg3(orig) = ',i1
     &         ,1x,'kexitg3 = ',i1)
 3000 format(/ ,1x,i5,4x,'Exit in point location:'1x,e13.6,15(1x,i5)
     &         ,1x,'<- Last point',/)
 3100 format(   2x,'Moving left-right: ilfrt = ',i2,2x,'kdir  = ',i2
     &         ,2x,'kmtype = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2(orig) = ',i1
     &         ,1x,'kentrp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1(orig) = ',i1
     &         ,1x,'kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1(orig) = ',i1
     &         ,1x,'kentrp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg1(orig) = ',i1
     &         ,1x,'kexitg1 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp1(orig) = ',i1
     &         ,1x,'kexitp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg2(orig) = ',i1
     &         ,1x,'kexitg2 = ',i1
     &       ,/,2x,'Other exit  point flag: kexitp2(orig) = ',i1
     &         ,1x,'kexitp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg3(orig) = ',i1
     &         ,1x,'kexitg3 = ',i1)
 3110 format(   2x,'Moving   up-down : iupdn = ',i2,2x,'kdir  = ',i2
     &         ,2x,'kmtype = ',i2
     &         ,2x,'for surface psiv(',i5,') = ',e13.6
     &       ,/,2x,'Other entry point flag: kentrp2(orig) = ',i1
     &         ,1x,'kentrp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid entry  line  flag: kentrg1(orig) = ',i1
     &         ,1x,'kentrg1 = ',i1
     &       ,/,2x,'Base  entry point flag: kentrp1(orig) = ',i1
     &         ,1x,'kentrp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg1(orig) = ',i1
     &         ,1x,'kexitg1 = ',i1
     &       ,/,2x,'Base  exit  point flag: kexitp1(orig) = ',i1
     &         ,1x,'kexitp1 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg2(orig) = ',i1
     &         ,1x,'kexitg2 = ',i1
     &       ,/,2x,'Other exit  point flag: kexitp2(orig) = ',i1
     &         ,1x,'kexitp2 = ',i1,':',2x,'psarray(',i5,',',i5,') = '
     &         ,e13.6
     &       ,/,2x,'Grid  exit line   flag: kexitg3(orig) = ',i1
     &         ,1x,'kexitg3 = ',i1)
 4000 format(   1x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &        ,13x,'icflg  = ',i5
     &       ,/,2x,'pdif   = ',e16.9,2x,'compr  = ',e16.9)
 4010 format(   1x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &        ,13x,'icflg  = ',i5
     &       ,/,1x,'xg1    = ',e16.9,2x,'xg2    = ',e16.9
     &         ,2x,'xg3    = ',e16.9,2x,'xg4    = ',e16.9
     &       ,/,1x,'xinp   = ',e16.9,2x,'xs     = ',e16.9
     &       ,/,1x,'p1y0   = ',e16.9,2x,'p2y0   = ',e16.9
     &         ,2x,'p3y0   = ',e16.9,2x,'p4y0   = ',e16.9
     &       ,/,1x,'pinp   = ',e16.9,2x,'ps     = ',e16.9
     &         ,2x,'pq     = ',e16.9,2x,'pdif   = ',e16.9
     &         ,2x,'compr  = ',e16.9)
 4020 format(   1x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &        ,13x,'icflg  = ',i5
     &       ,/,2x,'pdif   = ',e16.9,2x,'compr  = ',e16.9)
 4030 format(   1x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &        ,13x,'icflg  = ',i5
     &       ,/,1x,'yg1    = ',e16.9,2x,'yg2    = ',e16.9
     &         ,2x,'yg3    = ',e16.9,2x,'yg4    = ',e16.9
     &       ,/,1x,'yinp   = ',e16.9,2x,'ys     = ',e16.9
     &       ,/,1x,'p1x0   = ',e16.9,2x,'p2x0   = ',e16.9
     &         ,2x,'p3x0   = ',e16.9,2x,'p4x0   = ',e16.9
     &       ,/,1x,'pinp   = ',e16.9,2x,'ps     = ',e16.9
     &         ,2x,'pq     = ',e16.9,2x,'pdif   = ',e16.9
     &         ,2x,'compr  = ',e16.9)
 4100 format(  10x,'Original point:'
     &         ,1x,'xp00      = ',e16.9,2x,'yp00      = ',e16.9
     &      ,/,10x,'New      point:'
     &         ,1x,'xp(',i5,') = ',e16.9,2x,'yp(',i5,') = ',e16.9
     &      ,/,10x,'x (',i5,') = ',e16.9,2x,'x (',i5,') = ',e16.9
     &         ,2x,'x (',i5,') = ',e16.9,2x,'x (',i5,') = ',e16.9,/)
 4110 format(  10x,'Original point:'
     &         ,1x,'xp11      = ',e16.9,2x,'yp11      = ',e16.9
     &      ,/,10x,'New      point:'
     &         ,1x,'xp(',i5,') = ',e16.9,2x,'yp(',i5,') = ',e16.9
     &      ,/,10x,'x (',i5,') = ',e16.9,2x,'x (',i5,') = ',e16.9
     &         ,2x,'x (',i5,') = ',e16.9,2x,'x (',i5,') = ',e16.9,/)
 4120 format(  10x,'Original point:'
     &         ,1x,'xp00      = ',e16.9,2x,'yp00      = ',e16.9
     &      ,/,10x,'New      point:'
     &         ,1x,'xp(',i5,') = ',e16.9,2x,'yp(',i5,') = ',e16.9
     &      ,/,10x,'y (',i5,') = ',e16.9,2x,'y (',i5,') = ',e16.9
     &         ,2x,'y (',i5,') = ',e16.9,2x,'y (',i5,') = ',e16.9,/)
 4130 format(  10x,'Original point:'
     &         ,1x,'xp11      = ',e16.9,2x,'yp11      = ',e16.9
     &      ,/,10x,'New      point:'
     &         ,1x,'xp(',i5,') = ',e16.9,2x,'yp(',i5,') = ',e16.9
     &      ,/,10x,'y (',i5,') = ',e16.9,2x,'y (',i5,') = ',e16.9
     &         ,2x,'y (',i5,') = ',e16.9,2x,'y (',i5,') = ',e16.9,/)
 4200 format(   1x,i5,3(1x,e13.6),15(1x,i5))
 4210 format(/, 1x,i5,3(1x,e13.6),15(1x,i5)
     &         ,1x,'<- Last point',/)
      end
      subroutine fit(kopt,x1,x2,x3,x4,y1,y2,y3,y4,xin,yin
     &              ,xval,yval,ypval,ipmax,imax,critp,crit0
     &              ,kunit,iwarn,ier,icflag)
c
c --------------------------------------------
c For kopt   = 1  find yval(xin) and ypval(xin) with xin as input
c For kopt   = 2  find xval(yin) from Newtons Method iteration
c                 and ypval(xval) with yin as input and a starting
c                 guess xin
c --------------------------------------------
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize error flags
c
      iwarn    =  0
      ier      =  0
      icflag   = -1
c
c
c 1.2 Initialize iteration input
c
      iterpmax = ipmax
      itermax  = imax
c
c
c 1.3 Initialize coordinate increments
c
      dx1x2    = (x1-x2)
      dx1x3    = (x1-x3)
      dx1x4    = (x1-x4)
      dx2x3    = (x2-x3)
      dx2x4    = (x2-x4)
      dx3x4    = (x3-x4)
c
c
c 1.4 Check that x1, x2, x3, and x4 are ordered
c
c 1.4.1 Check non of the intervals vanish
c
      if(dx1x2*dx2x3*dx3x4 .eq. 0.0) then
         if(dx1x2       .eq. 0.0) ier  = -1
         if(dx2x3       .eq. 0.0) ier  = -2
         if(dx3x4       .eq. 0.0) ier  = -3
         xval     = xin
         yval     = yin
         ypval    = 0.0
         return
      endif
c
c 1.4.2 Check the ordering
c
      if(dx1x2*dx2x3 .lt. 0.0  .or.  dx2x3*dx3x4 .lt. 0.0) then
         if(dx1x2*dx2x3 .lt. 0.0)      iwarn  = +1
         if(dx2x3*dx3x4 .lt. 0.0)      iwarn  = +2
         if(dx1x2*dx2x3 .lt. 0.0  .and.  
     &      dx2x3*dx3x4 .lt. 0.0)      iwarn  = +3
      endif
c
c
c 1.5 Initialize fitting coefficients
c     
      c1       = +y1/(dx1x2*dx1x3*dx1x4)
      c2       = -y2/(dx1x2*dx2x3*dx2x4)
      c3       = +y3/(dx1x3*dx2x3*dx3x4)
      c4       = -y4/(dx1x4*dx2x4*dx3x4)
c
c
c
c 2.0 Find y(x) by collocation
c
      if(kopt .eq. 1) then
c
c 2.1 Set the x value
c
         x        =  xin
c
c
c 2.2 Collocation coefficients
c
         d1       =  x - x1
         d2       =  x - x2
         d3       =  x - x3
         d4       =  x - x4
c
         d12      = d1*d2
         d13      = d1*d3
         d14      = d1*d4
         d23      = d2*d3
         d24      = d2*d4
         d34      = d3*d4
c
c
c 2.3 Construct the function value
c
         fx       = (c1*d23 + c2*d13 + c3*d12)*d4  +  c4*d12*d3
         yp       =  c1*(d23 + d24 + d34)  +
     &               c2*(d13 + d14 + d34)  +
     &               c3*(d12 + d14 + d24)  +
     &               c4*(d12 + d13 + d23)
c
c
c 2.4 Set the function value and return
c
         xval     = xin
         yval     = fx
         ypval    = yp
         return
      endif
c
c
c
c 3.0 Find x(y) by Newtons Method
c
      if(kopt .eq. 2) then
c
c 3.1 Set the y value from input and initialize x
c
         x        = xin
         y        = yin
         yp       = 0.0
c
c
c 3.2 Check that y is in range
c
         if    (y .lt. amin1(y1,y2,y3,y4))  then
            ier      = +1
            xval     = xin
            yval     = yin
            ypval    = 0.0
            return
         elseif(y .gt. amax1(y1,y2,y3,y4))   then
            ier      = +2
            xval     = xin
            yval     = yin
            ypval    = 0.0
            return
         endif
c
c
c 3.3 Find the cell the initial point x is in
c     The sequence x1,x2,x3,x4 is assumed to be monotonic so xin can be
c     in only one interval
c     The sequence y1,y2,y3,y4 can be nonmonotonic so yin may be in multiple
c     intervals.  If xin and yin are in a consistent interval then the iteration
c     for x(yin) is initiated from xin.  Otherwise xin is ignored and the
c     iteration is initiated from the midpoint of the correct interval if only
c     one interval exists.  If the interval is nonunique an error is returned.
c
c 3.3.1 Check the first interval
c
         if    ((x-x1)*(x-x2) .lt. 0.0) then
            xa      = x1
            ya      = y1
            xb      = x2
            yb      = y2
            intvalx = 1
         elseif((x-x1) .eq. 0.0)        then
            xa      = x2
            ya      = y2
            xb      = x3
            yb      = y3
            intvalx = 2
c
c 3.3.2 Check the middle interval
c
         elseif((x-x2)*(x-x3) .lt. 0.0) then
            xa      = x2
            ya      = y2
            xb      = x3
            yb      = y3
            intvalx = 3
         elseif((x-x2) .eq. 0.0)        then
            xa      = x2
            ya      = y2
            xb      = x3
            yb      = y3
            intvalx = 4
         elseif((x-x3) .eq. 0.0)        then
            xa      = x2
            ya      = y2
            xb      = x3
            yb      = y3
            intvalx = 5
c
c 3.3.3 Check the last interval
c
         elseif((x-x3)*(x-x4) .lt. 0.0) then
            xa      = x3
            ya      = y3
            xb      = x4
            yb      = y4
            intvalx = 6
         elseif((x-x4) .eq. 0.0)        then
            xa      = x2
            ya      = y2
            xb      = x3
            yb      = y3
            intvalx = 7
c
c 3.3.4 Flag a warning if the initial guess is not in any interval
c       and reset the guess at the midpoint of the middle interval
c
         else
            iwarn   = +4
            xa      = x2
            ya      = y2
            xb      = x3
            yb      = y3
            intvalx = 8
         endif
c
c 3.3.5 Shift the guess to the middle of the interval if the initial guess
c       is on the grid point and the y value is in the right range
c
         if((y-ya)*(y-yb) .lt. 0.0) then
            if(intvalx .eq. 2  .or.  intvalx .eq. 4  .or.
     &         intvalx .eq. 5  .or.  intvalx .eq. 7  .or.
     &                               intvalx .eq. 8) 
     &         x  = (xa + xb)/2.0
         endif
c
c
c 3.4 Account for cases when y is not in the range set by the input xin
c     Choose a new guess in the correct range and ignore the original guess
c
         if((y-ya)*(y-yb) .ge. 0.0) then
c
c 3.4.1 Count the number of possible solutions
c
            nintval  = 0
            intval1  = 0
            intval2  = 0
            intval3  = 0
            intval4  = 0
            intval5  = 0
            intval6  = 0
            intval7  = 0
c
            if(y .eq. y1)              then
               intval1  = 1
               nintval  = nintval + 1
            endif
            if(y .eq. y2)              then
               intval2  = 1
               nintval  = nintval + 1
            endif
            if(y .eq. y3)              then
               intval3  = 1
               nintval  = nintval + 1
            endif
            if(y .eq. y4)              then
               intval4  = 1
               nintval  = nintval + 1
            endif
            if((y-y1)*(y-y2) .lt. 0.0) then
               intval5  = 1
               nintval  = nintval + 1
            endif
            if((y-y2)*(y-y3) .lt. 0.0) then
               intval6  = 1
               nintval  = nintval + 1
            endif
            if((y-y3)*(y-y4) .lt. 0.0) then
               intval7  = 1
               nintval  = nintval + 1
            endif
c
c 3.4.2 Reset the guess x in the correct range if there is a unique solution
c
            if(nintval .eq. 1) then
               iwarn    = +5
               if(intval1 .eq. 1) then
                  xa       = x1
                  ya       = y1
                  xb       = x2
                  yb       = y2
                  x        = x1
               endif
               if(intval2 .eq. 1) then
                  xa       = x2
                  ya       = y2
                  xb       = x3
                  yb       = y3
                  x        = x2
               endif
               if(intval3 .eq. 1) then
                  xa       = x2
                  ya       = y2
                  xb       = x3
                  yb       = y3
                  x        = x3
               endif
               if(intval4 .eq. 1) then
                  xa       = x3
                  ya       = y3
                  xb       = x4
                  yb       = y4
                  x        = x4
                endif
               if(intval5 .eq. 1) then
                  xa       = x1
                  ya       = y1
                  xb       = x2
                  yb       = y2
                  x        = (xa+xb)/2.0
               endif
               if(intval6 .eq. 1) then
                  xa       = x2
                  ya       = y2
                  xb       = x3
                  yb       = y3
                  x        = (xa+xb)/2.0
               endif
               if(intval7 .eq. 1) then
                  xa       = x3
                  ya       = y3
                  xb       = x4
                  yb       = y4
                  x        = (xa+xb)/2.0
               endif
c
c 3.4.3 Return if there is no solution
c
            elseif(nintval .eq. 0) then
               ier      = +3
               xval     = xin
               yval     = yin
               ypval    = 0.0
               return
c
c 3.4.4 Return if there is no unique solution
c
            elseif(nintval .gt. 1) then
               ier      = +4
               xval     = xin
               yval     = yin
               ypval    = 0.0
               return
            endif
         endif
c
c
c 3.5 Initialize Newton iteration
c
         icflag   = 0
         iter     = 0
         crit     = crit0*(abs(y1) + abs(y2) + abs(y3) + abs(y4))
c
 100     iter     =  iter  + 1
c
            isetp    = 0
            iterp    = 0
 110        iterp    =  iterp + 1
               d1       =  x - x1
               d2       =  x - x2
               d3       =  x - x3
               d4       =  x - x4
               d12      = d1*d2
               d13      = d1*d3
               d14      = d1*d4
               d23      = d2*d3
               d24      = d2*d4
               d34      = d3*d4
               fx       = (c1*d23 + c2*d13 + c3*d12)*d4  +  c4*d12*d3
               yp       =  c1*(d23 + d24 + d34)  +
     &                     c2*(d13 + d14 + d34)  +
     &                     c3*(d12 + d14 + d24)  +
     &                     c4*(d12 + d13 + d23)
c
c
c 3.6 Check the derivative
c
c 3.6.1 Set the derivative and reset the new xa or xb at the current x
c
c 3.6.1.1 Calculate the derivative from the current interval
               dybdx    = (yb-ya)/(xb-xa)
c
c 3.6.1.2 Reset the interval
               if    ((fx-y)*(ya-y) .ge. 0.0) then
                  xa       = x
                  ya       = fx
               elseif((fx-y)*(ya-y) .lt. 0.0) then
                  xb       = x
                  yb       = fx
               endif
c
c 3.6.2 Check convergence of the derivative
c       If derivative is not close enough then use bisection subiteration to
c       reset x at the midpoint of the interval instead of Newton iteration
c
               if(isetp .eq. 0) then
c
c 3.6.2.1 Reset x from bisection if derivative not converged
                  if    (abs(yp-dybdx) .ge. critp*abs(yp)) then
                     x        = (xa + xb)/2.0
c
c 3.6.2.2 Return to iterate bisection again
                     if    (iterp .lt. iterpmax) then
                        go to 110
c
c 3.6.2.3 Continue with Newton iteration if bisection iteration limit is reached
                     elseif(iterp .ge. iterpmax) then
                        icflag   = icflag + 1
                        isetp    = 1
                     endif
c
c 3.6.2.4 Continue with Newton iteration if derivative is sufficiently converged
                  elseif(abs(yp-dybdx) .lt. critp*abs(yp)) then
                     isetp    = 1
                  endif
               endif
c
c
c 3.7 Newtons method estimate for x(y)
c
            if(isetp .eq. 1) then
               dybdx    = (yb-ya)/(xb-xa)
               if(abs(yp-dybdx) .lt. critp*abs(yp)) dybdx    = yp
               x        = x  -  (fx - y)/dybdx
c
c 3.7.2 Check convergence of the Newton Method
c
               if(abs(fx - y) .lt. crit) then
c
c 3.7.2.1 Check if the bisection iterations failed at some point and set
c         a warning flag accordingly
                  if(icflag .ne. 0) then
                     if(iwarn .eq. 0) then
                        iwarn  = +6
                     else
                        iwarn  = -iwarn
                     endif
                  endif
c
c 3.7.2.2 Return with final result
                  xval     = x
                  yval     = fx
                  ypval    = yp
                  return
               endif
c
c
c 3.8 Check the number of iterations if not yet converged 
c
c 3.8.1 Continue iterating Newton Method
c
               if    (iter .lt. itermax) then
                  go to 100
c
c 3.8.2 Return with an error flag if number of Newton iterations reached
               elseif(iter .ge. itermax) then
c
c 3.8.2.1 Set the warning flag if the bisection iterations failed earlier
                  if(icflag .ne. 0) then
                     if(iwarn .eq. 0) then
                        iwarn  = +7
                     else
                        iwarn  = -iwarn
                     endif
                  endif
c
c 3.8.2.2 Set the error flag if the Newton iterations only failed
                  ier  = +5
c
c 3.8.2.3 Return with result 
                  xval     = x
                  yval     = fx
                  ypval    = yp
                  return
               endif
            endif
c
c
c 3.9 Set the flag in case of a failure in logic
c
            ier      = +6
            xval     = x
            yval     = fx
            ypval    = yp
            return
      endif
      end
      subroutine garea(tstart,tstop,th,rh,cspl,ncp,npmax,ifl,are)
c
c -----------------------------------------------------------------
c     gaussian quadrature constants for the interval 0 to 1.
c -----------------------------------------------------------------
c
      dimension th(npmax),rh(npmax),cspl(3,npmax)
      dimension yg(4),wg(4)
c
      data ngaus/4/
      data yg/ 0.069431844202974, 0.330009478207572,
     1         0.669990521792428, 0.930568155797027/
      data wg/ 0.173927422568727, 0.326072577431273,
     1         0.326072577431273, 0.173927422568727/
c
c     gaussian quadrature of (cubic spline) squared  (3 pt)
c     defined for interval (0,1)
c     ifl=1  integrate r(theta)**2
c     ifl=2  integrate sqrt(r**2+(dr/dtheta)**2)
c     ifl=3  integrate 1/grad(chi)
c
c
c
c 1.0 Search for first and last points in th
c
      do 10 i = 1,ncp
      iks     = i
      if(tstart .lt. th(iks)) go to 20
   10 continue
      iks     = ncp
c
   20 istart  = iks-1
      do 30 i = istart,ncp
      ikf     = i
      if(tstop .le. th(ikf)) go to 40
   30 continue
      ikf     = ncp
c
c
c
c 2.0 Initialize the loop over intervals from tstart to tstop
c
   40 continue
      istop   = ikf
c
      are     = 0.0
      is      = istart
      ts      = tstart
      tf      = amin1(tstop,th(is+1))
c
c
c
c 3.0 Perform the Gaussian integration
c
c 3.1 Set up the 3 gaussian quadrature points
c     integrate the interval from tstart to th(istart+1)
c
   45 continue
         delta   = tf - ts
         sum     = 0.0
         do 50 i = 1,ngaus
         yq      = ts + yg(i)*delta - th(is)
         ws      = ((cspl(3,is)*yq + cspl(2,is))*yq + cspl(1,is))*yq
     &                             +  rh(is)
c
         if(ifl .eq. 1) then
           wsum    = ws*ws
         elseif(ifl .eq. 2) then
           ws1     = (3.0*cspl(3,is)*yq + 2.0*cspl(2,is))*yq +
     &                                        cspl(1,is)
           wsum    = sqrt(ws*ws + ws1*ws1)
         elseif(ifl .eq. 3) then
           wsum    = ws
         endif
c
         sum     = sum + wsum*wg(i)
   50    continue
c
c
c 3.2 Add this contribution to the integral and increment the
c     index for the next interval
c
         sum     = sum*delta
         are     = are + sum
         is      = is+1
         if(is .lt. istop) then
           ts      = th(is)
           tf      = amin1(tstop,th(is+1))
           go to 45
         endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine garc(tp,xp,zp,csx,csz,arc,npc,npmax,gnm)
c
c ----------------------------------------------------------
c Gaussian quadrature for the interval from 0 to 1:
c This routine uses a four point gaussian quadrature to compute the
c integral of sqrt((dx/dt)**2 + gnm*(dz/dt)**2) with respect to t
c around the curve.
c ----------------------------------------------------------
c
      dimension tp(npc),xp(npc),zp(npc),arc(npc)
      dimension csx(3,npmax),csz(3,npmax)
      dimension yg(4),wg(4)
c
      data ngaus/4/
      data yg/ 0.069431844202974, 0.330009478207572,
     1         0.669990521792428, 0.930568155797027/
      data wg/ 0.173927422568727, 0.326072577431273,
     1         0.326072577431273, 0.173927422568727/
c
c
      arc(1)  = 0.0
      el      = 0.0
      do 20 j = 2,npc
      is      = j-1
      sum     = 0.0
      delta   = tp(j) - tp(is)
c
      do 10 i = 1,ngaus
      yq      = yg(i)*delta
      ws1     = (3.0*csx(3,is)*yq + 2.0*csx(2,is))*yq  +  csx(1,is)
      ws2     = (3.0*csz(3,is)*yq + 2.0*csz(2,is))*yq  +  csz(1,is)
      ws      = sqrt(ws1*ws1 + gnm*ws2*ws2)
      sum     = sum + ws*wg(i)
   10 continue
c
      el      = el + sum*delta
      arc(j)  = el
   20 continue
c
      return
      end
      subroutine garcq(x,f,cs,np,npmax,ans)
c
c ----------------------------------------------------------
c gaussian quadrature constants for the interval from 0 to 1
c this routine calculates the integral of f with respect to x by
c gaussian quadrature.
c ----------------------------------------------------------
c
      dimension x(npmax),f(npmax),cs(3,npmax)
      dimension yg(4),wg(4)
c
      data ngaus/4/
      data yg/ 0.069431844202974, 0.330009478207572,
     1         0.669990521792428, 0.930568155797027/
      data wg/ 0.173927422568727, 0.326072577431273,
     1         0.326072577431273, 0.173927422568727/
c
c
      ans     = 0.0
      do 20 j = 2,np
      is      = j-1
      sum     = 0.0
      delta   = x(j)-x(is)
c
      do 10 i = 1,ngaus
      yq      = yg(i)*delta
      ws      = ((cs(3,is)*yq + cs(2,is))*yq + cs(1,is))*yq + f(is)
      sum     = sum + ws*wg(i)
   10 continue
c
      ans     = ans + sum*delta
   20 continue
c
      return
      end
      subroutine getgsqm(p,grsq,nx,ny,dx,dy,nww,nhh,gpx,gpy)
c
c--------------------------------------------------------------------
c this routine calculates (grad(psi))**2 at each grid point
c-----------------------------------------------------------------------
c
      dimension grsq(nww,nhh),p(nww,nhh),gpx(nww,nhh),gpy(nww,nhh)
c
c
      fx  (psr,psl)          = (psr-psl)/(2.0*dx)
      fy  (psu,psl)          = (psu-psl)/(2.0*dy)
      fxe (psr,psl)          = (psr-psl)/dx
      fye (psu,psl)          = (psu-psl)/dy
      fxll(ps1,ps2,ps3,ps4)  = (ps1 - 8.0*ps2 + 8.0*ps3 - ps4) /
     &                                                    (12.0*dx)
      fyll(ps1,ps2,ps3,ps4)  = (ps1 - 8.0*ps2 + 8.0*ps3 - ps4) /
     &                                                    (12.0*dy)
c
c
c
c 1.0 Initialization
c
      nx1     = nx-1
      ny1     = ny-1
      nx2     = nx-2
      ny2     = ny-2
c
c
c
c 2.0 Calculate partial derivatives
c
c 2.1 Calculate derivative with respect to y
c
c 2.1.1 Calculate internal values
c
      do 20 ix    = 1,nx
      do 10 iy    = 3,ny2
      gpy(ix,iy)  = fyll(p(ix,iy-2),p(ix,iy-1),p(ix,iy+1),p(ix,iy+2))
   10 continue
   20 continue
c
c 2.1.2 Calculate boundary values
c
      do 30 ix    = 1,nx
      gpy(ix,1)   = fye(p(ix, 2),p(ix,  1))
      gpy(ix,2)   = fy (p(ix, 3),p(ix,  1))
      gpy(ix,ny1) = fy (p(ix,ny),p(ix,ny2))
      gpy(ix,ny)  = fye(p(ix,ny),p(ix,ny1))
   30 continue
c
c
c 2.2 Calculate derivative w/respect to x
c
c 2.2.1 Calculate internal values
c
      do 50 ix    = 3,nx2
      do 40 iy    = 1,ny
      gpx(ix,iy)  = fxll(p(ix-2,iy),p(ix-1,iy),p(ix+1,iy),p(ix+2,iy))
   40 continue
   50 continue
c
c 2.2.2 Calculate boundary values
c
      do 60 iy    = 1,ny
      gpx(1,iy)   = fxe(p( 2,iy),p( 1 ,iy))
      gpx(2,iy)   = fx (p( 3,iy),p( 1 ,iy))
      gpx(nx1,iy) = fx (p(nx,iy),p(nx2,iy))
      gpx(nx,iy)  = fxe(p(nx,iy),p(nx1,iy))
   60 continue
c
c
c
c 3.0 Calculate grsq
c
      do 200 ix    = 1,nx
      do 100 iy    = 1,ny
      grsq(ix,iy)  = gpx(ix,iy)*gpx(ix,iy)+gpy(ix,iy)*gpy(ix,iy)
  100 continue
  200 continue
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delyi,is0,js0,x1,y1,a1,b1,c1,d1,
     &               a2,a3,a4,a5,ier)
c
c -----------------------------------------------------------
c
c  Calculate coefficients for a local bicubic collocation around
c    initial point (x1,y1) from grid points centered around (is,js)
c
c Input:  xw(i=1,nw):              r array
c         yh(j=1,nh):              z array
c         psarray(i=1,nw,j=1,nhd): psi array
c         nwd:                     First dimension of psarray
c         NHD:                     Second dimension of psarray
c         pslim:                   Boundary psi value (required with ipg)
c         ipg:                     Profile option for p,f or p',ff'
c         delxi:                   Radial scale for dimensionless conversion
c         delyi:                   Axial  scale for dimensionless conversion
c         is0:                     Initial  radial  mesh cell index nearest x1 
c         js0:                     Initial vertical mesh cell index nearest y1
c         x1:                      Radial   point around which expansion is made
c         y1:                      Vertical point around which expansion is made
c Output: is0:                     Final  radial  mesh cell index nearest x1 
c         js0:                     Final vertical mesh cell index nearest y1 
c         a1...a5:                 Collocation coefficients
c         b1,c1,d1:                Collocation coefficients
c         ier:                     Error flag             
c
c -----------------------------------------------------------
c
      dimension xw(nw),yh(nh),psarray(nwd,nhd)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize error flags
c
      ier     = 0
c
c
c 1.2 Check for uninitialized input
c
c 1.2.1 Check for zero step size
c
      if(delxi .eq. 0.0  .or.   delyi .eq. 0.0) then
        if(delxi .eq. 0.0) ier   = +1
        if(delyi .eq. 0.0) ier   = +2
        if(delxi .eq. 0.0  .and.  delyi .eq. 0.0) ier   = +3
        return
      endif
c
c 1.2.2 Check for uninitialized search index
c
      if(is0 .lt.  1) then
        ier     = -1
        is0     = +1
      endif
c
      if(is0 .gt. nw) then
        ier     = -2
        is0     = +nw
      endif
c
      if(js0 .lt.  1) then
        ier     = -3
        js0     = +1
      endif
c
      if(js0 .gt. nh) then
        ier     = -4
        js0     = +nh
      endif
c
c
c
c 2.0 Search procedure for location of point
c
c 2.1 search for nearest x grid point
c
      is      = is0
c
   10 continue
      if(xw( is ) .le. x1) then
        if    (is .lt. nw) then
          is      = is+1
          go to 10
        elseif(is .ge. nw) then
          ier     = -5
          return
        endif
      endif
c
   20 continue
      if    ( is .gt. 1) then
        if(xw(is-1) .ge. x1) then
          is      = is-1
          go to 20
        endif
      elseif(is .le.  1) then
        ier     = -6
        return
      endif
c
c
c 2.2 Search for nearest y grid point
c
      js      = js0
   30 continue
      if(yh( js ) .le. y1) then
        if    (js .lt. nh) then
          js     = js+1
          go to 30
        elseif(js .ge. nh) then
          ier   = -7
          return
        endif
      endif
c
   40 continue
      if    (js .gt. 1) then
        if(yh(js-1) .ge. y1) then
          js     = js-1
          go to 40
        endif
      elseif(js .le.  1) then
        ier   = -8
        return
      endif
c
c
c 2.3 Reset the nearest grid point value for this and the subsequent search
c
      is      = is-1
      js      = js-1
      is0     = is
      js0     = js
c
c
c 2.4 Define the nearest grid point
c
      xpt     = (x1-xw(is))*delxi
      ypt     = (y1-yh(js))*delyi
c
c
c
c 3.0 Calculate interpolation coefficients
c
c 3.1 Construct coefficients for a free boundary equilibrium
c
      a11     =     ypt    *(ypt - 1.0)/6.0
      a12     = (2.0 - ypt)*(1.0 + ypt)/2.0
      a21     =     xpt    *(xpt - 1.0)/6.0
      a31     = (2.0 - xpt)*(1.0 + xpt)/2.0
c
      a1      = a11*(ypt - 2.0)
      b1      = a12*(1.0 - ypt)
      c1      = a12*ypt
      d1      = a11*(ypt + 1.0)
c
      a2      = a21*(xpt - 2.0)
      a3      = a31*(1.0 - xpt)
      a4      = a31*xpt
      a5      = a21*(1.0 + xpt)
c
c
c 3.2 Reset coefficients outside boundary for fixed boundary equilibirum
c
      if(ipg .ge. 4) then
        if((psarray(is-1,js-1) .gt. pslim)  .or.
     &     (psarray(is+1,js-1) .gt. pslim)  .or.
     &     (psarray(is+1,js+2) .gt. pslim)  .or.
     &     (psarray(is-1,js+2) .gt. pslim)) then
          a11  = 0.0
          a12  = 0.0
          a1   = 0.0
          b1   = 1.0 - ypt
          c1   = ypt
          d1   = 0.0
c
          a21  = 0.0
          a31  = 0.0
          a2   = 0.0
          a3   = 1.0 - xpt
          a4   = xpt
          a5   = 0.0
        endif
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine magax(x,nw,y,nh,cspln,nw1,nh1,xaxs,yaxs,psiaxs
     &                ,newtit,erconv)
c
c-------------------------------------------------------------------
c
c     use xaxs and yaxs as initial guess for newtons method to get
c     a more accurate value of psiaxs and the axis location (xaxs,yaxs)
c     This is sometimes necessary when the eqdsk parameters are inaccurate
c
c-------------------------------------------------------------------
c
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
      dimension pds(6),cspln(2,nw1,2*nh1),x(nw),y(nh)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize the range for the search
c
      xminn    = x(1)
      xmaxx    = x(nw)
      yminn    = y(1)
      ymaxx    = y(nh)
      xminr    =     (xmaxx - xminn)
      xmidpt   = 0.5*(xmaxx + xminn)
      yminr    =     (ymaxx - yminn)
      ymidpt   = 0.5*(ymaxx + yminn)
c
c
c 1.2 Initialize error tolerance
c
      erfatl   = sqrt(abs(erconv))
c
c
c 1.3 Set data from input
c
c 1.3.1 Set defaults
      newtn    = newtit
      xaxs0    = xaxs
      yaxs0    = yaxs
      psiaxs0  = psiaxs
c
c 1.3.2 Check input is valid
c
      if(xaxs0 .lt. xminn  .or.  xaxs0 .gt. xmaxx) then
        call abortjob
     &        ('magax   ',  1,   'Initial xaxs0 is outside mesh       '
     &        ,'nw      ', nw,       'nh      ', nh,       -1)
        xaxs0    = xmidpt
      endif
c
      if(yaxs0 .lt. yminn  .or.  yaxs0 .gt. ymaxx) then
        call abortjob
     &        ('magax   ',  2,   'Initial yaxs0 is outside mesh       '
     &        ,'nw      ', nw,       'nh      ', nh,       -1)
        yaxs0    = ymidpt
      endif
c
      if(newtit .lt. 1) then
        newtn    = 1
        call abortjob
     &        ('magax   ',  3,   'Input newtit=0: reset newtn=1       '
     &        ,'newtit  ', newtit,   'newtn   ', newtn,    -1)
      endif
c
c
c
c 2.0 Newtons iteration
c
c 2.1 Set up starting point
c
c 2.1.1 Start from the initial axis position
c
      xs       = xaxs0
      ys       = yaxs0
      psivl    = psiaxs0
c
c 2.1.2 Initialize reset direction
c
      nksign   = +1
      mksign   = +1
c
c
c 2.2 Iterate using Newtons Method
c
      do 100 n = 1,newtn
      niter    = n
c
c 2.2.1 Compute local derivatives from the spline fit to psi
c
      call dbcevl(x,nw,y,nh,cspln,nw1,nh1,xs,ys,pds,ier)
      if(ier .ne. 0) call abortjob
     &        ('magax   ',  4,   'Newton iteration spline error       '
     &        ,'ier     ', ier,      'niter   ', niter,    +1)
c
      detrm    = pds(5)*pds(6) - pds(4)*pds(4)
      if(detrm .eq. 0.0) then
        call abortjob
     &        ('magax   ',  5,   'Newton iteration gradient = zero    '
     &        ,'niter   ', niter,    'newtn   ', newtn,    -1)
        detrm    = 1.0
      endif
c
c 2.2.2 Compute the correction
c
      perr     = abs(psivl-pds(1))
      psivl    = pds(1)
c
      dxrr     = -pds(2)*pds(6) + pds(4)*pds(3)
      dyrr     = -pds(5)*pds(3) + pds(2)*pds(4)
      xerr     =  dxrr/detrm
      yerr     =  dyrr/detrm
      zerrsq   =  xerr*xerr + yerr*yerr
      zerr     =  sqrt(zerrsq)
c
c 2.2.3 Compute the new guess and exit if converged
c
      xs       = xs + xerr
      ys       = ys + yerr
c
      if(perr .lt. erconv  .and.  zerr .lt. erconv) go to 200
c
c
c 2.2.4 Reset the guess back in range if necessary
c
c 2.2.4.1 Check in the radial direction
        if(xs .le. xminn  .or.  xs .ge. xmaxx) then
          if(xs .le. xminn) ksign  = -1
          if(xs .ge. xmaxx) ksign  = +1
          shft    =  float(niter-1) / float(newtn)
          xreset  =  xmidpt + nksign*ksign*shft*xminr
          nksign  = -nksign
c
          call abortjob
     &        ('magax   ',  6,   'Newton iteration x outside range    '
     &        ,'niter   ', niter,    'ksign   ', ksign,    -1)
          write(kuout,1000) xminn,xs,xmaxx,dxrr,xerr,detrm,perr,zerr
     &                     ,erconv,shft,xmidpt,xreset
          xs      = xreset
        endif
c
c 2.2.4.2 Check in the axial direction
        if(ys .le. yminn  .or.  ys .ge. ymaxx) then
          if(ys .le. yminn) ksign  = -1
          if(ys .ge. ymaxx) ksign  = +1
          shft    =  float(niter-1) / float(newtn)
          yreset  =  ymidpt + mksign*ksign*shft*yminr
          mksign  = -mksign
c
          call abortjob
     &        ('magax   ',  7,   'Newton iteration y outside range    '
     &        ,'niter   ', niter,    'ksign   ', ksign,    -1)
          write(kuout,1010) yminn,ys,ymaxx,dyrr,yerr,detrm,perr,zerr
     &                     ,erconv,shft,ymidpt,yreset
          ys      = yreset
        endif
  100 continue
c
c
c 3.0 Print error message if no convergence
c
  110 continue
c
c
c 3.1 Print warning and continue if partial convergence
c
      if(perr .lt. erfatl  .or.   zerr .lt. erfatl) then
        call abortjob
     &        ('magax   ',  8,   'Poorly converged magnetic axis      '
     &        ,'niter   ', niter,    'newtn   ', newtn,    -1)
        write(kuout,2000) psiaxs,xaxs,yaxs,psivl,xs,ys,xaxs0,yaxs0,
     &                    xmidpt,xminn,xmaxx,ymidpt,yminn,ymaxx,
     &                    xminr,yminr
c
c
c 3.2 Print warning and return with initial values if no convergence
c
      else
        call abortjob
     &        ('magax   ',  9,   'Axis not converged: using input     '
     &        ,'niter   ', niter,    'newtn   ', newtn,    -1)
        write(kuout,2000) psiaxs,xaxs,yaxs,psivl,xs,ys,xaxs0,yaxs0,
     &                    xmidpt,xminn,xmaxx,ymidpt,yminn,ymaxx,
     &                    xminr,yminr
        return
      endif
c
c
c 4.0 Reset the new axis values and return
c
  200 continue
      psiaxs   = psivl
      xaxs     = xs
      yaxs     = ys
      return
c
 1000 format(4x,'xminn  = ',e16.6,2x,'xs     = ',e16.6
     &      ,2x,'xmaxx  = ',e16.6,/
     &      ,4x,'dxrr   = ',e16.6,2x,'xerr   = ',e16.6
     &      ,2x,'detrm  = ',e16.6,/
     &      ,4x,'perr   = ',e16.6,2x,'zerr   = ',e16.6
     &      ,2x,'erconv = ',e16.6,/
     &      ,4x,'shft   = ',e16.6,2x,'xmidpt = ',e16.6
     &      ,2x,'xreset = ',e16.6)
 1010 format(4x,'yminn  = ',e16.6,2x,'ys     = ',e16.6
     &      ,2x,'ymaxx  = ',e16.6,/
     &      ,4x,'dyrr   = ',e16.6,2x,'yerr   = ',e16.6
     &      ,2x,'detrm  = ',e16.6,/
     &      ,4x,'perr   = ',e16.6,2x,'zerr   = ',e16.6
     &      ,2x,'erconv = ',e16.6,/
     &      ,4x,'shft   = ',e16.6,2x,'ymidpt = ',e16.6
     &      ,2x,'yreset = ',e16.6)
 2000 format(4x,'Magnetic axis data:',/
     &,4x,'psiaxs = ',e16.6,2x,'xaxs   = ',e16.6,2x,'yaxs   = ',e16.6,/
     &,4x,'psivl  = ',e16.6,2x,'xs     = ',e16.6,2x,'ys     = ',e16.6,/
     &,31x,                    'xaxs0  = ',e16.6,2x,'yaxs0  = ',e16.6,/
     &,4x,'xmidpt = ',e16.6,2x,'xminn  = ',e16.6,2x,'xmaxx  = ',e16.6,/
     &,4x,'ymidpt = ',e16.6,2x,'yminn  = ',e16.6,2x,'ymaxx  = ',e16.6,/
     &,31x,                    'xminr  = ',e16.6,2x,'yminr  = ',e16.6,/)
      end
      subroutine meshpak
c
c   This routine sets up a non-equidistant psi mesh with points
c   automatically concentrated around the rational surfaces and optionally
c   at up to npk specified locations.
c   The points are set such that a fraction pkfrac are placed around the
c   rational and prescribed surfaces, a fraction qpfrac are equally spaced
c   in q and the remainder are set equally spaced in
c   cs = ((psi-psimax)/(psilim-psimax))**cspak
c
c   If pkfrac < 0.0 the default rational surfaces are ignored and a fraction
c   abs(pkfrac) points are packed around only the prescribed surfaces.
c
c   The optional packing q (or ntor*q) locations are prescribed by the array plpak(k1,k2)
c   and at the optional prescribed psi (or cs) locations by the array pspak(k1,k2).
c   For packing at prescribed q or ntor*qlocations,
c     plpak(1,k2) gives the location for packing at k2 = 1,iabs(npak) points.
c     (1.0 + plpak(2,k2)) prescribes the factor by which the default width
c         of the packed distribution is modified.
c     (1.0 + plpak(3,k2)) prescribes the factor by which the number of points
c         placed is to be modified from the default.
c   For packing at prescribed psi or cs locations,
c     pspak(1,k2) gives the location for packing at k2 = 1,iabs(mpak) points.
c     (1.0 + pspak(2,k2)) prescribes the factor by which the default width
c         of the packed distribution is modified.
c     (1.0 + pspak(3,k2)) prescribes the factor by which the number of points
c         placed is to be modified from the default.
c
c   The parameters npak and mpak control the optional packing:
c     If npak    >  0, packing is done at iabs(npak) prescribed q values.
c     If npak    <  0, packing is done at iabs(npak) prescribed ntor*q values.
c     If npak    =  0, no packing is done at the prescribed q values.
c     If mpak    >  0, packing is done at iabs(mpak) prescribed psi values.
c     If mpak    <  0, packing is done at iabs(mpak) prescribed cs values.
c     If mpak    =  0, no packing is done at the prescribed cs values.
c
c   The parameter nsrcheg controls the search for rational surfaces from the
c     initial grid:
c     If nsrcheg >  0, the search is performed right to the edge.
c     If nsrcheg <= 0, the search is not done over the last interval of the
c                      initial grid.
c
c   The parameter nedge controls the optional additional edge packing:
c     If nedge   >  0, packing is done at the edge.
c     If nedge   <= 0, no packing is done at the edge.
c     For iabs(nedge) = 1 or 3 the edge is included as a rational surface only
c                         if the last rational q has jplpak less than jpsi1.
c     for iabs(nedge) = 2 or 4 the edge is included as a rational surface even
c                         if it is already included because the last rational q
c                         has jplpak equal to jpsi1.
c     For iabs(nedge) = 1 or 2 the width for the edge packing is the global width
c     For iabs(nedge) = 3 or 4 the width for the edge packing is the local  width
c
c   If nrat is specified as well, then pkfrac is multiplied by
c   nrat/jpsi and qpfrac by (1 - nrat/jpsi).  If pkfrac = 0.0
c   and nrat is specified then pkfrac is taken to be just nrat/jpsi.
c
c   If nrepeat = 0 then all occurences of a rational q surface specified
c                  in plpak are packed.
c   If nrepeat > 0 then only the nrepeat'th occurence of the q surface is packed.
c   If nrepeat < 0 then the nrepeat'th occurence of the q surface is skipped and
c                  all the others are packed.
c
c   if nppack .ne. 0 the weights of the rational q (not edge and not set by plpak)
c   are modified to eliminate those in the negative shear region (nppack > 0) or
c   those in the positive shear region (nppack < 0).
c
c   if nqpack .ne. 0 the weights of the distribution in q is modified to be evenly
c   distributed in (s**nqpack)*q.
c
c
c   The surfaces are packed around each (rational or prescribed) location
c   according to a bell-shaped density distribution, with default width
c   proportional to the shear.  For rational surfaces, prescribed q (or n*q)
c   surfaces, and the edge, the shear used is the local shear.  For prescribed
c   flux surfaces (psi or cs given by pspak), the global shear is used so that
c   packing can be forced in shearless regions.  The default number of surfaces
c   within each packing location is the same for each surface, and is
c   determined by pkfrac/(no. of packing locations).  The plasma edge is
c   included as a packing surface as if it is prescribed by pspak.
c   For rational surfaces and packing surfaces prescribed by plpak the inverse
c   width is limited by swidmn and swidmx.  For surfaces prescribed by pspak,
c   these limits are ignored so can be overidden.  For the edge the inverse
c   width is limited only by swidmx.
c
c   The distribution of points is calculated by defining a weight
c   distribution wght(swgt) over the cs domain (0.0,1.0), in which wght
c   is the fraction of surfaces cs(jp) with cs(jp) < swgt.
c   delta * d/dswgt wght(swgt)  is then the fraction of the flux surfaces
c   placed within the interval from swgt-delta to swgt+delta.
c   The weight function wght is calculated on a fine non-equidistant mesh
c   swgt with points strategically concentrated around the surfaces
c   that are to be packed - i.e. where wght varies most rapidly.
c
c   Restrictions:
c   1.   If abs(pkfrac) + abs(qpfrac) .gt. 1.0  then
c                     qpfrac = 1.0 - abs(pkfrac)
c        is set and no contribution from equal spacing in s is done.
c   2.   If the number of rational and prescribed packing surfaces exceeds
c        nratmx, the outermost ones are deleted except for the edge.
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (npk=np1,nrtdm=np1,nptt=2401)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/mshc/  nmesh,npak,mpak,nedge,npkmax,nrat,mmesh,
     &              nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &              minpak,maxpak,incpak,psipak,chiwth,cspak,psincr,
     &              pkfrac,qpfrac,epsrat,sedg0,sedg1,epspak,
     &              spakmn,swidmn,swidmx,plpak(3,npk),pspak(3,npk)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/rpak/  nratnl,nwtot,cs(np1),
     &              qnval(np1),ldone(npk),mdone(npk),
     &              swgt (nptt), wght (nptt),
     &              dwds (nptt), qwgt (nptt),
     &              srat  (nrtdm),qrat   (nrtdm),dqds (nrtdm),
     &              swidth(nrtdm),sweight(nrtdm),jqrat(nrtdm),
     &              jplpak(nrtdm),jrepeat(nrtdm)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/smsh/  psim1(np1),psim2(np1),dpsim1(np1),dpssim1(np1),
     &              dpsim2(np1),dpssim2(np1)
      common/volm/  pvansh,vp0,pmantl,vpm(np1),apm(np1),vcurnt(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
c
c
c
c 1.0 Initialization.
c
c 1.1 Initialize local variables.
c
c 1.1.1 Check namelist input is valid.
c
      if    (maxpak .le.   0   ) then
        mxpk   = 1
        call abortjob
     &        ('meshpak ',  1,   'Input maxpak .le. 0: Set mxpk=1     '
     &        ,'maxpak  ', maxpak,   'mxpk    ', mxpk,     -1)
      elseif(maxpak .gt.   0   ) then
        mxpk   = maxpak
      endif
c
      if    (minpak .le.   0   ) then
        mnpk   = 1
        call abortjob
     &        ('meshpak ',  2,   'Input minpak .le. 0: Set mnpk=1     '
     &        ,'minpak  ', minpak,   'mnpk    ', mnpk,     -1)
      elseif(minpak .gt.   0   ) then
        mnpk   = minpak
      endif
c
      if    ( mnpk  .gt.  mxpk ) then
        mnpk   = mxpk
        call abortjob
     &        ('meshpak ',  3,   'mnpk > mxpk: Resetting mnpk=mxpk    '
     &        ,'mnpk    ', mnpk,     'mxpk    ', mxpk,     -1)
      endif
c
      if    (incpak .le.   0   ) then
        incpk  = 1
        call abortjob
     &        ('meshpak ',  4,   'Input incpak .le. 0: Set incpk=1    '
     &        ,'incpak  ', incpak,   'incpk   ', incpk,    -1)
      elseif(incpak .gt.   0   ) then
        incpk  = incpak
      endif
c
c 1.1.2 Set input.
c
      if(ntor .ne. 0) zwn = abs(float(ntor))
      if(ntor .eq. 0) zwn = 1.0
c
      npts      = nptt
      kpak      = mxpk
      kpst      = incpk
      nratmx    = min0(nrtdm,npkmax)
c
      jcutof    = ncutedg
      jplin     = jpsi - jcutof
      jplin     = max0(  1,  jplin)
      jplin     = min0(jpsi1,jplin)
c
      cspak0    = amax1(roundff,abs(cspak))
      cspak1    = 1.0/cspak0
c
      jp0st     = 1
      cs0st     = 0.0
c
      zwnorm    = 0.5
      wdmin     = swidmn
      wdmax     = swidmx
c
      zqaxe     = zwn*qaxe
      zqlim     = zwn*qlim
      smalls    = roundff
      smallq    = roundff*amax1(abs(zqaxe),abs(zqlim))
      smalqp    = smallq / abs(delpsir)
c
c
c 1.2 Set the parameters defining packing from plpak, pspak, and at the edge.
c
c 1.2.1 Set npakk and mpakk from the input npak and mpak.
c 
      if(npak .ne. 0) npakk = iabs(npak)
      if(npak .eq. 0) npakk = 0
c
      if(mpak .ne. 0) mpakk = iabs(mpak)
      if(mpak .eq. 0) mpakk = 0
c
      mpakk1    = mpakk + 1
c
c 1.2.2 Set the edge rational surface search parameter ksrch from nsrcheg.
c
      if(nsrcheg .le. 0) ksrch  =  0
      if(nsrcheg .gt. 0) ksrch  = +1
c
c 1.2.3 Set the edge rational surface packing from nedge
c
c 1.2.3.1 Set the default edge packing weights
      if    (nedge .gt. 0) then
        sedge0    = sedg0
        sedge1    = sedg1
        nratmx1   = nratmx - 1
      elseif(nedge .le. 0) then
        sedge0    = 0.0
        sedge1    = 0.0
        nratmx1   = nratmx
      endif
c
c 1.2.3.2 Set the edge packing parameters according to whether iabs(nedge) is odd or even
c       and larger or less than 2.
      kedgabs   = iabs(nedge)
      kedgpl1   = kedgabs + 1
      kedgevn   = kedgpl1 - 2*(kedgpl1/2)
c
      kedgadd   = kedgevn
      if(kedgabs .le. +2) kedgwid  =  0
      if(kedgabs .gt. +2) kedgwid  = +1
c
c 1.2.4 Print warnings if not all edge packing is requested.
c
      if(kedgadd .eq. 0) then
        write(kutty,1000)
        write(kuout,1000)
        write(kuout,1010) kedgadd,kedgabs,kedgwid
      else
        write(kutty,1020)
        write(kuout,1020)
        write(kuout,1010) kedgadd,kedgabs,kedgwid
      endif
c
      if(kedgwid .eq. 0) then
        write(kutty,1030)
        write(kuout,1030)
        write(kuout,1010) kedgadd,kedgabs,kedgwid
      else
        write(kutty,1040)
        write(kuout,1040)
        write(kuout,1010) kedgadd,kedgabs,kedgwid
      endif
c
c
c 1.3 Set nratt to min0(nrat,jpsi).
c
      if(iabs(nrat) .lt. jpsi) nratt   = nrat
      if(iabs(nrat) .ge. jpsi) then
        nratt     = jpsi
        call abortjob
     &        ('meshpak ',  5,   'nrat .ge. jpsi: Set nratt =jpsi     '
     &        ,'nrat    ', nrat,     'jpsi    ', jpsi,     -1)
      endif
c
c
c 1.4 Define the packing fraction according to nrat and pkfrac.
c     fpack and qpack are defined from pkfrac and qpfrac modified by nrat.
c
      ratpak    = float(iabs(nratt))/float(jpsi)
      if    (nratt .eq. 0  .and.  pkfrac .eq. 0.0) then
        fpack     =  0.0
        fpnorm    =  1.0
        pksign    = +1.0
      elseif(nratt .eq. 0  .and.  pkfrac .ne. 0.0) then
        fpack     = +pkfrac
        fpnorm    =  1.0
        pksign    = +1.0
      elseif(nratt .gt. 0  .and.  pkfrac .ne. 0.0) then
        fpack     = +pkfrac*ratpak
        fpnorm    =  abs(pkfrac)
        pksign    = +1.0
      elseif(nratt .lt. 0  .and.  pkfrac .ne. 0.0) then
        fpack     = -pkfrac*ratpak
        fpnorm    =  abs(pkfrac)
        pksign    = -1.0
      elseif(nratt .gt. 0  .and.  pkfrac .eq. 0.0) then
        fpack     = +ratpak
        fpnorm    =  1.0
        pksign    = +1.0
      elseif(nratt .lt. 0  .and.  pkfrac .eq. 0.0) then
        fpack     = -ratpak
        fpnorm    =  1.0
        pksign    = -1.0
      endif
c
      if(pkfrac .eq. 0.0) qratpk  = 1.0
      if(pkfrac .ne. 0.0) qratpk  = 0.0
      qpack   = qpfrac*(1.0 - pksign*qratpk*ratpak)
c
c
c 1.5 Set up the normalized flux coordinate cs in reverse order
c     from psival.
c     Set up qnval = ntor*qpsi corresponding to cs.
c
      jp1st        = 1
      cstart       = 0.0
      cfinal       = 1.0
      crange       = cfinal - cstart
      cs(jpsi1)    = cfinal
      delpsr       = delpsir
      qnval(jpsi1) = zqlim
      do 100 jp    = 1,jpsi
      ztemp        = (psival(jpsi-jp+1) - psimax)/delpsr
      cs( jp  )    = cstart  +  crange*(abs(ztemp))**cspak0
      qnval(jp)    = zwn*qp(jpsi-jp+1)
c
      if(cs(jp) .le. cs0st) jp1st  = jp
  100 continue
      jpstart      = max0(jp0st,jp1st)
c
      zdelcs0      = crange
      zdelcs       = crange/float(jpsi)
c
c
c
c 2.0 Determine the number of surfaces requiring packing.
c
c     jqrat   specifies the mesh index closest to the surface being packed.
c     jplpak  specifies the kind of surface being packed:
c             jplpak(lrat)  = -mpakk1 for edge packing
c             jplpak(lrat)  <   0     for packing at prescribed s values
c             jplpak(lrat)  =   0     for packing at rational q values
c             jplpak(lrat)  >   0     for packing at prescribed q values
c     qrat    specifies the n*q value of the surface being packed.
c     ldone   specifies whether a specified packing point from plpak is included or not:
c             ldone(lpq)    =   0 if the specified q surface is not present in the range
c             ldone(lpq)    =   1 if the specified q surface is included once
c             ldone(lpq)    >   1 if the specified q surface is included multiple times
c     mdone   specifies whether a specified packing point from pspak is included or not:
c             mdone(lps)    =   0 if the specified s surface is not present in the range
c             mdone(lps)    =   1 if the specified s surface is included once
c     jrepeat specifies whether a packed surface is considered a repeat or not:
c             jrepeat(lrat) =   0 if the surface was a default and not prescribed
c             jrepeat(lrat) >   0 if the surface was prescribed by either plpak or pspak
c                                 and represents the repeat number of this prescribed
c                                 surface.
c                                 For monotonic q profiles this should always equal 1.
c                                 For packing from pspak cs is monotonic by definition
c                                 and this should always equal 1.
c
c 2.1 Compute the maximum and minimum of qnval.
c
c 2.1.1 Determine how many grid points to include, depending on how
c       packing at the edge is requested.
c
      if(ksrch .eq. 0) jpsmx   = jpsi-1
      if(ksrch .ne. 0) jpsmx   = jpsi
c
c 2.1.2 Search through the grid points.
c
      jpsmx1    = jpsmx + 1
      zqmin     = qnval(jpsmx1)
      zqmax     = qnval(jpsmx1)
      do 200 jp = 1,jpsmx
      zqmin     = amin1(zqmin,qnval(jp))
      zqmax     = amax1(zqmax,qnval(jp))
  200 continue
c
c 2.1.3 Set the loop counters accordingly.
c
      if    (ksrch .eq. 0) then
        nqmin     = ifix(zqmin)
        nqmax     = ifix(zqmax) + 1
      elseif(ksrch .ne. 0) then
        nqmin     = ifix(zqmin)
        nqmax     = ifix(zqmax)
        if(nqmax .le. nqmin) nqmax = nqmin + 1
      endif
c
c
c 2.2 Initialize the number of rational surfaces for all cases.
c
      lrat      = 0
c
c
c 2.3 For the case where packing is reqested, find the surfaces
c     requiring packing.
c
      if(fpack .ne. 0.0) then
c
c 2.3.1 Initialize the rational surface counters.
c
c 2.3.1.1 Initialize the truncation counter.
        ltrunc    = 0
c
c 2.3.1.2 Initialize the counter for prescribed q and n*q packing.
        if(npakk .gt. 0) then
          do 205 lpq  = 1,npakk
          ldone(lpq)  = 0
  205     continue
        endif
c
c 2.3.1.3 Initialize the counter for prescribed psi and cs packing.
        if(mpakk .gt. 0) then
          do 210 lps  = 1,mpakk
          mdone(lps)  = 0
  210     continue
        endif
c
c 2.3.1.4 Initialize the counter for the combined rational surfaces.
          do 215 lrs    = 1,nratmx1
          jrepeat(lrs)  = 0
  215     continue
c
c                                                                Rational q Identification:
c
c 2.3.2 Set the surfaces requiring packing.
c
        do 250 jp = jpstart,jpsi
c
c 2.3.2.1 If fpack .gt. 0.0, look for rational surfaces between jp
c         and jp+1.
c         Otherwise, if fpack .lt. 0 then packing is only done at those
c         surfaces prescribed in plpak, pspak, and at the edge.
        if(fpack .gt. 0.0) then
c
c 2.3.2.1.1 Search for rational surfaces between qnval(jp) and qnval(jp+1).
          do 220 lq = nqmin,nqmax
          ratq      = float(lq)
          if((qnval(jp)-ratq)*(qnval(jp+1)-ratq) .lt. 0.0  .or.
     &                        (qnval(jp+1)-ratq) .eq. 0.0)  then
c
c 2.3.2.1.2 Set the packing surface.
            jpt   = jp+1
            if(lrat  .gt. nratmx1) then
              ltrunc = ltrunc + 1
            else
              lrat           = lrat + 1
              jqrat  (lrat)  =  jpt
              jplpak (lrat)  =  0
              jrepeat(lrat)  =  0
              qrat   (lrat)  = ratq
            endif
          endif
  220     continue
        endif
c
c                                                                Prescribed q value Identification:
c
c 2.3.2.2 If npakk .gt. 0, add in the surfaces prescribed by plpak.
        if(npakk .gt. 0) then
c
c 2.3.2.2.1 Search for prescribed surfaces between qnval(jp) and qnval(jp+1).
c           For npak .gt. 0, plpak(1,lpq) is assumed to be q.
c           For npak .lt. 0, plpap(1,lpq) is assumed to be ntor*q.
          do 230 lpq = 1,npakk
          if    (npak .gt. 0) then
            ratq       = zwn*plpak(1,lpq)
          elseif(npak .lt. 0) then
            ratq       =     plpak(1,lpq)
          endif
c
          if((qnval(jp)-ratq)*(qnval(jp+1)-ratq) .lt. 0.0  .or.
     &                        (qnval(jp+1)-ratq) .eq. 0.0)  then
c
c 2.3.2.2.2 Set the packing surface
            jpt    = jp+1
            if(lrat  .gt. nratmx1) then
              ltrunc  = ltrunc + 1
            else
              ldone  (lpq)   = ldone(lpq) + 1
              lrat           = lrat + 1
              jqrat  (lrat)  =  jpt
              jplpak (lrat)  = +lpq
              jrepeat(lrat)  =  ldone(lpq)
              qrat   (lrat)  = ratq
            endif
          endif
  230     continue
        endif
c
c                                                                Prescribed s value Identification:
c
c 2.3.2.3 If mpakk .gt. 0, add in the surfaces prescribed by pspak.
        if(mpakk .gt. 0) then
c
c 2.3.2.3.1 Search for prescribed surfaces between cs(jp) and cs(jp+1).
c           For mpak .gt. 0, pspak(1,lps) is assumed to be psi.
c           For mpak .lt. 0, pspap(1,lps) is assumed to be cs.
          do 240 lps = 1,mpakk
          if    (mpak .gt. 0) then
            ztemp      = (pspak(1,lps) - psimax)/delpsr
            rats       = cstart + crange*(abs(ztemp))**cspak0
          elseif(mpak .lt. 0) then
            rats       = pspak(1,lps)
          endif
c
          if(( cs  (jp)-rats)*( cs  (jp+1)-rats) .lt. 0.0  .or.
     &                        ( cs  (jp+1)-rats) .eq. 0.0)  then
c
c 2.3.2.3.2 Set the coefficients for interpolation
            jpt       = jp+1
            if(jpt .le. 2) then
              zx1    = cstart
              zx2    = cs   (1)
              zx3    = cs   (2)
              zy1    = zqaxe
              zy2    = qnval(1)
              zy3    = qnval(2)
            elseif(jpt .gt. 2) then
              zx1    = cs   (jpt-2)
              zx2    = cs   (jpt-1)
              zx3    = cs   (jpt)
              zy1    = qnval(jpt-2)
              zy2    = qnval(jpt-1)
              zy3    = qnval(jpt)
            endif
c
c 2.3.2.3.3 Interpolate qnval(cs) to get qnval(rats).
c           Use quadratic interpolation except right near the edge.
c           Resort to linear interpolation if quadratic interpolation fails.
            if    (jpt .lt. jplin) then
              call intqad(zx1,zx2,zx3,zy1,zy2,zy3,zas,zbs,zcs,ker0)
              if    (ker0 .eq. 0) then
                ratq    = (zas*rats + zbs)*rats  +  zcs
c
              elseif(ker0 .ne. 0) then
                call abortjob
     &        ('meshpak ',  6,   'Trying linear interpolation n*q     '
     &        ,'jpt     ', jpt   ,   'ker0    ', ker0,     -1)
                call intlin(zx2,zx3,zy2,zy3,zas,zbs,ker1)
                if    (ker1 .eq. 0) then
                  ratq    = zas*rats + zbs
                elseif(ker1 .ne. 0) then
                  call abortjob
     &        ('meshpak ',  7,   'Interpolations failed for qnval     '
     &        ,'ker0    ', ker0  ,   'ker1    ', ker1,     -2)
                  ratq    = 0.5*(zy2 + zy3)
                endif
              endif
c
c 2.3.2.3.4 Use linear interpolation near the edge.
            elseif(jpt .ge. jplin) then
                call intlin(zx2,zx3,zy2,zy3,zas,zbs,ker2)
                if    (ker2 .eq. 0) then
                  ratq    = zas*rats + zbs
                elseif(ker2 .ne. 0) then
                  call abortjob
     &        ('meshpak ',  8,   'Linear interpolation of q failed    '
     &        ,'jpt     ', jpt   ,   'ker2    ', ker2,     -2)
                  ratq    = 0.5*(zy2 + zy3)
                endif
            endif
c
c 2.3.2.3.5 Set the packing surface.
            if(lrat  .gt. nratmx1) then
              ltrunc  = ltrunc + 1
            else
              mdone  (lps)   = mdone(lps) + 1
              lrat           = lrat + 1
              jqrat  (lrat)  =  jpt
              jplpak (lrat)  = -lps
              jrepeat(lrat)  =  mdone(lps)
              qrat   (lrat)  = ratq
            endif
          endif
  240     continue
        endif
  250   continue
c
c 2.3.3 Check that all requested packing points were covered.
c
c 2.3.3.1 Check for the specified q or n*q points.
          if(npakk .gt. 0) then
            do 260 lpq  = 1,npakk
            lpp         = lpq
            lppdone     = ldone(lpp)
            if    (lppdone .le. 0) then
              call abortjob
     &        ('meshpak ',  9,   'Not all requested plpak included    '
     &        ,'lpp     ', lpp,      'lppdone ', lppdone,   0)
            elseif(lppdone .gt. 1  .and.  nrepeat .ne. 0) then
              call abortjob
     &        ('meshpak ', 10,   'Repeat q values will be ignored     '
     &        ,'lpp     ', lpp,      'npakk   ', npakk,     0)
            endif
  260       continue
          endif
c
c 2.3.3.2 Check for the specified psi or cs points.
          if(mpakk .gt. 0) then
            do 270 lps  = 1,mpakk
            lpp         = lps
            if(mdone(lpp) .eq. 0) then
              call abortjob
     &        ('meshpak ', 11,   'Not all requested pspak included    '
     &        ,'lpp     ', lpp,      'mpakk   ', mpakk,    -1)
            endif
  270       continue
          endif
c
c 2.3.4 Print a warning if the number of surfaces requiring packing has
c       exceeded the maximum allowed.
c       If this has occured, the excess surfaces are not packed.
c
        if(ltrunc .ne. 0) then
          call abortjob
     &        ('meshpak ', 12,   'Packing truncated at nratmx         '
     &        ,'ltrunc  ', ltrunc,   'nratmx1 ', nratmx1,  -1)
          write(kuout,1100) ltrunc,nratmx,lrat,nqmin,nqmax,jqrat(lrat)
     &                     ,jplpak(lrat),jrepeat(lrat),qrat(lrat)
        endif
c
c                                                                Edge Identification:
c
c 2.3.5 Add in the boundary as an extra rational surface.
c
c 2.3.5.1 Add in the boundary if nedge is odd (kedgadd = 0) and
c         the edge is not already included.
        if    (kedgadd .eq. 0  .and.  jqrat(lrat) .ne. jpsi1) then
          lrat           = lrat   + 1
          jqrat  (lrat)  = +jpsi1
          jplpak (lrat)  = -mpakk1
          jrepeat(lrat)  =  0
          qrat   (lrat)  = qnval(jpsi1)
c
c
c 2.3.5.2 Add in the boundary if nedge is even (kedgadd = 1)
c         irrespective of whether the edge is already included or not.
        elseif(kedgadd .gt. 0) then
          lrat           = lrat   + 1
          jqrat  (lrat)  = +jpsi1
          jplpak (lrat)  = -mpakk1
          jrepeat(lrat)  =  0
          qrat   (lrat)  = qnval(jpsi1)
        endif
      endif
c
c
c 2.4 Set the final number of rational surfaces for packing.
c
      nratnl    = lrat
c
c
c
c 3.0 Set up the constants that determine the weighting between
c     packing surfaces, surfaces at equal cs and surfaces at equal q.
c
c 3.1 Set zratp and zratq from fpack and qpack.
c
c 3.1.1 Set zratp to zero if there are no rational surfaces.
c
      if(nratnl  .eq.    0  ) zratp   = 0.0
      if(nratnl  .gt.    0  ) zratp   = amin1(1.0-epsrat,abs(fpack))
c
c 3.1.2 Set zratq.
c
      zratq   = amin1(1.0-epsrat,abs(qpack))
c
c
c 3.2 Set zrats from the remainder of zratp and zratq.
c
      zrats   = 1.0 - zratp - zratq
      if(zrats .le. epsrat) then
        zratq   = 1.0 - zratp
        zrats   = 0.0
      endif
c
c
c 3.3 Reset zratp, zratq, and zrats to zero if too small.
c
      if(zratp .le. epsrat) zratp   = 0.0
      if(zratq .le. epsrat) zratq   = 0.0
      if(zrats .le. epsrat) zrats   = 0.0
c
      if(zratp .eq.   0.0 ) zpnorm  = 1.0
      if(zratp .ne.   0.0 ) zpnorm  = fpnorm
c
c
c 3.4 Define lpakp, lpakq, and lpaks to skip contributions where none
c     are required.
c
      if(zratp .eq. 0.0  .or.   nratnl .le. 0) lpakp  = 0
      if(zratp .gt. 0.0  .and.  nratnl .gt. 0) lpakp  = 1
      if(zratq .eq. 0.0) lpakq  = 0
      if(zratq .gt. 0.0) lpakq  = 1
      if(zrats .eq. 0.0) lpaks  = 0
      if(zrats .gt. 0.0) lpaks  = 1
c
c
c 3.5 Set kswmsh according to whether there is sufficient packing.
c
      if    (lpakp .eq. 0) then
        kswmsh    = 0
        zratp0    = zratp
        lrat0     = nratnl
        call abortjob
     &        ('meshpak ', 13,   'No rational surface packing         '
     &        ,'nratnl  ', nratnl,   'nratt   ', nratt,    -1)
        write(kutty,1110) lrat0,jpsi,zratp0
        write(kuout,1110) lrat0,jpsi,zratp0
      elseif(lpakp .eq. 1) then
        kswmsh    = 1
      endif
c
c
c
c 4.0 Define the width of the packing weight functions for each
c     packing point.
c
      if(lpakp .ne. 0) then
c
c 4.1 Define the interpolated qnval and d/ds qnval at the rational
c     surfaces.
c
        do 400 lv = 1,nratnl
c
c 4.1.1 Find the neighbouring mesh points.
c
        lp        = lv
        jpt       = jqrat(lp)
        if    (jpt .le. 2) then
          zx1       = zqaxe
          zx2       = qnval(1)
          zx3       = qnval(2)
          zy1       = cstart
          zy2       = cs   (1)
          zy3       = cs   (2)
        elseif(jpt .gt. 2) then
          zx1       = qnval(jpt-2)
          zx2       = qnval(jpt-1)
          zx3       = qnval(jpt)
          zy1       = cs   (jpt-2)
          zy2       = cs   (jpt-1)
          zy3       = cs   (jpt)
        endif
c
c 4.1.2 Find cs at qrat(lp) for internal points using quadratic
c       interpolation as a first attempt.
c
        if    (jpt .lt. jplin) then
c
c 4.1.2.1 Interpolate zy(zx) to get cs at qrat(lp).
          call intqad(zx1,zx2,zx3,zy1,zy2,zy3,zas,zbs,zcs,ker0)
c
c 4.1.2.2 Check that zsrat is monotonic with respect to q.
          if    (ker0 .eq. 0) then
            zsrat      = (zas*qrat(lp) + zbs)*qrat(lp) + zcs
            zdsdq      = 2.0*zas*qrat(lp) + zbs
            if    ((qrat(lp)-zx1)*(qrat(lp)-zx2) .le. 0.0) then
              if((zsrat-zy1)*(zsrat-zy2) .le. 0.0) ker1  = 0
              if((zsrat-zy1)*(zsrat-zy2) .gt. 0.0) then
                if(abs(zsrat-zy1) .le. smalls  .or.
     &             abs(zsrat-zy2) .le. smalls)     ker1  = 0
                if(abs(zsrat-zy1) .gt. smalls  .and.
     &             abs(zsrat-zy2) .gt. smalls)     ker1  = 1
              endif
c
            elseif((qrat(lp)-zx2)*(qrat(lp)-zx3) .le. 0.0) then
              if((zsrat-zy2)*(zsrat-zy3) .le. 0.0) ker1  = 0
              if((zsrat-zy2)*(zsrat-zy3) .gt. 0.0) then
                if(abs(zsrat-zy2) .le. smalls  .or.
     &             abs(zsrat-zy3) .le. smalls)     ker1  = 0
                if(abs(zsrat-zy2) .gt. smalls  .and.
     &             abs(zsrat-zy3) .gt. smalls)     ker1  = 2
              endif
            else
              ker1    = 3
            endif
c
          elseif(ker0 .ne. 0) then
            ker1    = 0
          endif
c
c 4.1.2.3 If the quadratic interpolation failed or zsrat is
c         nonmonotonic, use a linear interpolation.
          if(ker0 .ne. 0  .or.  ker1 .ne. 0) then
c
c 4.1.2.3.1 Print warnings.
            if(ker0 .ne. 0) call abortjob
     &        ('meshpak ', 14,   'intqad failed: trying intlin        '
     &        ,'ker0    ', ker0,     'lp      ', lp,       -1)
            if(ker1 .ne. 0) call abortjob
     &        ('meshpak ', 15,   's(q) from intqad outside range      '
     &        ,'ker1    ', ker1,     'lp      ', lp,       -1)
c
c 4.1.2.3.2 Use linear interpolation depending on which interval the
c           point is in.
            if    ((qrat(lp)-zx1)*(qrat(lp)-zx2) .le. 0.0) then
              call intlin(zx1,zx2,zy1,zy2,zas,zbs,ker2)
            elseif((qrat(lp)-zx2)*(qrat(lp)-zx3) .le. 0.0) then
              call intlin(zx2,zx3,zy2,zy3,zas,zbs,ker2)
            else
c
c 4.1.2.3.3 Print a warning if the interval could not be determined and
c           then use the whole interval.
              if((qrat(lp)-zx1)*(qrat(lp)-zx3) .le. 0.0) then
                call abortjob
     &        ('meshpak ', 16,   'Trying intlin over full interval    '
     &        ,'ker1    ', ker1,     'lp      ', lp,       -1)
                call intlin(zx1,zx3,zy1,zy3,zas,zbs,ker2)
c
c 4.1.2.3.4 Print a warning if qrat(lp) is not within the expected total interval
c           and resort to taking just the linear mean over the interval.
              else
                call abortjob
     &        ('meshpak ', 17,   'qrat(lp) outside q(jpt-2),q(jpt)    '
     &        ,'lp      ', lp,       'jpt     ', jpt,      -2)
                zas    = 0.0
                zbs    = 0.5*(zy1 + zy3)
              endif
            endif
c
c 4.1.2.3.5 Print warning if the linear interpolation also failed and resort
c           to taking just the linear mean over the whole interval.
            if(ker2 .ne. 0) then
              call abortjob
     &        ('meshpak ', 18,   'intqad and intlin failed on s(q)    '
     &        ,'ker2    ', ker2,     'lp      ', lp,       -2)
              zas    = 0.0
              zbs    = 0.5*(zy1 + zy3)
            endif
c
c 4.1.2.3.6 Compute the interpolated point.
            zsrat      =  zas*qrat(lp) + zbs
            zdsdq      =  zas
          endif
c
c 4.1.3 Find cs at qrat(lp) for points between the jplin surface
c       and the edge.
c
        elseif(jpt .ge. jplin) then
c
c 4.1.3.1 Use linear interpolation over the last interval.
          if    ((qrat(lp)-zx2)*(qrat(lp)-zx3) .le. 0.0) then
            ker0    = 0
            call intlin(zx2,zx3,zy2,zy3,zas,zbs,ker1)
c
c 4.1.3.2 Use linear interpolation over the next to last interval
c         if in the wrong interval.
          elseif((qrat(lp)-zx1)*(qrat(lp)-zx2) .le. 0.0) then
            ker0    = 0
            call abortjob
     &        ('meshpak ', 19,   'Edge interpolation using zx1,zx2    '
     &        ,'lp      ', lp,       'jpt     ', jpt,      -1)
            call intlin(zx1,zx2,zy1,zy2,zas,zbs,ker1)
          else
            ker0    = 1
            ker1    = 0
          endif
c
c 4.1.3.3 Use linear interpolation over the double interval
c         if problems arose in previous attempt.
          if(ker0 .ne. 0  .or.  ker1 .ne. 0) then
c
c 4.1.3.3.1 Print warnings.
            if(ker0 .ne. 0) call abortjob
     &        ('meshpak ', 20,   'Could not find correct interval     '
     &        ,'lp      ', lp,       'jpt     ', jpt,      -1)
            if(ker1 .ne. 0) call abortjob
     &        ('meshpak ', 21,   'intlin failed: try full interval    '
     &        ,'ker1    ', ker1,     'lp      ', lp,       -1)
c
c 4.1.3.3.2 Use linear interpolation if the point is in the expected
c           interval.
            if((qrat(lp)-zx1)*(qrat(lp)-zx3) .le. 0.0) then
              call intlin(zx1,zx3,zy1,zy3,zas,zbs,ker2)
c
c 4.1.3.3.3 Resort to taking just the mean if the linear interpolation
c           over the whole interval failed.
              if(ker2 .ne. 0) then
                call abortjob
     &        ('meshpak ', 22,   'intlin failed for full interval     '
     &        ,'ker2    ', ker2,     'lp      ', lp,       -2)
                zas    = 0.0
                zbs    = 0.5*(zy1 + zy3)
              endif
c
c 4.1.3.3.4 Resort to using just the linear mean over the whole interval
c           if the point is not within the expected interval.
            else
              call abortjob
     &        ('meshpak ', 23,   'qrat(lp) outside q(jpt-2),q(jpt)    '
     &        ,'lp      ', lp,       'jpt     ', jpt,      -2)
              zas    = 0.0
              zbs    = 0.5*(zy1 + zy3)
            endif
          endif
c
c 4.1.3.4 Set the value for srat and dsdq.
          zsrat      =  zas*qrat(lp) + zbs
          zdsdq      =  zas
        endif
c
c 4.1.4 Check zsrat is within the total range.
c
        if(zsrat .lt. cstart) then
          call abortjob
     &        ('meshpak ', 24,   'zsrat from interpolation <cstart    '
     &        ,'lp      ', lp,       'jpt     ', jpt,      -1)
          zsrat = cstart
        endif
c
        if(zsrat .gt. cfinal) then
          call abortjob
     &        ('meshpak ', 25,   'zsrat from interpolation >cfinal    '
     &        ,'lp      ', lp,       'jpt     ', jpt,      -1)
          zsrat = cfinal
        endif
c
c 4.1.5 Define srat and dqds.  dqds is set to be nonzero.
c
        if(abs(zdsdq) .lt. smalqp) zdsdq = smalqp*sign(1.0,zdsdq)
        srat(lp)   =     zsrat
        dqds(lp)   = 1.0/zdsdq
  400   continue
c
c
c 4.2 Define the width of the packing weight functions.
c     swidth is an inverse width.
c
c 4.2.1 Initialize normalizations.
c
        zfrac0     = jpsi*zratp/zpnorm
        zfrac1     = zfrac0/float(nratnl)
        zfrac2     = amax1(float(jpsi)*(1.0-zratp/zpnorm),1.0)
        zfrac3     = zfrac1*zfrac2
c
        zdeltaq    = zqmax - zqmin
        if(abs(zdeltaq) .le. roundff) zdeltaq   = roundff
        zdqdfolt   = abs(zdeltaq/zdelcs0)
        zwidfac    = zwnorm*zfrac3/zdqdfolt
        zshave     = zfrac3
        widmin     = wdmin*zshave
        widmax     = wdmax*zshave
        zdelq      = abs(zdeltaq)/zfrac2
c
        do 450 lp  = 1,nratnl
        zdqds      = abs(dqds(lp))
        zwdfacl    = zwidfac*zdqds
        zwdfacs    = zwidfac*zdqdfolt
c
c 4.2.2 Modify the width for those surfaces prescribed by plpak, 
c       pspak, and sedge.
c       For iabs(nedge) = +1 or +2 (kedgwid = 0) use the default global
c       width for the edge
c       For iabs(nedge) = +3 or +4 (kedgwid = 1) use the local width
c       for the edge
c
        jpak       = jplpak(lp)
        jpak0      = iabs(jpak)
        if    (jpak .lt. 0  .and.  jpak .eq. -mpakk1) then
          zwidthx    = sedge0
          if(kedgwid .eq. 0) zwdfact  = zwdfacs
          if(kedgwid .ne. 0) zwdfact  = zwdfacl
        elseif(jpak .lt. 0  .and.  jpak .ne. -mpakk1) then
          zwidthx    = pspak(2,jpak0)
          zwdfact    = zwdfacs
        elseif(jpak .eq. 0) then
          zwidthx    = 0.0
          zwdfact    = zwdfacl
        elseif(jpak .gt. 0) then
          zwidthx    = plpak(2,jpak0)
          zwdfact    = zwdfacl
        endif
c
        zwidth     = 1.0 + zwidthx
        if(zwidth .lt. smalls) then
          call abortjob
     &        ('meshpak ', 26,   'Width factor reset to roundff       '
     &        ,'lp      ', lp,       'jpak    ', jpak,     -1)
          zwidth     = smalls
        endif
c
        swidth(lp) = zwdfact*zwidth
c
c 4.2.3 Keep swidth within reasonable bounds from widmin to widmax.
c       The minimum and maximum are ignored for packing specified
c       by pspak.  For the edge packing the mimimum is ignored.
c
        if    (jpak .lt. 0  .and.  jpak .eq. -mpakk1) then
          if(swidth(lp) .gt. widmax) swidth(lp) = widmax
        elseif(jpak .ge. 0) then
          if(swidth(lp) .lt. widmin) swidth(lp) = widmin
          if(swidth(lp) .gt. widmax) swidth(lp) = widmax
        endif
  450   continue
c
c
c 4.3 Reorder the packing points in ascending order.
c
        if(nratnl .gt. 1) then
c
c 4.3.1 Loop over points and store the value.
c
          do 480 lv   = 2,nratnl
          lp          = lv
          zs1         = srat   (lp)
          zq1         = qrat   (lp)
          zswd1       = swidth (lp)
          zdqds1      = dqds   (lp)
          kplp1       = jplpak (lp)
          krpt1       = jrepeat(lp)
          kqrt1       = jqrat  (lp)
c
c 4.3.2 Check against previous points and find the place to insert.
c
          lpa         = lp-1
          do 460 lpp  = lpa,1,-1
c
c 4.3.2.1 Store each value compared.
          zs0         = srat   (lpp)
          zq0         = qrat   (lpp)
          zswd0       = swidth (lpp)
          zdqds0      = dqds   (lpp)
          kplp0       = jplpak (lpp)
          krpt0       = jrepeat(lpp)
          kqrt0       = jqrat  (lpp)
c
c 4.3.2.2 Decide whether to switch values.
          kswitch     = 0
c
c 4.3.2.2.1 Switch if the points are misordered.
          if    (zs0 .gt. zs1) then
            kswitch     = 1
            if(kplp0 .eq. 0  .and.  kplp1 .eq. 0) then
              call abortjob
     &        ('meshpak ', 27,   'Rational surfaces are misordered    '
     &        ,'lp      ', lp,       'lpp     ', lpp,       0)
            endif
c
c 4.3.2.2.2 If the points are equal, order so that the narrower width point
c           is ordered second, or if both widths are also equal, according
c           to the type of request.
          elseif(zs0 .eq. zs1) then
            if(zswd0 .gt. zswd1) kswitch = 1
            if(zswd0 .eq. zswd1) then
              if(kplp0 .lt. 0  .and.  kplp1 .eq. 0) kswitch = 1
              if(kplp0 .lt. 0  .and.  kplp1 .gt. 0) kswitch = 1
              if(kplp0 .gt. 0  .and.  kplp1 .eq. 0) kswitch = 1
            endif
          endif
c
c 4.3.2.3 Stop searching if found the right place.
          if(kswitch .eq. 0) then
            lpnew     = lpp+1
            go to 470
c
c 4.3.2.4 Shuffle point upward if still searching for the right place.
          elseif(kswitch .eq. 1) then
            srat   (lpp+1)  = zs0
            qrat   (lpp+1)  = zq0
            dqds   (lpp+1)  = zdqds0
            swidth (lpp+1)  = zswd0
            jplpak (lpp+1)  = kplp0
            jrepeat(lpp+1)  = krpt0
            jqrat  (lpp+1)  = kqrt0
          endif
  460     continue
c
c 4.3.3 Insert the point from the main loop into the new place.
c
          lpnew  = 1
  470     continue
          if(lp .ne. lpnew) then
            call abortjob
     &        ('meshpak ', 28,   'Shuffled surface lp to lpnew        '
     &        ,'lp      ', lp,       'lpnew   ', lpnew,     0)
            srat   (lpnew)  = zs1
            qrat   (lpnew)  = zq1
            dqds   (lpnew)  = zdqds1
            swidth (lpnew)  = zswd1
            jplpak (lpnew)  = kplp1
            jrepeat(lpnew)  = krpt1
            jqrat  (lpnew)  = kqrt1
          endif
  480     continue
        endif
      endif
c
c
c
c 5.0 Compute the weight function mesh points.
c
c 5.1 Set up the mesh swgt for the weight function wght over the range
c     from cstart to cfinal for the case with equally spaced mesh
c     (too many rational surfaces).
c
c     For kswmsh = 0, swgt is an equally spaced mesh of
c             2*(kpst+kpak)*jpsi1
c     points, unless this exceeds the dimension for swgt.
c
      if    (kswmsh .eq. 0) then
        nwtot       = 2*(kpst + kpak)*jpsi1
        if(nwtot .gt. npts) then
          call abortjob
     &        ('meshpak ', 29,   'nwtot > npts for uniform mesh       '
     &        ,'nwtot   ', nwtot,    'npts    ', npts,     -1)
          write(kuout,2000) nwtot,npts,kpst,kpak
          nwtot     = npts
        endif
c
        zstart    = cstart
        zdsw      = (cfinal-cstart)/(nwtot-1.)
        do 500 nw = 1,nwtot
        swgt(nw)  = zstart + (nw-1.0)*zdsw
  500   continue
c
c
c 5.2 Set up the mesh swgt for the weight function wght over the range
c     from cstart to cfinal for the case with packing.
c
c     For kswmsh .ne. 0, swgt is defined with
c                  kpst  +  kpak*irat/nratnl
c     points around each rational surface and
c                  kpst  +  kpak*(shear/avedshear)*(jpsi-irat)
c     points between each rational surface, where irat = jpsi*zratp.
c
      elseif(kswmsh .gt. 0) then
c
c 5.2.1 Return here to start again if the number of packing points
c       has exceeded the dimensions.  Start loop over packing points.
c
  525   continue
c
c 5.2.2 Initialize loop over packing points.
c
        nwtot     = 1
        nws0      = 1
        nws1      = 1
        nwend     = 0
        zs0       = cstart
        zs1       = cstart
        swgt(1)   = cstart
        lrat1     = nratnl + 1
c
        do 570 lv = 1,lrat1
        lp        = lv
c
c 5.2.3 Place points between the rational surfaces lp-1 to lp
c       from zs0 to zs1.
c
c 5.2.3.1 First find the range and number of points to be placed.
c         Skip this section if either zs0 has reached cfinal or if the
c         previous packed section overlaps this one; if zs1 .lt. zs0
c         or if zs1 .lt. cstart.
        if(zs0 .lt. cfinal) then
          if(lp  .lt. lrat1) zs1  = srat(lp) - zfrac1/swidth(lp)
          if(lp  .eq. lrat1) zs1  = cfinal
c
c 5.2.3.2 Check that the range to fill in is not too small.
          zdiffs   = zs1 - zs0
          if(lp .eq. 1  .and.  lp .eq. lrat1)
     &                  zepspk  = abs(epspak)*(cfinal   - cstart    )
          if(lp .eq. 1  .and.  lp .lt. lrat1)
     &                  zepspk  = abs(epspak)*(srat(lp) - cstart    )
          if(lp .gt. 1  .and.  lp .lt. lrat1)
     &                  zepspk  = abs(epspak)*(srat(lp) - srat(lp-1))
          if(lp .gt. 1  .and.  lp .eq. lrat1)
     &                  zepspk  = abs(epspak)*(cfinal   - srat(lp-1))
c
c 5.2.3.3 Set the range to fill in.
          if    (zdiffs .ge. zepspk  .and.  zs1 .gt. cstart) then
            zdelqs   = zdelq*sign(1.0,dqds(lp))
            if(lp .eq.   1  ) zq0  = zqaxe
            if(lp .gt.   1  ) zq0  = qrat(lp-1) + zdelqs
            if(lp .lt. lrat1) zq1  = qrat(lp)   - zdelqs
            if(lp .eq. lrat1) zq1  = zqlim
c
            zdqinc   = (zq1 - zq0)/(zdelq*zdelcs0)
            nwpt01   = kpst + kpak*iabs(ifix(zdqinc))
            if(nwpt01 .le. 0) then
              call abortjob
     &        ('meshpak ', 30,   'nwpt01 .le. 0: Setting nwpt01=1     '
     &        ,'nwpt01  ', nwpt01,   'lp      ', lp,       -1)
              nwpt01   = 1
            endif
            zds      = zdiffs/float(nwpt01)
c
c 5.2.3.4 Fill in the points for this section between packing points.
            do 530 nwa = 1,nwpt01
            nwtot      = nwtot + 1
            if(nwtot .gt. npts) then
              call abortjob
     &        ('meshpak ', 31,   'nwtot > npts between rationals      '
     &        ,'nwtot   ', nwtot,    'npts    ', npts,      0)
              write(kuout,2010) nwtot,npts,lp,nwa,nwpt01,kpst,kpak
     &                         ,nws0,swgt(nws0)
              kpak   = kpak - 1
              if(kpak .ge. mnpk) go to 525
c
              if(kpak .lt. mnpk) then
                write(kuout,2012) kpak,mnpk
                write(kuout,2015) (swgt(nww),nww = 1,nwtot)
                call abortjob
     &        ('meshpak ', 32,   'kpak >  mnpk between rationals      '
     &        ,'nwtot   ', nwtot,    'kpak    ', kpak,     +1)
              endif
            endif
c
            nwcnt       = nws0 + nwa
            swgt(nwcnt) = zs0  + nwa*zds
  530       continue
c
c 5.2.3.5 Set the point counter nws1 for starting the packing around
c         the rational surface in the case where points were added.
            nws1        = nws0 + nwpt01
c
c 5.2.3.6 Set the point counter nws1 and reset the starting point zs1
c         for starting the packing around the rational surface for
c         the case where no new points were added because either
c         zs0 .gt. zs1  or  zs1 .le. cstart.
          elseif(zdiffs .lt. zepspk  .or.   zs1 .le. cstart) then
            zs1         = zs0
            nws1        = nws0
          endif
c
c 5.2.3.7 Set the point counter nws1 and reset the starting point zs1
c         for starting the packing around the rational surface for
c         the case where no new points were added because zs0 .eq. cfinal.
c         Otherwise, if zs0 .gt. cfinal set zs1 = cfinal and print warning.
        elseif(zs0 .eq. cfinal) then
          zs1         = zs0
          nws1        = nws0
          nwend       = -1
c
        elseif(zs0 .gt. cfinal) then
          zs1         = cfinal
          nws1        = nws0
          nwend       = +1
          call abortjob
     &        ('meshpak ', 33,   'Starting point zs0 exceeds end      '
     &        ,'lp      ', lp,       'nws1    ', nws1,     -1)
        endif
c
c 5.2.4 Place points around the rational surface lp if lp .le. nratnl
c       and the end has not yet been reached.
c       The points are packed in between zs1 = srat(lp) - zfrac1/swidth(lp)
c       and zs2 = srat(lp) + zfrac1/swidth(lp)
c
c
c 5.2.4.1 Check the end is not reached before all rational surfaces
c         have been treated.
        if(lp .lt. lrat1  .and.  nwend .eq. -1) then
          call abortjob
     &        ('meshpak ', 34,   'End reached  before lp = lrat1      '
     &        ,'lp      ', lp,       'lrat1   ', lrat1,    -1)
        endif
c
        if(lp .lt. lrat1  .and.  nwend .eq. +1) then
          call abortjob
     &        ('meshpak ', 35,   'End exceeded before lp = lrat1      '
     &        ,'lp      ', lp,       'lrat1   ', lrat1,    -1)
        endif
c
c 5.2.4.2 Find the number and range of points to be placed.
        if(lp .lt. lrat1  .and.  nwend .eq.  0) then
c
c 5.2.4.2.1 Check for multiple packing  surfaces at the same value.
          kskip     = 1
          zs2a      = srat(lp) + zfrac1/swidth(lp)
          if(lp .lt. nratnl) then
            if    (abs(srat(lp)-srat(lp+1)) .gt. smalls) then
              lp0        = lp
              lpw        = lp
            elseif(abs(srat(lp)-srat(lp+1)) .le. smalls) then
              lp0        = lp
              lpw        = lp
              lpn        = lp
              do 540 lpp = lpn,nratnl-1
              if    (abs(srat(lpp)-srat(lpp+1)) .le. smalls) then
                kskip      = kskip + 1
                lp0        = lpp+1
                zs2aa      = srat(lp0) + zfrac1/swidth(lp0)
                if(zs2aa .le. zs2a) then
                  lpw      = lp0
                  zs2a     = zs2aa
                endif
              elseif(abs(srat(lpp)-srat(lpp+1)) .gt. smalls) then
                go to 550
              endif
  540         continue
c
  550         continue
            endif
c
c 5.2.4.2.2 Check zs2 does not exceed the next rational surface beginning.
c           Note that swidth is an inverse width.
c           If it does then set it between this and the next rational point
c           depending on whether it exceeds the actual rational point and if so,
c           on the relative widths of the two rational points.
c
c 5.2.4.2.2.1 Compare zs2a with the lower limit of the next unique
c             rational surface if there is one.
            if    (lp0 .lt. nratnl) then
              zs2b     = srat(lp0+1) - zfrac1/swidth(lp0+1)
              if    (zs2a .gt. zs2b) then
                if(zs2a .lt. srat(lp0+1)  .and.
     &                                     zs2b .gt. srat(lp0)) then
                  if    (swidth(lpw) .lt. swidth(lp0+1)) then
                    zs2    = zs2b
                  elseif(swidth(lpw) .ge. swidth(lp0+1)) then
                    zs2    = zs2a
                  endif
                endif
                if(zs2a .lt. srat(lp0+1)  .and.  zs2b .le. srat(lp0))
     &            zs2    = zs2a
                if(zs2a .ge. srat(lp0+1)  .and.  zs2b .gt. srat(lp0))
     &            zs2    = zs2b
                if(zs2a .ge. srat(lp0+1)  .and.  zs2b .le. srat(lp0))
     &            zs2    = 0.5*(srat(lp0) + srat(lp0+1))
c
              elseif(zs2a .le. zs2b) then
                zs2    = zs2a
              endif
c
c 5.2.4.2.2.2 Set zs2 at zs2a if there are no more unique rational surfaces.
            elseif(lp0 .eq. nratnl) then
              zs2     = zs2a
            elseif(lp0 .gt. nratnl) then
              zs2     = zs2a
              call abortjob
     &        ('meshpak ', 36,   'Computed lp0 > nratnl:impossible    '
     &        ,'lp      ', lp,       'lp0     ', lp0,      -1)
            endif
c
c 5.2.4.2.3 Set zs2 at zs2a if no more rational surfaces are present.
          elseif(lp .eq. nratnl) then
            zs2    = zs2a
          endif
c
c 5.2.4.2.4 Check zs2 does not exceed the mesh endpoint.
          if(zs2 .gt. cfinal) zs2 = cfinal
c
c 5.2.4.2.5 Set the increments to fill in the points.
          nwpt00    = kpst + kpak*ifix(zfrac1)
          if(nwpt00 .le. 0) then
            call abortjob
     &        ('meshpak ', 37,   'nwpt00 < 0: Resetting nwpt00 = 1    '
     &        ,'nwpt00  ', nwpt00,   'lp      ', lp,       -1)
            nwpt00    = 1
          endif
          if    (zs2 .gt. zs1  .and.  abs(zs2-zs1) .gt. smalls) then
            nwpt12    = kskip*nwpt00
            zds       = (zs2 - zs1) /nwpt12
c
c 5.2.4.3 Fill in the points for this packing point.
            do 560 nwb  = 1,nwpt12
            nwtot       = nwtot + 1
            if(nwtot .gt. npts) then
              call abortjob
     &        ('meshpak ', 38,   'nwtot > npts around rationals       '
     &        ,'nwtot   ', nwtot,    'npts    ', npts,      0)
              write(kuout,2020) nwtot,npts,lp,nwb,nwpt12,kpst,kpak
     &                         ,nws1,swgt(nws1)
              kpak      = kpak - 1
              if(kpak .ge. mnpk) go to 525
c
              if(kpak .lt. mnpk) then
                write(kuout,2013) kpak,mnpk
                write(kuout,2015) (swgt(nww),nww = 1,nwtot)
                call abortjob
     &        ('meshpak ', 39,   'kpak < mnpk around rationals        '
     &        ,'nwtot   ', nwtot,    'kpak    ', kpak,     +1)
              endif
            endif
c
            nwcnt       = nws1 + nwb
            swgt(nwcnt) = zs1  + nwb*zds
  560       continue
c
c 5.2.4.4 Reset the starting values zs0 and nws0 at the point
c         just completed.
            zs0         = zs2
            nws0        = nws1 + nwpt12
c
c 5.2.4.5 Skip packing around this rational surface if too close
c         to the next one and reset the starting values zs0 and nws0
c         at the point just completed.
          elseif(zs2 .gt. zs1  .and.  abs(zs2-zs1) .le. smalls) then
            zs0         = zs2
            nws0        = nws1
c
c 5.2.4.6 Skip packing around this rational surface if less than
c         the next one and reset the starting values zs0 and nws0
c         at the point just completed.
          elseif(zs2 .le. zs1  .and.  abs(zs2-zs1) .le. smalls) then
            zs0           = zs2
            nws0          = nws1
            if(zs2 .lt. zs1) call abortjob
     &        ('meshpak ', 40,   'zs2 slightly< zs1: Reset zs0=zs2    '
     &        ,'lp      ', lp,       'nws0    ', nws0,     -1)
c
c 5.2.4.7 Skip packing around this rational surface if less than
c         the next one and reset the starting values zs0 and nws0
c         at the point just completed.
          elseif(zs2 .le. zs1  .and.  abs(zs2-zs1) .gt. smalls) then
            zs0           = zs2
            nws0          = nws1
            call abortjob
     &        ('meshpak ', 41,   'zs2 strictly< zs1: Reset zs0=zs2    '
     &        ,'lp      ', lp,       'nws0    ', nws0,     -1)
          endif
        endif
c
c 5.2.5 Check the counting of points.
c
        if(nwcnt .ne. nwtot) then
          maxcnt  = max0(nwcnt,nwtot)
          write(kutty,2030) lp,nwcnt,nwtot
          write(kuout,2030) lp,nwcnt,nwtot
          write(kuout,2040)
          write(kuout,2050) (swgt(nww),nww = 1,maxcnt)
          call abortjob
     &        ('meshpak ', 42,   'Miscounted points:nwcnt ne nwtot    '
     &        ,'nwcnt   ', nwcnt,    'nwtot   ', nwtot,    +1)
        endif
  570   continue
      endif
c
c
c 5.3 Set the last point of the mesh at cfinal.
c
      swgt(nwtot)   = cfinal
c
c
c 5.4 Check that swgt is properly ordered.
c
      kdiffs        = 0
      do 580 nw     = 2,nwtot
      nw1           = nw-1
      zswdif        = swgt(nw) - swgt(nw1)
      if(zswdif .le. 0.0) then
        kdiffs        = kdiffs + 1
        write(kuout,2100) kdiffs,nw,swgt(nw),nw1,swgt(nw1),zswdif
      endif
  580 continue
c
      if(kdiffs .gt. 0) then
        write(kutty,2110) kdiffs,nwtot
        write(kuout,2110) kdiffs,nwtot
        write(kuout,2120) (swgt(nww),nww = 1,nwtot)
        call abortjob
     &        ('meshpak ', 43,   'Weight mesh swgt is misordered      '
     &        ,'kdiffs  ', kdiffs,   'nwtot   ', nwtot,    +1)
      endif
c
c
c
c 6.0 Compute the weight function wght over the grid swgt(nw), nw = 1,nwtot.
c
c 6.1 Initialize weight and related values.
c
c 6.1.1 First set all weights to zero.
c
      do 600 nw     = 1,nwtot
      wght(nw)      = 0.0
  600 continue
c
c 6.1.2 Initialize qwgt axis value.
c
      qwgt(1)       = zqaxe
c
c
c 6.2 Add the contribution from equally spaced q.
c
      if(lpakq .ne. 0) then
c
c 6.2.1 Define the unnormalized weights for the contribution from
c       equal spacing in q.
c
c 6.2.1.1 Loop over weighting mesh points.
        do 605 nwv  = 2,nwtot
        nw          = nwv
        zstemp      = swgt(nw)
        zds         = swgt(nw) - swgt(nw-1)
c
c 6.2.1.2 Compute the interpolation coefficients.
        call compar(cs,jpsi1,zstemp,jpt)
        if    (jpt .le. 2) then
          zx1         = cstart
          zx2         = cs   (1)
          zx3         = cs   (2)
          zy1         = zqaxe
          zy2         = qnval(1)
          zy3         = qnval(2)
        elseif(jpt .gt. 2) then
          zx1         = cs   (jpt-2)
          zx2         = cs   (jpt-1)
          zx3         = cs   (jpt)
          zy1         = qnval(jpt-2)
          zy2         = qnval(jpt-1)
          zy3         = qnval(jpt)
        endif
c
c 6.2.1.3 Interpolate to get ntor*q at the point swgt(nw).
        call intqad(zx1,zx2,zx3,zy1,zy2,zy3,zaq,zbq,zcq,ker0)
c
c 6.2.1.4 Check if qnval is monotonic over the surrounding four points.
        if    (jpt .le. 2) then
          zx4         = cs   (  3  )
          zy4         = qnval(  3  )
        elseif(jpt .gt. 2  .and.  jpt .lt. jpsi1) then
          zx4         = cs   (jpt+1)
          zy4         = qnval(jpt+1)
        elseif(jpt .eq. jpsi1) then
          zx4         = cs   (jpsi1) + (zx2 - zx1)
          zy4         = qnval(jpsi1) + (zy2 - zy1)
        endif
c
        if(((zx1 .lt. zx2)  .and.  (zx2 .lt. zx3)  .and.
     &                             (zx3 .lt. zx4))      .or.
     &     ((zx1 .gt. zx2)  .and.  (zx2 .gt. zx3)  .and.
     &                             (zx3 .gt. zx4)))     then
          monotq      = 0
        else
          monotq      = 1
        endif
c
c 6.2.1.5 Check that zq is monotonic with respect to zstemp if qnval
c        is locally monotonic.
c
c 6.2.1.5.1 If qnval is locally monotonic and zq is inside the range,
c           use the interpolation from intqad.
c           If qnval is locally monotonic but zq is well outside the range,
c           set ker1 to redo the interpolation using intlin.
        if    (ker0 .eq. 0  .and.  monotq .eq. 0) then
          zq         = (zaq*zstemp + zbq)*zstemp + zcq
          if    ((zstemp-zx1)*(zstemp-zx2) .le. 0.0) then
            if((zq   -zy1)*(zq   -zy2) .le. 0.0) ker1  = 0
            if((zq   -zy1)*(zq   -zy2) .gt. 0.0) then
              if(abs(zq   -zy1) .le. smallq  .or.
     &           abs(zq   -zy2) .le. smallq)     ker1  = 0
              if(abs(zq   -zy1) .gt. smallq  .and.
     &           abs(zq   -zy2) .gt. smallq)     ker1  = 1
            endif
          elseif((zstemp-zx2)*(zstemp-zx3) .le. 0.0) then
            if((zq   -zy2)*(zq   -zy3) .le. 0.0) ker1  = 0
            if((zq   -zy2)*(zq   -zy3) .gt. 0.0) then
              if(abs(zq   -zy2) .le. smallq  .or.
     &           abs(zq   -zy3) .le. smallq)     ker1  = 0
              if(abs(zq   -zy2) .gt. smallq  .and.
     &           abs(zq   -zy3) .gt. smallq)     ker1  = 2
            endif
          else
            ker1       = 3
          endif
c
c 6.2.1.5.2 If qnval is not locally monotonic set ker1 = 0, print a warning,
c           and use intqad for zq in any case.
        elseif(ker0 .eq. 0  .and.  monotq .ne. 0) then
          zq         = (zaq*zstemp + zbq)*zstemp + zcq
          ker1       = 0
c
          call abortjob
     &        ('meshpak ', 44,   'qnval is locally nonmonotonic       '
     &        ,'nw      ', nw,       'jpt     ', jpt,       0)
c
c 6.2.1.5.3 If intqad failed set ker1 = 0 and redo the interpolation
c           using intlin.
        elseif(ker0 .ne. 0) then
          ker1       = 0
        endif
c
c 6.2.1.6 If the quadratic interpolation failed or zq from intqad is
c       unacceptable, use a linear interpolation from intlin.
c
c 6.2.1.6.1 Print warnings.
        if(ker0 .ne. 0  .or.  ker1 .ne. 0) then
          if(ker0 .ne. 0) call abortjob
     &        ('meshpak ', 45,   'intqad failed: trying intlin        '
     &        ,'ker0    ', ker0,     'nw      ', nw,        0)
          if(ker1 .ne. 0) call abortjob
     &        ('meshpak ', 46,   'intqad zq out of range zy1...zy3    '
     &        ,'ker1    ', ker1,     'nw      ', nw,        0)
c
c 6.2.1.6.2 Use linear interpolation depending on which range the point
c           is in.
          if    ((zstemp  -zx1)*(zstemp  -zx2) .le. 0.0) then
            call intlin(zx1,zx2,zy1,zy2,zaq,zbq,ker2)
          elseif((zstemp  -zx2)*(zstemp  -zx3) .le. 0.0) then
            call intlin(zx2,zx3,zy2,zy3,zaq,zbq,ker2)
c
c 6.2.1.6.3 Use linear interpolation over the whole interval if the
c           correct range could not be determined.
          else
            if((zstemp  -zx1)*(zstemp  -zx3) .le. 0.0) then
              call abortjob
     &        ('meshpak ', 47,   'Trying intlin over full interval    '
     &        ,'nw      ', nw,       'jpt     ', jpt,       0)
              call intlin(zx1,zx3,zy1,zy3,zaq,zbq,ker2)
c
c 6.2.1.6.4 Resort to taking the linear mean of the whole interval if
c           the point is not within the correct range.
            else
              call abortjob
     &        ('meshpak ', 48,   'swgt(nw) outside s(jpt-2),s(jpt)    '
     &        ,'nw      ', nw,       'jpt     ', jpt,      -2)
              zaq     = 0.0
              zbq     = 0.5*(zy1 + zy3)
            endif
          endif
c
c 6.2.1.6.5 Resort to taking the linear mean of the whole interval if
c           an eeror occured in the linear interpolation.
          if(ker2 .ne. 0) then
            call abortjob
     &        ('meshpak ', 49,   'intqad and intlin failed on q(s)    '
     &        ,'ker2    ', ker2,     'nw      ', nw,       -2)
            zaq      = 0.0
            zbq      = 0.5*(zy1 + zy3)
          endif
c
c 6.2.1.6.6 Compute the interpolated value.
          zq         =  zaq*zstemp   + zbq
        endif
c
c 6.2.1.7 Modify the weight from this q value.
        if(nqpack .le. 0) zqmod  = zq
        if(nqpack .gt. 0) zqmod  = zq*(zstemp**nqpack)
c
c 6.2.1.8 Add in the new weight from this q value.
        qwgt(nw)   = zqmod
        wght(nw)   = wght(nw-1) + zds*abs(zqmod)
  605   continue
c
c 6.2.2 Renormalize the weights.
c
        if(wght(nwtot) .eq. 0.0) then
          write(kuout,3000) nwtot,zratq,qpack
          write(kuout,3010)
          write(kuout,3020) (wght(nww),nww=1,nwtot)
          write(kuout,3030)
          write(kuout,3020) (swgt(nww),nww=1,nwtot)
          call abortjob
     &        ('meshpak ', 50,   'q contribution wght(nwtot) = 0      '
     &        ,'nwtot   ', nwtot,    'lpakq   ', lpakq,    +1)
        endif
c
        qnorm      = zratq/wght(nwtot)
        do 610 nw  = 1,nwtot
        wght(nw)   = qnorm*wght(nw)
  610   continue
      endif
c
c
c 6.3 Add in the contribution from equal spacing in cs.
c
      if(lpaks .ne. 0) then
        do 620 nw  = 1,nwtot
        zstemp     = swgt(nw)
        wght(nw)   = wght(nw) + zrats*zstemp
  620   continue
      endif
c
c
c 6.4 Add in the contribution from the packing near rational surfaces.
c
      if(lpakp .ne. 0) then
c
c 6.4.1 Find the normalization from the different weightings given
c       to different rational surfaces.
c
c 6.4.1.1 Loop over packing surfaces.
        sumfac       = zratp/float(nratnl)
c
        sumplpk      = 0.0
        do 630 lp    = 1,nratnl
        jpak         = jplpak (lp)
        jpak0        = iabs   (jpak)
        zdqds        = dqds   (lp)
        jrept        = jrepeat(lp)
c
c 6.4.1.2 Set the base backing to zero or one depending on whether
c         packing is switched off or not.
        if    (nppack .eq. 0) then
          sumbase       = 1.0
        elseif(nppack .lt. 0) then
          if    (jpak .eq. 0) then
            if(zdqds .lt. 0.0) sumbase  = 1.0
            if(zdqds .ge. 0.0) sumbase  = 0.0
          elseif(jpak .lt. 0) then
            sumbase        = 1.0
          elseif(jpak .gt. 0) then
            sumbase        = 1.0
          endif
        elseif(nppack .gt. 0) then
          if    (jpak .eq. 0) then
            if(zdqds .lt. 0.0) sumbase  = 0.0
            if(zdqds .ge. 0.0) sumbase  = 1.0
          elseif(jpak .lt. 0) then
            sumbase        = 1.0
          elseif(jpak .gt. 0) then
            sumbase        = 1.0
          endif
        endif
c
c 6.4.1.3 Switch off packing for repeated specified q surfaces according
c         to nrepeat option.
        if(nrepeat .lt. 0  .and.  jrept .ne. 0  .and.
     &                            jrept .eq. -nrepeat) sumbase  = 0.0
        if(nrepeat .gt. 0  .and.  jrept .ne. 0  .and.
     &                            jrept .ne. +nrepeat) sumbase  = 0.0           
c
c 6.4.1.4 Add extra packing weights for prescribed packing surfaces.
        if    (jpak .lt. 0  .and.  jpak .eq. -mpakk1) then
          zextra       = sedge1
        elseif(jpak .lt. 0  .and.  jpak .ne. -mpakk1) then
          zextra       = pspak(3,jpak0)
        elseif(jpak .eq. 0) then
          zextra       = 0.0
        elseif(jpak .gt. 0) then
          zextra       = plpak(3,jpak0)
        endif
c
c 6.4.1.5 Set the final weight and add it to the normalization.
        sumcont      = 1.0 + zextra
        if(sumcont .lt.   0.0 ) sumcont = 0.0
        if(sumcont .lt. spakmn) sumcont = spakmn
c
        sweight(lp)  = sumbase*sumcont
        sumplpk      = sumplpk + sweight(lp)
  630   continue
c
c 6.4.1.6 Define the normalization factor.
        spaknrm      = sumplpk/nratnl
c
c 6.4.2 Redefine the weights wght.
c
c 6.4.2.1 Loop over weighting mesh points.
        do 650 nw    = 2,nwtot
        zstemp       = swgt(nw)
c
c 6.4.2.2 Sum the contributions from all rational surfaces.
        sumwp        = 0.0
        do 640 lp    = 1,nratnl
        jpak         = jplpak(lp)
        jpak0        = iabs(jpak)
c
        zac0         = atan(swidth(lp)*srat(lp))
        zac0w        = zac0*swidth(lp)
        zac1         = atan(swidth(lp)*(cfinal-srat(lp)))
        zac1w        = zac1*swidth(lp)
        zacs         = atan(swidth(lp)*(zstemp-srat(lp)))
        zacsw        = zacs*swidth(lp)
c
        scont        = (zacsw + zac0w) / (zac1w + zac0w)
c
c 6.4.2.3 Adjust the normalization to account for different weighting.
        splmod       = sweight(lp)
c
c 6.4.2.4 Add the contribution to the weight from this rational surface.
        sumwp        = sumwp + splmod*scont
  640   continue
c
c 6.4.2.5 Add the total contribution from all rational surfaces to wght.
        zsumw        = sumwp*sumfac/spaknrm
        wght(nw)     = wght(nw) + zsumw
  650   continue
      endif
c
c
c 6.5 Check that wght is properly ordered.
c
      kdiffw         = 0
      do 675 nw      = 2,nwtot
      nw1            = nw-1
      zwdif          = wght(nw) - wght(nw1)
c
      if(zwdif .le. 0.0) then
        kdiffw         = kdiffw + 1
        write(kuout,3100) kdiffw,nw,wght(nw),nw1,wght(nw1),zwdif
      endif
  675 continue
c
      if(kdiffw .gt. 0) then
        write(kutty,3110) kdiffw,nwtot
        write(kuout,3110) kdiffw,nwtot
        write(kuout,3120) (wght(nww),nww = 1,nwtot)
        call abortjob
     &        ('meshpak ', 51,   'weight function is misordered       '
     &        ,'kdiffw  ', kdiffw,   'nwtot   ', nwtot,    +1)
      endif
c
c
c 6.6 Compute the derivative of wght(swgt).
c
      nwtm1          = nwtot - 1
      do 680 nw      = 2,nwtm1
      nwp1           = nw+1
      nwm1           = nw-1
      zwdif          = wght(nwp1) - wght(nwm1)
      zswdif         = swgt(nwp1) - swgt(nwm1)
c
      if(zswdif .le. 0.0) call abortjob
     &        ('meshpak ', 52,   'swgt(nw+1) - swgt(nw-1) .le. 0      '
     &        ,'nwp1    ', nwp1,     'nwtot   ', nwtot,    +1)
c
      dwds(  nw )    =  zwdif / zswdif
  680 continue
c
      zwdf1          =  wght(  2  ) - wght(  1  )
      zswdf1         =  swgt(  2  ) - swgt(  1  )
      if(zswdf1 .le. 0.0) call abortjob
     &        ('meshpak ', 53,   'swgt(2) - swgt(1) is .le. zero      '
     &        ,'nwtot   ', nwtot,    'kdiffs  ', kdiffs,   +1)
c
      zwdfn          =  wght(nwtot) - wght(nwtm1)
      zswdfn         =  swgt(nwtot) - swgt(nwtm1)
      if(zswdfn .le. 0.0) call abortjob
     &        ('meshpak ', 54,   'swgt(nwtot)-swgt(nwtot-1) .le. 0    '
     &        ,'nwtot   ', nwtot,    'kdiffs  ', kdiffs,   +1)
c
      dwds(  1  )    =  zwdf1 / zswdf1
      dwds(nwtot)    =  zwdfn / zswdfn
c
c
c
c 7.0 Construct the new weighted mesh and replace cs.
c
      cs(  1  )      = cstart
      cs(jpsi1)      = cfinal
      do 700 jp      = 1,jpsi-1
      zwtemp         = jp*zdelcs
      call compar(wght,nwtot,zwtemp,jpt)
      zdsw           =  swgt(jpt) - swgt(jpt-1)
      zaw            = (wght(jpt) - wght(jpt-1))/zdsw
      cs(jp+1)       =  swgt(jpt) + (zwtemp-wght(jpt))/zaw
  700 continue
c
c
c
c 8.0 Reset psival from the new weighted cs mesh.
c
c 8.1 Construct psival directly from cs in reverse order.
c
      psival(  1  )  = psilim
      psival(jpsi1)  = psimax
      do 800 jp      = 2,jpsi
      jpval          = jpsi1 - jp + 1
      psival(jpval)  = psimax   + 
     &                 delpsr*(((cs(jp)-cstart)/crange)**cspak1)
  800 continue
c
c
c 8.2 Redefine psival at the midpoints.
c     All psival values are reset here except psival(jpsi1) = psimax.
c
      do 810 jp      = 1,jpsi
      psval          = psival(jp)
      psvl1          = psival(jp+1)
      psival(jp)     = 0.5*(psval + psvl1)
  810 continue
c
c
c 8.3 Define psivl0.
c
      do 820 jp      = 2,jpsi1
      psivl0(jp)     = psival(jp-1)
  820 continue
c
c
c 8.4 Check that psival is ordered correctly.
c
      zpsi2          = psilim
      zdpsi2         = 0.0
      jpord          = 0
      do 850 jp      = 1,jpsi
      jp0            = jp
      zpsi1          = 2.0*psival(jp) - zpsi2
      zdpsi1         = zpsi2 - zpsi1
      if(zdpsi2*zdpsi1 .lt. 0.0) then
        jpord          = jpord + 1
        write(kuout,4000) jp0,zdpsi1,zdpsi2,zpsi1,zpsi2
      endif
c
      zpsi2          = zpsi1
      zdpsi2         = zdpsi1
  850 continue
c
      if(jpord .ne. 0) then
        write(kuout,4010)
        write(kuout,4011) (psival(jpp),jpp=1,jpsi1)
        write(kuout,4020)
        write(kuout,4011) (cs    (jpp),jpp=1,jpsi1)
      endif
c
c
c 8.5 Reset cs to the values corresponding to the new midpoint psival values
c     values.
c
      do 860 jp      = 1,jpsi1
      ztemp          = (psival(jp) - psimax)/delpsr
      cs(jp)         =  cstart  +  crange*(abs(ztemp))**cspak0
  860 continue
c
c
c
c 9.0 End Packing Routine.
c
c 9.1 Print out the packing data.
c
c 9.1.1 Print the namelist input.
c
      write(kuout,5000)
      write(kuout,5010) nmesh,mmesh,npak,mpak,nedge,npkmax,
     &                  nrat,nrepeat,nppack,nqpack,nsrcheg,ncutedg,
     &                  psipak,psincr,chiwth,cspak,
     &                  pkfrac,qpfrac,sedg0,sedg1,epsrat,
     &                  minpak,maxpak,incpak,
     &                  epspak,spakmn,swidmn,swidmx
c
c 9.1.2 Print out the rational surface constants.
c
      write(kuout,5100)
      write(kuout,5110) nratmx,nratmx1,nratt,jcutof,jplin,
     &                  wdmin,wdmax
      write(kuout,5120) zqaxe,zqlim,zqmin,zqmax,nqmin,nqmax,jpsmx
      write(kuout,5130) smallq,smalqp
c
c 9.2.3 Print out the packing fractions.
c
      write(kuout,5200)
      write(kuout,5210) fpack,qpack,lpakp,zratp,lpakq,zratq,lpaks,zrats
      write(kuout,5220) fpnorm,pksign,ratpak,qratpk,kswmsh
c
      write(kuout,5230) ksrch,sedge0,sedge1
      write(kuout,5235) kedgabs,kedgevn,kedgadd,kedgwid
c
      write(kuout,5240) nratnl
      write(kuout,5250) zfrac0,zfrac1,zfrac2,zfrac3,
     &                  zpnorm,zwidfac,zdqdfolt,zdeltaq,zdelq,
     &                  zshave,widmin,widmax
c
c 9.1.4 Print out the packing surfaces.
c
      if(npak  .gt. 0) write(kuout,5300) npakk
      if(npak  .lt. 0) write(kuout,5310) npakk
      if(npakk .gt. 0) then
        write(kuout,5320)
        write(kuout,5330) (lt, (plpak(li,lt),li=1,3),
     &                          ldone(lt),lt = 1,npakk)
      endif
c
      if(mpak  .gt. 0) write(kuout,5350) mpakk
      if(mpak  .lt. 0) write(kuout,5360) mpakk
      if(mpakk .gt. 0) then
        write(kuout,5370)
        write(kuout,5380) (ls, (pspak(li,ls),li=1,3),
     &                          mdone(ls),ls = 1,mpakk)
      endif
c
c 9.1.5 Print out the rational surface weights.
c
      write(kuout,5400)
      if(nratnl .gt. 0) then
        write(kuout,5410)
        do 900 lp   = 1,nratnl
        write(kuout,5420) lp,srat  (lp),qrat   (lp),dqds   (lp),
     &                       swidth(lp),sweight(lp),
     &                       jqrat (lp),jplpak (lp),jrepeat(lp)
  900    continue
      endif
c
c 9.1.6 Print out the weight mesh and weights.
c
      write(kuout,5500) nwtot
      if(nwtot  .gt. 0) then
        write(kuout,5510)
        do 910 nw   = 1,nwtot
        write(kuout,5520) nw,swgt(nw),wght(nw),dwds(nw),qwgt(nw)
  910   continue
      endif
c
c 9.1.7 Print out the final mesh.
c
      jp0         = 0
      csv0        = cfinal
      write(kuout,5600) jpsi1
      write(kuout,5610) jp0,csv0,psivl0(1)
      do 920 jp   = 1,jpsi1
      write(kuout,5620) jp,cs(jp),psival(jp),psivl0(jp+1)
  920 continue
c
c
c 9.2 Return and end.
c
      return
c
 1000 format(/, 1x,'Edge packing ignored edge as a packed surface')
 1010 format(   1x,'kedgadd  = ',i5,4x,'kedgabs  = ',i5
     &        , 4x,'kedgwid  = ',i5)
 1020 format(/, 1x,'Packing added edge as a packed surface')
 1030 format(/, 1x,'Edge packing using global shear ')
 1040 format(/, 1x,'Edge packing using local shear ')
 1100 format(   2x, 'There are too many rational surfaces:'
     &         ,1x,'ltrunc = ',i4,4x,'nratmx = ',i4,4x,'nratnl = ',i4
     &         ,4x,'nqmin  = ',i5,4x,'nqmax  = ',i5,/
     &         ,10x,'Packing is truncated at jqrat = ',i4
     &         ,4x,'jplpak = ',i4,4x,'jrepeat = ',i4
     &         ,4x,'qrat = ',e16.6,/)
 1110 format(   2x, 'Resorting to uniform mesh for zsw'
     &      ,/,10x,'nratnl = ',i5,4x,'jpsi  = ',i5
     &         ,4x,'zratp  = ',e16.6)
 2000 format(/, 2x, 'The number of weight mesh points in swgt nwtot = '
     &      ,i6,2x,'has exceeded npts = ',i6,2x,'(parameter nptt)',/
     &      ,5x,'for the case with no packing, kpst = ',i2
     &         ,', and kpak = ',i2,/
     &      ,2x,'nwtot has been reset to npts',/)
 2010 format(/, 2x, 'The number of weight mesh points in swgt nwtot = '
     &      ,i6,2x,'has exceeded npts = ',i6,2x,'(parameter nptt)',/
     &      ,5x,'Before rational surface lp = ',i4,4x,'nwa = ',i4
     &      ,4x,'nwpt01 = ',i4,4x,'kpst = ',i2,4x,'kpak = ',i2,/
     &      ,5x,'Last point filled: swgt(',i5,') = ',e12.5,/
     &      ,5x,'Decrementing kpak by one and trying again')
 2012 format(//,2x,'The value of kpak has been reduced below mnpk'
     &      ,5x,'kpak   = ',i5,4x,'mnpk   = ',i5
     &      ,//,5x,'swgt mesh:',/)
 2013 format(//,2x,'The value of kpak has been reduced below mnpk',/
     &      ,5x,'kpak   = ',i5,4x,'mnpk   = ',i5
     &      ,//,5x,'swgt mesh:',/)
 2015 format(10(1x,e12.5))
 2020 format(/, 2x, 'The number of weight mesh points in swgt nwtot = '
     &      ,i6,2x,'has exceeded npts = ',i6,2x,'(parameter nptt)',/
     &      ,5x,'At     rational surface lp = ',i4,4x,'nwb = ',i4
     &      ,4x,'nwpt12 = ',i4,4x,'kpst = ',i2,4x,'kpak = ',i2,/
     &      ,5x,'Last point filled: swgt(',i5,') = ',e12.5,/
     &      ,5x,'Decrementing kpak by one and trying again')
 2030 format(//,2x, 'The weighting function mesh swgt in subroutine'
     &         ,1x,'mesh is incorrectly filled for lp  =',i5,/
     &         ,10x,'nwcnt  = ',i5,4x,'nwtot  = ',i5)
 2040 format(/,5x, 'swgt array:',/)
 2050 format(10(1x,e12.5))
 2100 format(/, 2x, 'The mesh weighting function swgt in subroutine'
     &      ,' mesh is improperly ordered:',4x,'kdiffs  = ',i5,/
     &      ,4x,'swgt(',i5,')  = ',e16.6,4x,'swgt(',i5,')  = ',e16.6
     &      ,4x,'difference   = ',e16.6)
 2110 format(/, 2x, 'Fatal Error: the mesh weighting function swgt in'
     &      ,' subroutine mesh is improperly ordered:',/
     &      ,4x,'kdiffs  = ',i5,4x,'nwtot  = ',i5)
 2120 format(10(1x,e12.5))
 3000 format(//,2x, 'No weight is defined for q in subroutine mesh:'
     &      ,/,10x,' nwtot = ',i5,4x,'zratq = ',e12.5
     &      ,4x,'qpack = ',e12.5,/)
 3010 format(/,10x,'wght:')
 3020 format(10(1x,e12.5))
 3030 format(/,10x,'swgt:')
 3100 format(/, 2x, 'The weighting function wght in subroutine'
     &      ,' mesh is improperly ordered:',4x,'kdiffw  = ',i5,/
     &      ,4x,'wght(',i5,')  = ',e16.6,4x,'wght(',i5,')  = ',e16.6
     &      ,4x,'difference   = ',e16.6)
 3110 format(/,10x,'Fatal Error: the weighting function wght in'
     &      ,' subroutine mesh is improperly ordered:',/
     &      ,4x,'kdiffw  = ',i5,4x,'nwtot  = ',i5)
 3120 format(10(1x,e12.5))
 4000 format(/, 2x, 'Warning; new packed psival array is not properly'
     &      ,' ordered at jp = ',i4,/
     &      ,10x,'zdpsi1 = ',e12.5,4x,'zdpsi2 = ',e12.5
     &      ,4x, 'zpsi1  = ',e12.5,4x,'zpsi2  = ',e12.5,/)
 4010 format(10x,'psival:')
 4011 format(10(1x,e12.5))
 4020 format(/,10x,'cs:')
 5000 format(//,10x,'Mesh Packing Data',/,10x,'---- ------- ----',/
     &         ,5x, 'Namelist Input Parameters',/)
 5010 format(1x, 'nmesh    = ',i5,15x,  'mmesh    = ',i5,/
     &      ,1x, 'npak     = ',i5,15x,  'mpak     = ',i5
     &      ,15x,'nedge    = ',i5,/
     &      ,1x, 'npkmax   = ',i5,15x,  'nrat     = ',i5
     &      ,15x,'nrepeat  = ',i5,15x,/
     &      ,1x, 'nppack   = ',i5,15x,  'nqpack   = ',i5
     &      ,1x, 'nsrcheg  = ',i5,15x,  'ncutedg  = ',i5,//
     &      ,1x, 'psipak   = ',e16.9,4x,'psincr   = ',e16.9
     &      ,4x, 'chiwth   = ',e16.9,4x,'cspak    = ',e16.9,/
     &      ,1x, 'pkfrac   = ',e16.9,4x,'qpfrac   = ',e16.9,/
     &      ,1x, 'sedg0    = ',e16.9,4x,'sedg1    = ',e16.9
     &      ,4x, 'epsrat   = ',e16.9,/
     &      ,1x, 'minpak   = ',i5,15x,  'maxpak   = ',i5
     &      ,15x,'incpak   = ',i5,/
     &      ,1x, 'epspak   = ',e16.9,4x,'spakmn   = ',e16.9
     &      ,4x, 'swidmn   = ',e16.9,4x,'swidmx   = ',e16.9)
 5100 format(/,5x, 'Rational Surface Constants',/)
 5110 format(1x, 'nratmx   = ',i5,15x,  'nratmx1  = ',i5
     &      ,15x,'nratt    = ',i5,/
     &      ,1x, 'jcutof   = ',i5,15x,  'jplin    = ',i5,/
     &      ,1x, 'wdmin    = ',e16.9,4x,'wdmax    = ',e16.9)
 5120 format(1x, 'zqaxe    = ',e16.9,4x,'zqlim    = ',e16.9
     &      ,4x, 'zqmin    = ',e16.9,4x,'zqmax    = ',e16.9,/
     &      ,1x, 'nqmin    = ',i5,15x,  'nqmax    = ',i5
     &      ,15x,'jpsmx    = ',i5)
 5130 format(1x, 'smallq   = ',e16.9,4x,'smalqp   = ',e16.9)
 5200 format(/,5x, 'Packing Fractions',/)
 5210 format(1x, 'fpack    = ',e16.9,4x,'qpack    = ',e16.9,/
     &      ,1x, 'lpakp    = ',i5,15x,  'zratp    = ',e16.9,/
     &      ,1x, 'lpakq    = ',i5,15x,  'zratq    = ',e16.9,/
     &      ,1x, 'lpaks    = ',i5,15x,  'zrats    = ',e16.9)
 5220 format(1x, 'fpnorm   = ',e16.9,4x,'pksign   = ',e16.9,/
     &      ,1x, 'ratpak   = ',e16.9,4x,'qratpk   = ',e16.9
     &      ,4x, 'kswmsh   = ',i5)
 5230 format(1x, 'ksrch    = ',i5
     &      ,15x,'sedge0   = ',e16.9,4x,'sedge1   = ',e16.9)
 5235 format(1x, 'kedgabs  = ',i5,15x,  'kedgevn  = ',i5
     &      ,15x,'kedgadd  = ',i5,15x,  'kedgwid  = ',i5)
 5240 format(//,5x,'Rational Surface Packing',/
     &      ,1x, 'Total Number of Packing Surfaces:'
     &      ,19x,'nratnl   = ',i5)
 5250 format(/,1x, 'Packing Constants:',/
     &      ,1x, 'zfrac0   = ',e16.9,4x,'zfrac1   = ',e16.9,/
     &      ,1x, 'zfrac2   = ',e16.9,4x,'zfrac3   = ',e16.9,/
     &      ,1x, 'zpnorm   = ',e16.9,4x,'zwidfac  = ',e16.9,/
     &      ,1x, 'zdqdfolt = ',e16.9,4x,'zdeltaq  = ',e16.9
     &      ,4x, 'zdelq    = ',e16.9,/
     &      ,1x, 'zshave   = ',e16.9,4x,'widmin   = ',e16.9
     &      ,4x, 'widmax   = ',e16.9)
 5300 format(/,1x, 'Specified Packing at q locations:'
     &      ,17x,'npakk    = ',i5)
 5310 format(/,1x, 'Specified Packing at n*q locations:'
     &      ,15x,'npakk    = ',i5)
 5320 format(4x, 'lt',6x,'plpak(1,lt)',6x,'plpak(2,lt)'
     &      ,6x, 'plpak(3,lt)',4x,'ldone(lt)',/)
 5330 format(1x,i6,1x,e16.9,1x,e16.9,1x,e16.9,1x,i5)
 5350 format(/,1x, 'Specified Packing at flux locations:'
     &      ,14x,'mpakk    = ',i5)
 5360 format(/,1x, 'Specified Packing at cs locations:'
     &      ,16x,'mpakk    = ',i5)
 5370 format(4x, 'ls',6x,'pspak(1,ls)',6x,'pspak(2,ls)'
     &      ,6x, 'pspak(3,ls)',4x,'mdone(ls)',/)
 5380 format(1x,i6,1x,e16.9,1x,e16.9,1x,e16.9,1x,i5)
 5400 format(//,5x,'Rational Surface Weights',/)
 5410 format(5x, 'lp',9x,'srat',11x,'n*qrat',12x,'dqds'
     &      ,12x,'swidth',9x,'sweight',11x,'jqrat',3x,'jplpak'
     &      ,2x,'jrepeat',/)
 5420 format(1x,i6,5(1x,e16.9),3x,i6,3x,i6,3x,i6)
 5500 format(//,5x,'Weight Mesh'
     &      ,17x,'nwtot    = ',i5,/)
 5510 format(4x, 'nw',10x,'swgt',12x,'wght',12x,'dwds',13x,'qwgt',/)
 5520 format(1x,i6,4(1x,e16.9))
 5600 format(//,5x,'Final Mesh'
     &      ,17x,'jpsi1    = ',i5,//
     &      ,4x, 'jp',10x,'cs',13x,'psival',11x,'psivl0',/)
 5610 format(1x,i6,1x,e16.9,18x,e16.9)
 5620 format(1x,i6,3(1x,e16.9))
      end
      subroutine intqad(px1,px2,px3,py1,py2,py3,pa,pb,pc,ier)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize parameters
c
      ier      = 0
c
c
c 1.2 Check if mesh is improperly ordered
c
      zdx1     = (px1-px2)
      zdx2     = (px2-px3)
      zdx3     = (px1-px3)
      if(zdx1 .eq. 0.0  .or.  zdx2 .eq. 0.0  .or.
     &                        zdx3 .eq. 0.0) then
        ier      = -1
        return
      endif
c
      if(zdx1*zdx3 .lt. 0.0) then
        ier      = +1
        return
      endif
c
c
c
c 2.0 Compute quadratic interpolation coefficients
c
      zda      = (py1-py2)/zdx1
      zdb      = (py1-py3)/zdx3
      pa       = ( zda - zdb )/zdx2
      pb       =   zda   -  pa*(px1+px2)
      pc       = py2  - (pa*px2 + pb)*px2
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine intlin(px1,px2,py1,py2,pa,pb,ier)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize parameters
c
      ier      = 0
c
c 1.2 Check if mesh is improperly ordered
c
      zdx1     = (px1-px2)
      if(zdx1 .eq. 0.0) then
        ier      = -1
        return
      endif
c
c
c
c 2.0 Compute linear interpolation coefficients
c
      zda      = (py1-py2)/zdx1
      pa       = zda
      pb       = py2  - pa*px2
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine remove(xp,yp,gp,mdim,mp,deltar,delta0)
c-----------------------------------------------------------------------
c the interpolation and extrapolation routines are inaccurate if some of
c points found by furplm or cntour are too close together.  This routine
c chooses a subset of those points which are well spaced and redefines
c the arrays xp, yp, and gr to apply only to these points.
c The point deleted is chosen to make the spacing the most even, except
c at the endpoints where the endpoint is always retained and the
c neighbouring point is removed.
c-----------------------------------------------------------------------
c
      dimension xp(mdim),yp(mdim),gp(mdim)
c
c
c
c 1.0 Initialization
c
      mp0      = mp-1
      mpi      = mp0
      delta2   = delta0*delta0
      deltas   = deltar*deltar
c
c
c
c 2.0 Run through the points
c
      do 100 i = 1,mp0
c
c
c 2.1 End if all points have been checked
c
      if(i .gt. mpi) go to 120
c
c
c 2.2 Set local distance between points
c
   10 im1      = i-1
      ip1      = i+1
      ip2      = i+2
      xs       = (xp(ip1) - xp(i))**2
      ys       = (yp(ip1) - yp(i))**2
      ds       = xs + ys
c
c
c 2.3 Set nearby distances
c
c 2.3.1 For the first point
c
      if    (i .eq.  1  ) then
        icase    = -1
        xsl      =  0.0
        ysl      =  0.0
        xsr      = (xp(ip2) - xp(ip1))**2
        ysr      = (yp(ip2) - yp(ip1))**2
        dsl      = xsl + ysl
        dsr      = xsr + ysr
        ikill    =  2
c
c 2.3.2 For interior points
c
      elseif((i .gt. 1) .and. (i .lt. mpi)) then
        icase    =  0
        xsl      = (xp( i ) - xp(im1))**2
        ysl      = (yp( i ) - yp(im1))**2
        xsr      = (xp(ip2) - xp(ip1))**2
        ysr      = (yp(ip2) - yp(ip1))**2
        dsl      = xsl + ysl
        dsr      = xsr + ysr
        if(deltas .eq. 0.0) then
          ikill    = ip1
        else
          if(dsl .ge. dsr) ikill  =  ip1
          if(dsl .lt. dsr) ikill  =  i
        endif
c
c 2.3.3 For the final point
c
      elseif( i .eq. mpi ) then
        icase    = +1
        xsl      = (xp( i ) - xp(im1))**2
        ysl      = (yp( i ) - yp(im1))**2
        xsr      =  0.0
        ysr      =  0.0
        dsl      = xsl + ysl
        dsr      = xsr + ysr
        ikill    =  mpi
      endif
c
c
c 2.4 Delete points if too close
c
c 2.4.1 Decide whether to delete
c
      if(  ((delta2 .ne. 0.0  .and.  deltas .ne. 0.0)  .and.
     &     ((ds .lt. delta2) .and.
     &      (ds .lt. deltas*dsl .or. ds .lt. deltas*dsr)))   .or.
     &     ((delta2 .eq. 0.0)                          .and.
     &      (ds .lt. deltas*dsl .or. ds .lt. deltas*dsr))    .or.
     &     ((deltas .eq. 0.0)  .and.  (ds .lt. delta2))  )     then
c
c 2.4.2 Shuffle points back
c
        do 20 j  = ikill,mpi
        xp(j)    = xp(j+1)
        yp(j)    = yp(j+1)
        gp(j)    = gp(j+1)
   20   continue
c
c 2.4.3 Reset the number of points and set case for next point
c
        mpi      = mpi-1
        if(icase .eq. -1) go to 10
        if(icase .eq.  0) go to 10
        if(icase .eq. +1) go to 120
      endif
  100 continue
c
c
c
c 3.0 Reset the total number of points and gp
c
  120 mp       = mpi+1
c
      do 200 i = 1,mp
      gp(i)    = abs(gp(i))
  200 continue
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cubic(p1,p2,p3,p4,p,acoef,bcoef,ccoef,dcoef,tiny
     &                                                      ,iwn,kwn)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize warning flags
c
      iwn       = 0
      kwn       = 0
      intvlck   = 0
c
c
c 1.2 Set grid increments
c
c 1.2.1 Set the increments
c
      p1p2      =  p1 - p2
      p2p3      =  p2 - p3
      p3p4      =  p3 - p4
      p1p3      =  p1 - p3
      p2p4      =  p2 - p4
      p1p4      =  p1 - p4
c
c 1.2.2 Check the interval is well ordered
c
c 1.2.2.1 Find the interval senses
      k12       =  sign(1.5,p1p2)
      k23       =  sign(1.5,p2p3)
      k34       =  sign(1.5,p3p4)
c
c 1.2.2.2 Check there is a finite interval
      if    ((abs(p1p2) .lt. tiny)  .and.  (abs(p2p3) .lt. tiny)  .and.
     &                                     (abs(p3p4) .lt. tiny)) then
         intvlck  = +1

c
c 1.2.2.3 Check all three intervals are the same sense
      else
         if(iabs(k12 + k23 + k34) .ne. 3) then
            intvlck  =  +2
         endif
      endif
c
c
c 1.3 Set the local coordinate values
c
c 1.3.1 Set the values
c
      pp1       =  p - p1
      pp2       =  p - p2
      pp3       =  p - p3
      pp4       =  p - p4
c
c 1.3.2 If the intervals are ordered check if the point is in the
c       innermost interval between p2 and p3
c
      if(intvlck .eq. 0) then
c
c 1.3.2.1 Check the point is within the full range
         if    (pp1*pp4 .gt. 0.0) then
            if(abs(pp1) .ge. abs(pp4)) intvlck = -3
            if(abs(pp1) .lt. abs(pp4)) intvlck = +3

c
c 1.3.2.2 Check the point is within the middle interval
         elseif(pp1*pp4 .lt. 0.0) then     
            if(pp2*pp3 .gt. 0.0  .and. abs(pp2) .ge. tiny  .and.
     &                                 abs(pp3) .ge. tiny)  then
               if(abs(pp2) .ge. abs(pp3)) intvlck = -4
               if(abs(pp2) .lt. abs(pp3)) intvlck = +4
            endif
         endif
      endif
c
c
c
c 2.0 Set the choice of fit
c
c 2.1 Default fit for the case where the point is in the middle interval
c
      if    (intvlck .eq. 0) then
c
c 2.1.1 If all points are well spaced use default cubic fit
c
         kparab    = 0
c
c 2.1.2 If two intervals are too small use linear fit across the full range 
c
         if    ((abs(p1p2) .lt. tiny  .and.  abs(p2p3) .lt. tiny)  .or.
     &          (abs(p1p2) .lt. tiny  .and.  abs(p3p4) .lt. tiny)  .or.
     &          (abs(p2p3) .lt. tiny  .and.  abs(p3p4) .lt. tiny)) then
            kparab = +1
c
c 2.1.3 If at least one interval is too small use a lower order fit
c       Otherwise leave the fit at the default full cubic
c
         else
c
c 2.1.3.1 if point p2 is coincident with point p3 use constant value
c         of point p2 
            if    (abs(p2p3) .lt. tiny) then
               kparab = +2
c
c 2.1.3.2 If point p1 is coincident with point p2 use right parabolic fit 
c         (ignore p2)
            elseif(abs(p1p2) .lt. tiny) then
               kparab = +3
c
c 2.1.3.3 If point p4 is coincident with point p3 use left  parabolic fit
c         (ignore p3)
            elseif(abs(p3p4) .lt. tiny) then
               kparab = +4
            endif
         endif
c
c
c 2.2 Set cases where the intervals are not standard
c
c 2.2.1 For a mesh with no defined total interval use the mid value
c
      elseif(intvlck .eq. +1) then
         kparab  = +2
c
c 2.2.2 For non-uniform mesh use a left or right parabolic fit depending
c       on which interval is reversed
c
      elseif(intvlck .eq. +2) then
c
c 2.2.2.1 For the case where two intervals are vanishingly small
         if    ((abs(p1p2) .lt. tiny  .and.  abs(p2p3) .lt. tiny)  .or.
     &          (abs(p2p3) .lt. tiny  .and.  abs(p3p4) .lt. tiny)  .or.
     &          (abs(p1p2) .lt. tiny  .and.  abs(p3p4) .lt. tiny)) then
            kparab  = +1
c
c 2.2.2.2 For the case where at most one interval is vanishingly small
         else
c
c 2.2.2.2.1 Set a default for cases not covered
            kparab  = -1
c
c 2.2.2.2.2 For the case where all points are distinct use a right or left 
c           parabolic fit depending on which interval is reversed
            if    ((abs(p1p2) .ge. tiny)  .and.
     &             (abs(p2p3) .ge. tiny)  .and.
     &             (abs(p3p4) .ge. tiny))    then
               if(iabs(k12 + k23) .ne. 2) kparab = +3
               if(iabs(k12 + k23) .eq. 2) kparab = +4
c
c 2.2.2.2.3 For the case where p1 and p2 are coincident use a right
c           parabolic fit through points p2, p3, and p4
            elseif((abs(p1p2) .lt. tiny)  .and.
     &             (abs(p2p3) .ge. tiny)  .and.
     &             (abs(p3p4) .ge. tiny))    then
               kparab  = +3
c
c 2.2.2.2.4 For the case where p3 and p4 are coincident use a left
c           parabolic fit through points p1, p2, and p3
            elseif((abs(p1p2) .ge. tiny)  .and.
     &             (abs(p2p3) .ge. tiny)  .and.
     &             (abs(p3p4) .lt. tiny))    then
               kparab  = +4
c
c 2.2.2.2.5 For the case where p2 and p3 are coincident use a parabolic
c           fit through points p1, p3, and p4
            elseif((abs(p1p2) .ge. tiny)  .and.
     &             (abs(p2p3) .lt. tiny)  .and.
     &             (abs(p3p4) .ge. tiny))    then
               kparab  = +5
            endif
         endif
c
c 2.2.3 If the point is outside the full range use a lower order fit
c
      elseif(iabs(intvlck) .eq. +3) then
c
c 2.2.3.1 If points are not well spaced use a linear  fit through
c         the endpoints 
         if    ((abs(p1p2) .lt. tiny  .and.  abs(p2p3) .lt. tiny)  .or.
     &          (abs(p1p2) .lt. tiny  .and.  abs(p3p4) .lt. tiny)  .or.
     &          (abs(p2p3) .lt. tiny  .and.  abs(p3p4) .lt. tiny)) then
            kparab = +1
c
c
c 2.2.3.2 If points are well spaced use a parabolic fit ignoring points
c         p1 or p4 accordingly
         else
c
c 2.2.3.2.1 Set a default for cases not covered
            kparab  = -2
c
c 2.2.3.2.2 If points are well spaced use a right or left parabolic fit 
c           ignoring points p1 or p4 accordingly
            if    ((abs(p1p2) .ge. tiny)  .and.
     &             (abs(p3p4) .ge. tiny))    then
               if(intvlck .eq. -3) kparab = +3
               if(intvlck .eq. +3) kparab = +4
c
c 2.2.3.2.3 If any two points are coincident use parabolic fit ignoring 
c           the coincident point
            elseif(abs(p3p4) .lt. tiny) then
               kparab = +5
            elseif(abs(p1p2) .lt. tiny) then
               kparab = +6
            endif
         endif
c
c 2.2.4 If the point is outside the middle range use a lower order fit 
c
      elseif(iabs(intvlck) .eq. +4) then
c
c 2.2.4.1 If points are not well spaced use a linear fit through the
c         endpoints 
         if    ((abs(p1p2) .lt. tiny  .and.  abs(p2p3) .lt. tiny)  .or.
     &          (abs(p1p2) .lt. tiny  .and.  abs(p3p4) .lt. tiny)  .or.
     &          (abs(p2p3) .lt. tiny  .and.  abs(p3p4) .lt. tiny)) then
            kparab = +1
c
c 2.2.4.2 If no two points are coincident use full cubic fit or
c         if middle points are coincident then use a middle parabolic fit        
         else
c
c 2.2.4.2.1 Set a default for cases not covered
            kparab  = -3
c
c 2.2.4.2.2 If no two points are coincident use full cubic fit or 
c           if middle points are coincident then use a middle parabolic fit
            if    ((abs(p1p2) .ge. tiny)  .and.
     &             (abs(p3p4) .ge. tiny)) then
               if(abs(p2p3) .ge. tiny) kparab =  0
               if(abs(p2p3) .lt. tiny) kparab = +5
c
c 2.2.4.2.3 If point p1 is coincident with point p2 use right parabolic fit 
            elseif(abs(p1p2) .lt. tiny) then
               kparab = +3
c
c 2.2.4.2.4 If point p4 is coincident with point p3 use left  parabolic fit 
            elseif(abs(p3p4) .lt. tiny) then
               kparab = +4
            endif
         endif
c
c 2.2.5 Use the full cubic fit if there is a logic error
c
      else
            kparab =  -4
      endif
c
c
c
c 3.0 Perform the fit
c
c 3.1 Cubic fit between four points
c
      if    (kparab .le. 0) then
         acoef     =  pp2*pp3*pp4 / (p1p2*p1p3*p1p4)
         bcoef     = -pp1*pp3*pp4 / (p1p2*p2p3*p2p4)
         ccoef     =  pp1*pp2*pp4 / (p1p3*p2p3*p3p4)
         dcoef     = -pp1*pp2*pp3 / (p1p4*p2p4*p3p4)
c
c
c 3.2 Linear fit between the two endpoints
c
      elseif(iabs(kparab) .eq. +1) then
         acoef     = +pp4/p1p4
         bcoef     = 0.0
         ccoef     = 0.0
         dcoef     = -pp1/p1p4
c
c
c 3.3 Use the constant value at point p2
c
      elseif(iabs(kparab) .eq. +2) then
         acoef     = 0.0
         bcoef     = 1.0
         ccoef     = 0.0
         dcoef     = 0.0
c
c
c 3.4 Parabolic fit between three points
c
c 3.4.1 Right parabola between points p2, p3, and p4
      elseif(iabs(kparab) .eq. +3) then
         acoef     = 0.0
         call parab(p2,p3,p4,p,bcoef,ccoef,dcoef,tiny,kwn)
c
c 3.4.2 Left  parabola between points p1, p2, and p3
      elseif(iabs(kparab) .eq. +4) then
         dcoef     = 0.0
         call parab(p1,p2,p3,p,acoef,bcoef,ccoef,tiny,kwn)
c
c
c 3.5 Use parabolic fit between points p1, p3, and p4
c
      elseif(iabs(kparab) .eq. +5) then
         bcoef     = 0.0
         call parab(p1,p3,p4,p,acoef,ccoef,dcoef,tiny,kwn)
c
c
c 3.6 Use parabolic fit between points p1, p2, and p4
c
      elseif(iabs(kparab) .eq. +6) then
         ccoef     = 0.0
         call parab(p1,p2,p4,p,acoef,bcoef,dcoef,tiny,kwn)
      endif
c
c
c 4.0 Set warning parameters
c
c 4.1 Set warning from interval check
c
      if    (intvlck .ne. 0) then
         iwn      =  iabs(intvlck)
c
c
c 4.2 Set warning from kparab if reduced order is used
c
c 4.2.1 Set warning if serious error in choice of fit
c
      elseif(intvlck .eq. 0  .and.  kparab .lt. 0) then
         iwn      =  kparab
c
c 4.2.2 Set warning if simple loss of order in fit
c
      elseif(intvlck .eq. 0  .and.  kparab .gt. 0) then
           if(kwn .eq.  0) iwn   = +kparab + 4
           if(kwn .ne.  0) iwn   = +kparab + 11
      endif
c
      return
      end
      subroutine parab(p1,p2,p3,p,acoef,bcoef,ccoef,tiny,kwn)
c
c
c
c 1.0 Initialization
c
      kwn    = 0
c
      p1p2   = p1 - p2
      p2p3   = p2 - p3
      p1p3   = p1 - p3
      pp1    = p  - p1
      pp2    = p  - p2
      pp3    = p  - p3
c
c
c
c 2.0 Construct the parabolic interpolation
c
c 2.1 For p2 and p3 not coincident attempt a parabolic fit
c
      if    (abs(p2p3) .ge. tiny) then
c
c 2.1.1 Use a parabolic fit if p1, p2, and p3 are all different
c
        if    ((abs(p1p2) .ge. tiny)  .and.  (abs(p1p3) .ge. tiny)) then
c
c 2.1.1.1 Check p1p2 and p2p3 have the same sign
          k12    = sign(1.5,p1p2)
          k23    = sign(1.5,p2p3)
c
c 2.1.1.2 If p1p2 and p2p3 have the same sign use the parabolic fit
          if    (iabs(k12+k23) .eq.  2) then
            acoef  = +(pp2*pp3) / (p1p2*p1p3)
            bcoef  = -(pp1*pp3) / (p1p2*p2p3)
            ccoef  = +(pp1*pp2) / (p1p3*p2p3)
            return
c
c 2.1.1.3 If p1p2 and p2p3 have different sign, revert to a linear fit
c         between p2 and p3
          else
            kwn     = +1
            acoef   =  0.0
            bcoef   = +pp3/p2p3
            ccoef   = -pp2/p2p3
            return
          endif
c
c 2.1.2 Use a linear fit between p2 and p3 if p1 = p2 or p1 =p3
c
        elseif((abs(p1p2) .lt. tiny)  .or.   (abs(p1p3) .lt. tiny)) then
          kwn     = +2
          acoef   =  0.0
          bcoef   = +pp3/p2p3
          ccoef   = -pp2/p2p3
          return
        endif
c
c
c 2.2 For p2 and p3 equal use linear interpolation between p1 and p3
c
      elseif(abs(p2p3) .lt. tiny) then
        kwn     = +3
        acoef   = +pp3/p1p3
        bcoef   =  0.0
        ccoef   = -pp1/p1p3
        return
      endif
c
c
c 3.0 Return and end
c
      return
      end
      subroutine psifit(jp,iax,jax,rax,yax,psiax,ier)
c----------------------------------------------------------------------
c
c  This routine fits psi to the analytic form--
c   psi  = psimin  +  rho**2*rj0/4
c                  +  sa2*rho**2*cos(2*w)
c                  +  sb2*rho**2*sin(2*w)
c                  + (sa2/(4*r)-pp*r/4+rj0/(16*r))*rho**3*cos(w)
c                  +  sb2*rho**3*sin(w)/(4*r)
c                  +  sa3*rho**3*cos(3*w)
c                  +  sb3*rho**3*sin(3*w)
c                  +  rho**4*( -rj0*rjp/64-(4*sa2+8*r**2*pp+rj0)/(128*r**2)
c                  + (sa3/(4*r)-(4*sa2+4*r**2*pp+rj0)/(64*r**2)-sa2*rjp/12)*cos(2*w)
c                  + (sb3/(4*r)-sb2/(16*r**2)-sb2*rjp/12)*sin(2*w)
c                  +  sa4*cos(4*w) +sb4*sin(4*w) )
c
c            pp  =  pprime(psimin)
c            rj0 = -r**2*pp-ffprime(psimin)
c            rjp = -(rj)prime
c  The output are the coefficients:
c          sa0, sa2, sa3, sa4, sb2, sb3, sb4, rpsi and zpsi
c               where
c          rho  = sqrt((x-rpsi)**2+(y-zpsi)**2)
c               and
c          w    = atan((y-zpsi)/(x-rpsi))
c
c  The fitting is a three step process
c
c     (1)  Input the grid point at which psi is to be fitted
c
c     (2)  Set sa0=psimin, rpsi=rax, zpsi=yax
c
c     (3)  Perform the least squares fit for parameters sa2, sb2, sa3, sb3,
c           sa4, sb4
c
c  In a fourth step, the fit is checked against nearby psi values
c
c---------------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nf1=121,nf2=6,nf3=1,nf4=(nf2*(nf2+1))/2)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/psft/  rpsi,zpsi,rj0,rjp,rj3,rj5,rj7,sa0,sa2,sa3,sa4,
     &              sb2,sb3,sb4
c
      dimension als(nf1,nf2),bls(nf1,nf3),tls(nf2,nf3),wkx(nf4)
c
c
c
c 1.0 Initialize parameters
c
c 1.1 Initialize error parameters
c
      ier        = 0
      nptmin     = nf2 + nfitpts
      nk         = nf4
c
      rndff      = roundff
c
c
c 1.2 Initialize work arrays for ofima3
c
      tls(1,1)   = 0.0
      wkx(1)     = 0.0
c
c
c 1.3 Set the first coefficient
c
      sa0        = psiax
c
c
c 1.4 Initialize local equilibrium data
c
c 1.4.1 Axis values
c
      rpsi       = rax
      zpsi       = yax
c
c 1.4.2 Profile data: pprime ffprime, d/dpsi(pprime) and d/dpsi(ffprime)
c
c 1.4.2.1 For standard profiles
      if    (npst .eq. 0) then
         pp0       = amu*pp (jp)
         fp0       =     ffp(jp)
c
         p2p       = amu*sterpp(psival(jp),psimsh,spp, cspp, nprofl,
     &                                     npp,0, rndff, ierpp)
         f2p       =     sterpp(psival(jp),psimsh,sffp,csffp,nprofl,
     &                                     npp,0, rndff, ierfp)
c
         if(ierpp .ne. 0) call abortjob
     &        ('psifit  ',  1,   'Spline evaluation error:dpp/dpsi    '
     &        ,'ierpp   ', ierpp,    'jp      ', jp,       -1)
         if(ierfp .ne. 0) call abortjob
     &        ('psifit  ',  2,   'Spline evaluation error:dffp/dps    '
     &        ,'ierfp   ', ierfp,    'jp      ', jp,       -1)
c
c 1.4.2.2 For alternative profile option
      elseif(npst .eq. 1) then
         pp0       = amu*sterpp(psival(jp),psimsh,sp,  csp,  nprofl,
     &                                     npp,0, rndff, ierpp)
         f0a       =     sterpl(psival(jp),psimsh,sf,  csf,  nprofl,
     &                                     npp,0, rndff, ierff)
         f1a       =     sterpp(psival(jp),psimsh,sf,  csf,  nprofl,
     &                                     npp,0, rndff, ierfp)
         fp0       = f0a*f1a
c
         p2p       = amu*sterp2(psival(jp),psimsh,sp,  csp,  nprofl,
     &                                     npp,0, rndff, ierp2)
         f2a       =     sterp2(psival(jp),psimsh,sf,  csf,  nprofl,
     &                                     npp,0, rndff, ierf2)
         f2p       = f1a*f1a + f0a*f2a
c
         if(ierpp .ne. 0) call abortjob
     &        ('psifit  ',  3,   'Spline evaluation error: dp/dpsi    '
     &        ,'ierpp   ', ierpp,    'jp      ', jp,       -1)
         if(ierff .ne. 0) call abortjob
     &        ('psifit  ',  4,   'Spline evaluation error: f(psi)     '
     &        ,'ierff   ', ierff,    'jp      ', jp,       -1)
         if(ierfp .ne. 0) call abortjob
     &        ('psifit  ',  5,   'Spline evaluation error: df/dpsi    '
     &        ,'ierfp   ', ierfp,    'jp      ', jp,       -1)
         if(ierp2 .ne. 0) call abortjob
     &        ('psifit  ',  6,   'Spline evaluation error:dp/dpsi2    '
     &        ,'ierp2   ', ierp2,    'jp      ', jp,       -1)
         if(ierf2 .ne. 0) call abortjob
     &        ('psifit  ',  7,   'Spline evaluation error:df/dpsi2    '
     &        ,'ierf2   ', ierf2,    'jp      ', jp,       -1)
      endif
c
c 1.4.3 Local current density and derivatives
c
      rj0        =    -rpsi*rpsi*pp0 - fp0
      rjp        =     rpsi*rpsi*p2p + f2p
      rj3        = 3.0*rpsi*rpsi*pp0 - fp0
      rj5        = 5.0*rpsi*rpsi*pp0 + fp0
      rj7        = 7.0*rpsi*rpsi*pp0 - fp0
c
c
c 1.5 Set the fit and checking ranges
c
c 1.5.1 Set the fit range in terms of number of grid points
c
      irange     = ifitrng
      jrange     = jfitrng
      ibegin     = max0(iax - irange, 1)
      istop      = min0(iax + irange,nx)
      jbegin     = max0(jax - jrange, 1)
      jstop      = min0(jax + jrange,nz)
c
c 1.5.2 Set the range for the checking of the fit
c
      rrange     = (fitchek*dmx)**2
      jprange    = jfitchk
      jpbegin    = max0(jp-jprange,1)
      jpstop     = min0(jp+jprange,jpsi+1)
      jpc        = -1
c
c
c
c 2.0 Perform least squares fit for sa2,sb2,sa3,sb3,sa4,sb4
c
      iter       = 1
      jpsim2     = jpsi-2
      psirnge    = psival(jpsim2) - psival(jpsi)
c
c
c 2.2 Iterate with successively increasing psirnge
c
    5 continue
c
c 2.2.1 Search and count over neighbouring grid points for psi within psirnge
c
c 2.2.1.1 Loop over grid points
        lcount     = 0
        do 20 i    = ibegin,istop
        wsx        = x(i) - rpsi
        do 10 j    = jbegin,jstop
c
c 2.2.1.2 Check for psarray(i,j) within psirnge of sa0 = psiax
        if(abs(psarray(i,j)-sa0) .le. psirnge) then
          lcount     = lcount + 1
          wsy        = z(j) - zpsi
          rho        = sqrt(wsx*wsx +wsy*wsy)
          if    (rho .eq. 0.0) then
            cw         = 1.0
            sw         = 0.0
          elseif(rho .ne. 0.0) then
            cw         = wsx/rho
            sw         = wsy/rho
          endif
c
          s2w        = 2.0*sw*cw
          c2w        =     cw*cw   - sw*sw
          c3w        =     cw*c2w  - sw*s2w
          c4w        =     c2w*c2w - s2w*s2w
          s3w        =     sw*c2w  + cw*s2w
          s4w        = 2.0*s2w*c2w
          rho2       = rho*rho
          rho3       = rho*rho2
          rho4       = rho*rho3
          als(lcount,1) = rho2*c2w  +  rho3*cw/(4.0*rpsi)
     &                              -  rho4*c2w*(1.0/(16.0*rpsi*rpsi)
     &                              +  rjp/12.0)
     &                              -  rho4/(32.0*rpsi*rpsi)
          als(lcount,2) = rho3*c3w  +  rho4*c2w/(4.0*rpsi)
          als(lcount,3) = rho4*c4w
          als(lcount,4) = rho2*s2w  +  rho3*sw/(4.0*rpsi)
     &                              -  rho4*s2w*(1.0/(16.0*rpsi*rpsi)
     &                              +  rjp/12.0)
          als(lcount,5) = rho3*s3w  +  rho4*s2w/(4.0*rpsi)
          als(lcount,6) = rho4*s4w
          bls(lcount,1) = psarray(i,j) 
     &                              -  sa0  -  rho2*rj0/4.0
     &                              +  rj5*rho3*cw/(16.0*rpsi)
     &                              +  rho4*(rj7/(128.0*rpsi*rpsi)
     &                              +  rj0*rjp/64.0)
     &                              +  rj3*rho4*c2w/(64.0*rpsi*rpsi)
        endif
   10   continue
   20   continue
c
c
c 2.3 Set the counter for grid points within psirnge of sa0
c
        npoints    = lcount
c
c
c 2.4 Increment the iteration counter
c
c 2.4.1 Increment the counter
c
c
c 2.4.2 Print a warning and quit iterating if limit exceeded
c
        if(iter .ge. nfitmax) then
          if(npoints .gt. 0) call abortjob
     &        ('psifit  ',  8,   'Iteration limit nfitmax exceeded    '
     &        ,'iter    ', iter,     'npoints ', npoints,  -1)
          if(npoints .eq. 0) call abortjob
     &        ('psifit  ',  9,   'Iteration limit exceeded # point    '
     &        ,'iter    ', iter,     'npoints ', npoints,  +1)
c
c 2.5 Increase psirnge and continue iterations if not enough points were found
c
        elseif(iter .lt. nfitmax) then
          if(npoints .lt. nptmin) then
            iter       = iter + 1
            psirnge    = 2.0*psirnge
            go to 5
          endif
        endif
c
c
c 3.0 Compute the least square coefficients
c
c 3.1 Compute the coefficients
c
      call ofima3(als,nf1,bls,nf1,npoints,1,nf2,tls,nf2,wkx,nk,ier)
c
c
c 3.2 Print error and exit if found
c
      if(ier .ne. 0) then
         call abortjob
     &        ('psifit  ', 10,   'Least square fit error in ofima3    '
     &        ,'ier     ', ier,      'jp      ', jp,       -1)
         if(ier .lt. 0) call abortjob
     &        ('psifit  ', 11,   'Error occured in matrix multiply    '
     &        ,'ier     ', ier,      'npoints ', npoints,   0)
         if(ier .gt. 0) call abortjob
     &        ('psifit  ', 12,   'Error occured in linear solver      '
     &        ,'ier     ', ier,      'npoints ', npoints,   0)
      endif
c
c
c 3.3 Save the least square coefficients
c
c 3.3.1 Reset the coefficients
c
      sa2        = tls(1,1)
      sa3        = tls(2,1)
      sa4        = tls(3,1)
      sb2        = tls(4,1)
      sb3        = tls(5,1)
      sb4        = tls(6,1)
c
c 3.3.2 Write the coefficients
c
      write(kuout,1000) iter,npoints,psirnge
      write(kuout,1010) rpsi,zpsi,sa0,sa2,sa3,sa4,rj0,rjp,sb2,sb3,sb4
c
c
c
c 4.0 Check the fit
c
c 4.1 Loop over psi values in psival
c
      write(kuout,2000)
c
c 4.1.2 Loop from jpstop to jpbegin in reverse direction
c
      do 100 jj  = jpstop,jpbegin,jpc
      jjp        = jj
c
c
c 4.2 Initialize ps and the fit quality
c
      psvl       = psival(jjp)
      discrep    = 0.0
      iptnum     = 0
c
c
c 4.3 Search the equilibrium grid for points near psi
c     The accuracy is tested for all psi less than psival(jjp)
c     as psival(jjp) is successively increased
c
c 4.3.1 Loop over all grid points within rrange
c
      do 80 i    = 1,nx
      do 60 j    = 1,nz
      if((x(i)-rpsi)**2 + (z(j)-zpsi)**2  .le.  rrange) then
c
c 4.3.2 Construct analytic fit at (x(i),z(i)) for psi
c
        if(psarray(i,j) .le. psvl) then
          wsx        = x(i)
          wsy        = z(j)
          psdiff     = psian(wsx,wsy)  -  psarray(i,j)
c
c 4.3.3 Add the discrepancy from this point
c
          discrep    = discrep  +  abs(psdiff/psarray(i,j))
          iptnum     = iptnum + 1
        endif
      endif
   60 continue
   80 continue
c
c
c 4.4 Write the avearge local fit value for this psi value
c
c 4.4.1 Normalize to the number of grid points used
c
      if(iptnum .gt. 0) discrep = discrep/iptnum
c
c 4.4.2 Write the fit quality for this surface
c
      write(kuout,2010) jjp,iptnum,psiax,psvl,discrep
  100 continue
c
c
c 4.5 Print a warning if no points were found in range to check
c
      if(iptnum .eq. 0) then
         call abortjob
     &        ('psifit  ', 13,   'No points found in checking fit     '
     &        ,'iptnum  ', iptnum,   'jprange ', jprange,  -1)
      endif
c
c
c
c 5.0 Return and end
c
      return
 1000 format(//,1x,'Axis fit from psifit:',1x,i5,1x,'iterations:',/
     & ,1x,'npoints = ',i5,1x,'psirnge = ',e13.5)
 1010 format(/, 5x,'Fitting parameters:',/
     &        , 1x,'rpsi    = ',e13.5,3x,'y0      = ',e13.5,/
     &        , 1x,'a0      = ',e13.5,3x,'a2      = ',e13.5
     &        , 3x,'a3      = ',e13.5,3x,'a4      = ',e13.5,//
     &        , 1x,'rj0     = ',e13.5,3x,'rjp     = ',e13.5,/
     &        , 1x,'b2      = ',e13.5,3x,'b3      = ',e13.5
     &        , 3x,'b4      = ',e13.5)
 2000 format(/, 5x,'Check for analytic fit:',/
     &        , 4x,'Surface',4x,'No. of points',5x,'psi axis'
     &        ,10x,'psi grid',8x,'Ave discrepancy',/
     &        , 7x,'(jjp)',7x,'(iptnum)',8x, '(psiax)',11x,'(psvl)'
     &       ,12x,'(discrep)')
 2010 format(7x,i5,7x,i5,5x,e14.5,5x,e14.5,5x,e14.5)
      end
      function psian(x,y)
c
      common/psft/  rpsi,zpsi,rj0,rjp,rj3,rj5,rj7,sa0,sa2,sa3,sa4,
     &              sb2,sb3,sb4
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize position
c
      ex      = x-rpsi
      ey      = y-zpsi
      rho     = sqrt(ex*ex + ey*ey)
c
c
c 1.2 Construct coefficients
c
      if    (rho .eq. 0.0) then
        c1      = 1.0
        s1      = 0.0
      elseif(rho .ne. 0.0) then
        c1      = ex/rho
        s1      = ey/rho
      endif
c
      rpsi2   = rpsi*rpsi
      c2      =     c1*c1 - s1*s1
      s2      = 2.0*c1*s1
      c3      =     c1*c2 - s1*s2
      s3      =     s1*c2 + c1*s2
      c4      =     c2*c2 - s2*s2
      s4      = 2.0*c2*s2
      rho2    = rho*rho
      rho3    = rho*rho2
      rho4    = rho2*rho2
c
c
c
c 2.0 Construct analytic fit
c
      psian   =  sa0  +  0.25*rj0*rho2  -  rho3*rj5*c1/(16.0*rpsi)
     &                                  -  rho4*(rj7/(128.0*rpsi2)
     &                                  +  rj0*rjp/64.0
     &                                  +  rj3*c2/(64.0*rpsi2))
     &        +  sa2*(rho2*c2 + rho3*c1/(4.0*rpsi)
     &                                  -  rho4/(32.0*rpsi2)
     &                                  -  rho4*c2*(1.0/(16.0*rpsi2)
     &                                  +  rjp/12.0))
     &        +  sb2*(rho2*s2 + rho3*s1/(4.0*rpsi)
     &                                  -  rho4*s2*(1.0/(16.0*rpsi2)
     &                                  +  rjp/12.0))
     &        +  sa3*(rho3*c3 + rho4*c2/(4.0*rpsi))
     &        +  sb3*(rho3*s3 + rho4*s2/(4.0*rpsi))
     &        +  sa4*rho4*c4
     &        +  sb4*rho4*s4
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine mercier
c
c calculate the value of btor and q0 required for Mercier stability on axis
c
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nw2=2*nxx,nh2=2*nxz,nvk0=nw2+nh2)
c
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/prof/  nprofl,npst,nfast,nspbc0,nspbc1,
     &              psimsh(npp),sf(npp),sp(npp),
     &              sffp(npp),spp(npp),sfp(npp),sdns(npp),
     &              spfst(npp),spsif(npb),sfast(npb),bcb(4),
     &              csf(3,npp),csp(3,npp),csffp(3,npp),cspp(3,npp),
     &              csfp(3,npp),csdn(3,npp),csfst(3,npp)
      common/eqd1/  nx,nz,nxd,nzd,dmx,dmz,
     &              x(nxx),z(nxz),psarray(nxx,nxz),
     &              gpx(nxx,nxz),gpy(nxx,nxz),grsq(nxx,nxz),
     &              cspl1(2,nxx,nh2),work0(nxz,2,nxx),vork0(nvk0,2)
      common/dblt/  psisep,xsep,zsep,smap(2),smax(2),smaz(2),numax,
     &              psimx(2),xax(2),zax(2),fitax(14,2),fitsep(14)
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
c
c
c
c 1.0 Return if this calculation is not possible
c
c 1.1 Initialization
c
      kmap    = nmap
      smallno = roundff
c
c
c 1.2 Return if inverse equilibrium
c
      if(kmap .ne.  0) then
          call abortjob
     &        ('mercier ',  1,   'No Mercier done: inverse equilibrium'
     &        ,'kmap    ', kmap,     'nprofl  ', nprofl,   -1)
        qmer    = 0.0
        btmer   = 0.0
        return
      endif
c
c
c
c 2.0 Initialization
c
c 2.1 Initialize the axis fitting parameters
c
c 2.1.1 Parameters from fitting psi on axis
c
      sa2       = fitax( 9,1)
      sb2       = fitax(12,1)
      rj        = fitax( 3,1)
      ra        = fitax( 1,1)
      sa3       = fitax(10,1)
      sb3       = fitax(13,1)
c
c 2.1.2 Construct the parameters required for axis Mercier stability
c
      alp       =  0.5*atan2(-sb2,sa2)
      csa       =  cos(alp)
      ssa       =  sin(alp)
      ss2a      =  2.0*csa*ssa
      cs2a      =  csa*csa  - ssa*ssa
      ss3a      =  ssa*cs2a + ss2a*csa
      cs3a      =  csa*cs2a - ssa*ss2a
c
      eps       =  4.0*sa2 / (rj*cs2a)
      epssq     =  eps*eps
      eps1m     =  1.0 - eps
      eps1p     =  1.0 + eps
      eps2m     =  2.0 - eps
      eps2p     =  2.0 + eps
c
c
c 2.2 Initialize axis profile parameters
c
      if    (npst .eq. 0) then
        pp0       =  spp(1)
      elseif(npst .eq. 1) then
        pp0        = sterpp(psimax,psimsh,sp,  csp,  nprofl,npp,0,
     &                             smallno,ierp)
        if(ierp .ne. 0) call abortjob
     &        ('mercier ',  2,   'Differentiation error: sp(axis)     '
     &        ,'ierp    ', ierp,     'ijval   ', ijval,     0)
      endif
      fa        =  sf (1)
      bp0       = -amu*ra*ra*pp0 / rj
c
c
c
c 3.0 Calculate the value of q0 required for Mercier stability
c
c 3.1 Construct qmer for cases where a solution exists
c
      if(epssq .le. 1.0) then
c
c 3.1.1 Construct rhe coeeficients
c
        sqe2    =  1.0 - epssq
        sqe2i   =  sqrt(sqe2)
        betai   =  bp0*sqe2i
c
        q1a     =  eps2p*(sb3*ss3a - sa3*cs3a) / (rj*sqe2)
        q2a     =  eps2m*(sb3*cs3a + sa3*ss3a) / (rj*sqe2)
        q1b     =  eps*csa*(0.25*eps1p + bp0)  / (4.0*ra*sqe2)
        q2b     =  eps*ssa*(0.25*eps1m + bp0)  / (4.0*ra*sqe2)
        q1      =  q1a  +  q1b
        q2      =  q2a  -  q2b
c
        f1e     =  1.0  -  1.5*eps*eps1p/eps2p
        f1em    =  1.0  +  1.5*eps*eps1m/eps2m
        f2e     = +12.0*eps*eps1m/eps2p
        f2em    = -12.0*eps*eps1p/eps2m
        f3e     =  4.0*epssq*sqe2i  /
     &                (eps1p*eps2p**2*(1.0 + sqe2i - epssq/eps2p))
        f3em    =  4.0*epssq*sqe2i  /
     &                (eps1m*eps2m**2*(1.0 + sqe2i - epssq/eps2m))
c
c 3.1.2 Construct the inverse qmer value
c
        qminv   =  f1e*csa*csa    +  f1em*ssa*ssa      +
     &             q1*ra*f2e*csa  +  q2*ra*f2em*ssa    -
     &             betai*(f3e*csa*csa + f3em*ssa*ssa)
c
c
c 3.1.3 Construct qmer
c
c 3.1.3.1 Construct qmer if the calculation is valid
        if    (qminv .gt. 0.0) then
          qmer    = 1.0/sqrt(qminv)
c
c 3.1.3.2 Set qmer to a default value if the calculation is invalid
        elseif(qminv .le. 0.0) then
           call abortjob
     &        ('mercier ',  3,   'Mercier calculation is invalid      '
     &        ,'kmap    ', kmap,     'nx      ', nx,       -1)
           qmer      = 1000.0
        endif
c
c
c 3.2 Set qmer to the default value if no solution exists
c
      elseif(epssq .gt. 1.0) then
        call abortjob
     &        ('mercier ',  4,   'No solution to Mercier on axis      '
     &        ,'kmap    ', kmap,     'nx      ', nx,       -1)
        qmer      = 1000.0
      endif
c
c
c 3.3 Calculate btmer from qmer
c
      btmer     = abs(btor**2 + fa*fa*(qmer*qmer/(qaxe*qaxe) - 1.0)  /
     &                                                     (rcnt*rcnt))
      btmer     = sqrt(btmer)
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine kinetic
c
c -------------------------------------------------------------
c
c construct the separate electron and ion density temperature and
c fast ion profiles
c
c -------------------------------------------------------------
c
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
c
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/mapd/  mapmaxd,dpsisl,dpsisd,nqaxis,nwtmag,nfitmax,nfitpts,
     &              ifitrng,jfitrng,jfitchk,fitchek,cnvmag,epsaxs,
     &              maxerlp,maxerlv,delbox,delboz,delac,delav,
     &              delstsf,delstlp,delstlv,prfrac,
     &              nerstop,nerprnt,qptol,tolspln,tolbchi,tolbtor,
     &              tolsymm,tolaugm,errsep,precisn,plossmx,
     &              narcmx,ntrymx,ntdecr,ntmmin,npfit,npcmin,
     &              kuttaop,nrkmax0,nrkmax1,numstp,nwtfitp,nwtfitm,
     &              stepfac,flxstp,psispl,tolnwtp,tolnwtm,
     &              delpakf,delpakc,delpkf,delpkc,psichek,boxtnd,
     &              maptrace,norient,maxcutc,
     &              dresolv,dlclose,pntshft,endtol,
     &              narcln,nangax,nanglm,nbpmax,nwtmax,nslmax,nhfmax,
     &              bperor,sersnm,sertnm,arcmin,delgap,stepcut,
     &              novap,ioutm,iplotm
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/kinetc/pfactr,tfactr,dfactr,pffact,deutp,dmass,dnnova(np2),
     &              pfnova(np2), ptnova(np2), prnova(np2),pbnova(np2), 
     &              tenova(np2), tinova(np2), denova(np2),dinova(np2)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
c
c
c 1.0 Initialize
c
c 1.1 Roundoff
c
      rndoff     = roundff
c
c
c 1.2 Unit factors
c     Where indicated, pressure is printed in kPa
c                      Number density is printed in 10^19/m^3
c                      Temperature is printed in keV
c
      pfactr        = 1.0e03
      tfactr        = 1.0e03
      dfactr        = 1.0e19
      pffact        = betaf*pfnorm
c
      zeffct        = zeffect
      deutp         = 2.00
      dmass         = deutp*pmass
c
c
c
c 2.0 Set the unscaled density and fast ion profile variables
c
      do 100 jp     = 1,jpsi
      jpv           = jp
      jpp           = jpsi - jp + 2
      dnnova(jpp)   = dnsty(jpv)
      pfnova(jpp)   = pfast(jpv)
  100 continue
c
      dnnova(  1  ) = dnaxe
      dnnova(jpsi2) = dnlim
      pfnova(  1  ) = pfaxe
      pfnova(jpsi2) = pflim
c
c
c
c 3.0 Set the thermal and fast ion pressure profiles
c
c 3.1 Axis and limiter values
c
      prfax0        =  pffact*pfaxe
      prtax0        =  paxe
      prsax0        =  prtax0 - prfax0
c
      prflm0        =  pffact*pflim
      prtlm0        =  plim
      prslm0        =  prtlm0 - prflm0
c
      if(prsax0 .le. 0.0) then
        prsax0   =  0.0
        prfax0   =  prtax0
        call abortjob
     &        ('kinetic ',  1,   'Axis fast ion pressure exceeds total'
     &        ,'ifastp  ', ifastp,   'jpsi1   ', jpsi1,    -1)
      endif
c
      if(prslm0 .le. 0.0) then
        prslm0   =  0.0
        prflm0   =  prtlm0
        call abortjob
     &        ('kinetic ',  2,   'Edge fast ion pressure exceeds total'
     &        ,'ifastp  ', ifastp,   'jpsi1   ', jpsi1,    -1)
      endif
c
      prfax         =  prfax0/pfactr
      prtax         =  prtax0/pfactr
      prsax         =  prsax0/pfactr
c
      prflm         =  prflm0/pfactr
      prtlm         =  prtlm0/pfactr
      prslm         =  prslm0/pfactr
c
      ptnova(  1  ) = prtax
      prnova(  1  ) = prsax
      pbnova(  1  ) = prfax
      ptnova(jpsi2) = prtlm
      prnova(jpsi2) = prslm
      pbnova(jpsi2) = prflm
c
c
c 3.2 Internal values
c
      kptneg        = 0
      pthnegmx      = 0.0
      do 150 jj     = 1,jpsi
      jjj           = jj
      jj0           = jpsi1 - jjj
      jj1           = jjj + 1
      pfastp        =  pffact*pfast(jj0)
      ptotal        =  p    (jj0)
      pthermal      =  ptotal - pfastp
      if(pthermal .le. 0.0) then
        kptneg    =  kptneg + 1
        if(abs(pthermal) .ge. pthnegmx) then
          jptneg        = jjj
          pthnegmx      = pthermal
        endif
        pthermal      =  0.0
        pfastp        =  ptotal
      endif
      prfast        =  pfastp  /pfactr
      prtotl        =  ptotal  /pfactr
      pressr        =  pthermal/pfactr
c
      ptnova(jj1)   = prtotl
      prnova(jj1)   = pressr
      pbnova(jj1)   = prfast      
  150 continue
c
      if(kptneg .gt. 0) then
        call abortjob
     &        ('kinetic ',  3,   'Fast ion pressure exceeded total    '
     &        ,'kptneg  ', kptneg,   'jptneg  ', jptneg,   -1)
        write(kuout,1000) pthnegmx
      endif
c   
c
c
c 4.0 Set the individual electron and ion number density and temperature profiles
c     Number density is in units of 10^19/m^3 and temperature in keV
c     This assumes Deuterium ion mass and p = nkT
c
c 4.1 Print a warning if the input density is not real
c
      if(idnsty .le. 0) then
        call abortjob
     &        ('kinetic ',  4,   'Density profile is not real profile '
     &        ,'idnsty  ', idnsty,   'nmap    ', nmap,     -1)
      endif
c
c
c 4.2 Set the end values
c
      denaxi        = (dnaxe*dnnorm/dmass)/dfactr
      denaxe        =  zeffct*denaxi
      tmpaxi        = (prsax0/(denaxe+ denaxi))/tfactr
      tmpaxe        =  tmpaxi
c
      denlmi   = (dnlim*dnnorm/dmass)/dfactr
      denlme   =  zeffct*denlmi
      tmplmi   = (prslm0/(denlme+ denlmi))/tfactr
      tmplme   =  tmplmi
c
      dinova(  1  ) = denaxi
      denova(  1  ) = denaxe
      tinova(  1  ) = tmpaxi
      tenova(  1  ) = tmpaxe
c
      dinova(jpsi2) = denlmi
      denova(jpsi2) = denlme
      tinova(jpsi2) = tmplmi
      tenova(jpsi2) = tmplme
c
c
c 4.3 Subtract the fast ion pressure from  the total pressure and
c     separate the remainder into individual electron and ion
c     temperature and density
c
      do 200 jj     = 1,jpsi
      jjj           = jj
      jj0           = jpsi1 - jj
      jj1           = jjj + 1
      pfastp        =  pffact*pfast(jj0)
      pthermal      =  p    (jj0) - pfastp
      if(dnsty(jj0) .ge. rndoff) dennum  = (dnsty(jj0)*dnnorm/dmass)
     &                                                       /dfactr
      if(dnsty(jj0) .lt. rndoff) dennum  = (rndoff*    dnnorm/dmass)
     &                                                       /dfactr
      dennmi        =  dennum
      dennme        =  zeffct*dennmi
      tempri        = (pthermal/(dennme + dennmi))/tfactr
      tempre        =  tempri
c
      dinova(jj1)   = dennmi
      denova(jj1)   = dennme
      tinova(jj1)   = tempri
      tenova(jj1)   = tempre
  200 continue
c
c
c
c 4.0 Return and end
c
      return
 1000 format(   10x,'Negative pressures set to zero:'
     &          ,1x,'Maximum negative value was Pthermal = ',e14.7)
      end
      subroutine runkut(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,jmn,jmx,
     &                  jstart,rstart,zstart,step0,is,js,delxi,delzi,
     &                  ipg,psiv,rst,zst,jdone,npd,kuttas,initmax,
     &                  nstepmx,newtmxp,newtmxm,tolnwfp,tolnwfm,rndoff,
     &                  tolpsi,kunit,kerr)
c     --------------------------------------------------------
c     4th order runga kutta integration from jstart surface
c     to trace out lines orthogonal to the flux surfaces and
c     store the intersections
c     --------------------------------------------------------
c
      dimension xw(nw),yh(nh)
      dimension psarray(nwd,nhd),gpx(nwd,nhd),gpy(nwd,nhd)
      dimension psiv(npd),rst(npd),zst(npd)
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize counters and error flags
c
c 1.1.1 Error flags
c
      kerr       =  0
      nstep      =  0
      jdone      =  0
c
c 1.1.2 Fitting criteria
c
      imax       = newtmxm
      imaxp      = newtmxp
      crit       = tolnwfm
      critp      = tolnwfp
c
c 1.1.2 Flux surface counters
c
      jmin       =  jmn
      jmax       =  jmx
c
c 1.1.3 Check if jmin and jmax are reversed
c
      if    (jmin .ge. jmax) then
        call abortjob
     &        ('runkut  ',  1,   'Error in input: jmn<= jmx: Reversing'
     &        ,'jmin    ', jmin,     'jmax    ', jmax,     -1)
        jmin       = jmx
        jmax       = jmn
      endif
c
c 1.1.4 Auxiliary parameters
c
      pslim      =  psiv(jmin)
      psmax      =  psiv(jmax)
      psinm      =  abs(pslim) + abs(psmax)
      gradfac    =  1.0
c
c
c 1.2 Initialize rs1 and zs1 at zero
c
      do 10 jvl  = jmin,jmax
      rst(jvl)   = 0.0
      zst(jvl)   = 0.0
  10  continue
c
c
c 1.3 Check for valid step size
c
c 1.3.1 Check if the step size is negative
c
      if    (step0 .lt. 0.0) then
        call abortjob
     &        ('runkut  ',  2,   'Error in input: Integration step < 0'
     &        ,'jmin    ', jmin,     'jmax    ', jmax,     -1)
      endif
c
c 1.3.2 Return with error if the step size is zero
c
      if    (step0 .eq. 0.0) then
        call abortjob
     &        ('runkut  ',  3,   'Error in input: Integration step = 0'
     &        ,'jmin    ', jmin,     'jmax    ', jmax,      0)
        kerr       = -1
        return
      endif
c
c
c 1.4 Set the start and end targets
c
      if    (jstart .eq. jmax) then
        jfirst     =  jstart-1
        jlast      =  jmin
        jdirn      = -1
      elseif(jstart .ne. jmax) then
        jfirst     =  jstart+1
        jlast      =  jmax
        jdirn      = +1
      endif
c
c
c 1.5 Initialize grid counters
c
c 1.5.1 Grid counters
c
      is         =  1
      js         =  1
      kdirx      = +1
      kdiry      = +1
c
      r2         = 0.0
      z2         = 0.0
      r3         = 0.0
      z3         = 0.0
c
c 1.5.2 Initial step counters
c
      initstp    =  0
      rstart0    =  rstart
      zstart0    =  zstart
      stepp      =  step0

c
c
c 1.6 Initialize integration at (rstart+step0, zstart)
c     or at (rstart,zstart)
c
c 1.6.1 Iinitialize the data
c
      jdone      = jstart
      pstart     = psiv(jstart)
      ptargt     = psiv(jfirst)
c
c 1.6.2 Set the first point
c
      if    (kuttas .eq. 0) then
        rst(jstart) = rstart + stepp
        zst(jstart) = zstart
      elseif(kuttas .ne. 0) then
        rst(jstart) = rstart
        zst(jstart) = zstart
      endif
c
c 1.6.3 Find the interpolated psi value at rstart,zstart
c
      r1         = rstart
      z1         = zstart
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ierst0)
      if(ierst0 .ne. 0) call abortjob
     &        ('runkut  ',  4,   'Error in hbf at (rstart,zstart)     '
     &        ,'jstart  ', jstart,   'ierst0  ', ierst0,   -1)
c
      psist00    = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ker)
      gprst00    = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ier)
      gpzst00    = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,jer)
      if(ker .ne. 0  .or.  ier .ne. 0  .or.  jer .ne. 0) then
        if(ker .ne. 0) call abortjob
     &        ('runkut  ',  5,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(ier .ne. 0) call abortjob
     &        ('runkut  ',  6,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('runkut  ',  7,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      delp00     = psist00  - pstart
      if(abs(delp00) .gt. tolpsi*psinm) then
        if    (psist00 .lt. ptargt) then
          call abortjob
     &        ('runkut  ',  8,   'Interpolated psi(start) .ne. psiv   '
     &        ,'jstart  ', jstart ,  'kuttas  ', kuttas,    0)
        write(kunit,1000) kuttas,rstart0,zstart0,rstart,zstart
     &                          ,step0,stepp
        write(kunit,1010) pstart,psist00,delp00,gprst00,gpzst00
     &                   ,tolpsi,psinm
c
        elseif(psist00 .ge. ptargt) then
          call abortjob
     &        ('runkut  ',  9,   'Interpolated psi(start) past target '
     &        ,'jstart  ', jstart ,  'jfirst  ', jfirst,    -2)
          write(kunit,1020) psist00,pstart,ptargt
          psist00  = pstart
        endif
      endif
c
c
c
c 2.0 Find the value and gradient at the starting point
c
c 2.1 Initialize the search
c
c 2.1.1 Set the starting (r,z) point
c
      psprev       = psist00
      psifn        = psprev
  20  initstp      = initstp + 1
        kstep1       = 0
        kstep2       = 0
        ktrystp      = 0
        rinit        = rstart  + stepp
        zinit        = zstart
c
c 2.1.2 Check for error in ordering of the psi mesh
c
        if(ptargt .le. psprev) then
          call abortjob
     &        ('runkut  ', 10,   'Target psi is less than initial psi '
     &        ,'jstart  ', jstart,   'initstp ', initstp,  -2)
          kerr   = -2
          return
        endif
c
c
c 2.2 Find the starting psi(r1,z1) for this target from hbf interpolation
c     psprev is the previous point
c     psist0 is the new guess
c     ptargt is the first grid point
c     psist0 needs to be between psprev and ptargt
c
c 2.2.1 Set nearest grid cell and local interpolation coefficients
c
        r1           = rinit
        z1           = zinit
        call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &           delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                   a2,a3,a4,a5,ierst)
        if(ierst .ne. 0) call abortjob
     &        ('runkut  ', 11,   'Error in hbf at initial point       '
     &        ,'initstp ', initstp,  'ierst   ', ierst,    -1)
c
c 2.2.2 Set psi and gradient at the start point
c
        psist0       = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
        gprst0       = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
        gpzst0       = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
        if(ker .ne. 0  .or.  ier .ne. 0  .or.  jer .ne. 0) then
          if(ker .ne. 0) call abortjob
     &        ('runkut  ', 12,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
          if(ier .ne. 0) call abortjob
     &        ('runkut  ', 13,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
          if(jer .ne. 0) call abortjob
     &        ('runkut  ', 14,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
        endif
c
c
c 2.3 Check if gradient is too small
c
        if(abs(gprst0) .le. rndoff  .and.  abs(gpzst0) .le. rndoff) then
          call abortjob
     &        ('runkut  ', 15,   'Initial gradient is below roundoff  '
     &        ,'jstart  ', jstart,   'jdirn   ', jdirn,    -1)
          kstep1       = +1
        endif
c
c
c 2.4 Check the start point for the search is not past the first target
c
        delp1        = psist0 - psprev
        delp2        = ptargt - psprev
c
        if(delp1*delp2 .le. 0.0) then
          call abortjob
     &        ('runkut  ', 16,   'Initial point past the first point  '
     &        ,'initstp ', initstp,  'jfirst  ', jfirst,   -1)
          kstep2       = +1
        endif
c
c
c 2.5 Modify the step size if possible and try again
c
        if(kstep1 .ne. 0  .or.  kstep2 .ne. 0) then
c
c 2.5.1 Check the number of allowed attempts is not exceeded
c
          if(initstp .gt. initmax) then
            call abortjob
     &        ('runkut  ', 17,   'Maximum initial step tries reached  '
     &        ,'kstep1  ', kstep1,   'kstep2  ', kstep2,    0)
            kerr       = -3
            return
          endif
c
c 2.5.2 Check if there is a conflict in setting step size
c
          if(kstep1 .ne. 0  .and.  kstep2 .ne. 0) then
            call abortjob
     &        ('runkut  ', 18,   'Cannot reset initial step size      '
     &        ,'initstp ', initstp,  'initmax ', initmax,  -1)
            write(kunit,1100) kuttas,rstart0,zstart0,rstart,zstart
     &                              ,rinit,  zinit,  step0, stepp
            write(kunit,1110) pstart,psist0,psprev,jfirst,ptargt
     &                       ,delp1,delp2,gprst0,gpzst0
            kerr       = -4
            return
          endif
c
c 2.5.3 Adjust the step size and try again
c
          ktrystp      = +1
          if    (kstep1 .eq. 0  .and.  kstep2 .ne. 0) then
            call abortjob
     &        ('runkut  ', 19,   'Doubling step size from previous try'
     &        ,'initstp ', initstp,  'kstep2  ', kstep2,    0)
            write(kunit,1200) kuttas,rstart0,zstart0,rstart,zstart
     &                              ,rinit,  zinit,  step0, stepp
            write(kunit,1210) pstart,psist0,psprev,jfirst,ptargt
     &                       ,delp1,delp2,gprst0,gpzst0
c
            stepp  = 2.0*stepp
          elseif(kstep1 .ne. 0  .and.  kstep2 .eq. 0) then
            call abortjob
     &        ('runkut  ', 20,   'Halving  step size from previous try'
     &        ,'initstp ', initstp,  'kstep1  ', kstep1,    0)
            write(kunit,1200) kuttas,rstart0,zstart0,rstart,zstart
     &                              ,rinit,  zinit,  step0, stepp
            write(kunit,1210) pstart,psist0,psprev,jfirst,ptargt
     &                       ,delp1,delp2,gprst0,gpzst0
c
            stepp  = 0.5*stepp
          endif
        endif
c
c
c 2.6 Return to try again with a new step size or continue from this first
c       point
c
c 2.6.1 Repeat with a new step size
c
      if(ktrystp .ne. 0) go to 20
c
c 2.6.2 Continuue using this as the first point
c
      r0           = rinit
      z0           = zinit
      psist0       = psist0
c
c 2.6.3 Set the step direction
c
          if(gprst0 .ne. 0.0  .and.  
     &       abs(gpzst0) .le. gradfac*abs(gprst0)) kcr = +1
          if(gprst0 .eq. 0.0  .or. 
     &       abs(gpzst0) .gt. gradfac*abs(gprst0)) kcr = -1
c
      gpr0         = gprst0
      gpz0         = gpzst0
c
c
c
c 3.0 Loop over jval and set up the ray search
c     Calculate ray along theta(i)=constant to next target psi
c     Trace lines outward from jstart first
c     This is normally reverse counting for jval
c
      do 100 jval  = jfirst,jlast,jdirn
c
c 3.1 Set the initial point and target
c
c 3.1.1 Reinitialize step counter and set the target psi value
c
        nstep        = 0
        psprev       = psifn
        psifn        = psiv(jval)
        if(psifn .le. psprev) then
          call abortjob
     &        ('runkut  ', 21,   'Target psi value is < previous psi  '
     &        ,'jstart  ', jstart,   'jval    ', jval,     -2)
          kerr    = -5
          return
        endif
c
c 3.1.2 Set the starting (r,z) point for this target
c
        r1           = r0
        z1           = z0
c
c
c 3.2 Set the starting psi(r1,z1) for this target from hbf interpolation
c
c 3.2.1 Set nearest grid cell and local interpolation coefficients
c 
        call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &           delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                   a2,a3,a4,a5,ier0)
        if(ier0  .ne. 0) call abortjob
     &        ('runkut  ', 22,   'hbf error in setting start point    '
     &        ,'jval    ', jval,     'ier0    ', ier0,     -1)
c
c 3.2.2 Set initial psi and gradient
c
        psist        = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
        gprst        = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
        gpzst        = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
        if(ker .ne. 0  .or.  ier .ne. 0  .or.  jer .ne. 0) then
          if(ker .ne. 0) call abortjob
     &        ('runkut  ', 23,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
          if(ier .ne. 0) call abortjob
     &        ('runkut  ', 24,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
          if(jer .ne. 0) call abortjob
     &        ('runkut  ', 25,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
        endif
c
c
c
c 4.0 Iterate over steps and set vertical or horizontal step
c     Ray is heading towards grid point (x(is+kdirx), y(js+kdiry))
c
c 4.1 Increment the step counter
c
   50   nstep        =  nstep + 1
          kcrflag      =  0
          kcrprev      =  kcr
          kcr          =  0
c
c
c 4.2 Check if gradient is small
c
          if(abs(gprst) .le. rndoff  .and.  abs(gpzst) .le. rndoff) then
            if    (kcrprev .eq. 0) then
              call abortjob
     &        ('runkut  ', 26,   'Gradient direction not defined      '
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
              kerr       = +1
              return
            elseif(kcrprev .ne. 0) then
              call abortjob
     &        ('runkut  ', 27,   'Use gradient from last iteration    '
     &        ,'jval    ', jval,     'kcrprev ', kcrprev,   0)
              kcrflag  = 1
              kcr      = kcrprev
            endif
          endif
c
c
c 4.3 Set the step direction from the gradient if the gradient is well defined
c
          if(kcrflag .eq. 0) then
            if(gprst .ne. 0.0  .and.  
     &         abs(gpzst) .le. gradfac*abs(gprst)) kcr = +1
            if(gprst .eq. 0.0  .or. 
     &         abs(gpzst) .gt. gradfac*abs(gprst)) kcr = -1
          endif
c
c
c 4.4 Check the first step is radial
c
      if(nstep .eq. 1  .and.  kcr .ne. +1) then
        call abortjob
     &        ('runkut  ', 28,   'Initial gradient is not radial      '
     &        ,'kcr     ', kcr,      'kcrflag ', kcrflag,  -1)
        kcr   = +1
      endif
c
c
c
c 5.0 Increment in x direction using four-step Runge-Kutta along the gradient in psi
c     to a point with psi = psipt between psist and psifn
c
          if    (kcr .eq. +1) then
c
c 5.1 Step radially a half step
c
            delr     =  kdirx*step0
c
            dzdr1    =  gpzst/gprst
            delz1    =  delr*dzdr1
            r1p1     =  r0 + 0.5*delr
            z1p1     =  z0 + 0.5*delz1
c
            r1       =  r1p1
            z1       =  z1p1
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,ier1)
            if(ier1  .ne. 0) call abortjob
     &        ('runkut  ', 29,   'hbf error: First Runge-Kutta step   '
     &        ,'nstep   ', nstep,    'ier1    ', ier1,     -1)
c
            psipt    = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
            if(ker .ne. 0) call abortjob
     &        ('runkut  ', 30,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
c
c
c 5.2 Test that the half increment results in a psi value in the same
c     direction as the step from the initial point to the target by checking
c     psipt-psist has the same sign as psifn-psist
c     For the radial step the outboard direction is enforced by taking a 
c     positive step with kdirx  = +1 and the check can only fail if the
c     initial point is already displaced past the target.
c
c 5.2.1 Test the ordering of psipt psifn and psist
c       psist is the start point
c       psipt is the point for (r1,z1)
c       psifn is the target point
c
            dpsfn0   = psifn - psist
            dpspt0   = psipt - psist
            if(dpsfn0*dpspt0 .lt. 0.0) then
c
c 5.2.2 Return if the initial point is beyond the target point
c
              if(nstep .eq. 1) then
                call abortjob
     &        ('runkut  ', 31,   'Initial radial point past the target'
     &        ,'jval    ', jval,     'nstep   ', nstep,    -1)
                write(kunit,2000) kdirx,kcr,dpsfn0,dpspt0,psist,psipt
     &                           ,psifn,delr,delz1,r0,r1,z0,z1
     &                           ,gprst,gpzst,dzdr1
                kerr   = +2
                return
c
c 5.2.3 Reverse direction if the radial direction is incorrect
c
              elseif(nstep .gt. 1) then
c
c 5.2..3.1 Print a warning
                call abortjob
     &        ('runkut  ', 32,   'Reversing radial search direction   '
     &        ,'jval    ', jval,     'nstep   ', nstep,    -1)
                write(kunit,2005) kdirx,kcr,dpsfn0,dpspt0,psist,psipt
     &                           ,psifn,delr,delz1,r0,r1,z0,z1
     &                           ,gprst,gpzst,dzdr1

c
c 5.2.3.2 Reverse direction and redo the increment
c         The reverse direction is retained until modified again
                kdirx   = -kdirx
                delr    =  kdirx*step0
                delz1   =  delr*dzdr1
                r1p1    =  r0 + 0.5*delr
                z1p1    =  z0 + 0.5*delz1
c
                r1      =  r1p1
                z1      =  z1p1
                call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                   delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                           a2,a3,a4,a5,ierm1)
                if(ierm1 .ne. 0) call abortjob
     &        ('runkut  ', 33,   'hbf error in reversing direction    '
     &        ,'nstep   ', nstep,    'ierm1   ', ierm1,    -1)
c
                psipt   = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                              a2,a3,a4,a5,ker)
c
                if(ker .ne. 0) call abortjob
     &        ('runkut  ', 34,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
c 5.2.3.3 Check that the new direction works
                dpsfn1  = psifn - psist
                dpspt1  = psipt - psist
                write(kunit,2010) kdirx,kcr,dpsfn1,dpspt1,psist,psipt
     &                           ,psifn,delr,delz1,r0,r1,z0,z1
                if(dpsfn1*dpspt1 .lt. 0.0) then
                  call abortjob
     &        ('runkut  ', 35,   'Reversed radial search failed       '
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
                  kerr   = +3
                  return
                endif
              endif
            endif
c
c
c 5.3 Complete the Runge-Kutta step
c
c 5.3.1 Set up the step in the vertical direction and compute the gradients there
c
            gpr      = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
            gpz      = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
c
            if(ier .ne. 0  .or.  jer .ne. 0) then
              if(ier .ne. 0) call abortjob
     &        ('runkut  ', 36,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(jer .ne. 0) call abortjob
     &        ('runkut  ', 37,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            endif
c
            delz2    =  delr*gpz/gpr
            r1p2     =  r1p1
            z1p2     =  z0 + 0.5*delz2
c
c 5.3.2 Recompute the coefficients and gradient at the new intermediate point
c       with z incremented to the half step
c
            r1       =  r1p2
            z1       =  z1p2
            if(kuttas .gt. 0) then
              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,ier2)
              if(ier2  .ne. 0) call abortjob
     &        ('runkut  ', 38,   'hbf error: Runge-Kutta mid-step     '
     &        ,'nstep   ', nstep,    'ier2    ', ier2,     -1)
              gpr    = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
              gpz    = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
              if(ier .ne. 0  .or.  jer .ne. 0) then
                if(ier .ne. 0) call abortjob
     &        ('runkut  ', 39,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
                if(jer .ne. 0) call abortjob
     &        ('runkut  ', 40,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              endif
            endif
c
c 5.3.3 Complete the full Runge-Kutta step
c
c 5.3.3.1 Reset the new approximate point
            delz3    =  delr*gpz/gpr
            r1p3     =  r0 + delr
            z1p3     =  z0 + delz3
c
c 5.3.3.2 Recompute the gradient direction at the new point
            r1       =  r1p3
            z1       =  z1p3
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,ier3)
            if(ier3  .ne. 0) call abortjob
     &        ('runkut  ', 41,   'hbf error: Runge-Kutta completion   '
     &        ,'nstep   ', nstep,    'ier3    ', ier3,     -1)
            gpr      = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
            gpz      = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
            if(ier .ne. 0  .or.  jer .ne. 0) then
              if(ier .ne. 0) call abortjob
     &        ('runkut  ', 42,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(jer .ne. 0) call abortjob
     &        ('runkut  ', 43,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            endif
c
            delz4    =  delr*gpz/gpr
c
c 5.3.3.3 Recompute the new vertical estimate as an average
            r1p4     =  r1p3
            z1p4     =  z0 + (delz1 + 2.0*(delz2+delz3) + delz4)/6.0
c
c
c 5.4 Test if the target psi value was exceeded
c
c 5.4.1 Calculate the new psi value at (r1p4,z1p4)
c
            r1       =  r1p4
            z1       =  z1p4
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,ier4)
            if(ier4  .ne. 0) call abortjob
     &        ('runkut  ', 44,   'hbf error: New Runge-Kutta point    '
     &        ,'nstep   ', nstep,    'ier4    ', ier4,     -1)
            psipt    = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
            gprpt    = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
            gpzpt    = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
            if(ker .ne. 0  .or.  ier .ne. 0  .or.  jer .ne. 0) then
              if(ker .ne. 0) call abortjob
     &        ('runkut  ', 45,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(ier .ne. 0) call abortjob
     &        ('runkut  ', 46,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(jer .ne. 0) call abortjob
     &        ('runkut  ', 47,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            endif
c
c 5.4.2 Iterate radial step again if target psi value is not yet reached
c
c 5.4.2.1 Return with error if maximum number of iterations is exceeded
            psiyet   = psifn - psipt
            if(jdirn*psiyet .lt. 0.0) then
              if    (nstep .ge. nstepmx) then
                call abortjob
     &        ('runkut  ', 48,   'nstep exceeds maximum in radial step'
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
                write(kunit,3000) jdirn,psiyet,jval,psiv(jval)
     &                           ,psifn,psist,psipt,r0,z0,r1,z1
                kerr   = +4
                return
c
c 5.4.2.2 Iterate again if iteration limit is not yet reached
              elseif(nstep .lt. nstepmx) then
                psist   =  psipt
                gprst   =  gprpt
                gpzst   =  gpzpt
                r0      =  r1p4
                z0      =  z1p4
                go to 50
              endif
            endif
c
c
c 5.5 Find the target (r,z) value by calculating two intermediate points
c     (rs1,zs1) and (r2,z2) between (r0,z0) and (r3,z3) and interpolating
c
c 5.5.1 Set r3 at the new point past the surface and find corresponding z value
c
            r3       =  r1
            drg0     = (psifn-psist)/(psipt-psist)*(r3-r0)
c
            call rkuttaz(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                   pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                   a1,b1,c1,d1,a2,a3,a4,a5,drg0,
     &                   rndoff,r0,z0,z1,jerz1)
            if(jerz1 .ne. 0) call abortjob
     &        ('runkut  ', 49,   'rkuttaz error: Linear estimate      '
     &        ,'jval    ', jval,     'jerz1   ', jerz1,    -1)
c
c 5.5.2 Find intermediate point rs1 from linear estimate for psi(r0,z0) 
c 
            r1       =  r0 + drg0
c
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,jer1)
            if(jer1  .ne. 0) call abortjob
     &        ('runkut  ', 50,   'hbf error: Target linear estimate   '
     &        ,'jval    ', jval,     'jer1    ', jer1,     -1)
            psi1     = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
            if(ker .ne. 0) call abortjob
     &        ('runkut  ', 51,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
            rs1      =  r1
c
c 5.5.3 Set up fourth point at (r2,z2) for cubic fit
c
c 5.5.3.1 Determine if rs1 is closer to r0 or to r3
            drg1     =  0.5*(rs1-r0 )
            drg1a    =  0.5*(r3 -rs1)
c
c 5.5.3.2 For rs1 closer to r0 than to r3
            if(abs(drg1) .lt. abs(drg1a)) then
              drg2     =  drg1a + 2.0*drg1
              call rkuttaz(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                     pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                     a1,b1,c1,d1,a2,a3,a4,a5,drg2,
     &                     rndoff,r0,z0,z1,jerz2)
              if(jerz2 .ne. 0) call abortjob
     &        ('runkut  ', 52,   'rkuttaz error: Target fitting       '
     &        ,'jval    ', jval,     'jerz2   ', jerz2,    -1)
c
              r2       =  r0 + drg2
              r1       =  r2
c
              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,jer2)
              if(jer2  .ne. 0) call abortjob
     &        ('runkut  ', 53,   'hbf error: Target interpolation     '
     &        ,'jval    ', jval,     'jer2    ', jer2,     -1)
              psi2     = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ker)
              if(ker .ne. 0) call abortjob
     &        ('runkut  ', 54,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
c
              rinp     = rs1
              pinp     = psifn
              call fit(2,r0,rs1,r2,r3,psist,psi1,psi2,psipt,rinp,pinp,
     &                 rsnew,psnew,pq,imaxp,imax,critp,crit,kunit,
     &                 iwn0,ier0,icflg0)
c
              rn       = rsnew
              pdif     = psnew - pinp
              psumg    = abs(psist) + abs(psi1 ) + abs(psi2 ) +
     &                                abs(psipt) + abs(pinp )
              compr    = crit*psumg
              if(iwn0 .ne. 0) then
                if(iabs(iwn0) .le. +3) call abortjob
     &        ('runkut  ', 55,   'Misordered r grid in fit routine    '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,      0)
                if(iabs(iwn0) .eq. +4)
     &            call abortjob
     &        ('runkut  ', 56,   'Poor initial guess for r in fit     '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,      0)
                if(iwn0 .ge. +6  .or.  iwn0 .lt. 0) call abortjob
     &        ('runkut  ', 57,   'fit bisection iteration failed      '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,      0)
                if(iwn0 .ne. +5) then
                  write(kunit,4000) iwn0,ier0,icflg0,pdif,compr
                endif
              endif
c
              if(ier0 .ne. 0  .or.  abs(pdif) .ge. compr) then
                if    (ier0 .eq. 0) then
                   call abortjob
     &        ('runkut  ', 58,   'Newton iteration in r inaccurate    '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,     -1)
                elseif(ier0 .ne. 0) then
                   if(ier0 .lt. 0) call abortjob
     &        ('runkut  ', 59,   'Interval in r array fit is zero     '
     &        ,'jval    ', jval,     'ier0    ', ier0,     -2)
                   if(ier0 .gt. 0) call abortjob
     &        ('runkut  ', 60,   'Newton iteration failure: psi(r)    '
     &        ,'jval    ', jval,     'ier0    ', ier0,     -1)
                endif
                write(kunit,4010) iwn0,ier0,icflg0
     &                           ,r0,rs1,r2,r3
     &                           ,psist,psi1,psi2,psipt
     &                           ,rinp,rsnew,pinp,psnew
     &                           ,pq,pdif,compr
              endif
c
c 5.5.3.3 For rs1 closer to r3 than to r0 
            elseif(abs(drg1) .ge. abs(drg1a)) then
              drg2     =  drg1
              call rkuttaz(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                     pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                     a1,b1,c1,d1,a2,a3,a4,a5,drg2,
     &                     rndoff,r0,z0,z1,jerz3)
              if(jerz3 .ne. 0) call abortjob
     &        ('runkut  ', 61,   'rkuttaz error: Target fitting       '
     &        ,'jval    ', jval,     'jerz3   ', jerz3,    -1)
c
              r2       =  r0 + drg2
              r1       =  r2
c
              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,jer3)
              if(jer3  .ne. 0) call abortjob
     &        ('runkut  ', 62,   'hbf error: Target interpolation     '
     &        ,'jval    ', jval,     'jer3    ', jer3,     -1)
              psi2     = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ker)
              if(ker .ne. 0) call abortjob
     &        ('runkut  ', 63,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
              rinp     = rs1
              pinp     = psifn
              call fit(2,r0,r2,rs1,r3,psist,psi2,psi1,psipt,rinp,pinp,
     &                 rsnew,psnew,pq,imaxp,imax,critp,crit,kunit,
     &                 iwn1,ier1,icflg1)
c
              rn       = rsnew
              pdif     = psnew - pinp
              psumg    = abs(psist) + abs(psi1 ) + abs(psi2 ) +
     &                                abs(psipt) + abs(pinp )
              compr    = crit*psumg
              if(iwn1 .ne. 0) then
                if(iabs(iwn1) .le. +3) call abortjob
     &        ('runkut  ', 64,   'Misordered r grid in fit routine    '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,      0)
                if(iabs(iwn1) .eq. +4)
     &            call abortjob
     &        ('runkut  ', 65,   'Poor initial guess for r in fit     '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,      0)
                if(iwn1 .ge. +6  .or.  iwn1 .lt. 0) call abortjob
     &        ('runkut  ', 66,   'fit bisection iteration failed      '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,      0)
                if(iwn1 .ne. +5) then
                  write(kunit,4020) iwn1,ier1,icflg1,pdif,compr
                endif
              endif
c
              if(ier1 .ne. 0  .or.  abs(pdif) .ge. compr) then
                if    (ier1 .eq. 0) then
                   call abortjob
     &        ('runkut  ', 67,   'Newton iteration in r inaccurate    '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,     -1)
                elseif(ier1 .ne. 0) then
                   if(ier1 .lt. 0) call abortjob
     &        ('runkut  ', 68,   'Interval in r array fit is zero     '
     &        ,'jval    ', jval,     'ier1    ', ier1,     -2)
                   if(ier1 .gt. 0) call abortjob
     &        ('runkut  ', 69,   'Newton iteration failure: psi(r)    '
     &        ,'jval    ', jval,     'ier1    ', ier1,     -1)
                endif
                write(kunit,4030) iwn1,ier1,icflg1
     &                           ,r0,r2,rs1,r3
     &                           ,psist,psi2,psi1,psipt
     &                           ,rinp,rsnew,pinp,psnew
     &                           ,pq,pdif,compr
              endif
            endif
c
c
c 5.6 Set the increment for the new point from Runge-Kutta integration of z(r)
c
            drgn     =  rn - r0
            call rkuttaz(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                   pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                   a1,b1,c1,d1,a2,a3,a4,a5,drgn,
     &                   rndoff,r0,z0,z1,jerz4)
            if(jerz4 .ne. 0) call abortjob
     &        ('runkut  ', 70,   'rkuttaz error: Final increment      '
     &        ,'jval    ', jval,     'jerz4   ', jerz4,    -1)
c
            dzgn     =  z1 - z0
c
c
c
c 6.0 Increment in z direction using four-step Runge-Kutta along the gradient in psi
c     to a point with psi = psipt between psist and psifn
c
          elseif(kcr .eq. -1) then
c
c 6.1 Step vertically half a step
c
            delz     =  kdiry*step0 
c
            drdz1    =  gprst/gpzst
            delr1    =  delz*drdz1
            r1p1     =  r0 + 0.5*delr1
            z1p1     =  z0 + 0.5*delz
c
            r1       =  r1p1
            z1       =  z1p1
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,ier1)
            if(ier1  .ne. 0) call abortjob
     &        ('runkut  ', 71,   'hbf error: First Runge-Kutta step   '
     &        ,'nstep   ', nstep,    'ier1    ', ier1,     -1)
c
            psipt    = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
            if(ker .ne. 0) call abortjob
     &        ('runkut  ', 72,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
c
c
c 6.2 Test for correct direction along the ray by testing that psipt-psist is
c     the same sign as psifn-psist
c     For the vertical step the increment may by either direction
c
c 6.2.1 Test the direction
c
            dpsfn0   = psifn - psist
            dpspt0   = psipt - psist
            if(dpsfn0*dpspt0 .lt. 0.0) then
              call abortjob
     &        ('runkut  ', 73,   'Reverse vertical search direction   '
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
              write(kunit,2100) kdiry,kcr,dpsfn0,dpspt0,psist,psipt
     &                         ,psifn,delz,delr1,r0,r1,z0,z1
     &                         ,gprst,gpzst,drdz1
c
c 6.2.2 Reverse direction and redo the increment
c       The reverse direction is retained until modified again
c
              kdiry    = -kdiry
              delz     =  kdiry*step0
c
              delr1    =  delz*drdz1
              r1p1     =  r0 + 0.5*delr1
              z1p1     =  z0 + 0.5*delz
c
              r1       =  r1p1
              z1       =  z1p1
              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,ierm1)
              if(ierm1 .ne. 0) call abortjob
     &        ('runkut  ', 74,   'hbf error in reversing direction    '
     &        ,'nstep   ', nstep,    'ierm1   ', ierm1,    -1)
c
              psipt    = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ker)
              if(ker .ne. 0) call abortjob
     &        ('runkut  ', 75,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
c
c 6.2.3 Check that the new direction works
c
              dpsfn1   = psifn - psist
              dpspt1   = psipt - psist
              write(kunit,2110) kdiry,kcr,dpsfn1,dpspt1,psist,psipt
     &                         ,psifn,delz,delr1,r0,r1,z0,z1
              if(dpsfn1*dpspt1 .lt. 0.0) then
                call abortjob
     &        ('runkut  ', 76,   'Reversed vertical search failed     '
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
                kerr    = +5
                return
              endif
            endif
c
c
c 6.3 Complete the Runge-Kutta step
c
c 6.3.1 Set up the step in the radial direction and compute the gradients there
c
            gpr      = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ier)
            gpz      = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,jer)
            if(ier .ne. 0  .or.  jer .ne. 0) then
              if(ier .ne. 0) call abortjob
     &        ('runkut  ', 77,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(jer .ne. 0) call abortjob
     &        ('runkut  ', 78,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            endif
c
            delr2    =  delz*gpr/gpz
            r1p2     =  r0 + 0.5*delr2
            z1p2     =  z1p1
c
c 6.3.2 Recompute the coefficients and gradient at the new intermediate point
c       with z incremented to the half step
c
            r1       =  r1p2
            z1       =  z1p2
            if(kuttas .gt. 0) then
              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,ier2)
              if(ier2  .ne. 0) call abortjob
     &        ('runkut  ', 79,   'hbf error: Runge-Kutta mid-step     '
     &        ,'nstep   ', nstep,    'ier2    ', ier2,     -1)
c
              gpr      = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ier)
              gpz      = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,jer)
              if(ier .ne. 0  .or.  jer .ne. 0) then
                if(ier .ne. 0) call abortjob
     &        ('runkut  ', 80,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
                if(jer .ne. 0) call abortjob
     &        ('runkut  ', 81,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              endif
            endif
c
c 6.3.3 Complete the full Runge-Kutta step
c
c 6.3.3.1 Reset the new approximate point
            delr3    =  delz*gpr/gpz
            r1p3     =  r0 + delr3
            z1p3     =  z0 + delz
c
c 6.3.3.2 Recompute the gradient direction at the new point
            r1       =  r1p3
            z1       =  z1p3
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,ier3)
            if(ier3  .ne. 0) call abortjob
     &        ('runkut  ', 82,   'hbf error: Runge-Kutta completion   '
     &        ,'nstep   ', nstep,    'ier3    ', ier3,     -1)
            gpr      = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
            gpz      = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
            if(ier .ne. 0  .or.  jer .ne. 0) then
              if(ier .ne. 0) call abortjob
     &        ('runkut  ', 83,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(jer .ne. 0) call abortjob
     &        ('runkut  ', 84,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            endif
c
            delr4    =  delz*gpr/gpz
c
c 6.3.3.3 Recompute the new radial estimate as an average
            r1p4     =  r0 + (delr1 + 2.0*(delr2+delr3) + delr4)/6.0
            z1p4     =  z1p3
c
c
c 6.4 Test if the target psi value was exceeded
c
c 6.4.1 Calculate the new psi value at (r1p4,z1p4)
c
            r1       =  r1p4
            z1       =  z1p4
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,ier4)
            if(ier4  .ne. 0) call abortjob
     &        ('runkut  ', 85,   'hbf error: New Runge-Kutta point    '
     &        ,'nstep   ', nstep,    'ier4    ', ier4,     -1)
            psipt    = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
            gprpt    = fcn(gpx,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ier)
            gpzpt    = fcn(gpy,    nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,jer)
            if(ker .ne. 0  .or.  ier .ne. 0  .or.  jer .ne. 0) then
              if(ker .ne. 0) call abortjob
     &        ('runkut  ', 86,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(ier .ne. 0) call abortjob
     &        ('runkut  ', 87,   'Index out of range in fcn(gpx) call '
     &        ,'is      ', is,       'js      ', js,       -1)
              if(jer .ne. 0) call abortjob
     &        ('runkut  ', 88,   'Index out of range in fcn(gpy) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            endif
c
c
c 6.4.2 Iterate radial step again if target psi value is not yet reached
c
c 6.4.2.1 Return with error if maximum number of iterations is exceeded
            psiyet   = psifn - psipt
            if    (jdirn*psiyet .lt. 0.0) then
              if    (nstep .ge. nstepmx) then
                call abortjob
     &        ('runkut  ', 89,   'nstep exceeded maximum in axial step'
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
                write(kunit,3000) jdirn,psiyet,jval,psiv(jval)
     &                           ,psifn,psist,psipt,r0,z0,r1,z1
                kerr     = +6
                return
c
c 6.4.2.2 Iterate again if iteration limit is not yet reached
              elseif(nstep .lt. nstepmx) then
                psist    =  psipt
                gprst    =  gprpt
                gpzst    =  gpzpt
                r0       =  r1p4
                z0       =  z1p4
                go to 50
              endif
            endif
c
c
c 6.5 Find the target (r,z) value by calculating two intermediate points
c     (rs1,zs1) and (r2,z2) between (r0,z0) and (r3,z3) and interpolating
c
c 6.5.1 Set z3 at the new point past the surface and find corresponding r value
c
            z3       =  z1
            dzg0     = (psifn-psist)/(psipt-psist)*(z3-z0)
c
            call rkuttar(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                   pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                   a1,b1,c1,d1,a2,a3,a4,a5,dzg0,
     &                   rndoff,r0,z0,r1,jerr1)
            if(jerr1 .ne. 0) call abortjob
     &        ('runkut  ', 90,   'rkuttar error: Linear estimate      '
     &        ,'jval    ', jval,     'jerr1   ', jerr1,    -1)
c
c 6.5.2 Find intermediate point zs1 from linear estimate for psi(r0,z0)
c
            z1       =  z0 + dzg0
c
            call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &               delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                       a2,a3,a4,a5,jer1)
            if(jer1  .ne. 0) call abortjob
     &        ('runkut  ', 91,   'hbf error: Target linear estimate   '
     &        ,'jval    ', jval,     'jer1    ', jer1,     -1)
            psi1     = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                                 a2,a3,a4,a5,ker)
            if(ker .ne. 0) call abortjob
     &        ('runkut  ', 92,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
            zs1      =  z1
c
c 6.5.3 Set up fourth point at (r2,z2) for cubic fit
c
c 6.5.3.1 Determine if zs1 is closer to z0 or to z3
            dzg1     =  0.5*(zs1-z0 )
            dzg1a    =  0.5*(z3 -zs1)
c
c 6.5.3.2 For zs1 closer to z0 than to z3
            if(abs(dzg1) .lt. abs(dzg1a)) then
              dzg2     =  dzg1a + 2.0*dzg1
              call rkuttar(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                     pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                     a1,b1,c1,d1,a2,a3,a4,a5,dzg2,
     &                     rndoff,r0,z0,r1,jerr2)
              if(jerr2 .ne. 0) call abortjob
     &        ('runkut  ', 93,   'rkuttar error: Target fitting       '
     &        ,'jval    ', jval,     'jerr2   ', jerr2,    -1)
c
              z2       =  z0 + dzg2
              z1       =  z2

              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,jer2)
              if(jer2  .ne. 0) call abortjob
     &        ('runkut  ', 94,   'hbf error: Target interpolation     '
     &        ,'jval    ', jval,     'jer2    ', jer2,     -1)
              psi2     = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ker)
              if(ker .ne. 0) call abortjob
     &        ('runkut  ', 95,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
              zinp     = zs1
              pinp     = psifn
              call fit(2,z0,zs1,z2,z3,psist,psi1,psi2,psipt,zinp,pinp,
     &                 zsnew,psnew,pq,imaxp,imax,critp,crit,kunit,
     &                 iwn0,ier0,icflg0)
c
              zn       = zsnew
              pdif     = psnew - pinp
              psumg    = abs(psist) + abs(psi1 ) + abs(psi2 ) +
     &                                abs(psipt) + abs(pinp )
              compr    = crit*psumg
              if(iwn0 .ne. 0) then
                if(iabs(iwn0) .le. +3) call abortjob
     &        ('runkut  ', 96,   'Misordered z grid in fit routine    '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,      0)
                if(iabs(iwn0) .eq. +4)
     &            call abortjob
     &        ('runkut  ', 97,   'Poor initial guess for z in fit     '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,      0)
                if(iwn0 .ge. +6  .or.  iwn0 .lt. 0) call abortjob
     &        ('runkut  ', 98,   'fit bisection iteration failed      '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,      0)
                if(iwn0 .ne. +5) then
                  write(kunit,4100) iwn0,ier0,icflg0,pdif,compr
                endif
              endif
c
              if(ier0 .ne. 0  .or.  abs(pdif) .ge. compr) then
                if    (ier0 .eq. 0) then
                   call abortjob
     &        ('runkut  ', 99,   'Newton iteration in z inaccurate    '
     &        ,'jval    ', jval,     'iwn0    ', iwn0,     -1)
                elseif(ier0 .ne. 0) then
                   if(ier0 .lt. 0) call abortjob
     &        ('runkut  ',100,   'Interval in z array fit is zero     '
     &        ,'jval    ', jval,     'ier0    ', ier0,     -2)
                   if(ier0 .gt. 0) call abortjob
     &        ('runkut  ',101,   'Newton iteration failure: psi(z)    '
     &        ,'jval    ', jval,     'ier0    ', ier0,     -1)
                endif
                write(kunit,4110) iwn0,ier0,icflg0
     &                           ,z0,zs1,z2,z3
     &                           ,psist,psi1,psi2,psipt
     &                           ,zinp,zsnew,pinp,psnew
     &                           ,pq,pdif,compr
              endif
c
c 6.5.3.3 For zs1 closer to z3 than to z0
            elseif(abs(dzg1) .ge. abs(dzg1a)) then
              dzg2     =  dzg1
              call rkuttar(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                     pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                     a1,b1,c1,d1,a2,a3,a4,a5,dzg2,
     &                     rndoff,r0,z0,r1,jerr3)
              if(jerr3 .ne. 0) call abortjob
     &        ('runkut  ',102,   'rkuttar error: Target fitting       '
     &        ,'jval    ', jval,     'jerr3   ', jerr3,    -1)
c
              z2       =  z0 + dzg2
              z1       =  z2
c
              call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &                 delxi,delzi,is,js,r1,z1,a1,b1,c1,d1,
     &                                         a2,a3,a4,a5,jer3)
              if(jer3  .ne. 0) call abortjob
     &        ('runkut  ',103,   'hbf error: Target interpolation     '
     &        ,'jval    ', jval,     'jer3    ', jer3,     -1)
              psi2     = fcn(psarray,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1,
     &                                             a2,a3,a4,a5,ker)
              if(ker .ne. 0) call abortjob
     &        ('runkut  ',104,   'Index out of range in fcn(psi) call '
     &        ,'is      ', is,       'js      ', js,       -1)
c
              zinp     = zs1
              pinp     = psifn
              call fit(2,z0,z2,zs1,z3,psist,psi2,psi1,psipt,zinp,pinp,
     &                 zsnew,psnew,pq,imaxp,imax,critp,crit,kunit,
     &                 iwn1,ier1,icflg1)
c
              zn       = zsnew
              pdif     = psnew - pinp
              psumg    = abs(psist) + abs(psi1 ) + abs(psi2 ) +
     &                                abs(psipt) + abs(pinp )
              compr    = crit*psumg
              if(iwn1 .ne. 0) then
                if(iabs(iwn1) .le. +3) call abortjob
     &        ('runkut  ',105,   'Misordered z grid in fit routine    '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,      0)
                if(iabs(iwn1) .eq. +4)
     &            call abortjob
     &        ('runkut  ',106,   'Poor initial guess for z in fit     '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,      0)
                if(iwn1 .ge. +6  .or.  iwn1 .lt. 0) call abortjob
     &        ('runkut  ',107,   'fit bisection iteration failed      '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,      0)
                if(iwn1 .ne. +5) then
                  write(kunit,4120) iwn1,ier1,icflg1,pdif,compr
                endif
              endif
c
              if(ier1 .ne. 0  .or.  abs(pdif) .ge. compr) then
                if    (ier1 .eq. 0) then
                   call abortjob
     &        ('runkut  ',108,   'Newton iteration in z inaccurate    '
     &        ,'jval    ', jval,     'iwn1    ', iwn1,     -1)
                elseif(ier1 .ne. 0) then
                   if(ier1 .lt. 0) call abortjob
     &        ('runkut  ',109,   'Interval in z array fit is zero     '
     &        ,'jval    ', jval,     'ier1    ', ier1,     -2)
                   if(ier1 .gt. 0) call abortjob
     &        ('runkut  ',110,   'Newton iteration failure: psi(z)    '
     &        ,'jval    ', jval,     'ier1    ', ier1,     -1)
                endif
                write(kunit,4130) iwn1,ier1,icflg1
     &                           ,z0,z2,zs1,z3
     &                           ,psist,psi2,psi1,psipt
     &                           ,zinp,zsnew,pinp,psnew
     &                           ,pq,pdif,compr
              endif
            endif
c
c
c 6.6 Set the increment for the new point from Runge-Kutta integration of r(z)
c
            dzgn     =  zn - z0
            call rkuttar(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                   pslim,ipg,delxi,delzi,is,js,r1,z1,
     &                   a1,b1,c1,d1,a2,a3,a4,a5,dzgn,
     &                   rndoff,r0,z0,r1,jerr4)
            if(jerr2 .ne. 0) call abortjob
     &        ('runkut  ',111,   'rkuttar error: Final increment      '
     &        ,'jval    ', jval,     'jerr2   ', jerr2,    -1)
            drgn     =  r1 - r0
          endif
c
c
c
c 7.0 Save the target (r,z) and set up for the next target
c
c 7.1 Seset the start point for the next target psi value
c
        r0         =  r0 + drgn
        z0         =  z0 + dzgn
        if(kcr .eq. +1) r1   =  r0
        if(kcr .eq. -1) z1   =  z0
c
c
c 7.2 Save the new point
c
        jdone      =  jval
        rst(jval)  =  r0
        zst(jval)  =  z0
c
c
c 7.3 Exit with error if total number of iterations exceeded
c
        if    (nstep .ge. nstepmx) then
          call abortjob
     &        ('runkut  ',112,   'nstep exceeded maximum at target    '
     &        ,'jval    ', jval,     'nstep   ', nstep,     0)
          write(kunit,3000) jdirn,psiyet,jval,psiv(jval)
     &                     ,psifn,psist,psipt,r0,z0,r1,z1
          kerr      = +7
          return
        endif
c
c
c 7.4 End of iteration over target psi
c
  100 continue
c
c
c
c 8.0 Return and end
c
      return
c
 1000 format(   10x,'kuttas   = ',i5
     &       ,/,10x,'rstart0  = ',e16.9,2x,'zstart0  = ',e16.9
     &       ,/,10x,'rstart   = ',e16.9,2x,'zstart   = ',e16.9
     &       ,/,10x,'step0    = ',e16.9,2x,'stepp    = ',e16.9)
 1010 format(   10x,'pstart   = ',e16.9,2x,'psist00  = ',e16.9
     &         , 2x,'gprst00  = ',e16.9,2x,'gpzst00  = ',e16.9
     &      ,/, 10x,'delp00   = ',e16.9
     &         , 2x,'tolpsi   = ',e16.9,2x,'psinm    = ',e16.9)
 1020 format(   10x,'Resetting psist00 = ',e16.9,1x,'to pstart = '
     &              ,e16.9,1x,'(Compare to ptargt = ',e16.9,')')
 1100 format(   10x,'kuttas   = ',i5
     &       ,/,10x,'rstart0  = ',e16.9,2x,'zstart0  = ',e16.9
     &       ,/,10x,'rstart   = ',e16.9,2x,'zstart   = ',e16.9
     &       ,/,10x,'rinit    = ',e16.9,2x,'zinit    = ',e16.9
     &       ,/,10x,'step0    = ',e16.9,2x,'stepp    = ',e16.9)
 1110 format(   10x,'pstart   = ',e16.9,2x,'psist0   = ',e16.9
     &       ,/,10x,'psprev   = ',e16.9
     &         , 2x,'psiv(jfirst=',i5,') = ',e16.9
     &         , 2x,'delp1    = ',e16.9,2x,'delp2    = ',e16.9
     &      ,/, 10x,'gprst0   = ',e16.9,2x,'gpzst0   = ',e16.9)
 1200 format(   10x,'kuttas   = ',i5
     &       ,/,10x,'rstart0  = ',e16.9,2x,'zstart0  = ',e16.9
     &       ,/,10x,'rstart   = ',e16.9,2x,'zstart   = ',e16.9
     &       ,/,10x,'rinit    = ',e16.9,2x,'zinit    = ',e16.9
     &       ,/,10x,'step0    = ',e16.9,2x,'stepp    = ',e16.9)
 1210 format(   10x,'pstart   = ',e16.9,2x,'psist0   = ',e16.9
     &       ,/,10x,'psprev   = ',e16.9
     &         , 2x,'psiv(jfirst=',i5,') = ',e16.9
     &         , 2x,'delp1    = ',e16.9,2x,'delp2    = ',e16.9
     &      ,/, 10x,'gprst0   = ',e16.9,2x,'gpzst0   = ',e16.9)
 2000 format(   10x,'kdirx    = ',i2,  16x,'kcr      = ',i2
     &       ,/,10x,'dpsfn0   = ',e16.9,2x,'dpspt0   = ',e16.9
     &       ,/,10x,'psist    = ',e16.9,2x,'psipt    = ',e16.9
     &          ,5x,'psifn    = ',e16.9
     &       ,/,10x,'delr     = ',e16.9,2x,'delz1    = ',e16.9
     &       ,/,10x,'r0       = ',e16.9,2x,'r1       = ',e16.9
     &          ,5x,'z0       = ',e16.9,2x,'z1       = ',e16.9
     &       ,/,10x,'gprst    = ',e16.9,2x,'gpzst    = ',e16.9
     &          ,5x,'dzdr1    = ',e16.9)
 2005 format(    5x,'kdirx    = ',i2,  16x,'kcr      = ',i2
     &       ,/,10x,'dpsfn0   = ',e16.9,2x,'dpspt0   = ',e16.9
     &       ,/,10x,'psist    = ',e16.9,2x,'psipt    = ',e16.9
     &          ,5x,'psifn    = ',e16.9
     &       ,/,10x,'delr     = ',e16.9,2x,'delz1    = ',e16.9
     &       ,/,10x,'r0       = ',e16.9,2x,'r1       = ',e16.9
     &          ,5x,'z0       = ',e16.9,2x,'z1       = ',e16.9
     &       ,/,10x,'gprst    = ',e16.9,2x,'gpzst    = ',e16.9
     &          ,5x,'dzdr1    = ',e16.9)
 2010 format(    5x,'After reversal in  radial  direction:'
     &       ,/,10x,'kdirx    = ',i2,  16x,'kcr      = ',i2
     &       ,/,10x,'dpsfn0   = ',e16.9,2x,'dpspt0   = ',e16.9
     &       ,/,10x,'psist    = ',e16.9,2x,'psipt    = ',e16.9
     &          ,5x,'psifn    = ',e16.9
     &       ,/,10x,'delr     = ',e16.9,2x,'delz1    = ',e16.9
     &       ,/,10x,'r0       = ',e16.9,2x,'r1       = ',e16.9
     &          ,5x,'z0       = ',e16.9,2x,'z1       = ',e16.9)
 2100 format(    5x,'kdiry    = ',i2,  16x,'kcr      = ',i2
     &       ,/,10x,'dpsfn0   = ',e16.9,2x,'dpspt0   = ',e16.9
     &       ,/,10x,'psist    = ',e16.9,2x,'psipt    = ',e16.9
     &          ,5x,'psifn    = ',e16.9
     &       ,/,10x,'delz     = ',e16.9,2x,'delr1    = ',e16.9
     &       ,/,10x,'r0       = ',e16.9,2x,'r1       = ',e16.9
     &          ,5x,'z0       = ',e16.9,2x,'z1       = ',e16.9
     &       ,/,10x,'gprst    = ',e16.9,2x,'gpzst    = ',e16.9
     &          ,5x,'drdz     = ',e16.9)
 2110 format(    5x,'After reversal in vertical direction:'
     &       ,/,10x,'kdiry    = ',i2,  16x,'kcr      = ',i2
     &       ,/,10x,'dpsfn0   = ',e16.9,2x,'dpspt0   = ',e16.9
     &       ,/,10x,'psist    = ',e16.9,2x,'psipt    = ',e16.9
     &          ,5x,'psifn    = ',e16.9
     &       ,/,10x,'delz     = ',e16.9,2x,'delr1    = ',e16.9
     &       ,/,10x,'r0       = ',e16.9,2x,'r1       = ',e16.9
     &          ,5x,'z0       = ',e16.9,2x,'z1       = ',e16.9)
 3000 format(    5x,'Direction: jdirn = ',i5,2x,'psiyet     = ',e16.9
     &       ,/,10x,'psi(',i5,') = ',e16.9
     &          ,2x,'psifn      = ',e16.9,2x,'psist      = ',e16.9
     &          ,2x,'psipt      = ',e16.9
     &       ,/,10x,'r0         = ',e16.9,2x,'z0         = ',e16.9
     &          ,2x,'r1         = ',e16.9,2x,'z1         = ',e16.9)
 4000 format(   10x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &         ,13x,'icflg0 = ',i5
     &       ,/,10x,'pdif   = ',e16.9,2x,'compr  = ',e16.9)
 4010 format(   10x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &         ,13x,'icflg0 = ',i5
     &       ,/,10x,'r0     = ',e16.9,2x,'rs1    = ',e16.9
     &          ,2x,'r2     = ',e16.9,2x,'r3     = ',e16.9
     &       ,/,10x,'psist  = ',e16.9,2x,'psi1   = ',e16.9
     &          ,2x,'psi2   = ',e16.9,2x,'psipt  = ',e16.9
     &       ,/,10x,'rinp   = ',e16.9,2x,'rsnew  = ',e16.9
     &          ,2x,'pinp   = ',e16.9,2x,'psnew  = ',e16.9
     &       ,/,10x,'pq     = ',e16.9,2x,'pdif   = ',e16.9
     &          ,2x,'compr  = ',e16.9)
 4020 format(   10x,'iwn1   = ',i5,  13x,'ier1   = ',i5
     &         ,13x,'icflg1 = ',i5
     &       ,/,10x,'pdif   = ',e16.9,2x,'compr  = ',e16.9)
 4030 format(   10x,'iwn1   = ',i5,  13x,'ier1   = ',i5
     &         ,13x,'icflg1 = ',i5
     &       ,/,10x,'r0     = ',e16.9,2x,'r2     = ',e16.9
     &          ,2x,'rs1    = ',e16.9,2x,'r3     = ',e16.9
     &       ,/,10x,'psist  = ',e16.9,2x,'psi2   = ',e16.9
     &          ,2x,'psi1   = ',e16.9,2x,'psipt  = ',e16.9
     &       ,/,10x,'rinp   = ',e16.9,2x,'rsnew  = ',e16.9
     &          ,2x,'pinp   = ',e16.9,2x,'psnew  = ',e16.9
     &       ,/,10x,'pq     = ',e16.9,2x,'pdif   = ',e16.9
     &          ,2x,'compr  = ',e16.9)
 4100 format(   10x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &         ,13x,'icflg0 = ',i5
     &       ,/,10x,'pdif   = ',e16.9,2x,'compr  = ',e16.9)
 4110 format(   10x,'iwn0   = ',i5,  13x,'ier0   = ',i5
     &         ,13x,'icflg0 = ',i5
     &       ,/,10x,'z0     = ',e16.9,2x,'zs1    = ',e16.9
     &          ,2x,'z2     = ',e16.9,2x,'z3     = ',e16.9
     &       ,/,10x,'psist  = ',e16.9,2x,'psi1   = ',e16.9
     &          ,2x,'psi2   = ',e16.9,2x,'psipt  = ',e16.9
     &       ,/,10x,'zinp   = ',e16.9,2x,'zsnew  = ',e16.9
     &          ,2x,'pinp   = ',e16.9,2x,'psnew  = ',e16.9
     &       ,/,10x,'pq     = ',e16.9,2x,'pdif   = ',e16.9
     &          ,2x,'compr  = ',e16.9)
 4120 format(   10x,'iwn1   = ',i5,  13x,'ier1   = ',i5
     &         ,13x,'icflg1 = ',i5
     &       ,/,10x,'pdif   = ',e16.9,2x,'compr  = ',e16.9)
 4130 format(   10x,'iwn1   = ',i5,  13x,'ier1   = ',i5
     &         ,13x,'icflg1 = ',i5
     &       ,/,10x,'z0     = ',e16.9,2x,'z2     = ',e16.9
     &          ,2x,'zs1    = ',e16.9,2x,'z3     = ',e16.9
     &       ,/,10x,'psist  = ',e16.9,2x,'psi2   = ',e16.9
     &          ,2x,'psi1   = ',e16.9,2x,'psipt  = ',e16.9
     &       ,/,10x,'zinp   = ',e16.9,2x,'zsnew  = ',e16.9
     &          ,2x,'pinp   = ',e16.9,2x,'psnew  = ',e16.9
     &       ,/,10x,'pq     = ',e16.9,2x,'pdif   = ',e16.9
     &          ,2x,'compr  = ',e16.9)
      end
      subroutine rkuttar(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                   pslim,ipg,delxi,delyi,is,js,x1,y1,
     &                   a1,b1,c1,d1,a2,a3,a4,a5,dely0,
     &                   smallno,x0,y0,x2,ker)
c
c ---------------------------------------------------------------
c
c  Runge-Kutta integration for x(y) in psi gradient direction
c
c ---------------------------------------------------------------
c
      dimension xw(nw),yh(nh),psarray(nwd,nhd)
      dimension gpx(nwd,nhd),gpy(nwd,nhd)
c
c
c
c 1.0 Initialization point for Runge-Kutta
c
c 1.1 Initialization
c
c 1.1.1 Initialize error flag
c
      ker     = 0
c
c 1.1.2 Find local interpolation coefficients
c
      x1      =  x0
      y1      =  y0
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier0)
      if(ier0 .ne. 0) then
        call abortjob
     &        ('rkuttar ',  1,   'hbf error: Initial approximation    '
     &        ,'ier0    ', ier0,     'is      ', is,        0)
        ker     = ier0
      endif
c
c
c 1.2 Find local gradient
c
      gpx1    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy1    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttar ',  2,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttar ',  3,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpy1) .le. smallno) then
        call abortjob
     &        ('rkuttar ',  4,   'Gradient small at initial point     '
     &        ,'is      ', is,       'js      ', js,        0)
        ker     = -1
        gpy1    = smallno
      endif
      gprat1    = gpx1/gpy1
c
c
c
c 2.0 Half point approximation
c
c 2.1 First approximation using initial gradient
c
c 2.1.1 Find local interpolation coefficients
c
      delx1   =           dely0*gprat1
      dely1   =           dely0
      x1      =  x0 + 0.5*delx1
      y1      =  y0 + 0.5*dely1
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier1)
      if(ier1 .ne. 0) then
        call abortjob
     &        ('rkuttar ',  5,   'hbf error:Midpoint approximation    '
     &        ,'ier1    ', ier1,     'is      ', is,        0)
        ker     = ier1
      endif
c
c 2.1.2 Find local gradient
c
      gpx2    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy2    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttar ',  6,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttar ',  7,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpy2) .le. smallno) then
        call abortjob
     &        ('rkuttar ',  8,   'Gradient small at first midpoint    '
     &        ,'is      ', is,       'js      ', js,        0)
        ker     = -2
        gpy2    = smallno
      endif
      gprat2  = gpx2/gpy2
c
c
c 2.2 Second approximation using new gradient
c
c 2.2.1 Find local interpolation coefficients
c
      delx2   =           dely1*gprat2
      x1      =  x0 + 0.5*delx2
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier2)
      if(ier2 .ne. 0) then
        call abortjob
     &        ('rkuttar ',  9,   'hbf error:Midpoint approximation    '
     &        ,'ier2    ', ier2,     'is      ', is,        0)
        ker     = ier2
      endif
c
c 2.2.2 Find local gradient
c
      gpx3    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy3    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttar ', 10,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttar ', 11,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpy3) .le. smallno) then
        call abortjob
     &        ('rkuttar ', 12,   'Gradient small: second midpoint     '
     &        ,'is      ', is,       'js      ', js,        0)
        ker     = -3
        gpy3    = gpy2
      endif
      gprat3  = gpx3/gpy3
c
c
c
c 3.0 Full point approximation
c
c 3.1 Find local interpolation coefficients
c
      delx3   =           dely0*gprat3
      dely3   =           dely0
      x1      =  x0 +     delx3
      y1      =  y0 +     dely3
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier3)
      if(ier3 .ne. 0) then
        call abortjob
     &        ('rkuttar ', 13,   'hbf error: Final approximation      '
     &        ,'ier3    ', ier3,     'is      ', is,       -1)
        ker     = ier3
      endif
c
c 3.2 Find local gradient
c
      gpx4    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy4    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttar ', 14,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttar ', 15,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpy4) .le. smallno) then
        call abortjob
     &        ('rkuttar ', 16,   'Gradient small at final point       '
     &        ,'is      ', is,       'js      ', js,       -1)
        ker     = -4
        gpy4    = smallno
      endif
      gprat4  = gpx4/gpy4
c
c
c
c 4.0 Weighted Runge-Kutta average
c
      delx4   =        dely0*gprat4
      x2      =  x0 + (delx1  +  2.0*(delx2 + delx3)  +  delx4)/6.0
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine rkuttaz(xw,yh,nw,nh,psarray,gpx,gpy,nwd,nhd,
     &                   pslim,ipg,delxi,delyi,is,js,x1,y1,
     &                   a1,b1,c1,d1,a2,a3,a4,a5,delx0,
     &                   smallno,x0,y0,y2,ker)
c
c ---------------------------------------------------------------
c
c  Runge-Kutta integration for y(x) in psi gradient direction
c
c ---------------------------------------------------------------
c
      dimension xw(nw),yh(nh),psarray(nwd,nhd)
      dimension gpx(nwd,nhd),gpy(nwd,nhd)
c
c
c
c 1.0 Initialization point for Runge-Kutta
c
c 1.1 Initialization
c
c 1.1.1 Initialize error flag
c
      ker     = 0
c
c 1.1.2 Find local interpolation coefficients
c
      x1      = x0
      y1      = y0
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier0)
      if(ier0 .ne. 0) then
        call abortjob
     &        ('rkuttaz ',  1,   'hbf error: Initial approximation    '
     &        ,'ier0    ', ier0,     'js      ', js,        0)
        ker     = ier0
      endif
c
c
c 1.2 Find local gradient
c
      gpx1    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy1    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttaz ',  2,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttaz ',  3,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpx1) .le. smallno) then
        call abortjob
     &        ('rkuttaz ',  4,   'Gradient small at initial point     '
     &        ,'is      ', is,       'js      ', js,        0)
        ker     = -1
        gpx1    = smallno
      endif
      gprat1  = gpy1/gpx1
c
c
c
c 2.0 Half point approximation
c
c 2.1 First approximation using initial gradient
c
c 2.1.1 Find local interpolation coefficients
c
      delx1   =           delx0
      dely1   =           delx0*gprat1
      x1      =  x0 + 0.5*delx1
      y1      =  y0 + 0.5*dely1
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier1)
      if(ier1 .ne. 0) then
        call abortjob
     &        ('rkuttaz ',  5,   'hbf error:Midpoint approximation    '
     &        ,'ier1    ', ier1,     'js      ', js,        0)
        ker     = ier1
      endif
c
c 2.1.2 Find local gradient
c
      gpx2    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy2    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttaz ',  6,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttaz ',  7,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpx2) .le. smallno) then
        call abortjob
     &        ('rkuttaz ',  8,   'Gradient small at first midpoint    '
     &        ,'is      ', is,       'js      ', js,        0)
        ker     = -2
        gpx2    = smallno
      endif
      gprat2  = gpy2/gpx2
c
c
c 2.2 Second approximation using new gradient
c
c 2.2.1 Find local interpolation coefficients
c
      dely2   =           delx1*gprat2
      y1      =  y0 + 0.5*dely2
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier2)
      if(ier2 .ne. 0) then
        call abortjob
     &        ('rkuttaz ',  9,   'hbf error:Midpoint approximation    '
     &        ,'ier2    ', ier2,     'js      ', js,        0)
        ker     = ier2
      endif
c
c 2.2.2 Find local gradient
c
      gpx3    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy3    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttaz ', 10,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttaz ', 11,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpx3) .le. smallno) then
        call abortjob
     &        ('rkuttaz ', 12,   'Gradient small: second midpoint     '
     &        ,'is      ', is,       'js      ', js,        0)
        ker     = -3
        gpx3    = gpx2
      endif
      gprat3  = gpy3/gpx3
c
c
c
c 3.0 Full point approximation
c
c 3.1 Find local interpolation coefficients
c
      delx3   =           delx0
      dely3   =           delx0*gprat3
      x1      =  x0 +     delx3
      y1      =  y0 +     dely3
      call hbf(xw,yh,nw,nh,psarray,nwd,nhd,pslim,ipg,
     &         delxi,delyi,is,js,x1,y1,a1,b1,c1,d1,
     &                                 a2,a3,a4,a5,ier3)
      if(ier3 .ne. 0) then
        call abortjob
     &        ('rkuttaz ', 13,   'hbf error: Final approximation      '
     &        ,'ier3    ', ier3,     'js      ', js,       -1)
        ker     = ier3
      endif
c
c
c 3.2 Find local gradient
c
      gpx4    = fcn(gpx,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,ier)
      gpy4    = fcn(gpy,nw,nh,nwd,nhd,is,js,a1,b1,c1,d1
     &                                     ,a2,a3,a4,a5,jer)
      if(ier .ne. 0  .or.  jer .ne. 0) then
        if(ier .ne. 0) call abortjob
     &        ('rkuttaz ', 14,   'Index out of range:fcn(gpx) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
        if(jer .ne. 0) call abortjob
     &        ('rkuttaz ', 15,   'Index out of range:fcn(gpy) call    '
     &        ,'is      ', is,       'js      ', js,       -1)
      endif
c
      if(abs(gpx4) .le. smallno) then
        call abortjob
     &        ('rkuttaz ', 16,   'Gradient small at final point       '
     &        ,'is      ', is,       'js      ', js,       -1)
        ker     = -4
        gpx4    = smallno
      endif
      gprat4  = gpy4/gpx4
c
c
c
c 4.0 Weighted Runge-Kutta average
c
      dely4   =        delx0*gprat4
      y2      =  y0 + (dely1  +  2.0*(dely2 + dely3)  +  dely4)/6.0
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine sorter(xs,ys,gs,ns,xmx,ymx,xset,yset,gset,big
     &                 ,small,isense,iorder,ier)
      dimension xs(ns),ys(ns),gs(ns)
c
c
c     Check the order of the points
c     Keep checking pairwise until the order is apparent
c
      ier      = 0
      isense   = 0
      iorder   = 0
      ivs      = 0
   10 ivs      = ivs+1
c
         if(ivs .ge. ns) then
           if(ns .eq. 0) ier  = -1
           if(ns .ne. 0) ier  =  ns
           return
         endif
c
         dr1     = xs( ivs ) - xmx
         dr2     = xs(ivs+1) - xmx
         dy1     = ys( ivs ) - ymx
         dy2     = ys(ivs+1) - ymx
c
         dot     = dr1*dr2 + dy1*dy2
         cross   = dr1*dy2 - dr2*dy1
c
      if((abs(dot) .le. small) .or. (abs(cross) .le. small)) go to 10
c
c
c     Reorder the points to make them counterclockwise if needed
c
      if(cross*dot .lt. 0.0) then
         isense  = +ivs
         call reverse(xs,ys,gs,ns)
      endif
c
c
c     Sort so the first point is xset,yset and delete the last point
c
      ns1      = ns-1
      call sortog(xs,ys,gs,ns1,xset,yset,gset,big,iorder)
c
c
c     Reset the last point to equal the new first point
c
      xs(ns)   = xs(1)
      ys(ns)   = ys(1)
      gs(ns)   = gs(1)
      return
      end
      subroutine reverse(xs,ys,gs,ns)
      dimension xs(ns),ys(ns),gs(ns)
c
c
c     Reverse the order of the points.
c
      nsort    = ns/2
      nsl      = ns+1
      do 100 i = 1,nsort
      nsl      = nsl-1
      ts       = xs(i)
      xs(i)    = xs(nsl)
      xs(nsl)  = ts
c
      ts       = ys(i)
      ys(i)    = ys(nsl)
      ys(nsl)  = ts
c
      ts       = gs(i)
      gs(i)    = gs(nsl)
      gs(nsl)  = ts
  100 continue
c
      return
      end
      subroutine sortog(xs,ys,gs,ns,xset,yset,gset,big,korder)
      dimension xs(ns),ys(ns),gs(ns)
c
c
c     Find the point closest to (xset,yset).
c
      ker      = 0
      iset     = 1
      errdif   = big
      do 30 i  = 1,ns
      ws       = (xs(i)-xset)**2 + (ys(i)-yset)**2
      if(ws .le. errdif) then
        iset     = i
        errdif   = ws
      endif
   30 continue
c
c
c     Reset point iset to be (xset,yset).
c
      korder   = 0
      ys(iset) = yset
      xs(iset) = xset
      gs(iset) = gset
      if(iset .eq. 1) return
c
c
c     Rearrange the points to start from iset.
c
      korder   = iset
      iset1    = iset-1
      nsm1     = ns-1
      do 100 i = 1,iset1
      tsx      = xs(1)
      tsy      = ys(1)
      tsg      = gs(1)
      do 90 jj = 1,nsm1
      xs(jj)   = xs(jj+1)
      ys(jj)   = ys(jj+1)
      gs(jj)   = gs(jj+1)
   90 continue
c
      xs(ns)   = tsx
      ys(ns)   = tsy
      gs(ns)   = tsg
  100 continue
c
      return
      end
      function sterpl(thet1,th,rh,cspl,ncp,ncpmx,nbcd,rndoff,ier)
      dimension th(ncpmx),rh(ncpmx),cspl(3,ncpmx)
c
      ier     =  0
      thet    = thet1
c
c     Set periodic boundary conditions if point is outside the range
c
      kp      =  0
      thpd    = th(ncp) - th(1)
      rhpd    = rh(ncp) - rh(1)
      if(nbcd .eq. 1) then
        if(thet .lt. th( 1 )) kp    = +1
        if(thet .gt. th(ncp)) kp    = -1
      endif
c
      thet    = thet + kp*thpd
      if(thet .lt. (th( 1 )-rndoff)) ier   = -1
      if(thet .gt. (th(ncp)+rndoff)) ier   = +1
c
c     Search for the nearest grid point
c
      do 10 i = 2,ncp
      ic      = i
      if(thet .lt. th(ic)) go to 20
  10  continue
      ic      = ncp
c
c     Interpolate using the cubic spline coefficients
c
  20  is      = ic-1
      yq      = thet - th(is)
      stansw  = ((    cspl(3,is)*yq +     cspl(2,is))*yq + cspl(1,is))
     &                          *yq  +  rh(is)
      sterpl  = stansw - kp*rhpd
      return
      end
      function sterpp(thet1,th,rh,cspl,ncp,ncpmx,nbcd,rndoff,ier)
      dimension th(ncpmx),rh(ncpmx),cspl(3,ncpmx)
c
      ier     =  0
      thet    = thet1
c
c     Set periodic boundary conditions if point is outside the range
c     It is not clear that this works correctly for periodic boundary
c     conditions
c
      kp      =  0
      thpd    = th(ncp) - th(1)
      rhpd    = rh(ncp) - rh(1)
      if(nbcd .eq. 1) then
        if(thet .lt. th( 1 )) kp    = +1
        if(thet .gt. th(ncp)) kp    = -1
        ier     = +2
      endif
c
      thet    = thet + kp*thpd
      if(thet .lt. (th( 1 )-rndoff)) ier   = -1
      if(thet .gt. (th(ncp)+rndoff)) ier   = +1
c
c     Search for the nearest grid point
c
      do 10 i = 2,ncp
      ic      = i
      if(thet .lt. th(ic)) go to 20
  10  continue
      ic      = ncp
c
c     Interpolate using the cubic spline coefficients
c
  20  is      = ic-1
      yq      = thet - th(is)
      stansw  = ((3.0*cspl(3,is)*yq + 2.0*cspl(2,is))*yq + cspl(1,is))
      sterpp  = stansw
      return
      end
      function sterp2(thet1,th,rh,cspl,ncp,ncpmx,nbcd,rndoff,ier)
      dimension th(ncpmx),rh(ncpmx),cspl(3,ncpmx)
c
      ier     =  0
      thet    = thet1
c
c     Set periodic boundary conditions if point is outside the range
c     It is not clear that this works correctly for periodic boundary
c     conditions
c
      kp      =  0
      thpd    = th(ncp) - th(1)
      rhpd    = rh(ncp) - rh(1)
      if(nbcd .eq. 1) then
        if(thet .lt. th( 1 )) kp    = +1
        if(thet .gt. th(ncp)) kp    = -1
        ier     = +2
      endif
c
      thet    = thet + kp*thpd
      if(thet .lt. (th( 1 )-rndoff)) ier   = -1
      if(thet .gt. (th(ncp)+rndoff)) ier   = +1
c
c     Search for the nearest grid point
c
      do 10 i = 2,ncp
      ic      = i
      if(thet .lt. th(ic)) go to 20
  10  continue
      ic      = ncp
c
c     Interpolate using the cubic spline coefficients
c
  20  is      = ic-1
      yq      = thet - th(is)
      stansw  =   6.0*cspl(3,is)*yq + 2.0*cspl(2,is)
      sterp2  = stansw
      return
      end
      subroutine icsici (x,y,nx,bpar,c,nc,ier)
c
c
c   routine           - interpolatory approximation by cubic splines
c                           with arbitrary second derivative
c                           conditions.
c   usage               - call icsici(x,y,nx,bpar,c,nc,ier)
c   parameters   x      - vector of length nx containing the abscissae
c                           of the nx data points (x(i),y(i)) i=1,...,
c                           nx (input). x must be ordered so that
c                           x(i) .lt. x(i+1).
c                y      - vector of length nx containing the ordinates
c                          (or routine values) of the nx data points
c                           (input).
c                nx     - number of elements in x and y (input). nx
c                           must be .ge. 2.
c                bpar   - vector of length 4 containing the b c
c                           condition parameters (input).
c                           2.0*spp(1)+bpar(1)*spp(2) = bpar(2),
c                           bpar(3)*spp(nx-1)+2.0*spp(nx) = bpar(4),
c                           where spp(i) = second derivative of the
c                          cubic spline routine s evaluated at x(i).
c                c      - spline coefficients (output). c is an nx-1 by
c                           3 matrix. the value of the spline
c                           approximation at t is
c                           s(t) = ((c(3,i)*d+c(2,i))*d+c(1,i))*d+y(i)
c                           where x(i) .le. t .lt. x(i+1) and
c                           d = t-x(i).
c                nc     - row dimension of matrix c in the calling
c                           program (input). nc must be .ge. nx-1.
c                ier    - error parameter.
c                         terminal error
c                   x(j+1)        ier = -1, nc is less than nx-1.
c                           ier = +1, nx is less than 2.
c                           ier >  1, input abscissa are not ordered
c                                     at the j'th point
c ----------------------------------------------------------------------
c
      dimension          x(nx),y(nx),bpar(4),c(3,nc)
c
      data               zero/0.0/,half/0.5/,one/1.0/,
     &                   two /2.0/,six /6.0/
c
c
c                                    check error conditions
      ier        = 0
      nxm1       = nx-1
      if (nc .lt. nxm1) then
        ier        = -1
        call uertst(129,'icsici')
        return
      endif
c
      if     (nx .lt.  2 ) then
        ier        = +1
        call uertst(130,'icsici')
        return
c
      elseif (nx .eq. 2) then
        c(1,1)     = -bpar(1)*half
        c(2,1)     = +bpar(2)*half
c
      elseif (nx .gt. 2) then
c                                    compute coefficients and right
c                                    hand side of the tridiagonal
c                                    system defining the second
c                                    derivatives of the spline
c                                    interpolant for (x,y)
c                                    c(1,j) = lambda(j)
c                                    c(2,j) = mu(j)
c                                    c(3,j) = d(j)
        dxj      = x(2) - x(1)
        dyj      = y(2) - y(1)
        if (dxj .le. zero) then
          ier      = +2
          call uertst(131,'icsici')
          return
        endif
c
        do 5 j   = 2,nxm1
          dxjp1    = x(j+1) - x(j)
          if (dxjp1 .le. zero) then
            ier    = j+1
            call uertst(131,'icsici')
            return
          endif
c
          dyjp1  = y(j+1) - y(j)
          dxp    = dxj   + dxjp1
          c(1,j) = dxjp1 / dxp
          c(2,j) = one - c(1,j)
          c(3,j) = six*(dyjp1/dxjp1 - dyj/dxj)  /  dxp
          dxj    = dxjp1
          dyj    = dyjp1
    5   continue
c
c                                    factor the tridiagonal matrix
c                                    and solve for u
c                                    c(2,j)  = u(j)
c                                    c(1,j)  = q(j)
c                                    bpar(1) = lambda(1)
c                                    bpar(2) = d(1)
c                                    bpar(3) = mu(nx)
c                                    bpar(4) = d(nx)
        c(1,1)   = -bpar(1)*half
        c(2,1)   = +bpar(2)*half
c
        do 15 j  = 2,nxm1
          pj     =  c(2,j)*c(1,j-1) + two
          c(1,j) = -c(1,j)/pj
          c(2,j) = (c(3,j) - c(2,j)*c(2,j-1))  /  pj
   15   continue
      endif
c
c                                  solve for cubic coefficients
c                                  of spline interpolant
c                                  c(1,j), c(2,j), and c(3,j)
      yppb       = (bpar(4) - bpar(3)*c(2,nxm1))  /  
     &             (bpar(3)*c(1,nxm1) + two)
      sixi       = one/six
c
      do 25 i    = 1,nxm1
        j        = nx-i
        yppa     = c(1,j)*yppb + c(2,j)
        dx       = x(j+1) - x(j)
        c(3,j)   = sixi*(yppb - yppa)/dx
        c(2,j)   = half*yppa
        c(1,j)   = (y(j+1) - y(j))/dx  -  (c(2,j) + c(3,j)*dx)*dx
        yppb     = yppa
   25 continue
c
c
      return
      end
      subroutine leqt1p (a,na,m,n,b,ib,idgt,d1,d2,ier)
c
c-leqt1p--------s-------library 3---------------------------------------
c
c   routine            - linear equation solution - symmetric storage
c                           mode - space economizer solution
c   usage               - call leqt1p(a,na,m,n,b,ib,idgt,d1,d2,ier)
c   parameters   a      - input vector of length n(n+1)/2 containing the
c                           n by n coefficient matrix of the equation
c                           ax = b. a is a positive definite symmetric
c                           matrix stored in symmetric storage mode.
c                         on output, a is replaced by the lower
c                           triangular matrix l where a = l*l-transpose.
c                           l is stored in symmetric storage mode with
c                           the diagonal elements of l in reciprocal
c                           form.
c                na     - dimension for input vector a (n(n+1)/2)
c                m      - number of right hand sides (columns in b)
c                           (input)
c                n      - order of a and number of rows in b (input)
c                b      - input matrix of dimension n by m containing
c                           the right-hand sides of the equation
c                           ax = b.
c                         on output, the n by m solution matrix x
c                           replaces b.
c                ib     - row dimension of b as specified in the main
c                           program (input)
c                idgt   - the elements of a are assumed to be correct
c                           to idgt decimal digits(currently not used)
c                d1,d2  - components of the determinant of a.
c                           determinant(a) = d1*2**d2. (output)
c                ier    - error parameter.
c                           terminal error = 128+n.
c                           n = 1 indicates that the input matrix
c                             a is algorithmically not positive
c                             definite.
c   precision           - single
c   reqd. imsl routines - ludecp,luelmp,uertst
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - september 15, 1973
c                       - DECEMBER  02  2007
c
      dimension          a(na),b(ib,m)
c
c
c
c 1.0 Initialize ier
c
      ier     = 0
c
c
c
c 2.0 Calculation
c
c 2.1 Decompose a

      call ludecp (a,na,a,na,n,d1,d2,ier)
      if (ier .ne. 0) then
         call uertst(ier,'leqt1p') 
         return
      endif
c
c
c 2.2 Perform elimination
c
      do 10 i = 1,m
         call luelmp (a,na,b(1,i),n,b(1,i))
 10   continue
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine ludecp (a,na,ul,nu,n,d1,d2,ier)
c
c-ludecp--------s-------library 3---------------- ----------------------
c
c   routine             - cholesky decomposition of a matrix -
c                           symmetric storage mode
c   usage               - call ludecp (a,na,ul,nu,n,d1,d2,ier)
c   parameters   a      - input vector of length n(n+1)/2 containing
c                           the n by n positive definite symmetric
c                           matrix stored in symmetric storage mode.
c                na     - dimension of vector a (n(n+1)/2)
c                ul     - output vector of length n(n+1)/2 containing
c                           the decomposed matrix l such that a = l*
c                           l-transpose. l is stored in symmetric
c                           storage mode. the diagonal of l contains the
c                           reciprocals of the actual diagonal elements.
c                nu     - dimension of vector ul (n(n+1)/2)
c                n      - order of a. (input)
c                d1,d2  - components of the determinant of a.
c                           determinant(a) = d1*2**d2. (output)
c                ier    - error parameter.
c                         terminal error = 128+n.
c                           n = 1 indicates that matrix a is
c                             algorithmically not positive definite.
c                             (see the chapter l prelude).
c   precision           - single
c   reqd. imsl routines - uertst
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - february 8,1974
c                       - DECEMBER  02  2007
c
      dimension          a(na),ul(nu)
c
      data               zero,one,four/0.0,1.0,4.0/
      data               sxtnn,sixth/16.0,0.0625/
c
c
      ier      = 0
      d1       = one
      d2       = zero
      rn       = one/(n*sxtnn)
      ip       = 1
c
c
      do 45 i  = 1,n
         iq       = ip
         ir       = 1
         do 40 j  = 1,i
            x        = a(ip)
            if (j .ne. 1) then
               do 5  k = iq,ip1
                  x    = x - ul(k)*ul(ir)
                  ir   = ir+1
    5          continue
            endif
c
            if    (i .eq. j) then
               d1     = d1*x
               if (a(ip) + x*rn .le. a(ip)) then
                  ier = 129
                  call uertst(ier,'ludecp')
                  return
               endif
c
c
 10            continue
               if(abs(d1) .gt. one) then
                  d1 = d1 * sixth
                  d2 = d2 + four
                  go to 10
               endif
c
 20            continue
               if(abs(d1) .lt. sixth) then
                  d1 = d1 * sxtnn
                  d2 = d2 - four
                  go to 20
               endif
c
               ul(ip) = one/sqrt(x)
            elseif(i .ne. j) then
               ul(ip) = x * ul(ir)
            endif
c
            ip1   = ip
            ip    = ip+1
            ir    = ir+1
   40    continue
   45 continue
c
c
      return
      end
      subroutine luelmp (a,na,b,n,x)
c
c-luelmp--------s-------library 3---------------------------------------
c
c   routine            - elimination part of the solution of ax=b -
c                           symmetric storage mode
c   usage               - call luelmp (a,na,b,n,x)
c   parameters   a      - input vector of length n(n+1)/2 containing
c                           the n by n matrix l where a = l*l-transpose.
c                           l is a lower triangular matrix stored in
c                           symmetric storage mode. the main diagonal
c                           elements of l are stored in reciprocal
c                           form. matrix l may be obtained from imsl
c                           routine ludecp.
c                na     - dimension of vector a
c                b      - vector of length n containing the right hand
c                           side of the equation ax = b. (input)
c                n      - order of a and the length of b and x. (input)
c                x      - vector of length n containing the solution to
c                           the equation ax = b. (output)
c   precision           - single
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - september 15, 1973
c                       - DECEMBER  02  2007
c
      dimension          a(na),b(n),x(n)
      data               zero/0./
c                                  solution of ly = b
      ip      = 1
      iw      = 0
      do 15 i = 1,n
         t       = b(i)
         im1     = i - 1
         if    (iw .ne. 0) then
            ip      = ip + iw - 1
            do 5 k  = iw,im1
               t       = t - a(ip)*x(k)
               ip      = ip + 1
    5    continue
         elseif(iw .eq. 0) then
            if (t .ne. zero) iw = i
            ip      = ip+im1
         endif
c
         x(i)    = t*a(ip)
         ip      = ip + 1
   15 continue
c
c                                  solution of ux = y
      n1      = n+1
      do 30 i = 1,n
         ii      = n1-i
         ip      = ip-1
         is      = ip
         iq      = ii + 1
         t       = x(ii)
         if (n .ge. iq) then
            kk      = n
            do 20 k = iq,n
               t       = t - a(is)*x(kk)
               kk      = kk - 1
               is      = is - kk
   20       continue
         endif
c
         x(ii)   = t*a(is)
   30 continue
c
c
      return
      end
      subroutine dbcevl (x,nx,y,ny,c,nc1,nc2,xl,yl,pds,ier)
c   imsl routine name   - dbcevl
c
c-----------------------------------------------------------------------
c
c   computer            - cray/single
c
c   latest revision     - june 1, 1982
c                       - DECEMBER  02  2007
c
c   purpose             - bicubic spline mixed partial derivative
c                           evaluator
c
c   usage               - call dbcevl (x,nx,y,ny,c,nc1,nc2,xl,yl,pds,ier)
c
c   arguments    x      - vector of length nx. (input) x must be
c                           ordered so that x(i) .lt. x(i+1) for
c                           i=1,...,nx-1.
c                nx     - number of elements in x. (input) nx must be
c                           .ge. 2.
c                y      - vector of length ny. (input) y must be
c                           ordered so that y(j) .lt. y(j+1) for
c                           j=1,...,ny-1.
c                ny     - number of elements in y. (input) ny must be
c                           .ge. 2.
c                         note - the coordinate pairs (x(i),y(j)), for
c                           i=1,...,nx and j=1,...,ny, give the points
c                           where the function values are defined.
c                c      - array of spline coefficients. (input)
c                           c is of dimension 2 by nx by 2 by ny.
c                           the spline coefficients can be computed by
c                           imsl subroutine ibcccu.
c                           (note - c is treated internally as a
c                            2 by nx by 2*ny array because certain
c                            environments do not permit quadruply-
c                            dimensioned arrays.  in these
c                            environments the calling program may
c                            dimension c in the same manner.)
c                nc1    - second dimension of array c exactly as
c                           specified in the dimension statement
c                           (input).  nc1 must be .ge. nx.
c                nc2    - third dimension of array c exactly as
c                           specified in the dimension statement
c                           (input).  nc2 must be .ge. 2*nz.
c                xl,yl  - (xl,yl) is the point at which the mixed
c                           partial derivatives of the spline are to be
c                           evaluated. (input)
c                pds    - vector of length 6 containing the partial
c                           derivatives of the bicubic spline, s(x,y),
c                           evaluated at x=xl and y=yl. (output)
c                             pds(1) = s(xl,yl)
c                             pds(2) = ds/dx
c                             pds(3) = ds/dy
c                             pds(4) = d(ds/dx)/dy
c                             pds(5) = d(ds/dx)/dx
c                             pds(6) = d(ds/dy)/dy.
c                ier    - error parameter. (output)
c                         warning error
c                           ier = 33, xl is less than x(1).
c                           ier = 34, yl is less than y(1).
c                           ier = 35, xl is greater than x(nx).
c                           ier = 36, yl is greater than y(ny).
c
c   precision/hardware  - single and double/h32
c                       - single/h36,h48,h60
c
c   reqd. imsl routines - uertst,ugetio
c
c   notation            - information on special notation and
c                           conventions is available in the manual
c                           introduction or through imsl routine uhelp
c
c   copyright           - 1982 by imsl, inc. all rights reserved.
c
c   warranty            - imsl warrants only that imsl testing has been
c                           applied to this code. no other warranty,
c                           expressed or implied, is applicable.
c
c-----------------------------------------------------------------------
c
c                                  specifications for arguments
      integer            nx,ny,nc1,nc2,ier
      real               x(nx),y(ny),c(2,nc1,2*nc2),xl,yl,pds(6)
c
c                                  specifications for local variables
      integer            i,j,k,km1,kp1,kp2,lxpp,lx,ly,lp,lxp1
      real               hx,hy
      real               sux(2),suy(2),su(2),svx(2),sv(2),sxy(2)
      real               u, v
      real               spln0,spln1,spln2,s0,sh,sp0,sph,h,d
c
      spln0(s0,sh,sp0,sph,h,d) = s0   +   d*(h*sp0 + d*(3.*(sh-s0) - 
     &                           (sph + 2.0*sp0)*h + d*(2.*(s0-sh) + 
     &                           (sph + sp0)*h)))
      spln1(s0,sh,sp0,sph,h,d) = sp0  + d*(6.0*(sh-s0)/h -
     &                            2.0*(sph  + 2.0*sp0)  + 
     &                            3.0*d*(2.0*(s0-sh)/h  +
     &                                (sph  + sp0)))
      spln2(s0,sh,sp0,sph,h,d) = 6.0*(sh-s0)/h**2  -  
     &                           2.0*(sph  + 2.0*sp0)/h  +
     &                               d*(2.0*(s0-sh)/h**2 +
     &                               (sph  + sp0)/h)*6.0
c
c                                  first executable statement
      ier     = 0
c
      if(xl .lt. x(1)) ier = 33
      do 5 i  = 2,nx
         lx      = i - 1
         if(xl .le. x(i)) go to 10
    5 continue
      ier     = 35
c
   10 continue
      if(yl .lt. y(1)) ier = 34
         do 15 j = 2,ny
            ly      = j - 1
            if(yl .le. y(j)) go to 20
   15 continue
      ier     = 36
c
   20 continue
      lxp1     = lx + 1
      lyp1     = ly + 1
      hx       = x(lxp1) - x(lx)
      hy       = y(lyp1) - y(ly)
      u        = (xl-x(lx)) / hx
      v        = (yl-y(ly)) / hy
c
      k        = 2*ly
      kp1      = k + 1
      kp2      = k + 2
      km1      = k - 1
      do 25 lp = 1,2
         lxpp     = lx - 1 + lp
         i        = 2*(ly + lp - 1)
         j        = i - 1
         sux(lp)  = spln1(c(1,lx,j)     , c(1,lxp1,j)   , c(2,lx,j)   ,
     &                                    c(2,lxp1,j),hx,u)
         sxy(lp)  = spln1(c(1,lx,i)     , c(1,lxp1,i)   , c(2,lx,i)   ,
     &                                    c(2,lxp1,i),hx,u)
         su (lp)  = spln0(c(1,lx,j)     , c(1,lxp1,j)   , c(2,lx,j)   ,
     &                                    c(2,lxp1,j),hx,u)
         suy(lp)  = spln0(c(1,lx,i)     , c(1,lxp1,i)   , c(2,lx,i)   ,
     &                                    c(2,lxp1,i),hx,u)
         sv (lp)  = spln0(c(1,lxpp,km1) , c(1,lxpp,kp1) , c(1,lxpp,k) ,
     &                                    c(1,lxpp,kp2),hy,v)
         svx(lp)  = spln0(c(2,lxpp,km1) , c(2,lxpp,kp1) , c(2,lxpp,k) ,
     &                                    c(2,lxpp,kp2),hy,v)
   25 continue
c
      pds(1)   = spln0(sv (1),sv (2),svx(1),svx(2),hx,u)
      pds(2)   = spln1(sv (1),sv (2),svx(1),svx(2),hx,u)
      pds(3)   = spln1(su (1),su (2),suy(1),suy(2),hy,v)
      pds(4)   = spln1(sux(1),sux(2),sxy(1),sxy(2),hy,v)
      pds(5)   = spln2(sv (1),sv (2),svx(1),svx(2),hx,u)
      pds(6)   = spln2(su (1),su (2),suy(1),suy(2),hy,v)
      return
      end
      subroutine ibcccu (f,x,nx,y,ny,c,ic1,ic2,wk0,vk0,ic3,ier)
c   imsl routine name   - ibcccu
c
c-----------------------------------------------------------------------
c
c   computer            - cray/single
c
c   latest revision     - june 1, 1982
c                       - April 25, 2008
c
c   purpose             - bicubic spline two-dimensional coefficient
c                           calculator
c
c   usage               - call ibcccu (f,x,nx,y,ny,c,ic1,ic2,wk0,vk0,ic3,ier)
c
c   arguments    f      - nx by ny matrix containing the function
c                           values. (input) f(i,j) is the function value
c                           at the point (x(i),y(j)) for i=1,...,nx and
c                           j=1,...,ny.
c                x      - vector of length nx. (input) x must be
c                           ordered so that x(i) .lt. x(i+1) for
c                           i=1,...,nx-1.
c                nx     - number of elements in x. (input) nx must be
c                           .ge. 4.
c                y      - vector of length ny. (input) y must be
c                           ordered so that y(j) .lt. y(j+1) for
c                           j=1,...,ny-1.
c                ny     - number of elements in y. (input) ny must be
c                           .ge. 4.
c                         note - the coordinate pairs (x(i),y(j)), for
c                           i=1,...,nx and j=1,...,ny, give the points
c                           where the function values f(i,j) are
c                           defined.
c                c      - array of spline coefficients. (output)
c                           c is of dimension 2 by nx by 2 by ny.
c                           at the point (x(i),y(j))
c                             c(1,i,1,j) = s
c                             c(2,i,1,j) = ds/dx
c                             c(1,i,2,j) = ds/dy
c                             c(2,i,2,j) = d(ds/dx)/dy
c                           where s(x,y) is the spline approximation.
c                           (note - c is treated internally as a
c                             2nx by 2 by ny array because certain
c                             environments do not permit quadruply-
c                             dimensioned arrays.  in these
c                             environments the calling program may
c                             dimension c in the same manner.)
c                           note that this is also different from the way
c                           c is internally used in the application in
c                             dbcevl
c                ic1    - row dimension of matrix f (input)
c                             ic1 must be .ge. nx.
c                ic2    - second dimension of array c exactly as
c                           specified in the dimension statement (input).
c                             ic2 must be .ge. ny.
c                wk0    - work vector dimensioned as (nxz,2,nxx)
c                vk0    - work vector of length (ic3,2)
c                ic3    - first dimension of vk0
c                           should be greater than or equal to max(nx,ny)
c                ier    - error parameter. (output)
c                         terminal error
c                           ier = 129, ic1 is less than nx
c                           ier = 130, nx is less than 4
c                           ier = 131, ny is less than 4
c                           ier = 132, x or y are not ordered so that
c                             x(i) .lt. x(i+1) and
c                             y(i) .lt. y(i+1)
c
c   precision/hardware  - single and double/h32
c                       - single/h36,h48,h60
c
c   reqd. imsl routines - ibcdcu,uertst,ugetio
c
c-----------------------------------------------------------------------
c
c                                  specifications for arguments
      integer            nx,ny,ic1,ic2,ic3,ier
      real               f(ic1,ic2),x(ic1),y(ic2),c(2*ic1,2,IC2)
      real               wk0(ic2,2,ic1), vk0(ic3,2)
c
c                                  specifications for local variable
c
c
c 1.0 Initialization
c
c 1.1 Initialize parameters
c
      ier    = 0
c
c
c 1.2 Check for input errors
c
c 1.2.1 Check number of x values does not exceed dimension
c
      if (nx .gt. ic1) then
        ier     = -1
        return
      endif
c
c 1.2.2 Check number of y values does not exceed dimension
c
      if (ny .gt. ic2) then
        ier     = -2
        return
      endif
c
c 1.2.3 Check number of x values exceeds the minimum
c
      if (nx .lt.   4) then
        ier     = -3
        return
      endif
c
c 1.2.4 Check number of y values exceeds the minimum
c
      if (ny .lt.   4) then
        ier     = -4
        return
      endif
c
c
c
c 2.0 Compute the spline coefficients
c
c 2.1 Differentiate f with respect to x and store f and df/dx
c
c 2.1.1 Differentiate:
c       wk0 is dimensioned in ibcccu as wk0(ic2,2,ic1)
c       wk0 is dimensioned in ibcdcu as vs (ic2,2,ic1)
c
      call ibcdcu(x,f,  nx,1,ny,vk0,wk0,ic1,  ic2,ic3,ker)
c
c 2.1.2 Check error flags
c
      if (ker .gt. 0) then
        ier     = ker
        return
      endif
c
c
c 2.2 Differentiate f and df/x with respect to y and store f and df/dx
c     and then df/y and d/dy(df/dx)
c     Internally wk0 is treated as an array of dimension (ic2,2,ic1) in the first
c     call above and as an array of dimension (ic2,2*ic1) on this call
c
c 2.2.1 Differentiate
c
c       wk0 is dimensioned in ibcccu as wk0 (ic2,2,ic1)
c       wk0 is dimensioned in ibcdcu as gtau(ic2,2*ic1)
c       c   is dimensioned in ibcccu as c   (2*ic1,2,ic2)
c       c   is dimensioned in ibcccu as vs  (2*ic1,2,ic2)
c
      call ibcdcu(y,wk0,ny,2,nx,vk0,c,  ic2,2*ic1,ic3,ker)
c
c 2.2.2 Check error flags
c
      if (ker .gt. 0) then
        ier     = ker
        return
      endif
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine ibcdcu (tau,gtau,n,mp,m,w,vs,nc1,mc1,ncw,ier)
c   imsl routine name   - ibcdcu
c
c-----------------------------------------------------------------------
c
c   purpose             - nucleus called only by imsl subroutine ibcccu
c
c   reqd. imsl routines - none required
c
c-----------------------------------------------------------------------
c
c                                  specifications for arguments
      integer            n,mp,m,nc1,mc1,ncw,ier
      real               tau(n),gtau(nc1,mc1),w(ncw,2),vs(mc1,2,nc1)
c
c                                  specifications for local variables
      integer            i,im,ip,ipp,im1,ip1,ii,iip,k,k0,k1,kp,ll
      integer            nminus3,nminus2,nminus1,m2v,m2g,mc0,mc1p
      real               aa,bb,c1,c2,cc,dd,dtau,g,h,ratio,u,xilim
c
c
c     Initialize
c
      ier         = 0
c
      nminus1     = n - 1
      nminus2     = n - 2
      nminus3     = n - 3
c
c
c     Check input dimensions
c
      if(n .lt. 4) then
         ier      = -1
         return
      endif
c
      if(mp .lt. 1) then
         ier      = -2
         return
      endif
c
      mc0         = mc1/mp
      mc1p        = mc0*mp
c
      if(mc1p .ne. mc1) then
         ier      = -3
         return
      endif
c
c     Set the array counting for gtau and vs to be contiguous in the
c     respective second and first dimensions
c
      m2g         = m
      m2v         = m
c
c
c     Set initial step size
c
      w(2,1)      = tau(3) - tau(1)
      if (w(2,1) .le. 0.0) then
         ier      = +1
         return
      endif
c
c
c     Set vs(k,1,i)
c
c     Set first row of vs(k,1,i) for i = 1 equal to input gtau(i,kp)
c     gtau(i,kp)  is counted from kp = 1 to m and then kp = m2g+1 to m2g+m
c                 For m2g = m then this is contiguous from kp = 1 to 2m
c                 Thus gtau then stores the function and first derivative
c                 in the second dimension contiguously for mp = 2
c     vs  (k,1,i) is stored from k = 1 to m and then k = m2v+1 to m2v+m
c                 For m2v = m then this is contiguous from k  = 1 to 2m
c     vs stores it contiguously in the first dimension
c     The second dimension is not contiguous with the first because of the
c     structure of the dimensioning
c
      do 7 k0     = 1,mp
      do 5 k1     = 1,m
      k           = (k0-1)*m2v + k1
      kp          = (k0-1)*m2g + k1
      vs(k,1,1)   = gtau(1,kp)
    5 continue
    7 continue
c
c     Set remaining rows of vs(k,1,i) for i = 2, n-3
c     vs(k,1,i) is displaced from the input gtau(i,kp) by i+1 for each k,kp
c
      xilim       = tau(1)
      if (nminus3 .ge. 2) then
         xilim       = tau(n-2)
         do 15 i     = 2,nminus3
         ip          = i+1
         ipp         = i+2
         w(ip,1)     = tau(ipp) - tau(ip)
         if (w(ip,1) .le. 0.0) then
            ier         = +2
            return
         endif
c
         do 12 k0    = 1,mp
         do 10 k1    = 1,m
         k           = (k0-1)*m2v + k1
         kp          = (k0-1)*m2g + k1
         vs(k,1,i)   = gtau(ip,kp)
   10    continue
   12    continue
   15    continue
      endif
c
      w(nminus2,1)    = tau(n) - xilim
      if (w(nminus2,1) .le. 0.0) then
         ier          =  3
         return
      endif
c
c     Set vs(k,1,i) for i = n - 2 equal to input gtau(n,kp)
c     vs  (k,1,i) is then filled for all k and i = 1,2,...n-2 using input
c     gtau(i,kp)  for all kp and i = 1,3,4,....,n-3,n-2,n
c     Then vs  (k,1,n-1) and vs  (k,1,n)  are empty at this point
c     and  gtau(2,kp)    and gtau(n-1,kp) are not yet used
c
      do 27 k0        = 1,mp
      do 25 k1        = 1,m
      k               = (k0-1)*m2v + k1
      kp              = (k0-1)*m2g + k1
      vs(k,1,nminus2) = gtau(n,kp)
   25 continue
   27 continue
c
c
c     At this point:
c     For i  = 1:          vs(k,1, 1 ) = gtau( 1 ,kp)
c     For i  = 2,3...n-3:  vs(k,1, i ) = gtau(i+1,kp)  (vs are shifted down from gtau)
c     For i  = n-3:        vs(k,1,n-3) = gtau(n-2,kp)  (vs is  shifted down from gtau)
c     For i  = n-2:        vs(k,1,n-2) = gtau( n ,kp)
c     For i  = n-1:        vs(k,1,n-1) is not set
c     For i  = n:          vs(k,1, n ) is not set
c     gtau(i,kp)  is counted sequentially from kp = 1 to m and then
c                 kp = m2g+1 to m2g+m
c                 For m2g  = m this is then contiguous from kp = 1 to 2m
c     vs  (k,1,i) is stored sequentially  from k = 1 to m and then
c                 k = m2v+1 to m2v+m
c                 For m2v  = m this is then contiguous from k  = 1 to 2m
c
c     gtau( 2 ,kp) has not been accessed
c     gtau(n-1,kp) has not been accessed
c
c
c     Set vs(k,2,i) as the derivative of gtau with respect to the first variable (tau)

c
c     Initialize  vs(k,2,i) for all k and for i = 2,n-2
c
      do 35 i         = 2,nminus2
      im              = i-1
      do 32 k0        = 1,mp
      do 30 k1        = 1,m
      k               = (k0-1)*m2v + k1
      vs(k,2,i)       = (vs(k,1,i) - vs(k,1,im)) / w(i,1)
   30 continue
   32 continue
   35 continue
c
      dtau            = tau(2) - tau(1)
      ratio           = dtau/w(2,1)
      w(1,2)          = (ratio - 1.0)**2
      w(1,1)          = ratio*(    ratio - 1.0)
      c1              = ratio*(2.0*ratio - 3.0)
c
c     Set vs(k,2,i) for i = 1
c
      do 42 k0        = 1,mp
      do 40 k1        = 1,m
      k               = (k0-1)*m2v + k1
      kp              = (k0-1)*m2g + k1
      vs(k,2,1)       = (gtau(2,kp) - gtau(1,kp)) / dtau  +
     &                                            vs(k,2,2)*c1
  40  continue
  42  continue
c
c     Reset vs(k,2,i) for i = 2,n-3
c
      if (nminus3 .ge. 2) then
         do 50 i        = 2,nminus3
         ip             = i+1
         im             = i-1
         g              = -w(ip,1)/w(im,2)
         c1             = 3.0*w(i, 1)
         c2             = 3.0*w(ip,1)
c
         do 47 k0       = 1,mp
         do 45 k1       = 1,m
         k              = (k0-1)*m2v + k1
         vs(k,2,i)      = g*vs(k,2,im) + c1*vs(k,2,ip) + c2*vs(k,2,i)
   45    continue
   47    continue
c
         w(i,2)         = g*w(im,1) + 2.0*(w(i,1) + w(ip,1))
   50    continue
      endif
c
      dtau            = tau(nminus1) - xilim
      ratio           = dtau/w(nminus2,1)
      g               = -(ratio - 1.0)**2 / w(nminus3,2)
      w(nminus2,2)    =   ratio*(    ratio - 1.0)
      c1              =   ratio*(2.0*ratio - 3.0)
c
c     Set vs(k,2,i) for all k and for i = n-2
c
      do 62 k0        = 1,mp
      do 60 k1        = 1,m
      k               = (k0-1)*m2v + k1
      kp              = (k0-1)*m2g + k1
      vs(k,2,nminus2) = (gtau(nminus1,kp) - vs(k,1,nminus3)) / dtau
     &                                    + vs(k,2,nminus2)*c1
   60 continue
   62 continue
c
c     Reset vs(k,2,i) for all k and i = n-2
c
      w(nminus2,2)    = g*w(nminus3,1) + w(nminus2,2)
      do 67 k0        = 1,mp
      do 65 k1        = 1,m
      k               = (k0-1)*m2v + k1
      vs(k,2,nminus2) = (g*vs(k,2,nminus3) + vs(k,2,nminus2))
     &                                          / w(nminus2,2)
   65 continue
   67 continue
c
c
c     At this point:  vs(k,2,i) is set for all i = 1,2,...,n-2
c
c     Reset all vs(k,2,i) running in reverse order in i from
c               i = n-3 to i = 1
c     vs  (k,2,i) is then refilled for all k and i = 1,2,...n-3
c     vs  (k,2,n-2) is left unchanged
c     vs  (k,2,n-1) and vs  (k,2,n)  are not defined
c
      do 75 ii        = nminus3,1,-1
      iip             = ii+1
      do 72 k0        = 1,mp
      do 70 k1        = 1,m
      k               = (k0-1)*m2v + k1
      vs(k,2,ii)      = (vs(k,2,ii) - w(ii,1)*vs(k,2,iip)) / w(ii,2)
   70 continue
   72 continue
   75 continue
c
c
c
c     Construct the node values for f and df/dx and store final result
c     in vs
c
c     At this point the array vs  (k,ll,i) is filled for all k and ll = 1,2,
c     and all i = 1,2,...n-2
c
c
c     Loop over all values of the first index of vs
c
      do 97 k0        = 1,mp
      do 95 k1        = 1,m
      k               = (k0-1)*m2v + k1
c
c     Fill the arrays for all i = 1,2,...n from the set values in the
c     arrays from i = 1,2,...n-2
c     Shift vs(k,.,i) up by one place in i
c     vs(k,ll,1) and vs(k,ll,2) are set equal from the value originally
c     in vs(k,ll,1)
c     vs(k,ll, n ) is set from the value originally in vs(k,ll,n-2)
c     vs(k,ll,n-1) is set from the value originally in vs(k,ll,n-3)
c
        do 85 ii        = 1,n
        i               = n + 1 - ii
        im1             = i - 1
        if (i .eq. n) im1 = i - 2
        if (i. eq. 1) im1 = i
c
c
        do 80 ll        = 1,2
        vs(k,ll,i)      = vs(k,ll,im1)
   80   continue
   85   continue
c
c     Reset vs(k,.,i) for i = 2 and i = n-1 by interpolation
c
        do 90 i         = 2,nminus1,nminus3
        im1             = i - 1
        ip1             = i + 1
        if (im1 .eq.    2   ) im1 = 1
        if (ip1 .eq. nminus1) ip1 = n
        h               = tau(ip1) - tau(im1)
        u               = tau( i ) - tau(im1)
        aa              = vs(k,1,im1)
        bb              = vs(k,2,im1)
        cc              = (3.0* (vs(k,1,ip1) -       vs(k,1,im1))/ h
     &                       -  (vs(k,2,ip1) +  2.0* vs(k,2,im1)))
     &                                                           / h
        dd              = (2.0* (vs(k,1,im1) -       vs(k,1,ip1))/ h
     &                        + (vs(k,2,ip1) +       vs(k,2,im1)))
     &                                                           / h**2
        vs(k,1,i)       = aa  +  u*(bb  +  u*(cc + dd*u))
        vs(k,2,i)       = bb  +  u*(2.0*cc + 3.0*dd*u)
   90   continue
c
   95 continue
   97 continue
c
c
c     Return and end
c
      return
      end
      subroutine ofima3 (a,ia,b,ib,nv,ns,nf,t,it,wk,nk,ier)
c
c-ofima3--------s-------library 3---------------------------------------
c
c   routine            - least squares solution to the matrix
c                           equation at = b.
c   usage               - call ofima3 (a,ia,b,ib,nv,ns,nf,t,it,wk,nk,ier)
c   parameters   a      - input matrix of dimension nv by nf of
c                           column rank nf.
c                ia     - input first dimension of a in calling program.
c                b      - input nv by ns matrix.
c                ib     - input first dimension of b in calling program.
c                nv     - input number of rows in matrices a and b.
c                ns     - input number of columns in matrices t and b.
c                nf     - input number of rows in matrix t and
c                           number of columns in matrix a.
c                t      - output matrix of dimension nf by ns containing
c                           the least squares equation solution.
c                it     - input first dimension of t in calling program.
c                wk     - work vector of length (nf+1)*nf/2.
c                nk     - dimension of wk = (nf+1)*nf/2
c                ier    - error parameter.  ier=0 implies no error.
c                         terminal error = 128+n.
c                           n = 1 indicates that the rank of a is less
c                             than nf numerically.
c                           n = 2 indicates at least one of ia, ib, or
c                             it was specified incorrectly.
c   precision           - single
c   reqd. imsl routines - leqt1p,ludecp,luelmp,uertst,viprff,
c                           vmulfm,vtprof
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - april 15, 1975
c                       - DECEMBER  02  2007
c
      real               d1,d2
      real               a,b,t,wk
      dimension          a(ia,nf),b(ib,ns),t(it,ns),wk(nk)
c
c
c
c 1.0 Error checks
c
      if(nv .gt. ia  .or.   nv .gt. ib  .or.
     &   nf .gt. it  .or.   nf .gt. nv) then
         ier = 1
         jer = 130
         call uertst (jer,'ofima3')
         return
      endif
c
c
c
c 2.0 Calculations
c
c 2.1 Calculate (a-transpose) * a
c
      call vtprof (a,nv,nf,ia,wk,nk)
c
c
c 2.2 Calculate (a-transpose) * b
c
      call vmulfm (a,b,nv,nf,ns,ia,ib,t,it,jer)
      if(jer .ne. 0) then
         ier   = jer - 128
         call uertst (jer,'ofima3')
         return
      endif
c
c
c 2.3 Solve for t matrix
c
      call leqt1p (wk,nk,ns,nf,t,it,0,d1,d2,jer)
c
      if(jer .ne. 0) then
         ier   = 128 - jer
         call uertst (jer,'ofima3')
         return
      endif
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine vtprof (a,ldm,m,ia,ata,nwk)
c
c-vtprof--------s-------library 3---------------------------------------
c
c   routine            - transpose product of matrix-full storage mode
c   usage               - call vtprof(a,ldm,m,ia,ata,nwk)
c   parameters   a      - name of matrix
c                ldm    - maximum value of first subscript of a
c                m      - maximum value second subscript of a
c                ia     - dimension of a
c                ata    - resulting vector
c                nwk    - dimension of resulting vector
c   precision           - single
c   reqd. imsl routines - viprff
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - december 29, 1970
c                         DECEMBER 02  2007
c
      dimension a(ia,m),ata(nwk)
      dimension a1i(ia),a1j(ia)
c
      ix        = 1
      iy        = 1
      nix       = 1 + (ia-1)*ix
      niy       = 1 + (ia-1)*iy
c
c     The call to viprff has correct dimensioning provided ix = iy = 1
c     Otherwise, nix = ia + (ia-1)*(ix-1) > ia and a1a and a1j would need
c     to be dimensioned accordingly
c     This would mean a1i and a1j extend beyond a single row of a
c
      do 100 i  = 1,m
      k         = (i*(i-1))/2
         do 50 j   = 1,i
         k         = k + 1
c                        
         do 10 ii  = 1,ldm
         a1i(ii)   = a(ii,i)
         a1j(ii)   = a(ii,j)
   10    continue
c
         call viprff(a1i,a1j,ldm,ix,iy,nix,niy,atak)
         ata(k)    = atak
c
   50    continue
  100 continue
c
      return
      end
      subroutine viprff (x,y,ldm,ix,iy,nix,niy,xyip)
c
c-viprff--------s-------library 3---------------------------------------
c
c   routine            - vector inner product of two vectors or
c                           subsets of two vectors
c   usage               - call viprff (x,y,ldm,ix,iy,nix,niy,xyip)
c   parameters   x      - name of the first vector (address of the
c                           first element) - input
c                y      - name of the second vector (address of the
c                           first element) - input
c                ldm    - number of elements of vector x or y involved
c                           in the inner product (input)
c                ix     - increment between successive elements of x
c                           (input)
c                iy     - increment between successive elements of y
c                           (input)
c                nix    - number of elements of vector x
c                niy    - number of elements of vector y
c                xyip   - resultant inner product. xyip = x(1)*y(1)+
c                           x(1+ix)*y(1+iy)+...+x(1+ldm*ix)*y(1+ldm*iy).
c   precision           - single
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - july 19,1972
c                         DECEMBER 02  2007
c
      dimension          x(nix),y(niy)
      double precision   temp
c
      temp    = 0.0
      iend    = 1 + (ldm - 1)*ix
      k       = 1
c
      do 5 i  = 1,iend,ix
         temp    = temp + dble(x(i))*dble(y(k))
         k       = k + iy
    5    continue
c
      xyip    = temp
      return
      end
      subroutine vmulfm (a,b,ldm,m,n,ia,ib,c,ic,ier)
c
c-vmulfm--------s-------library 3---------------------------------------
c
c   routine             - matrix multiplication of the transpose of
c                           matrix a by matrix b (full storage mode)
c   usage               - call vmulfm (a,b,ldm,m,n,ia,ib,c,ic,ier)
c   parameters   a      - ldm by m matrix stored in full storage mode.
c                           (input)
c                b      - ldm by n matrix stored in full storage mode.
c                           (input)
c                ldm    - number of rows in a and b. (input)
c                m      - number of columns in matrix a and number
c                           of rows in matrix c. (input)
c                n      - number of columns in b and c. (input)
c                ia     - row dimension of a as specified in the
c                           calling program. ia must be greater than
c                           or equal to ldm. (input)
c                ib     - row dimension of b as specified in the
c                           calling program. ib must be greater than
c                           or equal to ldm. (input)
c                c      - m by n matrix containing the product
c                           c = (a-transpose) * b. (output)
c                ic     - row dimension of c as specified in the
c                           calling program. ic must be greater than
c                           or equal to m. (input)
c                ier    - error parameter. ier=0 implies no error.
c                         terminal error=128+n.
c                           n = 1 indicates a,b, or c was dimensioned
c                             incorrectly.
c   precision           - single
c   reqd. imsl routines - uertst
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision      - december 6, 1974
c                         DECEMBER 02  2007
c
      dimension          a(ia,m),b(ib,n),c(ic,n)
      double precision   temp
c
      ier     = 0
      if (ia .lt. ldm  .or.   ib .lt. ldm  .or.   ic .lt. m) then
         ier     = 129
         call uertst (ier,'vmulfm')
         return
      endif
c
c                                  row indicator
      do 20 i = 1,m
c                                  column indicator
         do 15 j = 1,n
            temp    = 0.0
c                                  vector dot product
            do 10 k = 1,ldm
               temp    = temp + dble(a(k,i))*dble(b(k,j))
   10       continue
            c(i,j)  = temp
   15    continue
   20 continue
c
c
c     Return and end
c
      return
      end
      subroutine uertst (ier,sname)
c-----------------------------------------------------------------------
c   routine             - error message generation
c   usage               - call uertst(ier,sname)
c   parameters   ier    - error parameter. type + n  where
c                         type= 128 implies terminal error
c                                64 implies warning with correction
c                                32 implies warning
c                         n   = error code relevant to calling routine
c                sname  - input scalar containing the name of the
c                         calling routine as a character string
c   language            - fortran
c-----------------------------------------------------------------------
c   latest revision     - Jan 31, 1990
c
      character*(*) sname
      character*8   etyp
      character*32  string
      integer warr,warf,term
c
      dimension etyp(3,4),ibit(4)
      equivalence (ibit(1),warr),(ibit(2),warf),(ibit(3),term)
c
      data etyp/'warning:',  ' (not co',  'rrected)',
     &          'warning:',  ' (correc',  'ted)    ',
     &          '        ',  'terminal',  ' error: ',
     &          '        ',  'undefine',  'd error:'/
      data ibit/32,64,128,0/
c
c
      ier2   = ier
c
c                                  undefined error:
      if(ier2 .lt. warr) then
        ier1   = 4
      else
c                                  terminal error:
        if     (ier2 .ge. term) then
          ier1   = 3
c                                  warning (with correction):
        elseif((ier2 .lt. term) .and. (ier2 .ge. warf)) then
          ier1   = 2
c                                  warning (with no correction):
        elseif((ier2 .lt. term) .and. (ier2 .lt. warf)) then
          ier1   = 1
        endif
      endif
c
c
c                                  extract *n*:
      ier2   = ier2 - ibit(ier1)
c
c                                  print error message:
      write(string,100) (etyp(i,ier1),i=1,3),sname
      call abortjob
     &        ('uertst  ',  1,   string
     &        ,'ier1    ', ier1,     'ier2    ', ier2,     -1)

 100  format(3a8,a8)
      return
      end
      subroutine bispline(x,y,nx,ny,nx1,ny1,cps,w,v,nv1,imth)

c
c     calculates bicubic spline representation with not-a-knot boundary
c     conditions
c     cps( , ,4) is f,fx,fy,fxy
      real x(nx1),y(ny1),cps(nx1,ny1,4),w(nx1,ny1),v(nv1)
c
      data pii/3.141592653589793/,twopii/6.283185307179586/
c
c
c     calculate fy
c
      nyy    = ny
      if(imth .eq. 0) then
         nbeg     = 2
      else
         nbeg     = 1
      endif

      if(nbeg .eq. 2) then
         v(2)   = (y(2)-y(1)) / (y(3)-y(2))
         do j   = 3,ny-1
         v(j)   = (y(j)-y(j-1)) / (y(j+1)-y(j-1))
         enddo
c
         do i       = 1,nx
         w(i,2)     = (v(2)-1.0) / (v(2)+2.0)
         cps(i,2,4) = 6.0*((cps(i,3,1) - cps(i,2,1)) / (y(3)-y(2))  -
     &         (cps(i,2,1)-cps(i,1,1))  /  (y(2)-y(1))) /
     &         ((y(3)-y(2))*(1.0 + v(2))*(2.0 + v(2)))
         enddo
c
c     3rd derivative = 0
      elseif(imth .eq. 1) then
         do j   = 2,ny-1
            v(j)   = (y(j)-y(j-1)) / (y(j+1)-y(j-1))
         enddo
         do i   = 1,nx
            w(i,1)      = 1.0
            cps(i,1,4)  = 0.0
         enddo
c
c     1st derivative=0
      elseif(imth .eq. 2) then
         do j   = 2,ny-1
         v(j)   = (y(j)-y(j-1)) / (y(j+1)-y(j-1))
         enddo
c
         do i       = 1,nx
         w(i,1)     = -0.5
         cps(i,1,4) = 3.0*(cps(i,2,1) - cps(i,1,1))  /  (y(2)-y(1))**2
         enddo
c
c     periodic
      elseif(imth .eq. -1) then
         nyy     = ny-1
         yn1     = y(ny-1) - twopii
         v(1)    = (y(1)-yn1) / (y(2)-yn1)
         do j    = 2,ny-1
         v(j)    = (y(j)-y(j-1)) / (y(j+1)-y(j-1))
         enddo
c
         do i       = 1,nx
            w(i,1)  = (v(1) - 1.0) / (1.0 + v(ny-1))
         cps(i,1,4) = 6.0*((cps(i,2,1) - cps(i,1,1))  /  (y(2)-y(1))   -
     &          (cps(i,1,1) - cps(i,ny-1,1))  /  (y(1)-yn1))  /
     &                            (y(2)-yn1)  /  (1.0+v(ny-1))
         cps(i,1,3) = 1.0 / (1.0 + v(ny-1))
         enddo
      endif
c
c
      one    = 0.0
      two    = 2.0
      do j   = nbeg + 1,ny-1
      if(imth .eq. -1  .and.  j .eq. ny-1) then
         two    = 2.0 - v(1)
         one    = 1.0
      endif
c
      do i       = 1,nx
      w(i,j)     = (v(j) - 1.0) / (v(j)*w(i,j-1) + two)
      cps(i,j,4) = (6.0*((cps(i,j+1,1) - cps(i,j,1))  /  (y(j+1)-y(j))
     &      -   (cps(i,j,1) - cps(i,j-1,1))  /  (y(j)-y(j-1)))  /
     &                     (y(j+1)-y(j-1)) - v(j)*cps(i,j-1,4)) /
     &                                    (v(j)*w(i,j-1) + two)
c
      if(imth .eq. -1) then
         cps(i,j,3) = (one - cps(i,j-1,3)*v(j)) / (v(j)*w(i,j-1) + two)
      endif
      enddo
      enddo
c
c     not-a-knot
      if(nbeg .eq. 2) then
         p       = 1.0/v(ny-1) - 1.0
         do i    = 1,nx
         w(i,ny) = -((cps(i,ny-2,4)*p) + ((w(i,ny-2)-1.)*p - 1.0)
     &               *cps(i,ny-1,4)) / (((w(i,ny-2) - 1.0)*p - 1.0)
     &                               *w(i,ny-1)  +  1.0)
         enddo
c
c     3rd derivative=0
      elseif(imth .eq. 1) then
         do i    = 1,nx
         w(i,ny) = cps(i,ny-1,4) / (1.0 - w(i,ny-1))
         enddo
c
c     1st derivative=0
      elseif(imth .eq. 2) then
         do i    = 1,nx
         w(i,ny) = -(3.0*(cps(i,ny,1) - cps(i,ny-1,1))  /
     &             (y(ny)-y(ny-1))**2  +  0.5*cps(i,ny-1,4))  /
     &                                 (1.0 + 0.5*w(i,ny-1))
         enddo
c
      elseif(imth .eq. -1) then
         do i          = 1,nx
         w(i,ny-1)     = cps(i,ny-1,4)
         cps(i,ny-1,2) = cps(i,ny-1,3)
         enddo
      endif
c
      do j    = nyy-1,nbeg,-1
      do i    = 1,nx
      if(imth .eq. -1) cps(i,j,2) = w(i,j)*cps(i,j+1,2) + cps(i,j,3)
      w(i,j)  = w(i,j)*w(i,j+1) + cps(i,j,4)
      enddo
      enddo
c
      if(imth .eq. -1) then
         do i        = 1,nx
         cps(i,ny,4) = ((1.0 - v(ny-1))*w(i,1) + v(1)*w(i,ny-1))  /
     &         (1.0 + (1.0 - v(ny-1))*cps(i,1,2) + v(1)*cps(i,ny-1,2))
         enddo
c
         do j     = ny-1,nbeg,-1
         do i     = 1,nx
         w(i,j)   = w(i,j) - cps(i,j,2)*cps(i,ny,4)
         enddo
         enddo
c
         do i    = 1,nx
         w(i,ny) = w(i,1)
         enddo
      endif
c
c
      if(nbeg .eq. 2) then
         do i    = 1,nx
         w(i,1)  = w(i,2) + v(2)*(w(i,2)-w(i,3))
         enddo
      endif
c
      do j       = 1,ny-1
      do i       = 1,nx
      cps(i,j,3) = (cps(i,j+1,1) - cps(i,j,1))  /  (y(j+1)-y(j))   -
     &                      (2.0*w(i,j) + w(i,j+1))*(y(j+1)-y(j))/6.0
      enddo
      enddo
c
      do i        = 1,nx
      cps(i,ny,3) = cps(i,ny-1,3) + 0.5*(w(i,ny) + w(i,ny-1))
     &                                 *(y(ny)-y(ny-1))
      enddo
c
c
c     calculate fx
c
      v(2)    = (x(2)-x(1)) / (x(3)-x(2))
      do i    = 3,nx-1
      v(i)    = (x(i)-x(i-1)) / (x(i+1)-x(i-1))
      enddo
c
      do j       = 1,ny
      w(2,j)     = (v(2) - 1.0) / (v(2) + 2.0)
      cps(2,j,4) = 6.0*((cps(3,j,1) - cps(2,j,1))  /  (x(3)-x(2))   -
     &      (cps(2,j,1) - cps(1,j,1))  /  (x(2)-x(1)))  /
     &      ((x(3)-x(2))*(1.0 + v(2))*(2.0 + v(2)))
      enddo
c
      do i       = 3,nx-1
      do j       = 1,ny
      w(i,j)     = (v(i) - 1.0) / (v(i)*w(i-1,j) + 2.0)
      cps(i,j,4) = (6.0*((cps(i+1,j,1) - cps(i,j,1))  /  (x(i+1)-x(i))
     &           -   (cps(i,j,1) - cps(i-1,j,1))  /  (x(i)-x(i-1)))   /
     &                        (x(i+1) - x(i-1)) - v(i)*cps(i-1,j,4))  /
     &                                         (v(i)*w(i-1,j) + 2.0)
      enddo
      enddo
c
      p       = 1.0/v(nx-1) - 1.0
      do j    = 1,ny
      w(nx,j) = -(cps(nx-2,j,4)*p + ((w(nx-2,j) - 1.0)*p - 1.0)
     &           *cps(nx-1,j,4))   /
     &                  (((w(nx-2,j) - 1.0)*p - 1.0)*w(nx-1,j) + 1.0)
      enddo
c
      do i    = nx-1,2,-1
      do j    = 1,ny
      w(i,j)  = w(i,j)*w(i+1,j) + cps(i,j,4)
      enddo
      enddo
c
      do j    = 1,ny
      w(1,j)  = w(2,j)  +  v(2)*(w(2,j)-w(3,j))
      enddo
c
      do i       = 1,nx-1
      do j       = 1,ny
      cps(i,j,2) = (cps(i+1,j,1) - cps(i,j,1))  /  (x(i+1)-x(i))   -
     &      (2.0*w(i,j) + w(i+1,j))*(x(i+1)-x(i)) / 6.0
      enddo
      enddo
c
      do j        = 1,ny
      cps(nx,j,2) = cps(nx-1,j,2) + 0.5*(w(nx,j) + w(nx-1,j))
     &                                 *(x(nx)-x(nx-1))
      enddo
c
c     calculate fxy
c
      do j       = 1,ny
      w(2,j)     = (v(2)-1.0) / (v(2)+2.0)
      cps(2,j,4) = 6.0*((cps(3,j,3) - cps(2,j,3))  /  (x(3)-x(2))   -
     &                  (cps(2,j,3) - cps(1,j,3))  /  (x(2)-x(1)))  /
     &                   ((x(3)-x(2))*(1.0 + v(2))*(2.0 + v(2)))
      enddo
c
      do i       = 3,nx-1
      do j       = 1,ny
      w(i,j)     = (v(i)-1.0) / (v(i)*w(i-1,j) + 2.0)
      cps(i,j,4) = (6.0*((cps(i+1,j,3) - cps(i,j,3))  /  (x(i+1)-x(i))
     &           -  (cps(i,j,3) - cps(i-1,j,3))  /  (x(i)-x(i-1)))   /
     &                         (x(i+1)-x(i-1)) - v(i)*cps(i-1,j,4))  /
     &                                           (v(i)*w(i-1,j) + 2.0)
      enddo
      enddo
c
      p        = 1.0/v(nx-1) - 1.0
      do j     = 1,ny
      w(nx,j)  = -(cps(nx-2,j,4)*p + ((w(nx-2,j)-1.)*p - 1.0)
     &                                         *cps(nx-1,j,4))  /
     &                    (((w(nx-2,j) - 1.0)*p - 1.0)*w(nx-1,j) + 1.0)
      enddo
c
      do i       = nx-1,2,-1
      do j       = 1,ny
      w(i,j)     = w(i,j)*w(i+1,j) + cps(i,j,4)
      enddo
      enddo
c
      do j       = 1,ny
      w(1,j)     = 2.0*w(2,j) - w(3,j)
      enddo
c
      do i       = 1,nx-1
      do j       = 1,ny
      cps(i,j,4) = (cps(i+1,j,3) - cps(i,j,3))  /  (x(i+1)-x(i))   -
     &                    (2.0*w(i,j) + w(i+1,j))*(x(i+1)-x(i)) / 6.0
      enddo
      enddo
c
      do j        = 1,ny
      cps(nx,j,4) = cps(nx-1,j,4) + 0.5*(w(nx,j) + w(nx-1,j))
     &                                        *(x(nx)-x(nx-1))
      enddo
c
c
      return
      end
      function dspeval(xary,nx,nx1,yary,ny,ny1,cps,xval,yval,pds,ier)
c
      integer nx,ny,nx1,ny1,ier,jxer,jyer
      integer ii,jj,ival,jval,ival1,jval1,ivalp,jvalp,k
      real xval,yval
      real xary(nx1),yary(ny1),cps(nx1,ny1,4),pds(6)
      real sux(2),suy(2),su(2),svx(2),sv(2),sxy(2)
      real dx,dy,xpval,ypval
      real spln0,spln1,spln2,s0,sh,sp0,sph,h,d
      real dltx1,dltx2,dlty1,dlty2,xmin,xmax,ymin,ymax
c
c
c     Statement functions
c
      spln0(s0,sh,sp0,sph,h,d) = s0   +   d*(h*sp0  +
     &                              d*(3.0*(sh-s0)-  (sph+2.*sp0)*h +
     &                              d*(2.0*(s0-sh)+(sph+sp0)*h)))
      spln1(s0,sh,sp0,sph,h,d) = sp0   +
     &                              d*(6.0*(sh-s0)/h-2.0*(sph+2.0*sp0) +
     &                           3.0*d*(2.0*(s0-sh)/h+(sph+sp0)))
      spln2(s0,sh,sp0,sph,h,d) = 6.0*(sh-s0)/h**2-2.0*(sph+2.0*sp0)/h +
     &                              d*(2.0*(s0-sh)/h**2+(sph+sp0)/h)*6.0
c
c
c
c 1.0 Initialization
c
c 1.1 Initialize error flags
c
      ier       = 0
      jxer      = 0
      jyer      = 0
c
c
c 1.2 Initialize constants
c
      dltx1     = xary(2 ) - xary( 1  )
      dltx2     = xary(nx) - xary(nx-1)
      dlty1     = yary(2 ) - yary( 1  )
      dlty2     = yary(ny) - yary(ny-1)
c
      xmin      = xary(1 ) - dltx1
      xmax      = xary(nx) + dltx2
      ymin      = yary(1 ) - dlty1
      ymax      = yary(ny) + dlty2
c
c
c
c 2.0 Search for the reference cell containing the point
c
c 2.1 Search in the x direction
c
c 2.1.1 Set error condition and ival if the point is to the left
c       of the whole array
c
      if    (xval .lt. xary(1)) then
        if(xval .ge. xmin) jxer   = -1
        if(xval .lt. xmin) jxer   = -2
        ival      = 1
c
c 2.1.2 Set ival if the point is on the left-most mesh point
c
      elseif(xval .eq. xary(1)) then
        ival      = 1
c
c 2.1.3 Set ival if the point is on the right-most mesh point
c
      elseif(xval .eq. xary(nx)) then
        ival      = nx-1
c
c 2.1.4 Set error condition and ival if the point is to the right
c       of the whole array
c
      elseif(xval .gt. xary(nx)) then
        if(xval .le. xmax) jxer   = +1
        if(xval .gt. xmax) jxer   = +2
        ival      = nx-1
c
c 2.1.5 Search the x array
c
      else
        do 10 ii  = 1,nx
        if(xval .lt. xary(ii)) then
          ival    = ii-1
          go to 15
        endif
   10   continue
   15   continue
      endif
c
c
c 2.2 Search in the y direction
c
c 2.2.1 Set error condition and jval if the point is below the
c       whole array
c
      if    (yval .lt. yary(1)) then
        if(yval .ge. ymin) jyer   = -1
        if(yval .lt. ymin) jyer   = -2
        jval      = 1
c
c 2.2.2 Set jval if the point is on the bottom-most mesh point
c
      elseif(yval .eq. yary(1)) then
        jval      = 1
c
c 2.2.3 Set jval if the point is on the top-most mesh point
c
      elseif(yval .eq. yary(ny)) then
        jval      = ny-1
c
c 2.2.4 Set error condition and jval if the point is above the
c       whole array
c
      elseif(yval .gt. yary(ny)) then
        if(yval .le. ymax) jyer   = +1
        if(yval .gt. ymax) jyer   = +2
        jval      = ny-1
c
c 2.2.5 Search the y array
c
      else
        do 20 jj = 1,ny
        if(yval .lt. yary(jj)) then
          jval      = jj-1
          go to 25
        endif
   20   continue
   25   continue
      endif
c
c
c 2.3 Set the error condition
c
      if(iabs(jxer) .gt. 1) then
        if(jxer .gt. 0) ier   = +1
        if(jxer .lt. 0) ier   = -1
        return
      endif
c
      if(iabs(jyer) .gt. 1) then
        if(jyer .gt. 0) ier   = +2
        if(jyer .lt. 0) ier   = -2
        return
      endif
c
c
c
c 3.0 Set the point value relative to the box
c
      ival1     = ival+1
      jval1     = jval+1
c
      dx        = xary(ival1) - xary(ival)
      dy        = yary(jval1) - yary(jval)
c
      xpval     = (xval - xary(ival)) / dx
      ypval     = (yval - yary(jval)) / dy
c
c
c
c 4.0 Construct the spline interpolants
c
c 4.1 First pass in each direction
c
      do 100 k  = 1,2
      ivalp     = ival+k-1
      jvalp     = jval+k-1
      sux(k)    = spln1(cps(ival, jvalp,1), cps(ival1,jvalp,1)
     &                 ,cps(ival, jvalp,2), cps(ival1,jvalp,2),dx,xpval)
      sxy(k)    = spln1(cps(ival, jvalp,3), cps(ival1,jvalp,3)
     &                 ,cps(ival, jvalp,4), cps(ival1,jvalp,4),dx,xpval)
      su (k)    = spln0(cps(ival, jvalp,1), cps(ival1,jvalp,1)
     &                 ,cps(ival, jvalp,2), cps(ival1,jvalp,2),dx,xpval)
      suy(k)    = spln0(cps(ival, jvalp,3), cps(ival1,jvalp,3)
     &                 ,cps(ival, jvalp,4), cps(ival1,jvalp,4),dx,xpval)
c
      sv (k)    = spln0(cps(ivalp,jval, 1), cps(ivalp,jval1,1)
     &                 ,cps(ivalp,jval, 3), cps(ivalp,jval1,3),dy,ypval)
      svx(k)    = spln0(cps(ivalp,jval, 2), cps(ivalp,jval1,2)
     &                 ,cps(ivalp,jval, 4), cps(ivalp,jval1,4),dy,ypval)
  100 continue
c
c
c 4.2 Second pass
c
      pds(1)    = spln0(sv(1), sv(2), svx(1),svx(2),dx,xpval)
      pds(2)    = spln1(sv(1), sv(2), svx(1),svx(2),dx,xpval)
      pds(3)    = spln1(su(1), su(2), suy(1),suy(2),dy,ypval)
      pds(4)    = spln2(sv(1), sv(2), svx(1),svx(2),dx,xpval)
      pds(5)    = spln1(sux(1),sux(2),sxy(1),sxy(2),dy,ypval)
      pds(6)    = spln2(su(1), su(2), suy(1),suy(2),dy,ypval)
c
c
c
c 5.0 Return and end
c
      dspeval    = pds(1)
c
      return
      end
      subroutine empty(kunit)
c
c ---------------------------------------------------------
c
c  Empty the buffer for file unit number kunit
c
c ---------------------------------------------------------
c
      logical filopen,filxist,filopen1,filxist1
      character*16  filform,filform1
      character*132 filnam
c
c ---------------------------------------------------------
c
c
c
c
c 1.0 Check if the file exists
c
c 1.1 Check if the file exists and find its attributes
c
c 1.1.1 Check for file existence
c
      inquire(unit = kunit,  name   = filnam, opened = filopen
     &                    , form   = filform, exist = filxist
     &                    , iostat = ier0)
c
c 1.1.2 Check for errors in file inquiry
c
      if(filxist  .and.  (ier0     .ne. 0)) then
        call abortjob
     &        ('empty   ',  1,   'Error detected in file inquiry      '
     &        ,'kunit   ', kunit,    'ier0    ', ier0,     -1)
        return
      endif
c
c
c 1.2 Set filxist false for the standard output
c
      if(kunit  .eq. 6) then
        filxist  = .false.
        return
      endif
c
c
c 1.3 Check that the name is compatible with the file keyword
c     These may not be compatible if the name was truncated or included the
c     full path length
c
c 1.3.1 Check the file exists with name filnam
c
      if(filxist) then
        inquire(file = filnam, form   = filform1, opened = filopen1
     &                       , exist  = filxist1, iostat = ier1)
c
c 1.3.2 Check for errors in file inquiry
c
        if(ier1    .ne. 0) then
          call abortjob
     &        ('empty   ',  2,   'Error detected in file inquiry      '
     &        ,'kunit   ', kunit,    'ier1    ', ier1,      0)
          return
        endif
c
c 1.3.3 Set the file attributes if file does not exist
c
      else
        filopen   = .false.
        filopen1  = .false.
        filxist1  = .false.
        return
      endif
c
c
c 1.4 Print error if existence checks are incompatible
c
      if(filxist .neqv. filxist1) then
        if(   filxist    ) kfilxst   = +1
        if(.not. filxist ) kfilxst   = -1
c
        call abortjob
     &        ('empty   ',  3,   'File name incompatible with unit    '
     &        ,'kunit   ', kunit,    'kfilxst ', kfilxst,  -1)
        return
      endif
c
      if(filopen .neqv. filopen1) then
        if(   filopen    ) kfilopn   = +1
        if(.not. filopen ) kfilopn   = -1
c
        call abortjob
     &        ('empty   ',  4,   'File open status inconsistency      '
     &        ,'kunit   ', kunit,    'kfilopn ', kfilopn,  -1)
        return
      endif
c
c
c
c 2.0 Close and reopen the file to empty the buffer
c
c 2.1 Check for existence of the file with the correct name
c
      if(filxist  .and.  (filxist1 .eqv. filxist)  .and.
     &                   (filopen1 .eqv. filopen)       ) then
c
c
c 2.2 Close the file if already opened
c
        if(filopen) then
          close  (unit = kunit)
        endif
c
c
c 2.3 Reopen the file in append mode
c
        open   (unit = kunit,  file   = filnam, form     = filform
     &                      , status = 'old',  position = 'append')
c
c
c 2.4 Print warning if file not emptied at this point
c
      else
        if(   filxist    ) kfilxst   = +1
        if(.not. filxist ) kfilxst   = -1
c
        call abortjob
     &        ('empty   ',  5,   'Empty reached inaccessible point    '
     &        ,'kunit   ', kunit,    'kfilxst ', kfilxst,  -1)
      endif
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine abortjob(routine,ident,errmsg,vnam0,ier0,vnam1,ier1,iw)
c
c ---------------------------------------------------------
c
c  Print warning or abort job if error detected
c
c ---------------------------------------------------------
c
      character*16  codenam
      character*(*) routine
      character*(*) vnam0, vnam1
      character*(*) errmsg
c
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c
c
c
c 1.0 Define the error label for termination
c
      codenam  = 'smap'
c
c
c
c 2.0 Write out error label and number
c
      if    (iw .lt. -2) then
         write(kutty,1000) iw,routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kuout,1000) iw,routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         return
c
      elseif(iw .eq. -2) then
         write(kutty,1100) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kuout,1100) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
c
      elseif(iw .eq. -1) then
         write(kutty,1200) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kuout,1200) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         return
c
      elseif(iw .eq.  0) then
         write(kutty,1300) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kuout,1300) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         return
c
      elseif(iw .eq. +1) then
         write(kutty,2000) codenam
         write(kuout,2000) codenam
         write(kutty,2010) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kuout,2010) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         call fileclose
         stop 'Terminated with Error'
c
      elseif(iw .gt. +1) then
         write(kutty,2100) codenam
         write(kuout,2100) codenam
         write(kutty,2110) errmsg,vnam0,ier0,vnam1,ier1
         write(kuout,2110) errmsg,vnam0,ier0,vnam1,ier1
         call fileclose
         stop 'Calculation complete'
      endif
c
c
c
c 3.0 Return and end
c
      return
c
 1000 format(/,2x,'***** Serious Warning: status number'
     &        ,2x,i2,1x,'*****'
     &      ,/,8x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 1100 format(/,2x,'***** Serious Warning:  '
     &        ,1x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,1x,'*****',/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 1200 format(/,8x,'Important Warning:'
     &        ,1x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 1300 format(/,8x,'Warning:'
     &        ,1x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8)
 2000 format(/,2x,'***** Aborting  run in',1x,a16,1x,'*****')
 2010 format(/,8x,'Fatal error in subroutine    ',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,1x,'Error: ',a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 2100 format(/,2x,'***** Completed run in',1x,a16,1x,'*****')
 2110 format(/,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
      end
      subroutine timeused(tmcpu,tmio,tmsys,tmwal,datechar,timechar)
c
c ---------------------------------------------------------
c
c  Compute time used
c
c ---------------------------------------------------------
c
      character*16  datechar,timechar
      character*16  date,time,zone
      character*16  string
c
      integer      tyear,tmnth,tdate,thour,tmins,tsecs,tmsec
      integer      nowdate,wallmsec
c SUN integer*4    nowdate,wallmsec
      real         cputime,walltime
      real         tmcpu,tmio,tmsys,tmwal
c
      dimension nowdate(8)
c
c
c
c 1.0 Set the computing time elapsed
c
      call cpusec(cputime)
      tmcpu     = cputime
      tmio      = 0.0
      tmsys     = 0.0
c
c
c
c 2.0 Set the wall clock time and the time and date stamps
c
c 2.1 Return date and elapsed wall clock time
c
      call date_and_time(date,time,zone,nowdate)
c
      tyear     = nowdate(1)
      tmnth     = nowdate(2)
      tdate     = nowdate(3)
c
      thour     = nowdate(5)
      tmins     = nowdate(6)
      tsecs     = nowdate(7)
      tmsec     = nowdate(8)
c
      wallmsec  = 1000*(3600*thour + 60*tmins + tsecs)  +  tmsec
c
      walltime  = float(wallmsec) / 1000.0
      tmwal     = walltime
c
c
c
c 2.2 Construct the date and time stamps
c
      write(string,1000) tmnth,tdate,tyear
      read (string,1010) datechar
c
      write(string,2000) thour,tmins,tsecs
      read (string,2010) timechar
c
c
c
c 3.0 Return and end
c
      return
 1000 format(i2,'/',i2,'/',i4)
 1010 format(a10)
 2000 format(i2,':',i2,':',i2)
 2010 format(a10)
      end
      subroutine cpusec(cputime)
c
c ---------------------------------------------------------
c
c  Return number of cpu seconds elapsed
c
c ---------------------------------------------------------
c
      implicit none
c
      real    cputime
c
clock integer counts,rate
c SGI real*4  etime, times(2)
c
c
c
c 1.0 Return elapsed CPU time
c
      call cpu_time(cputime)
c
clock call System_Clock(counts,rate)
clock if    (rate .le. 0) then
clock     cputime  = 0.0
clock elseif(rate .gt. 0) then
clock     cputime  = float(counts) / float(rate)
clock endif
c
c SGI cputime = dble (etime (times))
c
c
c
c 2.0 Return and end
c
      return
      end
      subroutine writnova
c
c###  To invoke the NetCDF routines:
c###     Delete the specifications between "include 'netcdf_dummy.h'" and "c###  use netcdf"
c###     Uncomment the "c###  use netcdf" statements
c###     Replace the calls for NF90_PUT_VAR and NF90_GET_VAR  with the original
c###     call marked with czzz
c###     Remove the return for abortcdf marked with c###
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
      parameter (nhd1=5,nhd2=3)
      parameter (nvn=7)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
      parameter (nntg    = 10,  nrlv    = 13,    nrld    = nvdim1)
c
c
c Global type declarations:
c
      character*8   headr
      character*8   etitl,date
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*16  sourcnam,sourcdat
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
      integer       nvdm1v,   nvdm2v,   jpsval,   mthval
c
      integer*4     k1
      integer*4     kt,       ktt
      integer*4     ip,       ipv,      jp,       jpv
      integer*4     kwmode,   krmode
      integer*4     kfileid,  kmode
      integer*4     length0
      integer*4     ndimens,  nattrib,  nglobat
      integer*4     ndimf,    kdimid
      integer*4     nvariabl, kvarid
      integer*4     ndset,    ndtype,   naset
      integer*4     nvstrt,   nvstrv
      integer*4     nvdimid,  ndimid
      integer*4     vartype,  varsize,  atttype,  attleng
      integer*4     nvarchar, nvarintg, nvar0drl,
     &              nvar1drr, nvar1drp, nvar2drr,
     &              kvarchar, kvarintg, kvar0drl,
     &              kvar1drr, kvar1drp, kvar2drr
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  filencdf
      character*16  dimname
      character*16  attname
      character*16  varname
      character*36  longname
c
      character*1   varinpt0
      character*1   blank
c
      integer*4     varinpt1
      integer*4     varinpta
      integer*4     mzero
c
      real*8        varinpt2, varinpt3, varinpt4, varinpt5
      real*8        zero
c
      integer*4     nxeq,     nzeq,     nosurf
      integer*4     mthet,    mtht0,    mtht1
      integer*4     remap,    njrval,   njgpsi,   njbtot
      real*8        xmin,     xmax,     zmin,     zmax,
     &              zcenter,  betator,  betas,    betan,   elli,
     &              ppfact,   upsilon
      character*160 title,    datv,     comment
c
c
c Global common declarations:
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/kinetc/pfactr,tfactr,dfactr,pffact,deutp,dmass,dnnova(np2),
     &              pfnova(np2), ptnova(np2), prnova(np2),pbnova(np2), 
     &              tenova(np2), tinova(np2), denova(np2),dinova(np2)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/cdfiles/kfileid,  kmode,    length0,  filencdf
      common/fdimens/ndimens,  ndimf  (ndims), kdimid(ndims),
     &                         dimname(ndims)
      common/fattrib/nglobat,nattrib,attname(nattr)
      common/vattrib/nvariabl,       varname(nvars),   vartype(nvars),
     &               ndset(nvars),   ndtype (nvars),   kvarid(nvars),
     &               nvdimid(ndims), varsize(nvars),
     &               naset(nvars),   atttype(nvars),
     &               attleng(nvars), longname(nvars),
     &               ndimid(nvars,ndims)
      common/variabc/nvarchar, nvarintg, nvar0drl,
     &               nvar1drr, nvar1drp, nvar2drr,
     &               kvarchar, kvarintg, kvar0drl,
     &               kvar1drr, kvar1drp, kvar2drr
      common/variabl/varinpt0(nvdim0), varinpt1(1),      varinpt2(1),
     &               varinpt3(nvdim1), varinpt4(nvdim2),
     &               varinpt5(nvdim3,nvdim1)
      common/savedat/varinpta(nntg),   varinptb(nrld)
      common/storage/nvdmid (ndims),nvstrt(ndims), nvdims(ndims),
     &               nvstrt0(ndims),nvdmns(ndims),
     &               nvstrv (ndims),nvstrv0(ndims),nvdmnv(ndims)
      common/passdat/title,  datv,   comment,
     &               nxeq,   nzeq,   nosurf, mthet,  mtht0,  mtht1,
     &               remap,  njrval, njgpsi, njbtot,
     &               xmin,   xmax,   zmin,   zmax,   zcenter,
     &               betator,betas,  betan,  elli,   ppfact, upsilon
c
c     f3 :         f / (r**2)
c     f4 :        -(mu0*jtor) / (r*Bpol)**2
c     f5 :        f * [d/dpsi(J/(r**2))](constant chi)
c     f7 :        2J{ ((mu0*jtor)/(r*Bpol))**2                           + 
c                     ((mu0*jtor)/((r**2)*Bpol))*[d/dpsi(r*Bpol)]normal  -
c                     ((mu0*p'/r)*[dr/dpsi]normal }
c        :        2J{ ((mu0*jtor)/(r*Bpol))**2                           + 
c                     ((mu0*jtor)/(r*Bpol))*[d/dpsi(Bpol)]normal         +
c                     ((ff'/r**3)*[dr/dpsi]normal }
c     f8 :        1 / [J*(r*Bpol)**2]
c     f9 :        J*(Bpol**2)
c     f10:        (r**2) / J
c     f11:        (mu0*gamma*p) / J
c     f12:        (f*J) / (r**2)
c     f13:        J (Jacobian)
c     f14:        [dJ/dpsi](constant chi)
c     f15:        [dJ/dchi](constant psi)
c     f16:         d/dpsi(grad(psi)**2)normal
c     f17:         d/dchi[grad(psi)**2]
c     f18:         d/dchi[grad(psi).grad(chi)]
c     f19:         d/dchi[(dchi/dpsi)normal]
c     f20:        -(grad(psi).grad(chi)) / (grad(psi)**2)
c                      (-nonorthogonality: [-dchi/dpsi]normal)
c     f21:        2*[(r**2)/f] * [d/dpsi(log(r)]]normal         = [1/f] * [dr**2/dpsi]normal
c     f22:        2*[(r**2)/f] * [d/dchi(log(r))](constant psi) = [1/f] * [dr**2/dchi](constant psi)
c     f23:        S = (f/r**2)*[del*(psi) - d/dpsi[grad(psi)**2]normal)] / grad(psi)**2)  -
c                                                     f'/r**2  (Local shear)
c     f24:        T - S  =  mu0*j.B/(grad(psi)**2) - S
c                        = (f/r**2)*[d/dpsi[grad(psi)**2]normal) -  2*del*(psi)] / grad(psi)**2)
c     f25:        +[darcl/dpsi]normal) (i.e. (nonorthogonality) for arclength angle
c     f26:        +[dpest/dpsi]normal) (i.e. (nonorthogonality) for PEST angle
c     f27:        +[dpest/darcl]constant psi
c     f28:        +[dpest/dpsi ]constant arcl
c
c
c
c 1.0 Set up the data
c
c 1.1 Initialize unit numbers
c
      kustt       =  kutty
      kusto       =  kuout
c
c
c 1.2 Initialize default data
c
      k1       = 1
      blank    = ' '
      mzero    = 0
      zero     = 0.0
c
c
c 1.3 Initialize miscellaneous data
c
      write(title,  998) (etitl(kt),kt=1,nft)
      write(datv,   998)  date
      write(comment,998) (headr(kh1,1),kh1=1,nhd1)
c
      xmin       = redge
      xmax       = redge + xdim
      zmin       = zlowr
      zmax       = zlowr + zdim
      zcenter    = 0.5*(zmax + zmin)
c
      ppfact     = 1.0
      betator    = betat
      betas      = betat*ppfact
      betan      = betat/(totcur/aminor*btor)
      elli       = 0.0
      upsilon    = 0.0
c
      nxeq       = ndim1
      nzeq       = ndim2
      nosurf     = jpsi1
      mthet      = itht  + 2
      mtht0      = mthet - 2
      mtht1      = mthet - 1
      remap      = +2
      njrval     = +1
      njgpsi     = +1
      njbtot     =  0
c
c
c 1.4 Check dimensions against jpsi and ithtp
c
      nvdm1v     = nvdim1
      nvdm2v     = nvdim2
      jpsval     = jpsi1
      mthval     = mthet
c
      if(jpsval .gt. nvdm1v) then
         call abortjob
     &        ('writnova',  1,   'jpsi1 is greater than nvdim1        '
     &        ,'jpsval  ', jpsval,   'nvdm1v  ', nvdm1v,   +1)
      endif
c
      if(mthval .gt. nvdm2v) then
         call abortjob
     &        ('writnova',  2,   'itht+2  is greater than nvdim2      '
     &        ,'mthval  ', mthval,   'nvdm2v  ', nvdm2v,   +1)
      endif
c
c
c 1.5 Initialize the arrays
c
      do 10 kt          = 1,nvdim0
      ktt               = kt
      varinpt0(ktt)     = blank
   10 continue
c
      varinpt1(k1)      = mzero
      varinpt2(k1)      = zero
c
      do 20 jp          = 1,nvdim1
      jpv               = jp
      varinpt3(jpv)     = zero
   20 continue
c
      do 30 ip          = 1,nvdim2
      ipv               = ip
      varinpt4(ipv)     = zero
   30 continue
c
      do 50 jp          = 1,nvdim1
      jpv               = jp
      do 40 ip          = 1,nvdim3
      ipv               = ip
      varinpt5(ipv,jpv) = zero
   40 continue
   50 continue
c
c
c 1.4 Set data
c
c 1.4.1 Initialize data for NetCDF
c
      kmode       =  NF90_CLOBBER
      kwmode      =  NF90_WRITE
      krmode      =  NF90_NOWRIT
      length0     =  1
c
c 1.4.2 Set the NetCDF data
c
      call ncdfset
c
c
c 1.5 Define the NetCDF variable dimensions and attributes to be written
c
      call setvar
c
c
c 1.6 Open the ASCII and binary mapout and mapdsk files
c
      call novaset
c
c
c
c 2.0 Set up the NetCDF variables
c
c 2.1 Define the NetCDF variables for the file
c
      call ncdfvar
c
c
c 2.2 Terminate define mode
c
      call endcdff(kfileid)
c
c
c
c 3.0 Check the file definitions
c
      call cdfchek(kfileid)
c
c
c
c 4.0 Close the NetCDF file
c
      call cdfclos(kfileid)
c
c
c
c 5.0 Write the data
c
      call writprof
      call writdata(kwmode)
c
c
c
c 6.0 Return and end
c
      return
c
 998  format(20a8)
      end
      subroutine ncdfset
c
c Set up the NetCDF file
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      integer*4     k1,       k2,       k3,       k4,      k5
      integer*4     kd,       kdd
      integer*4     kdimv0,   kdimid0
      integer*4     kfilstat, kdimstat
c
      integer*4     kfileid,  kmode
      integer*4     length0
      integer*4     ndimens,  nattrib,  nglobat
      integer*4     ndimf,    kdimid
c
      character*16  dimname0
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  filencdf
      character*16  dimname
      character*16  attname
      character*80  errstrng
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/cdfiles/kfileid,  kmode,    length0,  filencdf
      common/fdimens/ndimens,  ndimf  (ndims), kdimid(ndims),
     &                         dimname(ndims)
      common/fattrib/nglobat,nattrib,attname(nattr)
c
c
c
c 1.0 Initialize the file data
c
c 1.1 Index data
c
      k1           =  1
      k2           =  2
      k3           =  3
      k4           =  4
      k5           =  5
c
c
c 1.2 NetCDF file name
c
      filencdf    = 'mapout.cdf'
c
c
c 1.3 Dimension data
c
      ndimens      =  5
      ndimf   (k1) =  nvdim0
      ndimf   (k2) =  1
      ndimf   (k3) =  nvdim1
      ndimf   (k4) =  nvdim2
      ndimf   (k5) =  nvdim2-1
      dimname (k1) = 'string'
      dimname (k2) = 'none'
      dimname (k3) = 'psi'
      dimname (k4) = 'theta'
      dimname (k5) = 'theta'
c
c
c 1.4 Attibute data
c
      nglobat      =  0
      nattrib      =  1
      attname (k1) = 'long_name'
c
c
c
c 2.0 Create and define the NetCDF file
c
c 2.1 Create the file
c
c     NF90_CREATE INPUT:  filencdf, kmode
c                 OUTPUT: kfilstat, kfileid
c
      kfilstat = NF90_CREATE(filencdf,kmode,kfileid)
c
      if(kfilstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kfilstat)
         call abortcdf
     &        ('ncdfset ',  1,   errstrng
     &        ,'kfileid ', kfileid,  'kfilstat', kfilstat, -1)
      endif
c
      if(kfileid  .le.     0   ) then
         call abortcdf
     &        ('ncdfset ',  2,   'NetCDF file ID not properly defined '
     &        ,'kfileid ', kfileid,  'kfilstat', kfilstat, -1)
      endif
c
c
c 2.2 Set up the dimensions for the file
c
c 2.2.1 Loop over the total number of dimensions to be defined
c
      do 100 kd  = 1,ndimens
         kdd        = kd
c
c 2.2.2 Specify the dimensions
c
         kdimv0   = ndimf  (kdd)
         dimname0 = dimname(kdd)
c
c 2.2.2 Set the dimension and extract the dimension ID
c
c     NF90_DEF_DIM INPUT:  kfileid,  dimname0, kdimv0
c                  OUTPUT: kdimstat, kdimid0
c
         kdimstat  = NF90_DEF_DIM(kfileid,dimname0,kdimv0,kdimid0)

         if(kdimstat .ne. nf90_noerr) then
            errstrng = NF90_STRERROR(kdimstat)
            call abortcdf
     &        ('ncdfset ',  3,   errstrng
     &        ,'kdimid0 ', kdimid0,  'kdimstat', kdimstat, -1)
         endif
c
         if(kdimid0  .le.     0   ) then
            call abortcdf
     &        ('ncdfset ',  4,   'NetCDF dimension improperly defined '
     &        ,'kdimid0 ', kdimid0,  'kdimstat', kdimstat, -1)
         endif
c
c 2.2.3 Save the dimension ID
c
         kdimid(kdd)  = kdimid0
  100    continue
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine novaset
c
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
      character*16  ascifile, mapoutfl, mapdskfl
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
c
c
c
c 1.0 Set the unit numbers and file names
c
      kucdf       =  17
      kunva       =  19
      kudsk       =  20
      record      =  8
c
      ascifile    = 'nova.ascii'

      mapoutfl    = 'nova.mpout1'
      mapdskfl    = 'nova.mapdsk'
c
c
c
c 2.0 Open the ASCII output files
c
      open(unit   = kucdf, file   = ascifile, form   = 'formatted'
     &                                      , status = 'unknown')
c
c
c
c 3.0 Open the binary mapout and mapdsk output files
c
      open(unit   = kunva, file   = mapoutfl, form   = 'unformatted'
     &                   , access = 'direct', recl   =  record
     &                                      , status = 'unknown')
      open(unit   = kudsk, file   = mapdskfl, form   = 'unformatted'
     &                   , access = 'direct', recl   =  record
     &                                      , status = 'unknown')
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine setvar
c
c Define the variable data to be written
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      integer*4     k1,       k2,       k3,       k4,      k5
      integer*4     kvarv
      integer*4     kdim0,    kdim1,    kdim2
      integer*4     jp,       jpp,      iv,       ivv
      integer*4     nvarcnt,  nchrcnt,  nintcnt,  n0drcnt, n1drcnt,
     &              n1dpcnt,  n2drcnt
c
      integer*4     kfileid,  kmode
      integer*4     length0
      integer*4     ndimens,  nattrib,  nglobat
      integer*4     ndimf,    kdimid
      integer*4     nvariabl, kvarid
      integer*4     ndset,    ndtype,   naset
      integer*4     nvstrt,   nvstrv
      integer*4     nvdimid,  ndimid
      integer*4     vartype,  varsize,  atttype,  attleng
      integer*4     nvarchar, nvarintg, nvar0drl,
     &              nvar1drr, nvar1drp, nvar2drr,
     &              kvarchar, kvarintg, kvar0drl,
     &              kvar1drr, kvar1drp, kvar2drr
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  filencdf
      character*16  dimname
      character*16  attname
      character*16  varname
      character*36  longname
c
      character*1   varinpt0
      integer*4     varinpt1
      real*8        varinpt2, varinpt3, varinpt4, varinpt5
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/cdfiles/kfileid,  kmode,    length0,  filencdf
      common/fdimens/ndimens,  ndimf  (ndims), kdimid(ndims),
     &                         dimname(ndims)
      common/fattrib/nglobat,nattrib,attname(nattr)
      common/vattrib/nvariabl,       varname(nvars),   vartype(nvars),
     &               ndset(nvars),   ndtype (nvars),   kvarid(nvars),
     &               nvdimid(ndims), varsize(nvars),
     &               naset(nvars),   atttype(nvars),
     &               attleng(nvars), longname(nvars),
     &               ndimid(nvars,ndims)
      common/variabc/nvarchar, nvarintg, nvar0drl,
     &               nvar1drr, nvar1drp, nvar2drr,
     &               kvarchar, kvarintg, kvar0drl,
     &               kvar1drr, kvar1drp, kvar2drr
      common/variabl/varinpt0(nvdim0), varinpt1(1),      varinpt2(1),
     &               varinpt3(nvdim1), varinpt4(nvdim2),
     &               varinpt5(nvdim3,nvdim1)
c
c    ndtype(kvv) specifies what type of dimension
c               0    character of length 1
c               1    character array of dimension nvdim0
c               2    scalar integer
c               3    scalar real
c               4    1D real array of dimension (nvdim1)
c               5    1D real array of dimension (nvdim2)
c               6    2D real array of dimension (nvdim3,nvdim1)
c
c     ndimf (kd)     specifies the dimension values defined for the file
c     kdimid(kd)     specifies the dimension identifiers defined for the file
c     ndimid(kvv,kd) specifies the dimension identifiers for the variable
c     nvdimid(kd)    is a temporary storage for the dimension identifier for a
c                    given variable
c     To find the dimension value of a variable kvv use      ndimf (ndimid(kvv,kdd))
c     To find the dimension identifier of a variable kvv use kdimid(ndimid(kvv,kdd))
c
c
c
c 1.0 Initialization
c
c
c 1.1 Index data
c
      k1           =  1
      k2           =  2
      k3           =  3
      k4           =  4
      k5           =  5
c
c
c 1.2 Counters
c
      nvarcnt      =  0
      nchrcnt      =  0
      nintcnt      =  0
      n0drcnt      =  0
      n1drcnt      =  0
      n1dpcnt      =  0
      n2drcnt      =  0
c
c
c
c 2.0 Define the character variables
c     ndtype  = 1   varsize  = 1   ndimid  = 1  vartype = NF90_CHAR
c
c 2.1 First variable: 1D character array 
c
c 2.1.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nchrcnt             =  nchrcnt + 1
      varname (nvarcnt)   = 'Title'
c
c 2.1.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  1
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  1
      kdim0               =  ndimf(ndimid(nvarcnt,k1))
c
c 2.1.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_CHAR
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  10
      longname(nvarcnt)   = 'Case title'
c
c
c 2.2 Second variable: 1D character array
c
c 2.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nchrcnt             =  nchrcnt + 1
      varname (nvarcnt)   = 'Date'
c
c 2.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  1
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  1
      kdim0               =  ndimf(ndimid(nvarcnt,k1))
c
c 2.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_CHAR
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  10
      longname(nvarcnt)   = 'Case Date '
c
c 2.3 Third variable: 1D character array
c
c 2.3.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nchrcnt             =  nchrcnt + 1
      varname (nvarcnt)   = 'Comment'
c
c 2.3.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  1
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  1
      kdim0               =  ndimf(ndimid(nvarcnt,k1))
c
c 2.3.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_CHAR
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  8
      longname(nvarcnt)   = 'Comments'
c
c
c
c 3.0 Define the scalar integer variables
c     ndtype  = 2   varsize  = 0   ndimid  = 2  vartype = NF90_INT
c
c 3.1 Fourth variable: Integer Scalar
c
c 3.1.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nintcnt             =  nintcnt + 1
      varname (nvarcnt)   = 'mth'
c
c 3.1.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  2
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 3.1.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_INT
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  26
      longname(nvarcnt)   = 'Number of poloidal angles '
c
c
c 3.2 Fifth variable: Integer Scalar
c
c 3.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nintcnt             =  nintcnt + 1
      varname (nvarcnt)   = 'nosurf'
c
c 3.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  2
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 3.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_INT
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  24
      longname(nvarcnt)   = 'Number of flux surfaces '
c
c
c 3.2 Sixth variable: Integer Scalar
c
c 3.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nintcnt             =  nintcnt + 1
      varname (nvarcnt)   = 'remap'
c
c 3.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  2
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 3.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_INT
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  18
      longname(nvarcnt)   = 'Mapping Identifier'
c
c
c 3.3 Seventh variable: Integer Scalar
c
c 3.3.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nintcnt             =  nintcnt + 1
      varname (nvarcnt)   = 'mx'
c
c 3.3.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  2
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 3.3.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_INT
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  18
      longname(nvarcnt)   = 'Jacobian index #1 '
c
c
c 3.4 Eigth variable: Integer Scalar
c
c 3.4.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nintcnt             =  nintcnt + 1
      varname (nvarcnt)   = 'npsi'
c
c 3.4.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  2
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 3.4.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_INT
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  18
      longname(nvarcnt)   = 'Jacobian index #2 '
c
c
c 3.5 Ninth variable: Integer Scalar
c
c 3.5.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      nintcnt             =  nintcnt + 1
      varname (nvarcnt)   = 'kb'
c
c 3.5.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  2
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 3.5.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_INT
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  18
      longname(nvarcnt)   = 'Jacobian index #3 '
c
c
c
c 4.0 Define the scalar real variables
c     ndtype  = 3   varsize  = 0   ndimid  = 2  vartype = NF90_DOUBLE
c
c 4.1 Tenth variable: Real Scalar
c
c 4.1.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Xmin'
c
c 4.1.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.1.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  20
      longname(nvarcnt)   = 'Minimum major radius'
c
c
c 4.2 Eleventh variable: Real Scalar
c
c 4.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Xmax'
c
c 4.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  20
      longname(nvarcnt)   = 'Maximum major radius'
c
c
c 4.3 Twelfth variable: Real Scalar
c
c 4.3.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'X0'
c
c 4.3.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.3.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  20
      longname(nvarcnt)   = 'Nominal major radius'
c
c
c 4.4 Thirteenth variable: Real Scalar
c
c 4.4.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Xmag'
c
c 4.4.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.4.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  30
      longname(nvarcnt)   = 'Major radius of Magnetic axis'
c
c
c 4.5 Fourteenth variable: Real Scalar
c
c 4.5.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Zmin'
c
c 4.5.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.5.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  27
      longname(nvarcnt)   = 'Minimum vertical coordinate'
c
c
c 4.6 Fifteenth variable: Real Scalar
c
c 4.6.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Zmax'
c
c 4.6.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.6.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  27
      longname(nvarcnt)   = 'Maximum vertical coordinate'
c
c
c 4.7 Sixteenth variable: Real Scalar
c
c 4.7.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Z0'
c
c 4.7.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.7.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  27
      longname(nvarcnt)   = 'Nominal vertical coordinate'
c
c
c 4.8 Seventeenth variable: Real Scalar
c
c 4.8.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Zmag'
c
c 4.8.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.8.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  36
      longname(nvarcnt)   = 'Vertical coordinate of Magnetic axis'
c
c
c 4.9 Eighteenth variable: Real Scalar
c
c 4.9.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'B0'
c
c 4.9.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.9.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  34
      longname(nvarcnt)   = 'Nominal magnetic field at (X0,Z0) '
c
c
c 4.10 Ninetieth variable: Real Scalar
c
c 4.10.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Ip'
c
c 4.10.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.10.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  14
      longname(nvarcnt)   = 'Total Current '
c
c
c 4.11 20'th variable: Real Scalar
c
c 4.11.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Beta'
c
c 4.11.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.11.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  10
      longname(nvarcnt)   = 'Plasma Beta'
c
c
c 4.12 21'st variable: Real Scalar
c
c 4.12.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Betastar'
c
c 4.12.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.12.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  25
      longname(nvarcnt)   = 'Core weighted plasma beta'
c
c
c 4.13 22'nd variable: Real Scalar
c
c 4.13.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'BetaN'
c
c 4.13.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.13.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  34
      longname(nvarcnt)   = 'Troyon coefficient: Beta/(Ip/a*B0)'
c
c
c 4.14 23'rd variable: Real Scalar
c
c 4.14.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'li'
c
c 4.14.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.14.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  26
      longname(nvarcnt)   = 'Plasma internal inductance'
c
c
c 4.15 24'th variable: Real Scalar
c
c 4.15.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'PPF'
c
c 4.15.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.15.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  23
      longname(nvarcnt)   = 'Pressure Peaking Factor'
c
c
c 4.16 25'th variable: Real Scalar
c
c 4.16.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n0drcnt             =  n0drcnt + 1
      varname (nvarcnt)   = 'Upsiln'
c
c 4.16.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  0
      ndtype  (nvarcnt)   =  3
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  2
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 4.16.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  7
      longname(nvarcnt)   = 'Upsilon'
c
c
c
c 5.0 Define the poloidal flux vector arrays
c     ndtype  = 4   varsize  = 1   ndimid  = 3  vartype = NF90_DOUBLE
c
c 5.1 26'th variable: 1D Real Profile
c
c 5.1.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'psibig'
c
c 5.1.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.1.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  18
      longname(nvarcnt)   = '2pi* Poloidal flux'
c
c
c 5.2 27'th variable: 1D Real Profile
c
c 5.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'pa'
c
c 5.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  18
      longname(nvarcnt)   = '(mu0/B**2)*Pressure'
c
c
c 5.3 28'th variable: 1D Real Profile
c
c 5.3.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'ppa'
c
c 5.3.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.3.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  28
      longname(nvarcnt)   = '(mu0/B**2)*Pressure gradient'
c
c
c 5.4 29'th variable: 1D Real Profile
c
c 5.4.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'qa'
c
c 5.4.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.4.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  13
      longname(nvarcnt)   = 'Safety factor'
c
c
c 5.5 30'th variable: 1D Real Profile
c
c 5.5.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'qpa'
c
c 5.5.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.5.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  22
      longname(nvarcnt)   = 'Safety factor gradient'
c
c
c 5.6 31'st variable: 1D Real Profile
c
c 5.6.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'ga'
c
c 5.6.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.6.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  23
      longname(nvarcnt)   = 'Toroidal field function'
c
c
c 5.7 32'nd variable: 1D Real Profile
c
c 5.7.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1drcnt             =  n1drcnt + 1
      varname (nvarcnt)   = 'gpa'
c
c 5.7.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  4
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 5.7.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  33
      longname(nvarcnt)   = 'Toroidal field function gradient'

c
c
c
c 6.0 Define the poloidal angle vector arrays
c     ndtype  = 5   varsize  = 1   ndimid  = 4  vartype = NF90_DOUBLE
c
c 6.1 33'rd variable: 1D Real Profile
c
c 6.1.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1dpcnt             =  n1dpcnt + 1
      varname (nvarcnt)   = 'xinf'
c
c 6.1.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  5
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  4
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 6.1.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  24
      longname(nvarcnt)   = 'Plasma boundary r values'
c
c
c 6.2 34'th variable: 1D Real Profile
c
c 6.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n1dpcnt             =  n1dpcnt + 1
      varname (nvarcnt)   = 'zinf'
c
c 6.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  1
      ndtype  (nvarcnt)   =  5
      ndset   (nvarcnt)   =  1
      ndimid  (nvarcnt,k1)=  4
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
c
c 6.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  24
      longname(nvarcnt)   = 'Plasma boundary z values'
c
c
c
c 7.0 Define the 2D arrays
c     ndtype  = 6   varsize  = 2   ndimid  = (5,3)  vartype = NF90_DOUBLE
c
c 7.1 35'th variable: 2D Real Array
c
c 7.1.1 Variable name
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'xa'
c
c 7.1.2 Set the specific variable dimensions
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.1.3 Set the specific variable attributes
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  34
      longname(nvarcnt)   = 'radial values of mesh cell centers'
c
c
c 7.2 36'th variable: 2D Real Array
c
c 7.2.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'za'
c
c 7.2.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.2.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  34
      longname(nvarcnt)   = 'axial values of mesh cell centers'
c
c
c 7.3 37'th variable: 2D Real Array
c
c 7.3.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'xpth'
c
c 7.3.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.3.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  14
      longname(nvarcnt)   = 'dr/dthet array'
c
c
c 7.4 38'th variable: 2D Real Array
c
c 7.4.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'zpth'
c
c 7.4.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.4.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  14
      longname(nvarcnt)   = 'dz/dthet array'
c
c
c 7.5 39'th variable: 2D Real Array
c
c 7.5.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'xpsi'
c
c 7.5.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.5.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  13
      longname(nvarcnt)   = 'dr/dpsi array'
c
c
c 7.6 40'th variable: 2D Real Array
c
c 7.6.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'zpsi'
c
c 7.6.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.6.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  13
      longname(nvarcnt)   = 'dz/dpsi array'
c
c
c 7.7 41'st variable: 2D Real Array
c
c 7.7.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'grpssq'
c
c 7.7.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.7.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  14
      longname(nvarcnt)   = '[Grad(psi)]**2'
c
c
c 7.8 42'nd variable: 2D Real Array
c
c 7.8.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'grthsq'
c
c 7.8.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.8.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  16
      longname(nvarcnt)   = '[Grad(theta)]**2'
c
c
c 7.9 43'rd variable: 2D Real Array
c
c 7.9.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'grpsth'
c
c 7.9.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.9.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  21
      longname(nvarcnt)   = 'Grad(psi).grad(theta)'
c
c
c 7.10 44'th variable: 2D Real Array
c
c 7.10.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'gptdth'
c
c 7.10.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.10.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  30
      longname(nvarcnt)   = 'd/dthet[Grad(psi).grad(theta)]'
c
c
c 7.11 45'th variable: 2D Real Array
c
c 7.11.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'gpsdth'
c
c 7.11.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.11.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  23
      longname(nvarcnt)   = 'd/dthet{[Grad(psi)]**2}'
c
c
c 7.12 46'th variable: 2D Real Array
c
c 7.12.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'xjacob'
c
c 7.12.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.12.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  34
      longname(nvarcnt)   = '(psi,theta,phi) Coordinate Jacobian'
c
c
c 7.13 47'th variable: 2D Real Array
c
c 7.13.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'xjprym'
c
c 7.13.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.13.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  16
      longname(nvarcnt)   = 'd/dpsi(Jacobian)'
c
c
c 7.14 48'th variable: 2D Real Array
c
c 7.14.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'delta'
c
c 7.14.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.14.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  31
      longname(nvarcnt)   = 'Difference (theta - PEST angle)'
c
c
c 7.15 49'th variable: 2D Real Array
c
c 7.15.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'qdelp'
c
c 7.15.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.15.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  30
      longname(nvarcnt)   = 'd/dpsi[q*(theta - PEST angle)]'
c
c
c 7.16 50'th variable: 2D Real Array
c
c 7.16.1 Variable name
c
      nvarcnt             =  nvarcnt + 1
      n2drcnt             =  n2drcnt + 1
      varname (nvarcnt)   = 'theta'
c
c 7.16.2 Set the specific variable dimensions
c
      varsize (nvarcnt)   =  2
      ndtype  (nvarcnt)   =  6
      ndset   (nvarcnt)   =  2
      ndimid  (nvarcnt,k1)=  5
      ndimid  (nvarcnt,k2)=  3
      kdim1               =  ndimf(ndimid(nvarcnt,k1))
      kdim2               =  ndimf(ndimid(nvarcnt,k2))
c
c 7.16.3 Set the specific variable attributes
c
      vartype (nvarcnt)   =  NF90_DOUBLE
c
      naset   (nvarcnt)   =  1
      atttype (nvarcnt)   =  NF90_CHAR
      attleng (nvarcnt)   =  19
      longname(nvarcnt)   = 'Poloidal coordinate'
c
c
c
c 8.0 Return and end
c
c 8.1 Set the total number of variables
c
      nvariabl    = nvarcnt
      nvarchar    = nchrcnt
      nvarintg    = nintcnt
      nvar0drl    = n0drcnt
      nvar1drr    = n1drcnt
      nvar1drp    = n1dpcnt
      nvar2drr    = n2drcnt
c
c
c 8.2 Return
c
      return
      end
      subroutine ncdfvar
c
c Set the NetCDF variable characteristics
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      integer*4     k1,       k2,       k3,       k4
      integer*4     kv,       kvv
      integer*4     kd,       kdd,      ka,      kat
      integer*4     kvarstat, kattstat, kveror
      integer*4     kvarid0,  nndims
      integer*4     nvattrib
      integer*4     vartype0, atttype0, attleng0
c
      integer*4     kfileid,  kmode
      integer*4     length0
      integer*4     ndimens,  nattrib,  nglobat
      integer*4     ndimf,    kdimid
      integer*4     nvariabl, kvarid
      integer*4     ndset,    ndtype,   naset
      integer*4     nvstrt,   nvstrv
      integer*4     nvdimid,  ndimid
      integer*4     vartype,  varsize,  atttype,  attleng
      integer*4     namelen
c
      character(len=lenname)  varname0
c
      character*16  attname0
      character*26  attribt0
      character*36  longname0
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  filencdf
      character*16  dimname
      character*16  attname
      character*16  varname
      character*36  longname
      character*80  errstrng
c
      character*1   varinpt0
      integer*4     varinpt1
      real*8        varinpt2, varinpt3, varinpt4, varinpt5
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/cdfiles/kfileid,  kmode,    length0,  filencdf
      common/fdimens/ndimens,  ndimf  (ndims), kdimid(ndims),
     &                         dimname(ndims)
      common/fattrib/nglobat,nattrib,attname(nattr)
      common/vattrib/nvariabl,       varname(nvars),   vartype(nvars),
     &               ndset(nvars),   ndtype (nvars),   kvarid(nvars),
     &               nvdimid(ndims), varsize(nvars),
     &               naset(nvars),   atttype(nvars),
     &               attleng(nvars), longname(nvars),
     &               ndimid(nvars,ndims)
      common/variabl/varinpt0(nvdim0), varinpt1(1),      varinpt2(1),
     &               varinpt3(nvdim1), varinpt4(nvdim2),
     &               varinpt5(nvdim3,nvdim1)
c
c
c
c 1.0 Initialization
c
c 1.1 Index data
c
      k1           =  1
      k2           =  2
      k3           =  3
      k4           =  4
c
c
c
c 2.0 Set up the NetCDF variable names and dimensions
c
c 2.1 Loop through all the variables
c
      do 110 kv    = 1,nvariabl
      kvv          = kv
c
c
c 2.2 Set up the variable name and dimensions appropriate for this variable
c
         nndims       = ndset(kvv)
         if    (nndims .le. 0) then
            nvdimid(k1 ) = kdimid(ndimid(kvv,k1 ))
c
         elseif(nndims .gt. 0) then
            do 105 kd    = 1,nndims
            kdd          = kd
            nvdimid(kdd) = kdimid(ndimid(kvv,kdd))
  105       continue
         endif
c
         namelen     = lenname
         varname0    = varname(kvv)
         vartype0    = vartype(kvv)
c
c
c 2.3 Set up the variable with chosen dimensions and define the variable ID
c
         call definvar(kfileid,varname0,vartype0,nndims, nvdimid,
     &                         namelen, kvarid0,kvarstat,kveror)
c
         if(kveror .ne. 0) then
            call abortcdf
     &        ('ncdfvar ',  1,   'Error in setting NetCDF variable    '
     &        ,'kvarid0 ', kvarid0,  'kveror  ', kveror,   -1)
         endif
c
c
c 2.4 Save the variable ID
c
         kvarid(kvv)  = kvarid0
  110 continue
c
c
c
c 3.0 Set up the variable attributes
c
c     NF90_PUT_ATT INPUT:  kfileid,  kvarid0, attname0, attribt0
c                  OUTPUT: kattstat
c
c 3.1 Loop over variables
c
      do 200 kv  = 1,nvariabl
         kvv         = kv
         kvarid0     = kvarid  (kvv)
         nvattrib    = naset   (kvv)
         atttype0    = atttype (kvv)
         attleng0    = attleng (kvv)
         longname0   = longname(kvv)
c
c
c 3.2 Set the variable attributes
c
         if(nvattrib .gt. 0) then
c
c 3.2.1 Loop over variable attributes
c
            do 150 ka  = 1,nvattrib
               kat     = ka
               attname0    = attname (kat)
               if(attname0 .eq. 'long_name') then
                  attribt0 = longname0
               else
                  call abortcdf
     &        ('ncdfvar ',  2,   'NetCDF attribute is not long_name   '
     &        ,'kvarid0 ', kvarid0,  'kat     ', kat,      -1)
               endif
c
c 3.2.2 Set the attribute
c
               kattstat = NF90_PUT_ATT(kfileid,kvarid0,attname0,
     &                                                 attribt0)
c
               if(kattstat .ne. nf90_noerr) then
                  errstrng = NF90_STRERROR(kattstat)
                  call abortcdf
     &        ('ncdfvar ',  3,   errstrng
     &        ,'kvarid0 ', kvarid0,  'kattstat', kattstat, -1)
               endif
  150       continue
         endif
  200    continue
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine definvar(kfileid,varnam,vartyp, ndimv,   nvdmid,
     &                            namlen,kvarid0,kvarstat,kveror)
c
c Define the NetCDF variable name, type, and dimensions
c
c INPUT:  kfileid,  varnam,   vartyp,  ndimv,  nvdmid, namlen
c OUTPUT: kvarid0,  kvarstat, kveror
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Local type declarations:
c
      integer*4     kfileid,  vartyp,   ndimv,   nvdmid,   namlen
      integer*4     kvarid0,  kvarstat, kveror
c
      character*80  errstrng
      character(len=namlen)  varnam
c
      dimension nvdmid(ndimv)
c
c
c
c 1.0 Initialization
c
      kveror   = 0
c
c
c
c 2.0 Set up the variable with chosen dimensions and define the variable ID
c
c     NF90_DEF_VAR INPUT:  kfileid,  varnam, vartyp, nvdmid(ndimv)
c                  OUTPUT: kvarstat, kvarid0
c                  Hidden implicit dimension: ndimv
c
         kvarstat    = NF90_DEF_VAR(kfileid,varnam,vartyp,nvdmid
     &                                                   ,kvarid0)
c
c
c
c 3.0 Check for errors
c
c 3.1 Check errors in the definition
c
         if(kvarstat .ne. nf90_noerr) then
            kveror   = +1
            errstrng = NF90_STRERROR(kvarstat)
            call abortcdf
     &        ('definvar',  1,   errstrng
     &        ,'kvarid0 ', kvarid0,  'kvarstat', kvarstat, -1)
         endif
c
c
c 3.2 Check the variable ID is valid
c
         if(kvarid0  .le.     0   ) then
            kveror   = +2
            call abortcdf
     &        ('definvar',  2,   'NetCDF variable not properly defined'
     &        ,'kvarid0 ', kvarid0,  'kvarstat', kvarstat, -1)
         endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine endcdff(kfileid0)
c
c Terminate NetCDF define mode
c
c INPUT:  kfileid0
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
c
      integer*4     kfileid0
      integer*4     kendstat
c
      character*80  errstrng
c
c
c
c 1.0 Terminate define mode
c
c     NF90_ENDDEF INPUT:  kfileid0
c                 OUTPUT: kendstat
c
      kendstat = NF90_ENDDEF(kfileid0)
c
c
c
c 2.0 Check for errors
c
      if(kendstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kendstat)
         call abortcdf
     &        ('endcdff ',  1,   errstrng
     &        ,'kfileid0', kfileid0, 'kendstat', kendstat, -1)
      endif
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine cdfopen(filencdf,kfileid0,mode)
c
c Open the NetCDF file
c
c INPUT:  filencdf, kfileid0, mode
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Local type declarations:
c
      integer*4     mode
      integer*4     kfileid0, kfileid1
      integer*4     kopnstat
c
      character*16  filencdf
      character*80  errstrng
c
c
c
c 1.0 Reopen the file
c
c     NF90_OPEN  INPUT:  filencdf, mode
c                OUTPUT: kopnstat, kfileid1
c
      kopnstat = NF90_OPEN(filencdf,mode,kfileid1)
c
c
c
c 2.0 Check for errors
c
      if(kopnstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kopnstat)
         call abortcdf
     &        ('cdfopen ',  1,   errstrng
     &        ,'kfileid1', kfileid1, 'kopnstat', kopnstat, -1)
      endif
c
      if(kfileid1 .le.     0   ) then
         call abortcdf
     &        ('cdfopen ',  2,   'NetCDF file ID not proerly defined  '
     &        ,'kfileid1', kfileid1, 'kopnstat', kopnstat, -1)
      endif
c
      if(kfileid1 .ne. kfileid0) then
         call abortcdf
     &        ('cdfopen ',  3,   'NetCDF file ID is not correct       '
     &        ,'kfileid1', kfileid1, 'kfileid0', kfileid0, -1)
      endif
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine cdfclos(kfileid1)
c
c Close the NetCDF file
c
c INPUT:  kfileid1
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c Local type declarations:
c
      integer*4     kfileid1
      integer*4     kclsstat
c
      character*16  filencdf
      character*80  errstrng
c
c
c
c 1.0 Close the file and automatically terminate define mode
c
c     NF90_CLOSE INPUT:  kfileid1
c                OUTPUT: kclsstat
c
      kclsstat = NF90_CLOSE(kfileid1)
c
c
c
c 2.0 Check for errors
c
      if(kclsstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kclsstat)
         call abortcdf
     &        ('cdfclos ',  1,   errstrng
     &        ,'kfileid1', kfileid1, 'kclsstat', kclsstat, -1)
      endif
c
c
c
c 3.0 Return and end
c
      return
      end
      subroutine cdfchek(kfileid1)
c
c Check the NetCDF variables are correctly defined
c
c INPUT:  kfileid1
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      integer*4     kv,       kd
      integer*4     kinvstat
      integer*4     kvarid0,  kvarid1
c
      integer*4     kfileid1
      integer*4     ndimf,    kdimid
      integer*4     nvariabl, kvarid
      integer*4     ndset,    ndtype,   naset
      integer*4     nvstrt,   nvstrv
      integer*4     nvdimid,  ndimid
      integer*4     vartype,  varsize,  atttype,  attleng
c
      character*16  varname1
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  filencdf
      character*16  varname
      character*36  longname
      character*80  errstrng
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/vattrib/nvariabl,       varname(nvars),   vartype(nvars),
     &               ndset(nvars),   ndtype (nvars),   kvarid(nvars),
     &               nvdimid(ndims), varsize(nvars),
     &               naset(nvars),   atttype(nvars),
     &               attleng(nvars), longname(nvars),
     &               ndimid(nvars,ndims)
c
c
c
c 1.0 Extract the variable IDs to check
c
c 1.1 Loop over variables
c
      do 100 kv  = 1,nvariabl
         kvv        = kv

c     NF90_INQ_VARID INPUT:  kfileid1, varname1
c                    OUTPUT: kinvstat, kvarid1
c     
c 1.2 Save the correct variable ID and name
c
         kvarid0   = kvarid (kvv)
         varname1  = varname(kvv)
c
c
c 1.3 Extract the variable ID from the file
c
         kinvstat   = NF90_INQ_VARID(kfileid1,varname1,kvarid1)
c
c
c 1.4 Check for errors
c
c 1.4.1 Check for errors in the call
c
         if(kinvstat .ne. nf90_noerr) then
            errstrng = NF90_STRERROR(kinvstat)
            call abortcdf
     &        ('cdfchek ',  1,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kinvstat', kinvstat, -1)
         endif
c
c 1.4.2 Check the extracted ID against the expected ID
c
         if(kvarid0 .ne.   kvarid1) then
            call abortcdf
     &        ('cdfchek ',  2,   'NetCDF variable ID is not correct   '
     &        ,'kvarid0 ', kvarid0,  'kvarid1 ', kvarid1,  -1)
         endif
  100 continue
c
c
c
c 2.0 Return and end
c
      return
      end
      subroutine cdfnqir(kfileid1,kdimens,kvariabl,kglobat,
     &                            kdims,kvars,katts,lstdim)
c
c Check the characteristics of a NetCDF variable and find the dimensions
c
c INPUT:  kfileid1, kdimens,   kvariabl, kglobat
c OUTPUT: kdims,    kvars,     katts,    lstdim
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      integer*4     kd,       kdid,     kdidv
      integer*4     kinqstat, kindstat, kinistat
      integer*4     kmdim0,   kmdim1
c
      integer*4     kfileid1, kvariabl, kdimens,  kglobat
      integer*4     kdims,    kvars,    katts,    lstdim
c
      integer*4     ndimens,  ndimf
      integer*4     kdimid
c
      character*16  dmname0,  dmname1
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  dimname
      character*80  errstrng
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/fdimens/ndimens,  ndimf  (ndims), kdimid(ndims),
     &                         dimname(ndims)
c
c
c
c 1.0 Extract the basic file information
c
c     NF90_INQUIRE  INPUT:  kfileid1
c                   OUTPUT: kinqstat, kdims, kvars, katts, lstdim
c
      kinqstat   = NF90_INQUIRE(kfileid1,kdims,kvars,katts,lstdim)
c
c
c
c 2.0 Check against the intended data
c
      if(kinqstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kinqstat)
         call abortcdf
     &        ('cdfnqir ',  1,   errstrng
     &        ,'kfileid1', kfileid1, 'kinqstat', kinqstat, -1)
      endif
c
      if(kdims    .ne.  kdimens) then
         call abortcdf
     &        ('cdfnqir ',  2,   'NetCDF dimension is not correct     '
     &        ,'kdimens ', kdimens,  'kdims   ', kdims,    -1)
      endif
c
      if(kvars    .ne. kvariabl) then
         call abortcdf
     &        ('cdfnqir ',  3,   'NetCDF variable is not correct      '
     &        ,'kvariabl', kvariabl, 'kvars   ', kvars,    -1)
      endif
c
      if(katts    .ne.  kglobat) then
         call abortcdf
     &        ('cdfnqir ',  4,   'NetCDF file attributes are incorrect'
     &        ,'kglobat ', kglobat,  'katts   ', katts,    -1)
      endif
c
c
c
c 3.0 Extract the actual file Dimension data
c
c 3.1 Extract the dimension name and value from the dimension ID
c
c     NF90_INQUIRE_DIMENSION INPUT:  kfileid1, kdid
c                            OUTPUT: kindstat, dmname1,  kmdim1
c
      if(kdims .ne. 0) then
         do 100 kd = 1,kdims
            kdid      = kd
            kmdim0    = ndimf(kdid)
            dmname0   = dimname(kdid)
c
            kindstat  = NF90_INQUIRE_DIMENSION(kfileid1,kdid,dmname1,
     &                                                       kmdim1)
c
            if(kindstat .ne. nf90_noerr) then
               errstrng = NF90_STRERROR(kindstat)
               call abortcdf
     &        ('cdfnqir ',  5,   errstrng
     &        ,'kfileid1', kfileid1, 'kindstat', kindstat, -1)
            endif
c
c
c 3.2 Double check dimension by extracting the dimension ID from the
c           dimension name for consistency
c
c     NF90_INQ_DIMID INPUT:  kfileid1, dmname1
c                    OUTPUT: kinistat, kdidv
c
            kinistat  = NF90_INQ_DIMID(kfileid1,dmname1,kdidv)
c
            if(kinistat .ne. nf90_noerr) then
               errstrng = NF90_STRERROR(kinistat)
               call abortcdf
     &        ('cdfnqir ',  6,   errstrng
     &        ,'kfileid1', kfileid1, 'kinistat', kinistat, -1)
            endif
c
            if(kdidv    .ne.    kdid ) then
               call abortcdf
     &        ('cdfnqir ',  7,   'NetCDF dimension ID is not correct  '
     &        ,'kdidv   ', kdidv,    'kdid    ', kdid,     -1)
            endif
c
c
c 3.3 Check the dimension sizes and names against ndimf(kdid) and dimname(kdid)
c
            if(kmdim1   .ne.  kmdim0 ) then
               call abortcdf
     &        ('cdfnqir ',  8,   'NetCDF dimension value not correct  '
     &        ,'kmdim0  ', kmdim0,   'kmdim1  ', kmdim1,   -1)
            endif
c
            if(dmname1  .ne.  dmname0) then
               call abortcdf
     &        ('cdfnqir ',  9,   'NetCDF dimension name is not correct'
     &        ,'kfileid1', kfileid1, 'kdidv   ', kdidv,    -1)
            endif
  100    continue
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine writprof
c
c Write the profile data to the ASCII file
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
      parameter (nhd1=5,nhd2=3)
      parameter (nvn=7)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
      parameter (nntg    = 10,  nrlv    = 13,    nrld    = nvdim1)
c
c
c Global type declarations:
c
      character*8   headr
      character*8   etitl,date
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*16  sourcnam,sourcdat
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      character*16  ascifile, mapoutfl, mapdskfl
c
c
c Global common declarations:
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/kinetc/pfactr,tfactr,dfactr,pffact,deutp,dmass,dnnova(np2),
     &              pfnova(np2), ptnova(np2), prnova(np2),pbnova(np2), 
     &              tenova(np2), tinova(np2), denova(np2),dinova(np2)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
c
c
c
c 1.0 Initialization
c
      deerror  = 1.0e-02
      teerror  = 1.0e-02
      tierror  = 1.0e-02
      pterror  = 1.0e-02
      qperror  = 1.0e-02
      pserror  = 1.0e-02
      pferror  = 1.0e-02
c
c
c
c 2.0 Write the scalar data
c
      write(kucdf,1000) ntor
      write(kucdf,1100) btor
      write(kucdf,1110) rcgeom
      write(kucdf,1120) aminor
      write(kucdf,1130) capa
      write(kucdf,1140) triangl
      write(kucdf,1200) zeffect
      write(kucdf,1500)
c
c
c
c 3.0 Write the kinetic profile data as functions of toroidal flux
c
c 3.1 Electron number density
c
      if(idnsty .le. 0) then
         call abortjob
     &        ('writprof',  1,   'Density profile is not real profile '
     &        ,'idnsty  ', idnsty,   'nmap    ', nmap,     -1)
      endif
c
      write(kucdf,2000)
c
      do 100 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,2010) psintor(jjp),  denova (jjp), deerror
  100 continue
      write(kucdf,2050)
c
c
c 3.2 Electron temperature
c
      write(kucdf,2100)
c
      do 120 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,2110) psintor(jjp),  tenova (jjp), teerror
  120 continue
      write(kucdf,2150)
c
c
c 3.3 Ion temperature
c
      write(kucdf,2200)
c
      do 140 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,2210) psintor(jjp),  tinova (jjp), tierror
  140 continue
      write(kucdf,2250)
c
c
c 3.4 Total pressure
c
      write(kucdf,2500)
c
      do 150 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,2510) psintor(jjp),  ptnova (jjp), pterror
  150 continue
      write(kucdf,2550)
c
c
c
c 4.0 Write out the transformation between toroidal and sqrt(poloidal flux)
c
c 4.1 q profile
c
      write(kucdf,3000)
c
      do 200 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,3010) psintor(jjp),  qp1 (jjp), qperror
  200 continue
      write(kucdf,3050)
c
c 4.2 Poloidal flux profile
c
      write(kucdf,3100)
c
      do 220 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,3110) psintor(jjp),  psisqrt(jjp), pserror
  220 continue
      write(kucdf,3150)
c
c
c
c 5.0 Write out the fast ion pressure profile
c
      write(kucdf,4000) betaf
      write(kucdf,4010)
c
      do 300 jj = 1,jpsi2
      jjp       = jj
      write(kucdf,4020) psintor(jjp),  pbnova (jjp), pferror
  300 continue
      write(kucdf,4050)
c
c
c
c 6.0 Return and end
c    
      return
 1000 format('% Toroidal mode number'
     &     ,/,'%',/,4x,i3,/)
 1100 format('% Toroidal magnetic field [Tesla]'
     &     ,/,'%',/,4x,e14.6,/)
 1110 format('% Major radius [m]'
     &     ,/,'%',/,4x,e14.6,/)
 1120 format('% Minor radius [m]'
     &     ,/,'%',/,4x,e14.6,/)
 1130 format('% Elongation'
     &     ,/,'%',/,4x,e14.6,/)
 1140 format('% Triangularity'
     &     ,/,'%',/,4x,e14.6,/)
 1200 format('% Zeffective'
     &     ,/,'%',/,4x,e14.6,/)
 1500 format(//)
 2000 format('%',4x,'density data points:'
     &   ,//,'%',4x,'r/a',6x,'density [10^19/m^-3]'
     &          ,1x,'error [10^19/m^-3]')
 2010 format(3(3x,e13.6))
 2050 format('-1 -1 -1',//)
 2100 format('%',4x,'electron temperature data points:'
     &   ,//,'%',4x,'r/a',9x,'T_e [keV]',6x,'error [keV]')
 2110 format(3(3x,e13.6))
 2150 format('-1 -1 -1',//)
 2200 format('%',4x,'ion temperature data points:'
     &   ,//,'%',4x,'r/a',9x,'T_i [keV]',6x,'error [keV]')
 2210 format(3(3x,e13.6))
 2250 format('-1 -1 -1',//)
 2500 format('%',4x,'pressure data points:'
     &   ,//,'%',4x,'r/a',9x,'pressure [kPa]',6x,'error [kPa]')
 2510 format(3(3x,e13.6))
 2550 format('-1 -1 -1',/)
 3000 format('%',4x,'q profile data points:'
     &   ,//,'%',4x,'r/a',13x,'q',8x,'error')
 3010 format(3(3x,e13.6))
 3050 format('-1 -1 -1',//)
 3100 format('%',4x,'sqrt(psi)data points:'
     &   ,//,'%',4x,'r/a',9x,'sqrt(psi)',7x,'error')
 3110 format(3(3x,e13.6))
 3150 format('-1 -1 -1',//)
 4000 format('%',4x,'Central beta for fast ion species'
     &    ,//,'%',/,4x,e14.6,/)
 4010 format('%',4x,'fast ion species beta profile:'
     &    ,/,'%',4x,'r/a',3x,'beta',3x,'error')
 4020 format(3(3x,e13.6))
 4050 format('-1 -1 -1',///)
      end
      subroutine writdata(kwmode)
c
c Write the data to NetCDF and the binary files and write to ASCII file
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Global parameter declarations:
c
c###  parameter (npx=150,ncx=132,  np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (npx=200,ncx=2*npx,np1=npx+1,np2=npx+2,nc1=ncx+1)
      parameter (nxx=513,nxz=nxx)
      parameter (npp=929,ntt=2*npp-1,npb=npp)
      parameter (nft=5)
      parameter (nhd1=5,nhd2=3)
      parameter (nvn=7)
c
c Local parameter declarations:
c
      parameter (ndims   = 5,   nvars   = 100,   nattr   = 2)
      parameter (lenname = 16)
      parameter (lenword = 8,   nchdim  = 20)
      parameter (nvdim0  = lenword*nchdim)
      parameter (nvdim1  = np1, nvdim2  = nc1+1, nvdim3  = nc1)
      parameter (nntg    = 10,  nrlv    = 13,    nrld    = nvdim1)
c
c
c Global type declarations:
c
      character*8   headr
      character*8   etitl,date
      character*8   version
      character*8   verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6
      character*16  sourcnam,sourcdat
      character*16  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c Local type declarations:
c
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
      integer       jrev,     jfor,     ivv,      kvw
      integer       krtype,   kerr,     nstdsk,   nstnva,
     &              nfinsh,   nfinshs,  nfinsht,  clength
      integer       novatitl
      integer       nvariab,  kvariab
      integer       nvarchar, nvarintg, nvar0drl,
     &              nvar1drr, nvar1drp, nvar2drr,
     &              kvarchar, kvarintg, kvar0drl,
     &              kvar1drr, kvar1drp, kvar2drr
c
      integer*4     nvara1,   nvara2,   nvarb
c
      integer*4     kercd
      integer*4     k1,       k2,       k3,       k4
      integer*4     k5,       k6,       k7,       k8
      integer*4     k9,       k10,      k11,      k12,      k13
      integer*4     kwmode
      integer*4     length
      integer*4     kvarv,    nvarsize
      integer*4     nndms,    nndmv
      integer*4     kdim0,    kdim1,    kdim2
      integer*4     jp,       jpp,      iv,       ivp
      integer*4     ivp0,     ivp1
      integer*4     kt,       ktt,      kv,       kvv
      integer*4     kdims,    kvars,    katts,    lstdim
      integer*4     kfileid1, kvarid0,  kvarid1,  nvdms,    nvatts,
     &              nvdims
      integer*4     kdtyp,    kdset,    kaset
      integer*4     nvstrt0,  nvdmns
      integer*4     kvchar,   kvintg,   kvreal,   kvprfa,   kvprfb,
     &              kvaray
c
      integer*4     kfileid,  kmode
      integer*4     length0
      integer*4     ndimens,  nattrib,  nglobat
      integer*4     ndimf,    kdimid
      integer*4     nvariabl, kvarid
      integer*4     ndset,    ndtype,   naset
      integer*4     nvstrt,   nvstrv
      integer*4     nvdimid,  ndimid
      integer*4     vartype,  varsize,  atttype,  attleng
      integer*4     namelen
c
      character(len=lenname)  varnamev
c
      character*16  ascifile, mapoutfl, mapdskfl
      character*16  filencdf
      character*16  dimname
      character*16  attname
      character*16  varname
      character*36  longname
c
      character*1   varinpt0
c
      integer*4     varinpt1
      integer*4     varinpta
c
      real*8        varinpt2, varinpt3, varinpt4, varinpt5
      real*8        varin0,   varin1,   varmthet
c
      integer*4     nxeq,     nzeq,     nosurf
      integer*4     mthet,    mtht0,    mtht1
      integer*4     remap,    njrval,   njgpsi,   njbtot
      real*8        ppnorm,   ffnorm
      real*8        xmin,     xmax,     zmin,     zmax,
     &              zcenter,  betator,  betas,    betan,   elli,
     &              ppfact,   upsilon
      character*160 title,    datv,     comment
c
c
c Global common declarations:
c
      common/vsno/  verold0,verold1,verold2,verold3,verold4,verold5,
     &              verold6,sourcnam,sourcdat,version,headr(nhd1,nhd2)
      common/cnst/  pi,hlfpi,twopi,amu,boltzm,echarg,pmass,roundff,bigno
      common/inpd/  ntor,ncase,idnsty,ndnxp0,ndnxp1,ndnxp2,ifastp,
     &              nmap,neqtyp,mpreset,ndoublt,ndivert,nmtype,
     &              jpsi,itht,jpsi1,jpsi2,ithtp,jsep,
     &              isym,igrid,nham1,nham2,nham3,npowr,
     &              bfieldf,rdefolt,qxin,btdes,qsurf,
     &              gamma,gamav,rmantl,betaf,zeffect,
     &              ncorr,corrfac,nccellr,peqpk0,peqpk1,peqpk2
      common/ttle/  etitl(nft),date
      common/size/  xdim,zdim,redge,zlowr,ipestg
      common/ort1/  ndim1,ndim2,xma,zma,rcnt,btor,totcur,
     &              psimax0,psilim0,delpsir0,psimax1,psilim1,delpsir1,
     &              psimax,psilim,delpsir,dpsidec,dpsisv,dpedg1,dpedg2,
     &              eaxe,taxe,qaxe,fqiaxe,fqmaxe,paxe,faxe,ppaxe,ffpaxe,
     &              dnaxe,pfaxe,qppaxe,dlnaxe,dpnaxe,dhnaxe,
     &              arcaxe,dnnorm,pfnorm,
     &              qlim,fqilim,fqmlim,plim,flim,pplim,ffplim,
     &              dnlim,pflim,xlim,zlim,
     &              qmer,btmer,gkappa,arcprev,chicmax,
     &              charcmx,chpstmx,chhammx,arcnrm0,pstnrm0,hamnrm0,
     &              elongax1,elongax2,elongaxs,elongaxp,elongtn(npp)
      common/ort2/  psival(np1),pp(np1),ffp(np1),p(np1),f(np1),
     &              dnsty(np1),pfast(np1),qp(np1),fqpi(np1),fqim(np1),
     &              qdel(np1),psinitl(np1),qpinitl(np1),
     &              qprime(np1),qpint(np1),fqint(np1),
     &              psivl0(np2),rst(np2),zst(np2),rstp(np2),zstp(np2),
     &              rsinitl(np2),zsinitl(np2),
     &              arcsurf(nc1),pestchi(nc1),hamlchi(nc1),
     &              alfarc (nc1),alfpst (nc1),alfham (nc1),
     &              rs(nc1,np1),zs(nc1,np1)
      common/ort3/  rsrf(nc1),zsrf(nc1),chic(nc1),chie(nc1),dydx(nc1),
     &              xjsc(nc1)
      common/ort4/  rcell  (np1,nc1),zcell  (np1,nc1),
     &              dpsdr  (np1,nc1),dpsdz  (np1,nc1),
     &              chiarcl(np1,nc1),chipest(np1,nc1),chihaml(np1,nc1),
     &              xjcarcl(np1,nc1),xjcpest(np1,nc1),xjchaml(np1,nc1),
     &              alfarcl(np1,nc1),alfpest(np1,nc1),alfhaml(np1,nc1),
     &              arcnorm(np1),    pstnorm(np1),    hamnorm(np1),
     &              dlnlval(np1),    dpnlval(np1),    dhnlval(np1)
      common/ort5/  f3 (np1,nc1),f4 (np1,nc1),f5 (np1,nc1),
     &              f7 (np1,nc1),f8 (np1,nc1),f9 (np1,nc1),
     &              f10(np1,nc1),f11(np1,nc1),f12(np1,nc1),
     &              f13(np1,nc1),f14(np1,nc1),f15(np1,nc1),
     &              f16(np1,nc1),f17(np1,nc1),f18(np1,nc1),
     &              f19(np1,nc1),f20(np1,nc1),f21(np1,nc1),
     &              f22(np1,nc1),f23(np1,nc1),f24(np1,nc1),
     &              f25(np1,nc1),f26(np1,nc1),f27(np1,nc1),
     &              f28(np1,nc1)
      common/ort6/  savgax,tavgax,sntax0,sntax1,sntax2,sntax3,sntax4,
     &              svint(nvn),savge(np1),tavge(np1),sint0(np1),
     &              sint1(np1),sint2(np1),sint3(np1),sint4(np1)
      common/auxmsh/rh2tot,rhotot,flxtot,voltot,
     &              anltflxp,dvrtflxp,anltvolp,dvrtvolp,
     &              analtflx,divrtflx,analtvol,divrtvol,
     &              psivl1 (np2),qp1    (np2),fqpi1  (np2),
     &              qprim1 (np2),sintp0 (np2),psivmsh(np2),
     &              psivalu(np2),psinorm(np2),psisqrt(np2),
     &              psirho2(np2),psirhov(np2),psinrho(np2),
     &              psitorf(np2),psintor(np2),psisqtf(np2),
     &              psivolm(np2),psinvol(np2),psisqvl(np2),
     &              dpsirh2(np2),dpsirho(np2),dpsinrh(np2),
     &              dpsitor(np2),dpsintf(np2),dpsisqt(np2),
     &              dpsivol(np2),dpsinvl(np2),dpsisqv(np2)
      common/vcal/  btnew,btave,bpave,betat,betap,betax0,betax1,volme,
     &              vhalf,bavet(3,nxx),bavep(3,nxx),pvolm(3,nxx),
     &              betav(3,nxx)
      common/geom/  aminor,rcgeom,epslon,capa,triangl,
     &              allim,bpornl,deltal,qcyl,q0surf,welln,
     &              well(np1),vdpsi(np1)
      common/inout/ kutty,kuout,kuinp,kueql,kumap,kugrd,kurdm,kurdn,
     &              kufst,krdeqlb,krdmgta,krdngta,krdfast
      common/flnm/  filout,filinp,fileql,filmap,filgrd,filrdm,filrdn,
     &              filfst,filplt
c
c Local common declarations:
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
      common/cdfiles/kfileid,  kmode,    length0,  filencdf
      common/fdimens/ndimens,  ndimf  (ndims), kdimid(ndims),
     &                         dimname(ndims)
      common/fattrib/nglobat,nattrib,attname(nattr)
      common/vattrib/nvariabl,       varname(nvars),   vartype(nvars),
     &               ndset(nvars),   ndtype (nvars),   kvarid(nvars),
     &               nvdimid(ndims), varsize(nvars),
     &               naset(nvars),   atttype(nvars),
     &               attleng(nvars), longname(nvars),
     &               ndimid(nvars,ndims)
      common/variabc/nvarchar, nvarintg, nvar0drl,
     &               nvar1drr, nvar1drp, nvar2drr,
     &               kvarchar, kvarintg, kvar0drl,
     &               kvar1drr, kvar1drp, kvar2drr
      common/variabl/varinpt0(nvdim0), varinpt1(1),      varinpt2(1),
     &               varinpt3(nvdim1), varinpt4(nvdim2),
     &               varinpt5(nvdim3,nvdim1)
      common/savedat/varinpta(nntg),   varinptb(nrld)
      common/storage/nvdmid (ndims),nvstrt(ndims), nvdims(ndims),
     &               nvstrt0(ndims),nvdmns(ndims),
     &               nvstrv (ndims),nvstrv0(ndims),nvdmnv(ndims)
      common/passdat/title,  datv,   comment,
     &               nxeq,   nzeq,   nosurf, mthet,  mtht0,  mtht1,
     &               remap,  njrval, njgpsi, njbtot,
     &               xmin,   xmax,   zmin,   zmax,   zcenter,
     &               betator,betas,  betan,  elli,   ppfact, upsilon
c
c
c
c 1.0 Initialization
c
c 1.1 Index data
c
      k1           =  1
      k2           =  2
      k3           =  3
      k4           =  4
      k5           =  5
      k6           =  6
      k7           =  7
      k8           =  8
      k9           =  9
      k10          =  10
      k11          =  11
      k12          =  12
      k13          =  13
c
c
c 1.2 Constants
c
      krtype       = 1
c
c
c 1.3 Direct access counting
c
      novatitl     = 20
      nvara1       = 5
      nvara2       = 10
      nvarb        = 13
c
c
c 1.4 Physical data
c
      ppnorm       =  btor**2/amu
      ffnorm       =  flim
c
c
c 1.5 Reopen the file in write mode
c
      call cdfopen(filencdf,kfileid,kwmode)
c
c
c 1.6 Extract and check the file information
c
      call cdfnqir(kfileid,ndimens,nvariabl,nglobat,kdims,kvars,
     &                                              katts,lstdim)
c
c
c
c 2.0 Write the data in NetCDF, mapout, mapdsk, and the ASCII file
c     The data conventions are modified as follows:
c     The poloidal angle is reversed starting on the outboard midplane and proceeding
c         clockwise
c         This requires rlabeling for all poloidally varying quantities and sign changes
c         for variables depending on theta or d/dtheta
c     The poloidal grid is at the half cell points
c         This is done by averaging in a separate loop after the quantity is calculated
c     Two additional periodic points are added at the end of the poloidal arrays
c     Psi arrays begin near the axis and include the plasma boundary point
c
      kv           = 0
      kvchar       = 0
      kvintg       = 0
      kvreal       = 0
      kvprfa       = 0
      kvprfb       = 0
      kvaray       = 0
      kfileid1     = kfileid
c
c
c 2.1  First variable:  1D character array title(nvdim0)
c
c      Initialize the loop varaiable data
        kv        = kv     + 1
        kvchar    = kvchar + 1
          kvv       = kv
          kvw       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim0               =  ndimf(ndimid(kvv,k1))
c
          read(title,  999) (varinpt0(kt),kt=1,nvdim0)
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D character array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          length              =  length0*nvdim0
          call cdwr1c(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                length,varinpt0)
c
c      Write the input data to the ASCII file
          write(kucdf,1000) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1010) kdtyp,kdset,kaset,nvarsize,kdim0
          write(kucdf,1020) (varinpt0(ktt),ktt=1,kdim0)
          write(kucdf,1030)
c
c      Write to the binary direct access file mapdsk
          nstdsk  = 1
          nfinsh  = length0*novatitl*record
          clength = length0
          call writcab(krtype,kudsk,nstdsk,nfinsh,clength, record,
     &                                            varinpt0,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  1,   'Error writing mapdsk character title'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c      Write to the binary direct access file mpout1
          nstnva  = 1
          nfinsh  = length0*novatitl*record
          clength = length0
          call writcab(krtype,kunva,nstnva,nfinsh,clength, record,
     &                                            varinpt0,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  2,   'Error writing mpout1 character title'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.2  Second variable: 1D character array (nvdim0)
c
c      Initialize the loop varaiable data
        kv        = kv     + 1
        kvchar    = kvchar + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim0               =  ndimf(ndimid(kvv,k1))
c
          read(datv,   999) (varinpt0(kt),kt=1,nvdim0)
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D character array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          length              =  length0*nvdim0
          call cdwr1c(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                length,varinpt0)
c
c      Write the input data to the ASCII file
          write(kucdf,1000) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1010) kdtyp,kdset,kaset,nvarsize,kdim0
          write(kucdf,1020) (varinpt0(ktt),ktt=1,kdim0)
          write(kucdf,1030)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = length0*record
          clength = length0
          call writcab(krtype,kudsk,nstdsk,nfinsh,clength, record,
     &                                            varinpt0,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  3,   'Error writing mapdsk character date '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c      Write to the binary direct access file mpout1
          nfinsh  = length0*record
          clength = length0
          call writcab(krtype,kunva,nstnva,nfinsh,clength, record,
     &                                            varinpt0,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  4,   'Error writing mpout1 character date '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.3  Third variable:  1D character array comment(nvdim0)
c
        kv        = kv     + 1
        kvchar    = kvchar + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim0               =  ndimf(ndimid(kvv,k1))
c
          read(comment,999) (varinpt0(kt),kt=1,nvdim0)
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D character array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          length              =  length0*nvdim0
          call cdwr1c(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                length,varinpt0)

c
c      Write the input data to the ASCII file
          write(kucdf,1000) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1010) kdtyp,kdset,kaset,nvarsize,kdim0
          write(kucdf,1020) (varinpt0(ktt),ktt=1,kdim0)
          write(kucdf,1030)
c
c                                    Data not written for the binary files mapdsk and mpout1
c
c
c 2.4  Fourth variable: Scalar integer   mth
c
        kv        = kv     + 1
        kvintg    = kvintg + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt1(k1)        =  mtht0
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar integer
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0i(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt1)
c
c      Write the input data to the ASCII file
          write(kucdf,1100) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1110) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1120) varinpt1(k1)
          write(kucdf,1130)
c
c      Store the variable for writing to the mapdsk and mpout files
          varinpta(k4)   = varinpt1(k1)
c
c
c 2.5  Fifth  variable: Scalar integer   nosurf
c
        kv        = kv     + 1
        kvintg    = kvintg + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt1(k1)        =  nosurf
c
c     Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar integer
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0i(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt1)
c
c      Write the input data to the ASCII file
          write(kucdf,1100) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1110) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1120) varinpt1(k1)
          write(kucdf,1130)
c
c      Store the variable for writing to the mapdsk and mpout files
          varinpta(k3)   = varinpt1(k1)
c
c
c 2.6  Sixth  variable: Scalar integer   remap
c
        kv        = kv     + 1
        kvintg    = kvintg + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt1(k1)        =  remap
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar integer
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0i(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt1)
c
c      Write the input data to the ASCII file
          write(kucdf,1100) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1110) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1120) varinpt1(k1)
          write(kucdf,1130)
c
c      Store the variable for writing to the mapdsk and mpout files
          varinpta(k1)   = nxeq
          varinpta(k2)   = nzeq
          varinpta(k5)   = varinpt1(k1)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = nvara1
          call writiab(krtype,kudsk,nstdsk,nfinsh,varinpta,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  5,   'Error writing mapdsk integer data   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c      Write to the binary direct access file mpout1
          nfinsh  = nvara1
          call writiab(krtype,kunva,nstnva,nfinsh,varinpta,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  6,   'Error writing mpout1 integer data   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.7  Seventh  variable: Scalar integer   mx
c
        kv        = kv     + 1
        kvintg    = kvintg + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt1(k1)        =  njrval
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar integer
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0i(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt1)
c
c      Write the input data to the ASCII file
          write(kucdf,1100) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1110) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1120) varinpt1(k1)
          write(kucdf,1130)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinpta(k1)   = varinpt1(k1)
c
c
c 2.8  Eighth  variable: Scalar integer   npsi
c
        kv        = kv     + 1
        kvintg    = kvintg + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt1(k1)        =  njgpsi
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar integer
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0i(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt1)
c
c      Write the input data to the ASCII file
          write(kucdf,1100) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1110) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1120) varinpt1(k1)
          write(kucdf,1130)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinpta(k2)   = varinpt1(k1)
c
c
c 2.9  Ninth  variable: Scalar integer   kb
c
        kv        = kv     + 1
        kvintg    = kvintg + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt1(k1)        =  njbtot
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar integer
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0i(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt1)
c
c      Write the input data to the ASCII file
          write(kucdf,1100) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1110) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1120) varinpt1(k1)
          write(kucdf,1130)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinpta(k3)   = varinpt1(k1)
c
c
c 2.10 Tenth  variable: Scalar real      xmin
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  xmin
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinptb(k3)   = varinpt2(k1)
c
c
c 2.11 Eleventh variable: Scalar real      Xmax
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  xmax
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.12 Twelfth variable: Scalar real      X0
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  rcnt
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinptb(k5)   = varinpt2(k1)
c
c
c 2.13 Thirteenth variable: Scalar real      Xmag
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  xma
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinptb(k4)   = varinpt2(k1)
c
c
c 2.14 Fourteenth  variable: Scalar real      zmin
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  zmin
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.15 Fifteenth variable: Scalar real      Zmax
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  zmax
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.16 Sixteenth variable: Scalar real      Z0
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  zcenter
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.17 Seventeenth variable: Scalar real      Zmag
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  zma
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.18 Eighteenth variable: Scalar real      B0
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  btor
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.19 19'th variable: Scalar real      Ip
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  totcur
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.20 20'th variable: Scalar real      Beta
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  betator
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinptb(k12)  = varinpt2(k1)
c
c
c 2.21 21'st variable: Scalar real      Betastar
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  betas
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.22 22'nd variable: Scalar real      BetaN
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  betan
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.23 23'rd variable: Scalar real      li
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  elli
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.24 24'th variable: Scalar real      PPF
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  ppfact
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c                                    Data not written to the binary direct access files mapdsk and mpout1
c
c
c 2.25 25'th variable: Scalar real      Upsiln
c
        kv        = kv     + 1
        kvreal    = kvreal + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
c
          varinpt2(k1)        =  upsilon
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: scalar real
          nndms               =  1
          nvstrt0(k1)         =  1
          nvdmns(k1)          =  nvdims(k1)
          call cdwr0d(kfileid1,kvarid0,nvstrt0,nvdmns,nndms,kdtyp,
     &                                                      varinpt2)
c
c      Write the input data to the ASCII file
          write(kucdf,1200) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1210) kdtyp,kdset,kaset,nvarsize
          write(kucdf,1220) varinpt2(k1)
          write(kucdf,1230)
c
c      Save the variable for writing to binary files mapdsk and mpout1
          varinptb(k13)  = varinpt2(k1)
c
c      Set the additional data for writing to the binary direct access
c      files mapdsk and mpout1
          varinptb(k1)   = 0.0
          varinptb(k2)   = 0.0
          varinptb(k6)   = p(jpsi1) / ppnorm
          varinptb(k7)   = 0.0
          varinptb(k8)   = twopi*(psimax - psilim)
          varinptb(k9)   = twopi*(psilim - psilim)
          varinptb(k10)  = psilim
          varinptb(k11)  = 0.0
c
c      Write to the binary direct access file mapdsk
          nfinsh  = nvarb
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinptb,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  7,   'Error writing mapdsk scalar data set'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c      Write to the binary direct access file mpout1
          nfinsh  = nvarb
          call writrab(krtype,kunva,nstnva,nfinsh,varinptb,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  8,   'Error writing mpout1 scalar data set'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c      Set the additional data for writing to the binary direct access
c      files mapdsk and mpout1
          varinpta(k4)   = 0
          varinpta(k5)   = 0
          varinpta(k6)   = 0
          varinpta(k7)   = 0
          varinpta(k8)   = 0
          varinpta(k9)   = 0
          varinpta(k10)  = 0
c
c      Write to the binary direct access file mapdsk
          nfinsh  = nvara2
          call writiab(krtype,kudsk,nstdsk,nfinsh,varinpta,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata',  9,   'Error writing mapdsk integer data   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c      Write to the binary direct access file mpout1
          nfinsh  = nvara2
          call writiab(krtype,kunva,nstnva,nfinsh,varinpta,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 10,   'Error writing mpout1 integer data   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.26 26'th  variable: 1D real array      psibig(nvdim1)
c                                          2pi*(psi - psilim)
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 100 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  twopi*(psilim - psilim)
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  twopi*(psival(jrev) - psilim)
          endif
  100     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c      Save the variable for writing to binary file mpout1
          nfinsht             =  kdim1
          do 110 jp           =  1,jpsi1
          jpp                 =  jp
          varinptb(jpp)       =  varinpt3(jpp)
  110     continue
c
c
c 2.27 27'th  variable: 1D real array      pa(nvdim1)
c                                         (mu0/B**2)*pressure
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 120 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  plim    / ppnorm
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  p(jrev) / ppnorm
          endif
  120     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 11,   'Error writing mpout1 real array p   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.28 28'th  variable: 1D real array      ppa(nvdim1)
c                                         (mu0/B**2)*pressure gradient
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 130 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  pplim    / ppnorm
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  pp(jrev) / ppnorm
          endif
  130     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 12,   'Error writing mpout1 real array pp  '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.29 29'th  variable: 1D real array      qa(nvdim1)
c                                          Safety Factor
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 140 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  qlim
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  qp(jrev)
          endif
  140     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 13,   'Error writing mpout1 real array q   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.30 30'th  variable: 1D real array      qpa(nvdim1)
c                                          Safety Factor gradient
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 150 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          varinpt3(jpp)       =  qprime(jfor)
  150     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 14,   'Error writing mpout1 real array qp  '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.31 31'st  variable: 1D real array      ga(nvdim1)
c                                          Toroidal field function
c                                         (normalized to 1.0 at psilim)
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          do 160 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  flim   /ffnorm
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  f(jrev)/ffnorm
          endif
  160     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 15,   'Error writing mpout1 real array g   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.32 32'nd  variable: 1D real array      gpa(nvdim1)
c                                          Toroidal field function gradient
c
        kv        = kv     + 1
        kvprfa    = kvprfa + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          do 170 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  (ffplim   /flim   ) / ffnorm
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  (ffp(jrev)/f(jrev)) / ffnorm
          endif
  170     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt3)
c
c      Write the input data to the ASCII file
          write(kucdf,1300) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1310) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1320) (varinpt3(jpp),jpp=1,kdim1)
          write(kucdf,1330)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1
          nfinshs = nfinsh
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 16,   'Error writing mpout1 real array gp  '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.32a Set the data for fb and write to the binary direct access file mpout1
c
c      Set the data for fb
          do 180 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  rcnt*flim/qlim       /ffnorm
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  rcnt*f(jrev)/qp(jrev)/ffnorm
          endif
  180     continue
c
c                                    Data not written to NetCDF
c
c                                    Data not written to the ASCII file
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
c
          nfinsh    = nfinshs
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 17,   'Error writing mpout1 real array fb  '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c 2.32b Set the data for fbp and write to the binary direct access file mpout1
c
          do 190 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)      =  rcnt*((ffplim/flim)*qlim           -
     &                                    qprime(jfor)*flim)          /
     &                                  ( ffnorm*qlim*qlim)
          elseif(jrev .gt. 0) then
             varinpt3(jpp)      =  rcnt*((ffp(jrev)/f(jrev))*qp(jrev) -
     &                                    qprime(jfor)*f(jrev))       /
     &                                  ( ffnorm*qp(jrev)*qp(jrev))
          endif
  190     continue
c
c                                    Data not written to NetCDF
c
c                                    Data not written to the ASCII file
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
c
          nfinsh    = nfinshs
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 18,   'Error writing mpout1 real array fbp '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.32c Set the data for psig and write to the binary direct access file mpout1
c
          do 200 jp           =  1,jpsi1
          jpp                 =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  sqrt((psilim - psimax) /
     &                                   (psilim - psimax))
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  sqrt((psival(jrev) - psimax) /
     &                                   (psilim       - psimax))
          endif
  200     continue
c
c                                    Data not written to NetCDF
c
c                                    Data not written to the ASCII file
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
c
          nfinsh    = nfinshs
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt3,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 27,   'Error writing mpout1 real array     '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.33 33'rd  variable: 1D Real array    xinf(nvdim2)
c                                        Plasma boundary r values
c
        kv        = kv     + 1
        kvprfb    = kvprfb + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 210 iv           =  2,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt4(ivp)       =  rsrf(ivv)
  210     continue
          varinpt4( k1  )     =  rsrf(1)
          varinpt4(mtht1)     =  varinpt4(1)
          varinpt4(mthet)     =  varinpt4(2)
c
          do 220 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt4(ivp0)
          varin1              =  varinpt4(ivp1)
          varinpt4(ivp0)      = +0.5*(varin0 + varin1)
  220     continue
          varinpt4(mthet)     =  varinpt4(k2)
          
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt4)
c
c      Write the input data to the ASCII file
          write(kucdf,1400) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1410) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1420) (varinpt4(ivp),ivp=1,kdim1)
          write(kucdf,1430)
c
c      Write to the binary direct access file mapdsk
c      Note: for this the array length is only mthet and not the full dimension
          nfinsh  = mthet
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt4,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 19,   'Error writing mapdsk real data xinf '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.34 34'th  variable: 1D Real array    zinf(nvdim2)
c                                        Plasma boundary z values
c
        kv        = kv     + 1
        kvprfb    = kvprfb + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
c
          do 230 iv           =  2,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt4(ivp)       =  zsrf(ivv)
  230     continue
          varinpt4( k1  )     =  zsrf(1)
          varinpt4(mtht1)     =  varinpt4(k1)
          varinpt4(mthet)     =  varinpt4(k2)
c
          do 240 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt4(ivp0)
          varin1              =  varinpt4(ivp1)
          varinpt4(ivp0)      = +0.5*(varin0 + varin1)
  240     continue
          varinpt4(mthet)     =  varinpt4(k2)
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 1D real array
          nndms               =  nvarsize
          nvstrt(k1)          =  1
          call cdwr1d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt4)
c
c      Write the input data to the ASCII file
          write(kucdf,1400) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1410) kdtyp,kdset,kaset,nvarsize,kdim1
          write(kucdf,1420) (varinpt4(ivp),ivp=1,kdim1)
          write(kucdf,1430)
c
c      Write to the binary direct access file mapdsk
c      Note: for this the array length is only mthet and not the full dimension
          nfinsh  = mthet
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt4,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 20,   'Error writing mapdsk real data zinf '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.34a Write additional data psibig to the binary direct access file mapdsk
c                                    Data was calculated previously and written in the NetCDF file
c       Note: for this the array length is only nosurf and not the full dimension
c
          nfinsh  = nosurf
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinptb,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 21,   'Error writing mapdsk real data psibg'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.35 35'th  variable: 2D real array    xa(nvdim3,nvdim1)
c                                        Grid r values
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 320 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 300 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  rcell(jfor,ivv)
  300     continue
          varinpt5(k1,   jpp) =  rcell(jfor,1)
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 310 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  310     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  320     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 325 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  325     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1*kdim2
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 22,   'Error writing mpout1 real array xa  '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.36 36'th  variable: 2D real array    za(nvdim3,nvdim1)
c                                        Grid z values
c                                        Set to zcell - zma
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 350 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 330 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  zcell(jfor,ivv) - zma
  330     continue
          varinpt5(k1,   jpp) =  zcell(jfor,1  ) - zma
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 340 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  340     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  350     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 355 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  355     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1*kdim2
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 23,   'Error writing mpout1 real array za  '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.37 37'th  variable: 2D real array    xpth(nvdim3,nvdim1)
c                                        dr/dtheta
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 380 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 360 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  0.5*f22  (jfor,ivv)*
     &                               f3   (jfor,ivv)*rcell(jfor,ivv)
  360     continue
          varinpt5(k1,   jpp) =  0.5*f22  (jfor,1  )*
     &                               f3   (jfor,1  )*rcell(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 370 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  370     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  380     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 385 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  385     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1*kdim2
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 24,   'Error writing mpout1 real array xpth'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.38 38'th  variable: 2D real array    zpth(nvdim3,nvdim1)
c                                        dz/dtheta
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 420 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 400 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  dpsdr(jfor,ivv) *
     &                          (f13  (jfor,ivv)/rcell(jfor,ivv))
  400     continue
          varinpt5(k1,   jpp) =  dpsdr(jfor,1  ) *
     &                          (f13  (jfor,1  )/rcell(jfor,1  ))
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 410 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  410     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  420     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 425 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  425     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1*kdim2
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 25,   'Error writing mpout1 real array zpth'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.39 39'th  variable: 2D real array    xpsi(nvdim3,nvdim1)
c                                        dr/dpsi[constant theta]
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 450 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 430 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  0.5*(f21  (jfor,ivv)   + 
     &                                f22  (jfor,ivv)*f20  (jfor,ivv))*
     &                                f3   (jfor,ivv)*rcell(jfor,ivv)
  430     continue
          varinpt5(k1,   jpp) =  0.5*(f21  (jfor,1  )   + 
     &                                f22  (jfor,1  )*f20  (jfor,1  ))*
     &                                f3   (jfor,1  )*rcell(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 440 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  440     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  450     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 455 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  455     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1*kdim2
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 26,   'Error writing mpout1 real array xpsi'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.40 40'th  variable: 2D real array    zpsi(nvdim3,nvdim1)
c                                        dz/dpsi [constant theta]
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 480 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 460 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =   dpsdz(jfor,ivv) /
     &                           (f9   (jfor,ivv)*f10  (jfor,ivv))
     &                        +   dpsdr(jfor,ivv)*f20  (jfor,ivv)*
     &                            f13  (jfor,ivv)/rcell(jfor,ivv)
  460     continue
          varinpt5(k1,   jpp) =   dpsdz(jfor,1  ) /
     &                           (f9   (jfor,1  )*f10  (jfor,1  ))
     &                        +   dpsdr(jfor,1  )*f20  (jfor,1  )*
     &                            f13  (jfor,1  )/rcell(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 470 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  470     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  480     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 485 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  485     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access file mapdsk
c
c      Write to the binary direct access file mpout1
          nfinsh  = kdim1*kdim2
          call writrab(krtype,kunva,nstnva,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 27,   'Error writing mpout1 real array zpsi'
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c
c 2.41 41'st  variable: 2D real array    grpssq(nvdim3,nvdim1)
c                                       [Grad(psi)]**2
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 520 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 500 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  f9 (jfor,ivv)*f10(jfor,ivv)
  500     continue
          varinpt5(k1,   jpp) =  f9 (jfor,1  )*f10(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 510 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  510     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  520     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 525 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  525     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 28,   'Error writing mapdsk array grpssq   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.41a Write additional data xsq to the binary direct access file mapdsk
c
          do 550 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 530 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  rcell(jfor,ivv)*rcell(jfor,ivv)
  530     continue
          varinpt5(k1,   jpp) =  rcell(jfor,1  )*rcell(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 540 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  540     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  550     continue
c
c                                    Data not written to NetCDF
c
c                                    Data not written to the ASCII file
c
c      Write to the binary direct access file mapdsk
          nfinsh  = nfinshs
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 29,   'Error writing mapdsk array xsq      '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.42 42'nd  variable: 2D real array    grthsq(nvdim3,nvdim1)
c                                       [Grad(theta)]**2
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 580 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 560 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  (   f20(jfor,ivv)*f20(jfor,ivv)*
     &                               f9 (jfor,ivv)*f10(jfor,ivv))
     &                        + 1.0/(f13(jfor,ivv)*f9 (jfor,ivv))
  560     continue
          varinpt5(k1,   jpp) =  (   f20(jfor,1  )*f20(jfor,1  )*
     &                               f9 (jfor,ivv)*f10(jfor,1  ))
     &                        + 1.0/(f13(jfor,1  )*f9 (jfor,1  ))
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 570 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  570     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  580     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 585 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  585     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 30,   'Error writing mapdsk array grthsq   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.43 43'rd  variable: 2D real array    grpsth(nvdim3,nvdim1)
c                                        Grad(psi).Grad(theta)
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 620 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 600 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  -f20(jfor,ivv)*
     &                            f9 (jfor,ivv)*f10(jfor,ivv)
  600     continue
          varinpt5(k1,   jpp) =  -f20(jfor,1  )*
     &                            f9 (jfor,1  )*f10(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 610 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  610     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  620     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 625 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  625     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 31,   'Error writing mapdsk array grpsth   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.44 44'th  variable: 2D real array    gptdth(nvdim3,nvdim1)
c                                        d/dtheta(grad(psi).grad(theta)) [constant psi]
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 650 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 630 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  +f18(jfor,ivv)
  630     continue
          varinpt5(k1,   jpp) =  +f18(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 640 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  640     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  650     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 655 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  655     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 32,   'Error writing mapdsk array gptdth   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.44a Write additional data xsqdps to the binary direct access file mapdsk
c
          do 680 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 660 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  1.0*(f21  (jfor,ivv)   +
     &                                f22  (jfor,ivv)*f20  (jfor,ivv))*
     &                                f3   (jfor,ivv)*
     &                                rcell(jfor,ivv)*rcell(jfor,ivv)
  660     continue
          varinpt5(k1,   jpp) =  1.0*(f21  (jfor,1  )   +
     &                                f22  (jfor,1  )*f20  (jfor,1  ))*
     &                                f3   (jfor,1  )*
     &                                rcell(jfor,1  )*rcell(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 670 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  670     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  680     continue
c
c                                    Data not written to NetCDF
c
c                                    Data not written to the ASCII file
c
c      Write to the binary direct access file mapdsk
          nfinsh  = nfinshs
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 33,   'Error writing mapdsk array xsqdps   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.45 45'th  variable: 2D real array    gpsdth(nvdim3,nvdim1)
c                                        d/theta(grad(psi)**2) [constant psi]
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 720 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 700 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  f17  (jfor,ivv)
  700     continue
          varinpt5(k1,   jpp) =  +f17  (jfor,1)
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 710 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  710     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  720     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 725 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  725     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 34,   'Error writing mapdsk array gpsdth   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.45a Write additional data xsqdth to the binary direct access file mapdsk
c
          do 750 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 730 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  1.0*f22  (jfor,ivv)*
     &                               f3   (jfor,ivv)*
     &                               rcell(jfor,ivv)*rcell(jfor,ivv)
  730     continue
          varinpt5(k1,   jpp) =  1.0*f22  (jfor,1  )*
     &                               f3   (jfor,1  )*
     &                               rcell(jfor,1  )*rcell(jfor,1  )
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 740 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  740     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  750     continue
c
c                                    Data not written to NetCDF
c
c                                    Data not written to the ASCII file
c
c      Write to the binary direct access file mapdsk
          nfinsh  = nfinshs
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 35,   'Error writing mapdsk array xsqdth   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.46 46'th  variable: 2D real array    xjacob(nvdim3,nvdim1)
c                                        Jacobian
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 780 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 760 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  f13  (jfor,ivv)
  760     continue
          varinpt5(k1,   jpp) =  +f13  (jfor,1)
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 770 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  770     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  780     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 785 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  785     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 36,   'Error writing mapdsk array xjacob   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.47 47'th  variable: 2D real array    xjprym(nvdim3,nvdim1)
c                                        d/dpsi(Jacobian) [constant theta]
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 820 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 800 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          varinpt5(ivp,jpp)   =  +f14    (jfor,ivv)
  800     continue
          varinpt5(k1,   jpp) =  +f14  (jfor,1)
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 810 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = +0.5*(varin0 + varin1)
  810     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  820     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 825 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  825     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 37,   'Error writing mapdsk array xjprym   '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.48 48'th  variable: 2D real array    delta(nvdim3,nvdim1)
c                                        chipest - chiarcl
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 850 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 830 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          if    (igrid .eq. 0) then
            varinpt5(ivp,jpp) =  chipest(jfor,ivv) - chiarcl(jfor,ivv)
          elseif(igrid .eq. 1) then
            varinpt5(ivp,jpp) =  0.0
          endif
  830     continue
          if    (igrid .eq. 0) then
            varinpt5(k1,   jpp) =  chipest(jfor,1)   - chiarcl(jfor,1)
          elseif(igrid .ne. 0) then
            varinpt5(k1,   jpp) =  0.0
          endif
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 840 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  840     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  850     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 855 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  855     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 38,   'Error writing mapdsk array delta    '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.49 49'th  variable: 2D real array    qdelp(nvdim3,nvdim1)
c                                        d/dpsi(q*delta)[const theta]
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 880 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          if    (jrev .eq. 0) then
             varinpt3(jpp)       =  qlim
          elseif(jrev .gt. 0) then
             varinpt3(jpp)       =  qp(jrev)
          endif
          do 860 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          if    (igrid .eq. 0) then
            varinpt5(ivp,jpp)   =  qprime(jfor)*
     &                            (chipest(jfor,ivv)-chiarcl(jfor,ivv))
     &                          +  varinpt3(jpp)*
     &                            (f26    (jfor,ivv)-f25    (jfor,ivv)*
     &                                               f27    (jfor,ivv))
          elseif(igrid .ne. 0) then
            varinpt5(ivp,jpp)   =  0.0
          endif
  860     continue
          if    (igrid .eq. 0) then
            varinpt5(k1,   jpp) =  qprime(jfor)*
     &                            (chipest(jfor,1  )-chiarcl(jfor,1  ))
     &                          +  varinpt3(jpp)*
     &                            (f26    (jfor,1  )-f25    (jfor,1  )*
     &                                               f27    (jfor,ivv))
          elseif(igrid .ne. 0) then
            varinpt5(k1,   jpp) =  0.0
          endif
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 870 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  870     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  880     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 885 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  885     continue
          write(kucdf,1540)
c
c      Write to the binary direct access file mapdsk
          nfinsh  = kdim1*kdim2
          nfinshs = nfinsh
          call writrab(krtype,kudsk,nstdsk,nfinsh,varinpt5,kerr)
          if(kerr .ne. 0) then
             kercd     = kerr
             call abortjob
     &        ('writdata', 39,   'Error writing mapdsk array qdelp    '
     &        ,'kvw     ', kvw,      'kerr    ', kerr,     -1)
          endif
c
c                                    Data not written to the binary direct access file mpout1
c
c
c 2.50 50'th  variable: 2D real array    theta(nvdim3,nvdim1)
c                                        Poloidal coordinate
c
        kv        = kv     + 1
        kvaray    = kvaray + 1
          kvv       = kv
          kvarid0   = kvarid (kvv)
          kdtyp     = ndtype (kvv)
          kdset     = ndset  (kvv)
          kaset     = naset  (kvv)
          varnamev  = varname(kvv)
          nvarsize  = varsize(kvv)
c
c      Set the data
          namelen             =  lenname
          kdim1               =  ndimf(ndimid(kvv,k1))
          kdim2               =  ndimf(ndimid(kvv,k2))
c
          do 920 jp           =  1,jpsi1
          jpp                 =  jp
          jfor                =  jp
          jrev                =  jpsi - jp + 1
          do 900 iv           =  1,itht
          ivp                 =  iv
          ivv                 =  itht - iv + 2
          if    (igrid .eq. 0) then
            varinpt5(ivp,jpp)   =  chiarcl(jfor,ivv)
          elseif(igrid .eq. 1) then
            varinpt5(ivp,jpp)   =  chipest(jfor,ivv)
          else
            varinpt5(k1,   jpp) =  chihaml(jfor,ivv)
          endif
  900     continue
          if    (igrid .eq. 0) then
            varinpt5(k1,   jpp) =  chiarcl(jfor,1  )
          elseif(igrid .eq. 1) then
            varinpt5(k1,   jpp) =  chipest(jfor,1  )
          else
            varinpt5(k1,   jpp) =  chihaml(jfor,1  )
          endif
          varinpt5(mtht1,jpp) =  varinpt5(k1,jpp)
          varmthet            =  varinpt5(k2,jpp)
c
          do 910 iv           =  1,mtht1
          ivp0                =  iv
          ivp1                =  iv + 1
          varin0              =  varinpt5(ivp0,jpp)
          if(ivp0 .lt. mtht1) varin1  =  varinpt5(ivp1,jpp)
          if(ivp0 .eq. mtht1) varin1  =  varmthet
          varinpt5(ivp0, jpp) = -0.5*(varin0 + varin1)
  910     continue
c
c      Add the additional periodic point if there is additional space 
          if(mthet .le. kdim1) varinpt5(mthet,jpp) =  varinpt5(k2,jpp)
  920     continue
c
c      Extract the variable ID and identifying information and attributes
          call cdvarid(kfileid1,kvarid0,kdset, kaset, varnamev,
     &                 namelen, nvdms,  nvatts,nvdmid,nvdims,  ndimens)
c
c      Write the data to NetCDF: 2D real array
          nndms               =  nvarsize
          nvstrt (k1)         =  1
          nvstrt (k2)         =  1
          call cdwr2d(kfileid1,kvarid0,nvstrt, nvdims,nndms,kdtyp,
     &                                                      varinpt5)
c
c      Write the input data to the ASCII file
          write(kucdf,1500) varnamev,longname(kvv)
     &                     ,kvarid0
          write(kucdf,1510) kdtyp,kdset,kaset,nvarsize,kdim1,kdim2
          do 925 jp  = 1,kdim2
          jpp        = jp
          write(kucdf,1520) jpp
          write(kucdf,1530) (varinpt5(ivp,jpp),ivp=1,kdim1)
  925     continue
          write(kucdf,1540)
c
c                                    Data not written to the binary direct access files mpout1 and mapdsk
c
c
c 2.50 Check the counting of variables
c
      nvariab    = nvariabl
      kvariab    = kv
      kvarchar   = kvchar
      kvarintg   = kvintg
      kvar0drl   = kvreal
      kvar1drr   = kvprfa
      kvar1drp   = kvprfb
      kvar2drr   = kvaray
c
      if(kvariab  .ne. nvariab ) then
        call abortjob
     &        ('writdata', 40,   'Miscounted variables being written  '
     &        ,'kvariab ', kvariab,  'nvariab ', nvariab,  -1)
      endif
c
      if(kvarchar .ne. nvarchar) then
        call abortjob
     &        ('writdata', 41,   'Miscounted # of character variables '
     &        ,'kvarchar', kvarchar, 'nvarchar', nvarchar, -1)
      endif
c
      if(kvarintg .ne. nvarintg) then
        call abortjob
     &        ('writdata', 42,   'Miscounted integer scalar variables '
     &        ,'kvarintg', kvarintg, 'nvarintg', nvarintg, -1)
      endif
c
      if(kvar0drl .ne. nvar0drl) then
        call abortjob
     &        ('writdata', 43,   'Miscounted real    scalar variables '
     &        ,'kvar0drl', kvar0drl, 'nvar0drl', nvar0drl, -1)
      endif
c
      if(kvar1drr .ne. nvar1drr) then
        call abortjob
     &        ('writdata', 44,   'Miscounted real 1D array  variables '
     &        ,'kvar1drr', kvar1drr, 'nvar1drr', nvar1drr, -1)
      endif
c
      if(kvar1drp .ne. nvar1drp) then
        call abortjob
     &        ('writdata', 45,   'Miscounted real 1D array  variables '
     &        ,'kvar1drp', kvar1drp, 'nvar1drp', nvar1drp, -1)
      endif
c
      if(kvar2drr .ne. nvar2drr) then
        call abortjob
     &        ('writdata', 46,   'Miscounted real 2D array  variables '
     &        ,'kvar2drr', kvar2drr, 'nvar2drr', nvar2drr, -1)
      endif
c
c
c
c 3.0 Return and end
c
c 3.1 Close the file
c
      call cdfclos(kfileid1)
c
c
c 3.2 Return
c
      return
c
 999  format(160a1)
 1000 format(2x,'For variable:',1x,a8,4x,'(',a26,')',2x,'ID = ',i2
     &     ,/,5x,'INPUT:')
 1010 format(1x,'Type     = ',i1,2x,'kdset = ',i1,2x,'kaset  = ',i1
     &      ,2x,'nvarsize = ',i1,2x,'kdim0 = ',i5)
 1020 format(1x,20a1)
 1030 format(/)
 1100 format(2x,'For variable:',1x,a8,4x,'(',a26,')',2x,'ID = ',i2
     &     ,/,5x,'INPUT:')
 1110 format(1x,'Type     = ',i1,2x,'kdset = ',i1,2x,'kaset  = ',i1
     &      ,2x,'nvarsize = ',i1)
 1120 format(1x,i5)
 1130 format(/)
 1200 format(2x,'For variable:',1x,a8,4x,'(',a26,')',2x,'ID = ',i2
     &     ,/,5x,'INPUT:')
 1210 format(1x,'Type     = ',i1,2x,'kdset = ',i1,2x,'kaset  = ',i1
     &      ,2x,'nvarsize = ',i1)
 1220 format(1x,e12.5)
 1230 format(/)
 1300 format(2x,'For variable:',1x,a8,4x,'(',a26,')',2x,'ID = ',i2
     &     ,/,5x,'INPUT:')
 1310 format(1x,'Type     = ',i1,2x,'kdset = ',i1,2x,'kaset  = ',i1
     &      ,2x,'nvarsize = ',i1,2x,'kdim1 = ',i5)
 1320 format(10(1x,e12.5))
 1330 format(/)
 1400 format(2x,'For variable:',1x,a8,4x,'(',a26,')',2x,'ID = ',i2
     &     ,/,5x,'INPUT:')
 1410 format(1x,'Type     = ',i1,2x,'kdset = ',i1,2x,'kaset  = ',i1
     &      ,2x,'nvarsize = ',i1,2x,'kdim1 = ',i5)
 1420 format(10(1x,e12.5))
 1430 format(/)
 1500 format(2x,'For variable:',1x,a8,4x,'(',a26,')',2x,'ID = ',i2
     &     ,/,5x,'INPUT:')
 1510 format(1x,'Type     = ',i1,2x,'kdset = ',i1,2x,'kaset  = ',i1
     &      ,2x,'nvarsize = ',i1,2x,'kdim1 = ',i5,2x,'kdim2 = ',i5)
 1520 format(1x,'jp = ',i5)
 1530 format(10(1x,e12.5))
 1540 format(/)
      end
      subroutine writcab(krtype,kudsk,nstart,nlength,clength,
     &                                record,array,  kerr)
c
c  Write character data to binary file either in sequential or direct access
c  Charcter(clength) input data is converted to character(record) for writing
c  The record length is assumed to be 8 bytes corresponding to character*8
c
c  INPUT:   krtype, kudsk, nstart, nlength, array
c  OUTPUT:  kerr
c
c
c Local type declarations:
c
      integer   ierr,    iw,      iwr
      integer   numchar, numrec,  nextra,   irec
      integer   naddrs,  naddrf,  iaddrs,   iarray
c
      integer   kerr
      integer   krtype,  kudsk,   nstart,   nlength
      integer   clength, record
      character(len=clength)        array (nlength)
      character(len=record )        arrayp
c
c
c
c 1.0 Initialization
c
c 1.1 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c 1.2 Set the number of records
c
      numchar   = record/ clength
      numrec    = nlength/numchar
c
c
c 1.3 Check that the input character length and record length are compatable
c
      if(numchar*clength .ne. record) then
        kerr     = -4
        return
      endif
c
c
c 1.4 Set any extra character required
c
      if(numrec*numchar .eq. nlength) nextra = 0
      if(numrec*numchar .ne. nlength) nextra = 1
c
c
c
c 2.0 Write the file data one record at a time
c     After testing the sequential option can be taken out and replaced by a 
c     single implied loop read
c
c 2.1 Write the data
c
      naddrs    = nstart
      naddrf    = naddrs + numrec + nextra - 1
c
      do 100 iw = 1,numrec
      iwr       = iw
      iaddrs    = naddrs + iwr -1
      iarray    = (iwr-1)*record
      write(arrayp,1000) (array(iarray+irec),irec=1,record)
c
c     Sequential access
      if    (krtype .eq. 0) then
        write(kudsk,err = 200) arrayp
c
c     Direct access
      elseif(krtype .eq. 1) then
        write(kudsk, rec = iaddrs, err = 200) arrayp
      endif
c
      ierr          = iwr
  100 continue
c
c
c 2.1 Write the last piece
c
      if(nextra .eq. 1) then
        iaddrs    = naddrs + numrec
        iarray    = numrec*record
        write(arrayp,1000) (array(iarray+irec),irec=1,record)
c
c     Sequential access
        if    (krtype .eq. 0) then
          write(kudsk,err = 200) arrayp
c
c     Direct access
        elseif(krtype .eq. 1) then
          write(kudsk, rec = iaddrs, err = 200) arrayp
        endif
c
        ierr          = numrec + 1
      endif
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. numrec+nextra) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
 1000 format(8a1)
      end
      subroutine writiab(krtype,kudsk,nstart,nlength,array,kerr)
c
c  Write integer data to binary file either in sequential or direct access
c  Integer*4 input data is first converted to integer*8 for writing
c  The record length is assumed to be 8 bytes corresponding to integer*8
c
c  INPUT:   krtype, kudsk, nstart, nlength, array
c  OUTPUT:  kerr
c
c
c Local type declarations:
c
      integer   ierr,    iw,      iwr
      integer   naddrs,  naddrf,  iaddrs,   iarray
      integer*8 arrayp
c
      integer   kerr
      integer   krtype,  kudsk,   nstart,   nlength
      integer*4 array(nlength)
c
c
c
c 1.0 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c
c 2.0 Write the file data one item at a time
c     After testing the sequential option can be taken out and replaced by a 
c     single implied loop read
c
      naddrs    = nstart
      naddrf    = naddrs + nlength - 1
c
      do 100 iw = 1,nlength
      iwr       = iw
      iaddrs    = naddrs + iwr -1
      iarray    = iwr
      arrayp    = array(iarray)
c
c     Sequential access
      if    (krtype .eq. 0) then
        write(kudsk,err = 200) arrayp
c
c     Direct access
      elseif(krtype .eq. 1) then
        write(kudsk, rec = iaddrs, err = 200) arrayp
      endif
c
      ierr          = iwr
  100 continue
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. nlength) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine writrab(krtype,kudsk,nstart,nlength,array,kerr)
c
c  Write real numbers to binary file either in sequential or direct access
c  Real*8 input data is first converted to real for writing
c  The record length is assumed to be 8 bytes corresponding to real*8
c  
c
c  INPUT:   krtype, kudsk, nstart, nlength, array
c  OUTPUT:  kerr
c
c
c Local type declarations:
c
      integer   ierr,    iw,      iwr
      integer   naddrs,  naddrf,  iaddrs,   iarray
c
      real      arrayp
c
      integer   kerr
      integer   krtype,  kudsk,   nstart,   nlength
      real*8    array(nlength)
c
c
c
c 1.0 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c
c 2.0 Write the file data one item at a time
c     After testing the sequential option can be taken out and replaced by a 
c     single implied loop read
c
      naddrs    = nstart
      naddrf    = naddrs + nlength - 1
c
      do 100 iw = 1,nlength
      iwr       = iw
      iaddrs    = naddrs + iwr -1
      iarray    = iwr
      arrayp    = array(iarray)
c
c     Sequential access
      if    (krtype .eq. 0) then
        write(kudsk,err = 200) arrayp
c
c     Direct access
      elseif(krtype .eq. 1) then
        write(kudsk, rec = iaddrs, err = 200) arrayp
      endif
c
      ierr          = iwr
  100 continue
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. nlength) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine readcab(krtype,kudsk,nstart,nlength,clength,
     &                                record,array,  kerr)
c
c  Read  character data from binary file either in sequential or direct access
c  Charcter(clength) input data is converted to character(record) for writing
c  The record length is assumed to be 8 bytes corresponding to character*8
c
c  INPUT:   krtype, kudsk, nstart, nlength
c  OUTPUT:  kerr,   array
c
c
c Local type declarations:
c
      integer   ierr,    ir,      ird
      integer   numchar, numrec,  nextra,   irec
      integer   naddrs,  naddrf,  iaddrs,   iarray
c
      integer   kerr
      integer   krtype,  kudsk,   nstart,   nlength
      integer   clength, record
      character(len=clength)      array(nlength)
      character(len=record)       arrayp
c
c
c
c 1.0 Initialization
c
c 1.1 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c 1.2 Set the number of records
c
      numchar   = record/ clength
      numrec    = nlength/numchar
c
c
c 1.3 Check that the input character length and record length are compatable
c
      if(numchar*clength .ne. record) then
        kerr     = -4
        return
      endif
c
c
c 1.4 Set any extra character required
c
      if(numrec*numchar .eq. nlength) nextra = 0
      if(numrec*numchar .ne. nlength) nextra = 1
c
c
c
c 2.0 Read  the file data one item at a time
c     After testing the sequential option can be taken out and replaced by a 
c     single implied loop read
c
      naddrs    = nstart
      naddrf    = naddrs + numrec + nextra - 1
c
      do 100 ir = 1,numrec
      ird       = ir
      iaddrs    = naddrs + ird - 1
      iarray    = (ird-1)*record
c
c     Sequential access
      if    (krtype .eq. 0) then
        read (kudsk,err = 200) arrayp
c
c     Direct access
      elseif(krtype .eq. 1) then
        read (kudsk, rec = iaddrs, err = 200) arrayp
      endif
c
      read (arrayp,1000) (array(iarray+irec),irec=1,record)
 1000 format(8a1)
      ierr          = ird
  100 continue
c
c
c 2.1 Read the last piece
c
      if(nextra .eq. 1) then
        iaddrs    = naddrs + numrec
        iarray    = numrec*record
c
c     Sequential access
        if    (krtype .eq. 0) then
          read (kudsk,err = 200) arrayp
c
c     Direct access
        elseif(krtype .eq. 1) then
          read (kudsk, rec = iaddrs, err = 200) arrayp
        endif
c
        read (arrayp,1000) (array(iarray+irec),irec=1,record)
        ierr          = numrec + 1
      endif
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. numrec+nextra) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine readiab(krtype,kudsk,nstart,nlength,array,kerr)
c
c  Read  integer data from binary file either in sequential or direct access
c  Integer data is converted to integer*4 for output
c  The record length is assumed to be 8 bytes corresponding to integer*8
c
c  INPUT:   krtype, kudsk, nstart, nlength
c  OUTPUT:  kerr,   array
c
c
c Local type declarations:
c
      integer   ierr,    ir,      ird
      integer   naddrs,  naddrf,  iaddrs,   iarray
      integer*8 arrayp
c
      integer   kerr
      integer   krtype,  kudsk,   nstart,   nlength
      integer*4 array(nlength)
c
c
c
c 1.0 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c
c 2.0 Read  the file data one item at a time
c     After testing the sequential option can be taken out and replaced by a 
c     single implied loop read
c
      naddrs    = nstart
      naddrf    = naddrs + nlength - 1
c
      do 100 ir = 1,nlength
      ird       = ir
      iaddrs    = naddrs + ird -1
      iarray    = ird
c
c     Sequential access
      if    (krtype .eq. 0) then
        read (kudsk,err = 200) arrayp
c
c     Direct access
      elseif(krtype .eq. 1) then
        read (kudsk, rec = iaddrs, err = 200) arrayp
      endif
c
      array(iarray) = arrayp
      ierr          = ird
  100 continue
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. nlength) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine readrab(krtype,kudsk,nstart,nlength,array,kerr)
c
c  Read  real data from binary file either in sequential or direct access
c  Real data is converted to real*8 for output
c  The record length is assumed to be 8 bytes corresponding to real*8
c
c  INPUT:   krtype, kudsk, nstart, nlength
c  OUTPUT:  array,  kerr
c
c
c Local type declarations:
c
      integer   ierr,    ir,      ird
      integer   naddrs,  naddrf,  iaddrs,   iarray
c
      real*8    arrayp
c
      integer   kerr
      integer   krtype,  kudsk,   nstart,   nlength
      real*8    array(nlength)
c
c
c
c 1.0 Set error flags
c
      kerr      = 0
      ierr      = 0
c
      if(krtype .ne. krtype*krtype) then
        krtype   =  0
        kerr     = -1
        return
      endif
c
      if(nstart .le. 0) then
        nstart   =  1
        kerr     = -2
        return
      endif
c
      if(nlength .le. 0) then
        nlength  =  1
        kerr     = -3
        return
      endif
c
c
c
c 2.0 Read  the file data one item at a time
c     After testing the sequential option can be taken out and replaced by a 
c     single implied loop read
c
      naddrs    = nstart
      naddrf    = naddrs + nlength - 1
c
      do 100 ir = 1,nlength
      ird       = ir
      iaddrs    = naddrs + ird -1
      iarray    = ird
c
c     Sequential access
      if    (krtype .eq. 0) then
        read (kudsk,err = 200) arrayp
c
c     Direct access
      elseif(krtype .eq. 1) then
        read (kudsk, rec = iaddrs, err = 200) arrayp
      endif
c
      array(iarray) = arrayp
      ierr          = ird
  100 continue
c
c
c
c 3.0 Handle errors
c
  200 continue
      if(ierr .ne. nlength) then
        kerr = +ierr
      endif
c
c
c
c 4.0 Reset the start address
c
      nstart  = naddrf + 1
c
c
c
c 5.0 Return and end
c
      return
      end
      subroutine cdvarid(kfileid1,kvarid0,kdset,kaset,varname1,
     &                   namlen,  nvdms,nvatts,nvdmid,nvdims,ndim0)
c
c Extract the variable ID and identifying information and attributes
c from the NetCDF file
c
c INPUT:  kfileid1,kvarid0,kdset,  kaset, varname1, namlen
c OUTPUT: nvdms,   nvatts, nvdmid(nvdms), nvdims(nvdms)
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
c
c Local type declarations:
c
      integer*4     kvarid1,  kinvstat, vartypv
      integer*4     kindstat
      integer*4     kd,       kdd,      kdid,     nmdims
      integer*4     kfileid1, kvarid0,  kdset,    kaset,  namlen
      integer*4     nvdms,    nvatts,   nvdmid,   nvdims
      integer*4     ndim0
c
      character*16  dmname
      character*80  errstrng
c
      character(len=namlen)  varname1
      character(len=namlen)  varname0
c
      dimension nvdmid(ndim0),nvdims(ndim0)
c
c
c
c 1.0 Initialization
c
c
c 1.2 Check for input errors
c
      if(ndim0 .le. 0) then
         call abortcdf
     &        ('cdvarid ',  1,   'Input dimension of nvdims(ndim0)zero'
     &        ,'kfileid1', kfileid1, 'ndim0   ', ndim0,    -1)
      endif
c
c
c
c 1.0 Extract the variable ID
c
c 1.1 Extract the ID
c
c     NF90_INQ_VARID INPUT:  kfileid1, varname1
c                    OUTPUT: kinvstat, kvarid1
c
         kinvstat   = NF90_INQ_VARID(kfileid1,varname1,kvarid1)
c
c
c 1.2 Check for errors
c
      if(kinvstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kinvstat)
         call abortcdf
     &        ('cdvarid ',  2,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kinvstat', kinvstat, -1)
      endif
c
      if(kvarid1  .ne.  kvarid0) then
         call abortcdf
     &        ('cdvarid ',  3,   'NetCDF variable ID is not correct   '
     &        ,'kfileid1', kfileid1, 'kvarid1 ', kvarid1,  -1)
      endif
c
c
c
c 2.0 Extract the variable identifying information and attributes
c
c 2.1 Extract the information
c
c     NF90_INQUIRE_VARIABLE INPUT:  kfileid1, kvarid0
c                           OUTPUT: kinvstat, varname0, vartypv, nvdms,
c                                                       nvdmid,  nvatts

      kinvstat  = NF90_INQUIRE_VARIABLE(kfileid1,kvarid0,varname0,
     &                                  vartypv, nvdms,  nvdmid,
     &                                                   nvatts)
c
c
c 2.2 Check for errors
c
      if(kinvstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kinvstat)
         call abortcdf
     &        ('cdvarid ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kinvstat', kinvstat, -1)
      endif
c
      if(nvdms    .ne.    kdset) then
         call abortcdf
     &        ('cdvarid ',  5,   'NetCDF variable dimension  incorrect'
     &        ,'kvarid0 ', kvarid0,  'nvdms   ', nvdms,    -1)
      endif
c
      if(nvatts    .ne.   kaset) then
         call abortcdf
     &        ('cdvarid ',  6,   'NetCDF variable attributes incorrect'
     &        ,'kvarid0 ', kvarid0,  'nvatts  ', nvatts,   -1)
      endif
c
      if(nvdms    .gt.    ndim0) then
         call abortcdf
     &        ('cdvarid ',  7,   'NetCDF variable dimension  incorrect'
     &        ,'nvdms   ', nvdms,    'ndim0   ', ndim0,    -1)
      endif
c
c
      if(varname0  .ne.   varname1) then
         call abortcdf
     &        ('cdvarid ',  8,   'NetCDF variable name is incorrect   '
     &        ,'nvdms   ', nvdms,    'ndim0   ', ndim0,    -1)
      endif
c
c
c
c 3.0 Extract the dimension name and value from the dimension ID nvdmid
c
c     NF90_INQUIRE_DIMENSION INPUT:  kfileid1, kdid
c                            OUTPUT: kindstat, dmname,   nmdims
c
c 3.1 Loop over dimensions
c
      if(nvdms .ne. 0) then
         do 150 kd = 1,nvdms
            kdd         = kd
            kdid        = nvdmid(kdd)
c
c
c 3.2 Extract the dimensions
c
            kindstat  = NF90_INQUIRE_DIMENSION(kfileid1,kdid,dmname,
     &                                                       nmdims)
c
c
c 3.3 Check for errors
c
            if(kindstat .ne. nf90_noerr) then
               errstrng = NF90_STRERROR(kindstat)
               call abortcdf
     &        ('cdvarid ',  9,   errstrng
     &        ,'kdid    ', kdid,     'kindstat', kindstat, -1)
            endif

c
c
c 3.4 Save the dimensions
c
            nvdims(kdd) = nmdims
  150    continue
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdwr0c(kfileid1,kvarid1,nvstrt,nvdims,nndims,nntype
     &                                                ,length,varinpt)
c
c Write a scalar character to NetCDF (nndims = 1, nntype = 0)
c
c INPUT:  kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype, length,
c                                                            varinpt
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*(*) varinpt
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     kwrtstat
      integer*4     kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype,
     &                                                         length
c
      dimension     nvstrt (nndims),nvdims(nndims)
      dimension     varinpt(nvdims(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdwr0c  ',  1,   'Single character write: nndims not 1'
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdims(1)
      if(nvdmsv .ne. 1) then
         call abortcdf
     &        ('cdwr0c  ',  2,   'Single character write: nvdims not 1'
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 0) then
         call abortcdf
     &        ('cdwr0c  ',  3,   'Single character write: nntype not 0'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Write the data
c
c     NF90_PUT_VAR INPUT:  kfileid1, kvarid1, nvstrt(nndims), nvdims(nndims),
c                          varinpt
c                          Hidden implicit dimension: nndims
c                  OUTPUT: kwrtstat
c
      kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,nvstrt,nvdims)
cvvv  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt,nvstrt,nvdims)
czzz  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt)
czzz  Original had the four variable call 
c
c
c
c 3.0 Check for errors
c
      if(kwrtstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kwrtstat)
         call abortcdf
     &        ('cdwr0c  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kwrtstat', kwrtstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdwr1c(kfileid1,kvarid1,nvstrt,nvdims,nndims,nntype,
     &                                                 length,varinpt)
c
c Write a character array to NetCDF (nndims = 1, nntype = 1)
c
c INPUT:  kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype, length,
c                                                            varinpt
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*(*) varinpt
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     kwrtstat
      integer*4     kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype,
     &                                                         length
c
      dimension     nvstrt (nndims), nvdims(nndims)
      dimension     varinpt(nvdims(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdwr1c  ',  1,   'Character string write: nndims not 1'
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdims(1)
      if(nvdmsv .lt. 1) then
         call abortcdf
     &        ('cdwr1c  ',  2,   'Character string write: nvdmsv <  1 '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 1) then
         call abortcdf
     &        ('cdwr1c  ',  3,   'Character string write: nntype not 1'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c 2.0 Write the data
c

c     NF90_PUT_VAR INPUT:  kfileid1, kvarid1, nvstrt(nndims), nvdims(nndims),
c                          varinpt
c                          Hidden implicit dimension: nndims
c                  OUTPUT: kwrtstat
c
      kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,nvstrt,nvdims)
cvvv  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt,nvstrt,nvdims)
czzz  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt)
czzz  Original call was the six argument call
c
c
c
c 3.0 Check for errors
c
      if(kwrtstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kwrtstat)
         call abortcdf
     &        ('cdwr1c  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kwrtstat', kwrtstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdwr0i(kfileid1,kvarid1,nvstrt,nvdims,nndims,nntype,
     &                                                        varinpt)
c
c Write a scalar integer to NetCDF (nndims = 1  nntype = 2)
c
c INPUT:  kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype, varinpt
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     kwrtstat
      integer*4     kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype
      integer*4     varinpt
c
      dimension     nvstrt (nndims),nvdims(nndims)
      dimension     varinpt(nvdims(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdwr0i  ',  1,   'Single integer write: nndims not 1  '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdims(1)
      if(nvdmsv .ne. 1) then
         call abortcdf
     &        ('cdwr0i  ',  2,   'Single integer write: nvdims not 1  '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 2) then
         call abortcdf
     &        ('cdwr0i  ',  3,   'Single integer write: nntype not 2  '
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Write the data
c
c     NF90_PUT_VAR INPUT:  kfileid1, kvarid1, nvstrt(nndims), nvdims(nndims),
c                          varinpt
c                          Hidden implicit dimension: nndims
c                  OUTPUT: kwrtstat
c
      kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,nvstrt,nvdims)
cvvv  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt,nvstrt,nvdims)
czzz  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt)
czzz  Original call was the four argument call
c
c
c
c 3.0 Check for errors
c
      if(kwrtstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kwrtstat)
         call abortcdf
     &        ('cdwr0i  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kwrtstat', kwrtstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdwr0d(kfileid1,kvarid1,nvstrt,nvdims,nndims,nntype,
     &                                                        varinpt)
c
c Write a scalar real to NetCDF (nndims = 1, nntype = 3)
c
c INPUT:  kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype, varinpt
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     kwrtstat
      integer*4     kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype
      real*8        varinpt
c
      dimension     nvstrt (nndims),nvdims(nndims)
      dimension     varinpt(nvdims(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdwr0d  ',  1,   'Real scalar write: nndims not 1     '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdims(1)
      if(nvdmsv .ne. 1) then
         call abortcdf
     &        ('cdwr0d  ',  2,   'Real scalar write: nvdims not 1     '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 3) then
         call abortcdf
     &        ('cdwr0d  ',  3,   'Real scalar write: nntype not 3     '
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Write the data
c
c     NF90_PUT_VAR INPUT:  kfileid1, kvarid1, nvstrt(nndims), nvdims(nndims),
c                          varinpt
c                          Hidden implicit dimension: nndims
c                  OUTPUT: kwrtstat
c
      kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,nvstrt,nvdims)
cvvv  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt,nvstrt,nvdims)
czzz  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt)
czzz  Original call was the four argument call
c
c
c
c 3.0 Check for errors
c
      if(kwrtstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kwrtstat)
         call abortcdf
     &        ('cdwr0d  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kwrtstat', kwrtstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdwr1d(kfileid1,kvarid1,nvstrt,nvdims,nndims,nntype,
     &                                                        varinpt)
c
c Write a vector real array to NetCDF (nndims = 1, nntype = 4 or 5)
c
c INPUT:  kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype, varinpt
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     kwrtstat
      integer*4     kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype
      real*8        varinpt
c
      dimension     nvstrt (nndims),nvdims(nndims)
      dimension     varinpt(nvdims(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdwr1d  ',  1,   'Real 1D array write: nndims not 1   '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdims(1)
      if(nvdmsv .lt. 1) then
         call abortcdf
     &        ('cdwr1d  ',  2,   'Real 1D array write: nvdims <  1    '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 4  .and.  nntype .ne. 5) then
         call abortcdf
     &        ('cdwr1d  ',  3,   'Real 1D array write:nntype incorrect'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c 2.0 Write the data
c
c     NF90_PUT_VAR INPUT:  kfileid1, kvarid1, nvstrt(nndims), nvdims(nndims),
c                          varinpt
c                          Hidden implicit dimension: nndims
c                  OUTPUT: kwrtstat
c
      kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,nvstrt,nvdims)
cvvv  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt,nvstrt,nvdims)
czzz  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt)
czzz  Original call was the six argument call
c
c
c
c 3.0 Check for errors
c
      if(kwrtstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kwrtstat)
         call abortcdf
     &        ('cdwr1d  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kwrtstat', kwrtstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdwr2d(kfileid1,kvarid1,nvstrt,nvdims,nndims,nntype,
     &                                                        varinpt)
c
c Write an array to NetCDF (nndims = 2, nntype = 6)
c
c INPUT:  kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype, varinpt
c OUTPUT: none
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdms1,   nvdms2
      integer*4     kwrtstat
      integer*4     kfileid1, kvarid1, nvstrt, nvdims, nndims, nntype
      real*8        varinpt
c
      dimension     nvstrt (nndims),  nvdims(nndims)
      dimension     varinpt(nvdims(1),nvdims(2))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 2) then
         call abortcdf
     &        ('cdwr2d  ',  1,   'Real 2D array write: nndims not 2   '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdms1    = nvdims(1)
      nvdms2    = nvdims(2)
      if(nvdims(1) .lt. 1) then
         call abortcdf
     &        ('cdwr2d  ',  2,   'Real 2D array write: nvdims(1) <  1 '
     &        ,'kvarid1 ', kvarid1,  'nvdms1  ', nvdms1,   -1)
      endif
c
      if(nvdims(2) .lt. 1) then
         call abortcdf
     &        ('cdwr2d  ',  3,   'Real 2D array write: nvdims(2) <  1 '
     &        ,'kvarid1 ', kvarid1,  'nvdms2  ', nvdms2,   -1)
      endif
c
      if(nntype .ne. 6) then
         call abortcdf
     &        ('cdwr2d  ',  4,   'Real 2D array write:nntype incorrect'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Write the data
c
c     NF90_PUT_VAR INPUT:  kfileid1, kvarid1, nvstrt(nndims), nvdims(nndims),
c                          varinpt
c                          Hidden implicit dimension: nndims
c                  OUTPUT: kwrtstat
c
      kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,nvstrt,nvdims)
cvvv  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt,nvstrt,nvdims)
czzz  kwrtstat  = NF90_PUT_VAR(kfileid1,kvarid1,varinpt)
czzz  Original call was the four argument call
c
c
c
c 3.0 Check for errors
c
      if(kwrtstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(kwrtstat)
         call abortcdf
     &        ('cdwr2d  ',  5,   errstrng
     &        ,'kvarid1 ', kvarid1,  'kwrtstat', kwrtstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdrd0c(kfileid1,kvarid1,nvstrv,nvdimv,nndims,nntype,
     &                                                 length,varoutp)
c
c Read a scalar character  from NetCDF (nndims = 1, nntype = 0)
c
c INPUT:  kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype, length
c OUTPUT: varoutp
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
      character*(*) varoutp
c
      integer*4     nvdmsv
      integer*4     krddstat
      integer*4     kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype,
     &                                                         length
c
      dimension     nvstrv (nndims),nvdimv(nndims)
      dimension     varoutp(nvdimv(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdrd0c  ',  1,   'Single character read:  nndims not 1'
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdimv(1)
      if(nvdmsv .ne. 1) then
         call abortcdf
     &        ('cdrd0c  ',  2,   'Single character read:  nvdimv not 1'
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 0) then
         call abortcdf
     &        ('cdrd0c  ',  3,   'Single character read:  nntype not 0'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Read the data
c
c     NF90_GET_VAR INPUT:  kfileid1, kvarid1, nvstrv(nndims), nvdimv(nndims)
c                          Hidden implicit dimension: nndims
c                  OUTPUT: krddstat, varoutp
c
      krddstat  = NF90_GET_VAR(kfileid1,kvarid1,nvstrv,nvdimv)
czzz  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp,nvstrv,nvdimv)
czzz  Original call was the four argument call
c
c
c
c 3.0 Check for errors
c
      if(krddstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(krddstat)
         call abortcdf
     &        ('cdrd0c  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'krddstat', krddstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdrd1c(kfileid1,kvarid1,nvstrv,nvdimv,nndims,nntype,
     &                                                 length,varoutp)
c
c Read a character string from NetCDF (nndims = 1, nntype = 1)
c
c INPUT:  kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype, length
c OUTPUT: varoutp
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
      character*(*) varoutp
c
      integer*4     nvdmsv
      integer*4     krddstat
      integer*4     kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype,
     &                                                         length
c
      dimension     nvstrv (nndims),  nvdimv(nndims) 
      dimension     varoutp(nvdimv(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdrd1c  ',  1,   'Character string read:  nndims not 1'
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdimv(1)
      if(nvdmsv .lt. 1) then
         call abortcdf
     &        ('cdrd1c  ',  2,   'Character string read:  nvdimv <  1 '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 1) then
         call abortcdf
     &        ('cdrd1c  ',  3,   'Character string read:  nntype not 1'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Read the data
c
c
c     NF90_GET_VAR INPUT:  kfileid1, kvarid1, nvstrv(nndims), nvdimv(nndims)
c                          Hidden implicit dimension: nndims
c                  OUTPUT: krddstat, varoutp
c
      krddstat  = NF90_GET_VAR(kfileid1,kvarid1,nvstrv,nvdimv)
cvvv  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp,nvstrv,nvdimv)
czzz  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp)
czzz  Original call was the six argument call
c
c
c
c 3.0 Check for errors
c
      if(krddstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(krddstat)
         call abortcdf
     &        ('cdrd1c  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'krddstat', krddstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdrd0i(kfileid1,kvarid1,nvstrv,nvdimv,nndims,nntype,
     &                                                        varoutp)
c
c Read a scalar from NetCDF (nndims = 1, nntype = 2)
c
c INPUT:  kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
c OUTPUT: varoutp
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     krddstat
      integer*4     kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
      integer*4     varoutp
c
      dimension     nvstrv (nndims),nvdimv(nndims)
      dimension     varoutp(nvdimv(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdrd0i  ',  1,   'Single integer read:  nndims not 1  '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdimv(1)
      if(nvdmsv .ne. 1) then
         call abortcdf
     &        ('cdrd0i  ',  2,   'Single integer read:  nvdimv not 1  '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 2) then
         call abortcdf
     &        ('cdrd0i  ',  3,   'Single integer read:  nntype not 2  '
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Read the data
c
c     NF90_GET_VAR INPUT:  kfileid1, kvarid1, nvstrv(nndims), nvdimv(nndims)
c                          Hidden implicit dimension: nndims
c                  OUTPUT: krddstat, varoutp
c
      krddstat  = NF90_GET_VAR(kfileid1,kvarid1,nvstrv,nvdimv)
cvvv  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp,nvstrv,nvdimv)
czzz  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp)
czzz  Original call was the four argument call
c
c
c
c 3.0 Check for errors
c
      if(krddstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(krddstat)
         call abortcdf
     &        ('cdrd0i  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'krddstat', krddstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdrd0d(kfileid1,kvarid1,nvstrv,nvdimv,nndims,nntype,
     &                                                        varoutp)
c
c Read a scalar from NetCDF (nndims = 1, nntype = 3)
c
c INPUT:  kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
c OUTPUT: varoutp
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     krddstat
      integer*4     kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
      real*8        varoutp
c
      dimension     nvstrv (nndims),nvdimv(nndims)
      dimension     varoutp(nvdimv(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdrd0d  ',  1,   'Real scalar read:  nndims not 1     '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdimv(1)
      if(nvdmsv .ne. 1) then
         call abortcdf
     &        ('cdrd0d  ',  2,   'Real scalar read:  nvdimv not 1     '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 3) then
         call abortcdf
     &        ('cdrd0d  ',  3,   'Real scalar read:  nntype not 3     '
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Read the data
c
c     NF90_GET_VAR INPUT:  kfileid1, kvarid1, nvstrv(nndims), nvdimv(nndims)
c                          Hidden implicit dimension: nndims
c                  OUTPUT: krddstat, varoutp
c
      krddstat  = NF90_GET_VAR(kfileid1,kvarid1,nvstrv,nvdimv)
cvvv  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp,nvstrv,nvdimv)
czzz  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp)
czzz  Original call was the four argument call
c
c
c
c 3.0 Check for errors
c
      if(krddstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(krddstat)
         call abortcdf
     &        ('cdrd0d  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'krddstat', krddstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdrd1d(kfileid1,kvarid1,nvstrv,nvdimv,nndims,nntype,
     &                                                        varoutp)
c
c Read a vector array from NetCDF (nndims = 1, nntype = 4 or 5)
c
c INPUT:  kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
c OUTPUT: varoutp
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmsv
      integer*4     krddstat
      integer*4     kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
      real*8        varoutp
c
      dimension     nvstrv (nndims),  nvdimv(nndims)
      dimension     varoutp(nvdimv(1))
c
c
c
c 1.0 Check the input dimensions are appropriate
c

      if(nndims .ne. 1) then
         call abortcdf
     &        ('cdrd1d  ',  1,   'Real 1D array read:  nndims not 1   '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmsv   = nvdimv(1)
      if(nvdmsv .lt. 1) then
         call abortcdf
     &        ('cdrd1d  ',  2,   'Real 1D array read:  nvdimv <  1    '
     &        ,'kvarid1 ', kvarid1,  'nvdmsv  ', nvdmsv,   -1)
      endif
c
      if(nntype .ne. 4  .and.  nntype .ne. 5) then
         call abortcdf
     &        ('cdrd1d  ',  3,   'Real 1D array read: nntype incorrect'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Read the data
c
c     NF90_GET_VAR INPUT:  kfileid1, kvarid1, nvstrv(nndims), nvdimv(nndims)
c                          Hidden implicit dimension: nndims
c                  OUTPUT: krddstat, varoutp
c
      krddstat  = NF90_GET_VAR(kfileid1,kvarid1,nvstrv,nvdimv)
cvvv  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp,nvstrv,nvdimv)
czzz  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp)
czzz  Original call was the six argument call
c
c
c
c 3.0 Check for errors
c
      if(krddstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(krddstat)
         call abortcdf
     &        ('cdrd1d  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'krddstat', krddstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine cdrd2d(kfileid1,kvarid1,nvstrv,nvdimv,nndims,nntype,
     &                                                        varoutp)
c
c Read an array from NetCDF (nndims = 2, nntype = 6)
c
c INPUT:  kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
c OUTPUT: varoutp
c
c###  include 'netcdf_dummy.h'
      integer*4     nf90_clobber,nf90_write,nf90_nowrit,nf90_noerr
      integer*4     nf90_char,nf90_int,nf90_double
      character*36 nf90_strerror
c
      data nf90_clobber/0/,nf90_write/0/,nf90_nowrit/0/,nf90_noerr/0/,
     &     nf90_char/0/,nf90_int/0/,nf90_double/0/
c###  use netcdf
c
      character*80  errstrng
c
      integer*4     nvdmv1,   nvdmv2
      integer*4     krddstat
      integer*4     kfileid1, kvarid1, nvstrv, nvdimv, nndims, nntype
      real*8        varoutp
c
      dimension     nvstrv (nndims),  nvdimv(nndims)
      dimension     varoutp(nvdimv(1),nvdimv(2))
c
c
c
c 1.0 Check the input dimensions are appropriate
c
      if(nndims .ne. 2) then
         call abortcdf
     &        ('cdrd2d  ',  1,   'Real 2D array read:  nndims not 2   '
     &        ,'kvarid1 ', kvarid1,  'nndims  ', nndims,   -1)
      endif
c
      nvdmv1   = nvdimv(1)
      if(nvdmv1 .lt. 1) then
         call abortcdf
     &        ('cdrd2d  ',  2,   'Real 2D array read:  nvdimv(1) <  1 '
     &        ,'kvarid1 ', kvarid1,  'nvdmv1  ', nvdmv1,   -1)
      endif
c
      nvdmv2   = nvdimv(2)
      if(nvdmv2 .lt. 1) then
         call abortcdf
     &        ('cdrd2d  ',  3,   'Real 2D array read:  nvdimv(2) <  1 '
     &        ,'kvarid1 ', kvarid1,  'nvdmv2  ', nvdmv2,   -1)
      endif
c
      if(nntype .ne. 6) then
         call abortcdf
     &        ('cdrd2d  ',  4,   'Real 2D array read: nntype incorrect'
     &        ,'kvarid1 ', kvarid1,  'nntype  ', nntype,   -1)
      endif
c
c
c
c 2.0 Read the data
c
c     NF90_GET_VAR INPUT:  kfileid1, kvarid1, nvstrv(nndims), nvdimv(nndims)
c                          Hidden implicit dimension: nndims
c                  OUTPUT: krddstat, varoutp
c
      krddstat  = NF90_GET_VAR(kfileid1,kvarid1,nvstrv,nvdimv)
cvvv  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp,nvstrv,nvdimv)
czzz  krddstat  = NF90_GET_VAR(kfileid1,kvarid1,varoutp)
czzz  Original call was the six argument call
c
c
c
c 3.0 Check for errors
c
      if(krddstat .ne. nf90_noerr) then
         errstrng = NF90_STRERROR(krddstat)
         call abortcdf
     &        ('cdrd1d  ',  4,   errstrng
     &        ,'kvarid1 ', kvarid1,  'krddstat', krddstat, -1)
      endif
c
c
c
c 4.0 Return and end
c
      return
      end
      subroutine abortcdf(routine,ident,errmsg,vnam0,ier0,vnam1,ier1,iw)
c
c ---------------------------------------------------------
c
c  Print warning or abort job if error detected
c
c ---------------------------------------------------------
c
      integer       ident,    iw
      integer       kustt,    kusto,    kucdf
     &              kunva,    kudsk,    record
c
      integer*4     ier0, ier1
c
      character*16  codenam
      character*(*) routine
      character*(*) vnam0, vnam1
      character*(*) errmsg
c
      character*16  ascifile, mapoutfl, mapdskfl
c
      common/cdfout/ kustt,    kusto,    kucdf,
     &               kunva,    kudsk,    record,
     &               ascifile, mapoutfl, mapdskfl
c
c
c
c
c 1.0 Define the error label for termination
c
      codenam  = 'NetCDF'
c### Return for dummy NetCDF routines
      return
c###
c
c
c
c 2.0 Write out error label and number
c
      if    (iw .lt. -2) then
         write(kustt,1000) iw,routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kusto,1000) iw,routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         return
c
      elseif(iw .eq. -2) then
         write(kustt,1100) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kusto,1100) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
c
      elseif(iw .eq. -1) then
         write(kustt,1200) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kusto,1200) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         return
c
      elseif(iw .eq.  0) then
         write(kustt,1300) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kusto,1300) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         return
c
      elseif(iw .eq. +1) then
         write(kustt,2000) codenam
         write(kusto,2000) codenam
         write(kustt,2010) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         write(kusto,2010) routine,ident,errmsg,vnam0,ier0,vnam1,ier1
         call fileclose
         stop 'Terminated with Error'
c
      elseif(iw .gt. +1) then
         write(kustt,2100) codenam
         write(kusto,2100) codenam
         write(kustt,2110) errmsg,vnam0,ier0,vnam1,ier1
         write(kusto,2110) errmsg,vnam0,ier0,vnam1,ier1
         call fileclose
         stop 'Calculation complete'
      endif
c
c
c
c 3.0 Return and end
c
      return
c
 1000 format(/,2x,'***** NetCDF Important Warning: status number'
     &        ,2x,i2,1x,'*****'
     &      ,/,8x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 1100 format(/,2x,'***** NetCDF Serious Warning:  '
     &        ,1x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,1x,'*****',/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 1200 format(/,8x,'NetCDF Important Warning:'
     &        ,1x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 1300 format(/,8x,'NetCDF Warning:'
     &        ,1x,'Non fatal error in subroutine',2x,a8,1x,'at location'
     &        ,1x,i4,/
     &        ,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8)
 2000 format(/,2x,'***** Aborting  run in',1x,a16,1x,'*****')
 2010 format(/,8x,'NetCDF Fatal error in subroutine    ',2x,a8
     &        ,1x,'at location',1x,i4,/
     &        ,1x,'Error: ',a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
 2100 format(/,2x,'***** Completed run in',1x,a16,1x,'*****')
 2110 format(/,8x,a36,' :',4x,a8,' = ',i8,4x,a8,' = ',i8,/)
      end
      INTEGER FUNCTION NF90_CREATE(filencdf,kmode,kfileid)
      character*(*) filencdf
      integer*4     kmode,kfileid
c
      kfileid      = 1
      nf90_create  = 0
      return
      end

      CHARACTER*(*) FUNCTION NF90_STRERROR(kfilstat)
      integer*4     kfilstat
c
      nf90_strerror  = 'none'
      return
      end

      INTEGER FUNCTION NF90_DEF_DIM(kfileid,dimname,kdimv,kdimid)
      character*(*) dimname
      integer*4     kfileid,kdimv,kdimid
c
      kdimid        = 1
      nf90_def_dim  = 0
      return
      end

      INTEGER FUNCTION NF90_PUT_ATT(kfileid,kvarid,attname,attribt)
      character*(*) attname
      character*(*) attribt
      integer*4     kfileid,kvarid
c
      nf90_put_att  = 0
      return
      end

      INTEGER FUNCTION NF90_GET_ATT(kfileid,kvarid,attname,attribt)
      character*(*) attname
      character*(*) attribt
      integer*4     kfileid,kvarid
c
      attribt       = 'none'
      nf90_get_att  = 0
      return
      end

      INTEGER FUNCTION NF90_DEF_VAR(kfileid,varname,vartype,nvdmid
     &                                                     ,kvarid)
c
c     nvdmid has a hidden dimension not explicit here
c
      character*(*) varname
      integer*4     vartype
      integer*4     kfileid,nvdmid,kvarid
      dimension     nvdmid(1)
c
      kvarid        = 1
      nf90_def_var  = 0
      return
      end

      INTEGER FUNCTION NF90_ENDDEF(kfileid)
      integer*4     kfileid
c
      nf90_enddef  = 0
      return
      end

      INTEGER FUNCTION NF90_OPEN(filencdf,mode,kfileid)
      character*(*) filencdf
      integer*4     mode, kfileid
c
      kfileid    = 1
      nf90_open  = 0
      return
      end

      INTEGER FUNCTION NF90_CLOSE(kfileid)
      integer*4     kfileid
c
      nf90_close  = 0
      return
      end

      INTEGER FUNCTION NF90_INQ_VARID(kfileid,varname,kvarid)
      character*(*) varname
      integer*4     kfileid,kvarid
c
      kvarid          = 1
      nf90_inq_varid  = 0
      return
      end

      INTEGER FUNCTION NF90_INQUIRE(kfileid,kdims,kvars,katts,lstdim)
      integer*4     kfileid,kdims,kvars,katts,lstdim
c
      kdims         = 1
      kvars         = 1
      katts         = 0
      lstdim        = 1
      nf90_inquire  = 0
      return
      end

      INTEGER FUNCTION NF90_INQUIRE_DIMENSION(kfileid,kdid,dimname,
     &                                                     kmdim)
      character*(*) dimname
      integer*4     kfileid,kdid,kmdim
c
      dimname                 = 'none'
      kmdim                   = 1
      nf90_inquire_dimension  = 0
      return
      end

      INTEGER FUNCTION NF90_INQ_DIMID(kfileid,dimname,kdid)
      character*(*) dimname
      integer*4     kfileid,kdid
c
      kdid            = 1
      nf90_inq_dimid  = 0
      return
      end

      INTEGER FUNCTION NF90_INQUIRE_VARIABLE(kfileid,kvarid,varname,
     &                                       vartype,nvdms, nvdmid,
     &                                                      nvatts)
      character*(*) varname
      integer*4     vartype
      integer*4     kfileid,kvarid,nvdms,nvdimd,nvatts
c
      dimension nvdmid(2)
c
      varname                = 'none'
      vartype                = 1
      nvdms                  = 2
      nvdmid(1)              = 1
      nvdmid(2)              = 1
      nvatts                 = 0
      nf90_inquire_variable  = 0
      return
      end

      INTEGER FUNCTION NF90_PUT_VAR(kfileid,kvarid,nvstrt,
     &                                      nvdims)
cvvv  INTEGER FUNCTION NF90_PUT_VAR(kfileid,kvarid,varinpt,nvstrt,
cvvv &                                      nvdims)
c
c     varinpt is of any type
c     nvstrt and nvdims have a hidden dimension not explicit here
c
      integer*4     kfileid,kvarid,nvstrt,nvdims
      dimension     nvstrt(1),nvdims(1)
c
      nf90_put_var  = 0
      return
      end

      INTEGER FUNCTION NF90_GET_VAR(kfileid,kvarid,nvstrt,
     &                                      nvdims)
cvvv  INTEGER FUNCTION NF90_GET_VAR(kfileid,kvarid,varoutp,nvstrt,
cvvv &                                      nvdims)
c
c     varoutp is of any type
c     nvstrt and nvdims have a hidden dimension not explicit here
c
      integer*4     kfileid,kvarid,nvstrt,nvdims
      dimension     nvstrt(1),nvdims(1)
c
      nf90_get_var  = 0
      return
      end
cbcde    1         2         3         4         5         6         712
